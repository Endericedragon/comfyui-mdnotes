var bv = (n) => {
  throw TypeError(n);
};
var Ag = (n, e, t) => e.has(n) || bv("Cannot " + t);
var N = (n, e, t) => (Ag(n, e, "read from private field"), t ? t.call(n) : e.get(n)), ee = (n, e, t) => e.has(n) ? bv("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), W = (n, e, t, r) => (Ag(n, e, "write to private field"), r ? r.call(n, t) : e.set(n, t), t), u0 = (n, e, t) => (Ag(n, e, "access private method"), t);
import { h as V, defineComponent as Xt, ref as ce, Fragment as xa, createApp as oi, watchEffect as au, watch as W5, computed as sa, onMounted as Td, onUnmounted as l1, shallowRef as cm, createBlock as a9, openBlock as c9, unref as Og, withCtx as Eg, createElementVNode as h0, createVNode as vv, withModifiers as jD } from "vue";
import UD from "primevue/config";
import { app as GD } from "../../../scripts/app.js";
import * as KD from "../../../scripts/utils.js";
import { Dialog as YD, Button as wv } from "primevue";
const Yl = GD, u9 = {
  sendCurrentModel: "/mdnotes/current_model",
  saveContent: "/mdnotes/save"
}, x4 = {
  showEditor: "endericedragon-show-editor"
}, k4 = {
  saveOnClose: "comfyui-mdnotes.savingOptions.saveOnClose",
  cdnSwitch: "comfyui-mdnotes.cdnSwitch"
};
var S4 = /* @__PURE__ */ ((n) => (n.CKPT = "ckpt", n.LORA = "lora", n.UNKNOWN = "unknown", n))(S4 || {});
class h9 {
  constructor(e, t) {
    this.content = e, this.rel_file_path = t;
  }
  toJSON() {
    return {
      content: this.content,
      rel_file_path: this.rel_file_path
    };
  }
}
async function f9(n, e, t) {
  return n.api.fetchApi(e, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(t)
  }).then((r) => {
    switch (r.status) {
      case 201:
        Yl.extensionManager.toast.add({
          severity: "warn",
          summary: "MDNotes Warning",
          detail: "Note not found, ready to create one",
          life: 3e3
        });
      case 200:
        return r.json();
      default:
        return Yl.extensionManager.toast.add({
          severity: "error",
          summary: "MDNotes Error",
          detail: `Status code = ${r.status}`,
          life: 3e3
        }), Promise.reject(r.status);
    }
  });
}
var d9 = typeof global == "object" && global && global.Object === Object && global, JD = typeof self == "object" && self && self.Object === Object && self, ka = d9 || JD || Function("return this")(), um = ka.Symbol, p9 = Object.prototype, XD = p9.hasOwnProperty, ZD = p9.toString, Vu = um ? um.toStringTag : void 0;
function QD(n) {
  var e = XD.call(n, Vu), t = n[Vu];
  try {
    n[Vu] = void 0;
    var r = !0;
  } catch {
  }
  var i = ZD.call(n);
  return r && (e ? n[Vu] = t : delete n[Vu]), i;
}
var eN = Object.prototype, tN = eN.toString;
function nN(n) {
  return tN.call(n);
}
var rN = "[object Null]", iN = "[object Undefined]", xv = um ? um.toStringTag : void 0;
function Ad(n) {
  return n == null ? n === void 0 ? iN : rN : xv && xv in Object(n) ? QD(n) : nN(n);
}
function cu(n) {
  return n != null && typeof n == "object";
}
var sN = "[object Symbol]";
function oN(n) {
  return typeof n == "symbol" || cu(n) && Ad(n) == sN;
}
var C4 = Array.isArray, lN = /\s/;
function aN(n) {
  for (var e = n.length; e-- && lN.test(n.charAt(e)); )
    ;
  return e;
}
var cN = /^\s+/;
function uN(n) {
  return n && n.slice(0, aN(n) + 1).replace(cN, "");
}
function Dr(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var kv = NaN, hN = /^[-+]0x[0-9a-f]+$/i, fN = /^0b[01]+$/i, dN = /^0o[0-7]+$/i, pN = parseInt;
function Sv(n) {
  if (typeof n == "number")
    return n;
  if (oN(n))
    return kv;
  if (Dr(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Dr(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = uN(n);
  var t = fN.test(n);
  return t || dN.test(n) ? pN(n.slice(2), t ? 2 : 8) : hN.test(n) ? kv : +n;
}
function m9(n) {
  return n;
}
var mN = "[object AsyncFunction]", gN = "[object Function]", yN = "[object GeneratorFunction]", bN = "[object Proxy]";
function j5(n) {
  if (!Dr(n))
    return !1;
  var e = Ad(n);
  return e == gN || e == yN || e == mN || e == bN;
}
var Ig = ka["__core-js_shared__"], Cv = function() {
  var n = /[^.]+$/.exec(Ig && Ig.keys && Ig.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function vN(n) {
  return !!Cv && Cv in n;
}
var wN = Function.prototype, xN = wN.toString;
function kN(n) {
  if (n != null) {
    try {
      return xN.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var SN = /[\\^$.*+?()[\]{}|]/g, CN = /^\[object .+?Constructor\]$/, MN = Function.prototype, TN = Object.prototype, AN = MN.toString, ON = TN.hasOwnProperty, EN = RegExp(
  "^" + AN.call(ON).replace(SN, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function IN(n) {
  if (!Dr(n) || vN(n))
    return !1;
  var e = j5(n) ? EN : CN;
  return e.test(kN(n));
}
function DN(n, e) {
  return n == null ? void 0 : n[e];
}
function U5(n, e) {
  var t = DN(n, e);
  return IN(t) ? t : void 0;
}
var Mv = Object.create, NN = /* @__PURE__ */ function() {
  function n() {
  }
  return function(e) {
    if (!Dr(e))
      return {};
    if (Mv)
      return Mv(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
}();
function g9(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function RN(n, e) {
  var t = -1, r = n.length;
  for (e || (e = Array(r)); ++t < r; )
    e[t] = n[t];
  return e;
}
var PN = 800, LN = 16, BN = Date.now;
function zN(n) {
  var e = 0, t = 0;
  return function() {
    var r = BN(), i = LN - (r - t);
    if (t = r, i > 0) {
      if (++e >= PN)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function _N(n) {
  return function() {
    return n;
  };
}
var hm = function() {
  try {
    var n = U5(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), FN = hm ? function(n, e) {
  return hm(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: _N(e),
    writable: !0
  });
} : m9, HN = zN(FN), $N = 9007199254740991, VN = /^(?:0|[1-9]\d*)$/;
function y9(n, e) {
  var t = typeof n;
  return e = e ?? $N, !!e && (t == "number" || t != "symbol" && VN.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function G5(n, e, t) {
  e == "__proto__" && hm ? hm(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function a1(n, e) {
  return n === e || n !== n && e !== e;
}
var qN = Object.prototype, WN = qN.hasOwnProperty;
function jN(n, e, t) {
  var r = n[e];
  (!(WN.call(n, e) && a1(r, t)) || t === void 0 && !(e in n)) && G5(n, e, t);
}
function UN(n, e, t, r) {
  var i = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var l = e[s], a = void 0;
    a === void 0 && (a = n[l]), i ? G5(t, l, a) : jN(t, l, a);
  }
  return t;
}
var Tv = Math.max;
function GN(n, e, t) {
  return e = Tv(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = Tv(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var l = Array(e + 1); ++i < e; )
      l[i] = r[i];
    return l[e] = t(o), g9(n, this, l);
  };
}
function b9(n, e) {
  return HN(GN(n, e, m9), n + "");
}
var KN = 9007199254740991;
function v9(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= KN;
}
function K5(n) {
  return n != null && v9(n.length) && !j5(n);
}
function YN(n, e, t) {
  if (!Dr(t))
    return !1;
  var r = typeof e;
  return (r == "number" ? K5(t) && y9(e, t.length) : r == "string" && e in t) ? a1(t[e], n) : !1;
}
function JN(n) {
  return b9(function(e, t) {
    var r = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, o = i > 2 ? t[2] : void 0;
    for (s = n.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && YN(t[0], t[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var l = t[r];
      l && n(e, l, r, s);
    }
    return e;
  });
}
var XN = Object.prototype;
function w9(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || XN;
  return n === t;
}
function ZN(n, e) {
  for (var t = -1, r = Array(n); ++t < n; )
    r[t] = e(t);
  return r;
}
var QN = "[object Arguments]";
function Av(n) {
  return cu(n) && Ad(n) == QN;
}
var x9 = Object.prototype, eR = x9.hasOwnProperty, tR = x9.propertyIsEnumerable, M4 = Av(/* @__PURE__ */ function() {
  return arguments;
}()) ? Av : function(n) {
  return cu(n) && eR.call(n, "callee") && !tR.call(n, "callee");
};
function nR() {
  return !1;
}
var k9 = typeof exports == "object" && exports && !exports.nodeType && exports, Ov = k9 && typeof module == "object" && module && !module.nodeType && module, rR = Ov && Ov.exports === k9, Ev = rR ? ka.Buffer : void 0, iR = Ev ? Ev.isBuffer : void 0, S9 = iR || nR, sR = "[object Arguments]", oR = "[object Array]", lR = "[object Boolean]", aR = "[object Date]", cR = "[object Error]", uR = "[object Function]", hR = "[object Map]", fR = "[object Number]", dR = "[object Object]", pR = "[object RegExp]", mR = "[object Set]", gR = "[object String]", yR = "[object WeakMap]", bR = "[object ArrayBuffer]", vR = "[object DataView]", wR = "[object Float32Array]", xR = "[object Float64Array]", kR = "[object Int8Array]", SR = "[object Int16Array]", CR = "[object Int32Array]", MR = "[object Uint8Array]", TR = "[object Uint8ClampedArray]", AR = "[object Uint16Array]", OR = "[object Uint32Array]", yt = {};
yt[wR] = yt[xR] = yt[kR] = yt[SR] = yt[CR] = yt[MR] = yt[TR] = yt[AR] = yt[OR] = !0;
yt[sR] = yt[oR] = yt[bR] = yt[lR] = yt[vR] = yt[aR] = yt[cR] = yt[uR] = yt[hR] = yt[fR] = yt[dR] = yt[pR] = yt[mR] = yt[gR] = yt[yR] = !1;
function ER(n) {
  return cu(n) && v9(n.length) && !!yt[Ad(n)];
}
function IR(n) {
  return function(e) {
    return n(e);
  };
}
var C9 = typeof exports == "object" && exports && !exports.nodeType && exports, Vh = C9 && typeof module == "object" && module && !module.nodeType && module, DR = Vh && Vh.exports === C9, Dg = DR && d9.process, Iv = function() {
  try {
    var n = Vh && Vh.require && Vh.require("util").types;
    return n || Dg && Dg.binding && Dg.binding("util");
  } catch {
  }
}(), Dv = Iv && Iv.isTypedArray, M9 = Dv ? IR(Dv) : ER;
function NR(n, e) {
  var t = C4(n), r = !t && M4(n), i = !t && !r && S9(n), s = !t && !r && !i && M9(n), o = t || r || i || s, l = o ? ZN(n.length, String) : [], a = l.length;
  for (var c in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    y9(c, a)) || l.push(c);
  return l;
}
function RR(n, e) {
  return function(t) {
    return n(e(t));
  };
}
function PR(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var LR = Object.prototype, BR = LR.hasOwnProperty;
function zR(n) {
  if (!Dr(n))
    return PR(n);
  var e = w9(n), t = [];
  for (var r in n)
    r == "constructor" && (e || !BR.call(n, r)) || t.push(r);
  return t;
}
function T9(n) {
  return K5(n) ? NR(n) : zR(n);
}
var gf = U5(Object, "create");
function _R() {
  this.__data__ = gf ? gf(null) : {}, this.size = 0;
}
function FR(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var HR = "__lodash_hash_undefined__", $R = Object.prototype, VR = $R.hasOwnProperty;
function qR(n) {
  var e = this.__data__;
  if (gf) {
    var t = e[n];
    return t === HR ? void 0 : t;
  }
  return VR.call(e, n) ? e[n] : void 0;
}
var WR = Object.prototype, jR = WR.hasOwnProperty;
function UR(n) {
  var e = this.__data__;
  return gf ? e[n] !== void 0 : jR.call(e, n);
}
var GR = "__lodash_hash_undefined__";
function KR(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = gf && e === void 0 ? GR : e, this;
}
function oa(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
oa.prototype.clear = _R;
oa.prototype.delete = FR;
oa.prototype.get = qR;
oa.prototype.has = UR;
oa.prototype.set = KR;
function YR() {
  this.__data__ = [], this.size = 0;
}
function c1(n, e) {
  for (var t = n.length; t--; )
    if (a1(n[t][0], e))
      return t;
  return -1;
}
var JR = Array.prototype, XR = JR.splice;
function ZR(n) {
  var e = this.__data__, t = c1(e, n);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : XR.call(e, t, 1), --this.size, !0;
}
function QR(n) {
  var e = this.__data__, t = c1(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function eP(n) {
  return c1(this.__data__, n) > -1;
}
function tP(n, e) {
  var t = this.__data__, r = c1(t, n);
  return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this;
}
function eo(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
eo.prototype.clear = YR;
eo.prototype.delete = ZR;
eo.prototype.get = QR;
eo.prototype.has = eP;
eo.prototype.set = tP;
var A9 = U5(ka, "Map");
function nP() {
  this.size = 0, this.__data__ = {
    hash: new oa(),
    map: new (A9 || eo)(),
    string: new oa()
  };
}
function rP(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function u1(n, e) {
  var t = n.__data__;
  return rP(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function iP(n) {
  var e = u1(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function sP(n) {
  return u1(this, n).get(n);
}
function oP(n) {
  return u1(this, n).has(n);
}
function lP(n, e) {
  var t = u1(this, n), r = t.size;
  return t.set(n, e), this.size += t.size == r ? 0 : 1, this;
}
function uu(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
uu.prototype.clear = nP;
uu.prototype.delete = iP;
uu.prototype.get = sP;
uu.prototype.has = oP;
uu.prototype.set = lP;
var O9 = RR(Object.getPrototypeOf, Object), aP = "[object Object]", cP = Function.prototype, uP = Object.prototype, E9 = cP.toString, hP = uP.hasOwnProperty, fP = E9.call(Object);
function dP(n) {
  if (!cu(n) || Ad(n) != aP)
    return !1;
  var e = O9(n);
  if (e === null)
    return !0;
  var t = hP.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && E9.call(t) == fP;
}
function pP() {
  this.__data__ = new eo(), this.size = 0;
}
function mP(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function gP(n) {
  return this.__data__.get(n);
}
function yP(n) {
  return this.__data__.has(n);
}
var bP = 200;
function vP(n, e) {
  var t = this.__data__;
  if (t instanceof eo) {
    var r = t.__data__;
    if (!A9 || r.length < bP - 1)
      return r.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new uu(r);
  }
  return t.set(n, e), this.size = t.size, this;
}
function hu(n) {
  var e = this.__data__ = new eo(n);
  this.size = e.size;
}
hu.prototype.clear = pP;
hu.prototype.delete = mP;
hu.prototype.get = gP;
hu.prototype.has = yP;
hu.prototype.set = vP;
var I9 = typeof exports == "object" && exports && !exports.nodeType && exports, Nv = I9 && typeof module == "object" && module && !module.nodeType && module, wP = Nv && Nv.exports === I9, Rv = wP ? ka.Buffer : void 0;
Rv && Rv.allocUnsafe;
function xP(n, e) {
  return n.slice();
}
var Pv = ka.Uint8Array;
function kP(n) {
  var e = new n.constructor(n.byteLength);
  return new Pv(e).set(new Pv(n)), e;
}
function SP(n, e) {
  var t = kP(n.buffer);
  return new n.constructor(t, n.byteOffset, n.length);
}
function CP(n) {
  return typeof n.constructor == "function" && !w9(n) ? NN(O9(n)) : {};
}
function MP(n) {
  return function(e, t, r) {
    for (var i = -1, s = Object(e), o = r(e), l = o.length; l--; ) {
      var a = o[++i];
      if (t(s[a], a, s) === !1)
        break;
    }
    return e;
  };
}
var TP = MP(), Ng = function() {
  return ka.Date.now();
}, AP = "Expected a function", OP = Math.max, EP = Math.min;
function h1(n, e, t) {
  var r, i, s, o, l, a, c = 0, u = !1, h = !1, f = !0;
  if (typeof n != "function")
    throw new TypeError(AP);
  e = Sv(e) || 0, Dr(t) && (u = !!t.leading, h = "maxWait" in t, s = h ? OP(Sv(t.maxWait) || 0, e) : s, f = "trailing" in t ? !!t.trailing : f);
  function d(C) {
    var I = r, _ = i;
    return r = i = void 0, c = C, o = n.apply(_, I), o;
  }
  function p(C) {
    return c = C, l = setTimeout(b, e), u ? d(C) : o;
  }
  function m(C) {
    var I = C - a, _ = C - c, F = e - I;
    return h ? EP(F, s - _) : F;
  }
  function g(C) {
    var I = C - a, _ = C - c;
    return a === void 0 || I >= e || I < 0 || h && _ >= s;
  }
  function b() {
    var C = Ng();
    if (g(C))
      return w(C);
    l = setTimeout(b, m(C));
  }
  function w(C) {
    return l = void 0, f && r ? d(C) : (r = i = void 0, o);
  }
  function k() {
    l !== void 0 && clearTimeout(l), c = 0, r = a = i = l = void 0;
  }
  function T() {
    return l === void 0 ? o : w(Ng());
  }
  function M() {
    var C = Ng(), I = g(C);
    if (r = arguments, i = this, a = C, I) {
      if (l === void 0)
        return p(a);
      if (h)
        return clearTimeout(l), l = setTimeout(b, e), d(a);
    }
    return l === void 0 && (l = setTimeout(b, e)), o;
  }
  return M.cancel = k, M.flush = T, M;
}
function T4(n, e, t) {
  (t !== void 0 && !a1(n[e], t) || t === void 0 && !(e in n)) && G5(n, e, t);
}
function IP(n) {
  return cu(n) && K5(n);
}
function A4(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function DP(n) {
  return UN(n, T9(n));
}
function NP(n, e, t, r, i, s, o) {
  var l = A4(n, t), a = A4(e, t), c = o.get(a);
  if (c) {
    T4(n, t, c);
    return;
  }
  var u = s ? s(l, a, t + "", n, e, o) : void 0, h = u === void 0;
  if (h) {
    var f = C4(a), d = !f && S9(a), p = !f && !d && M9(a);
    u = a, f || d || p ? C4(l) ? u = l : IP(l) ? u = RN(l) : d ? (h = !1, u = xP(a)) : p ? (h = !1, u = SP(a)) : u = [] : dP(a) || M4(a) ? (u = l, M4(l) ? u = DP(l) : (!Dr(l) || j5(l)) && (u = CP(a))) : h = !1;
  }
  h && (o.set(a, u), i(u, a, r, s, o), o.delete(a)), T4(n, t, u);
}
function Y5(n, e, t, r, i) {
  n !== e && TP(e, function(s, o) {
    if (i || (i = new hu()), Dr(s))
      NP(n, e, o, t, Y5, r, i);
    else {
      var l = r ? r(A4(n, o), s, o + "", n, e, i) : void 0;
      l === void 0 && (l = s), T4(n, o, l);
    }
  }, T9);
}
function D9(n, e, t, r, i, s) {
  return Dr(n) && Dr(e) && (s.set(e, n), Y5(n, e, void 0, D9, s), s.delete(e)), n;
}
var RP = JN(function(n, e, t, r) {
  Y5(n, e, t, r);
}), PP = b9(function(n) {
  return n.push(void 0, D9), g9(RP, void 0, n);
}), LP = "Expected a function";
function f1(n, e, t) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(LP);
  return Dr(t) && (r = "leading" in t ? !!t.leading : r, i = "trailing" in t ? !!t.trailing : i), h1(n, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const BP = 1024;
let zP = 0, Ur = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
class We {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = zP++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Nr.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
We.closedBy = new We({ deserialize: (n) => n.split(" ") });
We.openedBy = new We({ deserialize: (n) => n.split(" ") });
We.group = new We({ deserialize: (n) => n.split(" ") });
We.isolate = new We({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
We.contextHash = new We({ perNode: !0 });
We.lookAhead = new We({ perNode: !0 });
We.mounted = new We({ perNode: !0 });
class yf {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[We.mounted.id];
  }
}
const _P = /* @__PURE__ */ Object.create(null);
let Nr = class N9 {
  /**
  @internal
  */
  constructor(e, t, r, i = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : _P, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new N9(e.name || "", t, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(We.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        t[i] = e[r];
    return (r) => {
      for (let i = r.prop(We.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = t[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
};
Nr.none = new Nr(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class J5 {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      t.push(i ? new Nr(r.name, i, r.id, r.flags) : r);
    }
    return new J5(t);
  }
}
const f0 = /* @__PURE__ */ new WeakMap(), Lv = /* @__PURE__ */ new WeakMap();
var Et;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Et || (Et = {}));
class mt {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, i, s) {
    if (this.type = e, this.children = t, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = yf.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new fm(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let i = f0.get(this) || this.topNode, s = new fm(i);
    return s.moveTo(e, t), f0.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Mn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = bf(f0.get(this) || this.topNode, e, t, !1);
    return f0.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = bf(Lv.get(this) || this.topNode, e, t, !0);
    return Lv.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return $P(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & Et.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | Et.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= s && a.to >= i && (!l && a.type.isAnonymous || t(a) !== !1)) {
        if (a.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Q5(Nr.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, i) => new mt(this.type, t, r, i, this.propValues), e.makeTree || ((t, r, i) => new mt(Nr.none, t, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return VP(e);
  }
}
mt.empty = new mt(Nr.none, [], [], 0);
class X5 {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new X5(this.buffer, this.index);
  }
}
class Vo {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Nr.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[t], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, i, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != t && !(R9(s, i, o[a + 1], o[a + 2]) && (l = a, r > 0)); a = o[a + 3])
      ;
    return l;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let i = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let l = e, a = 0; l < t; ) {
      s[a++] = i[l++], s[a++] = i[l++] - r;
      let c = s[a++] = i[l++] - r;
      s[a++] = i[l++] - e, o = Math.max(o, c);
    }
    return new Vo(s, o, this.set);
  }
}
function R9(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function bf(n, e, t, r) {
  for (var i; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !r && n instanceof Mn && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = r ? 0 : Et.IgnoreOverlays;
  if (r)
    for (let o = n, l = o.parent; l; o = l, l = o.parent)
      o instanceof Mn && o.index < 0 && ((i = l.enter(e, t, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (n = l);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class P9 {
  cursor(e = 0) {
    return new fm(this, e);
  }
  getChild(e, t = null, r = null) {
    let i = Bv(this, e, t, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return Bv(this, e, t, r);
  }
  resolve(e, t = 0) {
    return bf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return bf(this, e, t, !0);
  }
  matchContext(e) {
    return O4(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let i = t.lastChild;
      if (!i || i.to != t.to)
        break;
      i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Mn extends P9 {
  constructor(e, t, r, i) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, c = t > 0 ? l.length : -1; e != c; e += t) {
        let u = l[e], h = a[e] + o.from;
        if (R9(i, r, h, h + u.length)) {
          if (u instanceof Vo) {
            if (s & Et.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, t, r - h, i);
            if (f > -1)
              return new Ui(new FP(o, u, e, h), null, f);
          } else if (s & Et.IncludeAnonymous || !u.type.isAnonymous || Z5(u)) {
            let f;
            if (!(s & Et.IgnoreMounts) && (f = yf.get(u)) && !f.overlay)
              return new Mn(f.tree, h, e, o);
            let d = new Mn(u, h, e, o);
            return s & Et.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? u.children.length - 1 : 0, t, r, i);
          }
        }
      }
      if (s & Et.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let i;
    if (!(r & Et.IgnoreOverlays) && (i = yf.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
          return new Mn(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function Bv(n, e, t, r) {
  let i = n.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(t), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function O4(n, e, t = e.length - 1) {
  for (let r = n; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class FP {
  constructor(e, t, r, i) {
    this.parent = e, this.buffer = t, this.index = r, this.start = i;
  }
}
class Ui extends P9 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, r);
    return s < 0 ? null : new Ui(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & Et.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new Ui(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ui(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Ui(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), t.push(0);
    }
    return new mt(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function L9(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let s = 1; s < n.length; s++) {
    let o = n[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let r = t instanceof Mn && t.index < 0 ? null : t.parent, i = n.slice();
  return r ? i[e] = r : i.splice(e, 1), new HP(i, t);
}
class HP {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return L9(this.heads);
  }
}
function $P(n, e, t) {
  let r = n.resolveInner(e, t), i = null;
  for (let s = r instanceof Mn ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, t)), s = o;
    } else {
      let o = yf.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new Mn(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(bf(l, e, t, !1));
      }
    }
  return i ? L9(i) : r;
}
class fm {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Mn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof Mn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & Et.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Et.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Et.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = i);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let l = r._tree.children[s];
          if (this.mode & Et.IncludeAnonymous || l instanceof Vo || !l.type.isAnonymous || Z5(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index)
              return o;
            t = o, r = s + 1;
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++)
      t = new Ui(this.buffer, t, this.stack[i]);
    return this.bufferNode = new Ui(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && t && t(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return O4(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return O4(this._tree, e, i);
      let o = r[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function Z5(n) {
  return n.children.some((e) => e instanceof Vo || !e.type.isAnonymous || Z5(e));
}
function VP(n) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: i = BP, reused: s = [], minRepeatType: o = r.types.length } = n, l = Array.isArray(t) ? new X5(t, t.length) : t, a = r.types, c = 0, u = 0;
  function h(M, C, I, _, F, L) {
    let { id: $, start: B, end: se, size: te } = l, ie = u, Ce = c;
    for (; te < 0; )
      if (l.next(), te == -1) {
        let Me = s[$];
        I.push(Me), _.push(B - M);
        return;
      } else if (te == -3) {
        c = $;
        return;
      } else if (te == -4) {
        u = $;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${te}`);
    let Oe = a[$], Re, Be, D = B - M;
    if (se - B <= i && (Be = g(l.pos - C, F))) {
      let Me = new Uint16Array(Be.size - Be.skip), _e = l.pos - Be.size, O = Me.length;
      for (; l.pos > _e; )
        O = b(Be.start, Me, O);
      Re = new Vo(Me, se - Be.start, r), D = Be.start - M;
    } else {
      let Me = l.pos - te;
      l.next();
      let _e = [], O = [], rt = $ >= o ? $ : -1, Le = 0, Ke = se;
      for (; l.pos > Me; )
        rt >= 0 && l.id == rt && l.size >= 0 ? (l.end <= Ke - i && (p(_e, O, B, Le, l.end, Ke, rt, ie, Ce), Le = _e.length, Ke = l.end), l.next()) : L > 2500 ? f(B, Me, _e, O) : h(B, Me, _e, O, rt, L + 1);
      if (rt >= 0 && Le > 0 && Le < _e.length && p(_e, O, B, Le, B, Ke, rt, ie, Ce), _e.reverse(), O.reverse(), rt > -1 && Le > 0) {
        let Dt = d(Oe, Ce);
        Re = Q5(Oe, _e, O, 0, _e.length, 0, se - B, Dt, Dt);
      } else
        Re = m(Oe, _e, O, se - B, ie - se, Ce);
    }
    I.push(Re), _.push(D);
  }
  function f(M, C, I, _) {
    let F = [], L = 0, $ = -1;
    for (; l.pos > C; ) {
      let { id: B, start: se, end: te, size: ie } = l;
      if (ie > 4)
        l.next();
      else {
        if ($ > -1 && se < $)
          break;
        $ < 0 && ($ = te - i), F.push(B, se, te), L++, l.next();
      }
    }
    if (L) {
      let B = new Uint16Array(L * 4), se = F[F.length - 2];
      for (let te = F.length - 3, ie = 0; te >= 0; te -= 3)
        B[ie++] = F[te], B[ie++] = F[te + 1] - se, B[ie++] = F[te + 2] - se, B[ie++] = ie;
      I.push(new Vo(B, F[2] - se, r)), _.push(se - M);
    }
  }
  function d(M, C) {
    return (I, _, F) => {
      let L = 0, $ = I.length - 1, B, se;
      if ($ >= 0 && (B = I[$]) instanceof mt) {
        if (!$ && B.type == M && B.length == F)
          return B;
        (se = B.prop(We.lookAhead)) && (L = _[$] + B.length + se);
      }
      return m(M, I, _, F, L, C);
    };
  }
  function p(M, C, I, _, F, L, $, B, se) {
    let te = [], ie = [];
    for (; M.length > _; )
      te.push(M.pop()), ie.push(C.pop() + I - F);
    M.push(m(r.types[$], te, ie, L - F, B - L, se)), C.push(F - I);
  }
  function m(M, C, I, _, F, L, $) {
    if (L) {
      let B = [We.contextHash, L];
      $ = $ ? [B].concat($) : [B];
    }
    if (F > 25) {
      let B = [We.lookAhead, F];
      $ = $ ? [B].concat($) : [B];
    }
    return new mt(M, C, I, _, $);
  }
  function g(M, C) {
    let I = l.fork(), _ = 0, F = 0, L = 0, $ = I.end - i, B = { size: 0, start: 0, skip: 0 };
    e: for (let se = I.pos - M; I.pos > se; ) {
      let te = I.size;
      if (I.id == C && te >= 0) {
        B.size = _, B.start = F, B.skip = L, L += 4, _ += 4, I.next();
        continue;
      }
      let ie = I.pos - te;
      if (te < 0 || ie < se || I.start < $)
        break;
      let Ce = I.id >= o ? 4 : 0, Oe = I.start;
      for (I.next(); I.pos > ie; ) {
        if (I.size < 0)
          if (I.size == -3)
            Ce += 4;
          else
            break e;
        else I.id >= o && (Ce += 4);
        I.next();
      }
      F = Oe, _ += te, L += Ce;
    }
    return (C < 0 || _ == M) && (B.size = _, B.start = F, B.skip = L), B.size > 4 ? B : void 0;
  }
  function b(M, C, I) {
    let { id: _, start: F, end: L, size: $ } = l;
    if (l.next(), $ >= 0 && _ < o) {
      let B = I;
      if ($ > 4) {
        let se = l.pos - ($ - 4);
        for (; l.pos > se; )
          I = b(M, C, I);
      }
      C[--I] = B, C[--I] = L - M, C[--I] = F - M, C[--I] = _;
    } else $ == -3 ? c = _ : $ == -4 && (u = _);
    return I;
  }
  let w = [], k = [];
  for (; l.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, w, k, -1, 0);
  let T = (e = n.length) !== null && e !== void 0 ? e : w.length ? k[0] + w[0].length : 0;
  return new mt(a[n.topID], w.reverse(), k.reverse(), T);
}
const zv = /* @__PURE__ */ new WeakMap();
function cp(n, e) {
  if (!n.isAnonymous || e instanceof Vo || e.type != n)
    return 1;
  let t = zv.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != n || !(r instanceof mt)) {
        t = 1;
        break;
      }
      t += cp(n, r);
    }
    zv.set(e, t);
  }
  return t;
}
function Q5(n, e, t, r, i, s, o, l, a) {
  let c = 0;
  for (let p = r; p < i; p++)
    c += cp(n, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, m, g, b, w) {
    for (let k = g; k < b; ) {
      let T = k, M = m[k], C = cp(n, p[k]);
      for (k++; k < b; k++) {
        let I = cp(n, p[k]);
        if (C + I >= u)
          break;
        C += I;
      }
      if (k == T + 1) {
        if (C > u) {
          let I = p[T];
          d(I.children, I.positions, 0, I.children.length, m[T] + w);
          continue;
        }
        h.push(p[T]);
      } else {
        let I = m[k - 1] + p[k - 1].length - M;
        h.push(Q5(n, p, m, T, k, M, I, null, a));
      }
      f.push(M + w - s);
    }
  }
  return d(e, t, r, i, 0), (l || a)(h, f, o);
}
class Voe {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Ui ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Mn && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Ui ? this.getBuffer(e.context.buffer, e.index) : e instanceof Mn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Hs {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, i, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let i = [new Hs(0, e.length, e, 0, !1, r)];
    for (let s of t)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let u = l < t.length ? t[l] : null, h = u ? u.fromA : 1e9;
      if (h - a >= r)
        for (; o && o.from < h; ) {
          let f = o;
          if (a >= f.from || h <= f.to || c) {
            let d = Math.max(f.from, a) - c, p = Math.min(f.to, h) - c;
            f = d >= p ? null : new Hs(d, p, f.tree, f.offset + c, l > 0, !!u);
          }
          if (f && i.push(f), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      a = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
let B9 = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new qP(e)), r = r ? r.length ? r.map((i) => new Ur(i.from, i.to)) : [new Ur(0, 0)] : [new Ur(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let i = this.startParse(e, t, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class qP {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Woe(n) {
  return (e, t, r, i) => new jP(e, n, t, r, i);
}
class _v {
  constructor(e, t, r, i, s) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = i, this.from = s;
  }
}
function Fv(n) {
  if (!n.length || n.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
class WP {
  constructor(e, t, r, i, s, o, l) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const E4 = new We({ perNode: !0 });
class jP {
  constructor(e, t, r, i, s) {
    this.nest = t, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new mt(r.type, r.children, r.positions, r.length, r.propValues.concat([[E4, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[We.mounted.id] = new yf(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new KP(this.fragments), t = null, r = null, i = new fm(new Mn(this.baseTree, this.ranges[0].from, 0, null), Et.IncludeAnonymous | Et.IgnoreMounts);
    e: for (let s, o; ; ) {
      let l = !0, a;
      if (this.stoppedAt != null && i.from >= this.stoppedAt)
        l = !1;
      else if (e.hasNode(i)) {
        if (t) {
          let c = t.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos, f = u.to + c.pos;
              h >= i.from && f <= i.to && !t.ranges.some((d) => d.from < f && d.to > h) && t.ranges.push({ from: h, to: f });
            }
        }
        l = !1;
      } else if (r && (o = UP(r.ranges, i.from, i.to)))
        l = o != 2;
      else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
        i.tree || GP(i);
        let c = e.findMounts(i.from, s.parser);
        if (typeof s.overlay == "function")
          t = new WP(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, t);
        else {
          let u = Vv(this.ranges, s.overlay || (i.from < i.to ? [new Ur(i.from, i.to)] : []));
          u.length && Fv(u), (u.length || !s.overlay) && this.inner.push(new _v(s.parser, u.length ? s.parser.startParse(this.input, qv(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((h) => new Ur(h.from - i.from, h.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : l = !1;
        }
      } else if (t && (a = t.predicate(i)) && (a === !0 && (a = new Ur(i.from, i.to)), a.from < a.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == a.from ? t.ranges[c] = { from: t.ranges[c].from, to: a.to } : t.ranges.push(a);
      }
      if (l && i.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent())
            break e;
          if (t && !--t.depth) {
            let c = Vv(this.ranges, t.ranges);
            c.length && (Fv(c), this.inner.splice(t.index, 0, new _v(t.parser, t.parser.startParse(this.input, qv(t.mounts, c), c), t.ranges.map((u) => new Ur(u.from - t.start, u.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function UP(n, e, t) {
  for (let r of n) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function Hv(n, e, t, r, i, s) {
  if (e < t) {
    let o = n.buffer[e + 1];
    r.push(n.slice(e, t, o)), i.push(o - s);
  }
}
function GP(n) {
  let { node: e } = n, t = [], r = e.context.buffer;
  do
    t.push(n.index), n.parent();
  while (!n.tree);
  let i = n.tree, s = i.children.indexOf(r), o = i.children[s], l = o.buffer, a = [s];
  function c(u, h, f, d, p, m) {
    let g = t[m], b = [], w = [];
    Hv(o, u, g, b, w, d);
    let k = l[g + 1], T = l[g + 2];
    a.push(b.length);
    let M = m ? c(g + 4, l[g + 3], o.set.types[l[g]], k, T - k, m - 1) : e.toTree();
    return b.push(M), w.push(k - d), Hv(o, l[g + 3], h, b, w, d), new mt(f, b, w, p);
  }
  i.children[s] = c(0, l.length, Nr.none, 0, o.length, t.length - 1);
  for (let u of a) {
    let h = n.tree.children[u], f = n.tree.positions[u];
    n.yield(new Mn(h, f + n.from, u, n._tree));
  }
}
class $v {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Et.IncludeAnonymous | Et.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, Et.IgnoreOverlays | Et.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof mt)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
class KP {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(E4)) !== null && t !== void 0 ? t : r.to, this.inner = new $v(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(E4)) !== null && e !== void 0 ? e : t.to, this.inner = new $v(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(We.mounted);
        if (o && o.parser == t)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= s.to)
              break;
            a.tree == this.curFrag.tree && i.push({
              frag: a,
              pos: s.from - a.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function Vv(n, e) {
  let t = null, r = e;
  for (let i = 1, s = 0; i < n.length; i++) {
    let o = n[i - 1].to, l = n[i].from;
    for (; s < r.length; s++) {
      let a = r[s];
      if (a.from >= l)
        break;
      a.to <= o || (t || (r = t = e.slice()), a.from < o ? (t[s] = new Ur(a.from, o), a.to > l && t.splice(s + 1, 0, new Ur(l, a.to))) : a.to > l ? t[s--] = new Ur(l, a.to) : t.splice(s--, 1));
    }
  }
  return r;
}
function YP(n, e, t, r) {
  let i = 0, s = 0, o = !1, l = !1, a = -1e9, c = [];
  for (; ; ) {
    let u = i == n.length ? 1e9 : o ? n[i].to : n[i].from, h = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
    if (o != l) {
      let f = Math.max(a, t), d = Math.min(u, h, r);
      f < d && c.push(new Ur(f, d));
    }
    if (a = Math.min(u, h), a == 1e9)
      break;
    u == a && (o ? (o = !1, i++) : o = !0), h == a && (l ? (l = !1, s++) : l = !0);
  }
  return c;
}
function qv(n, e) {
  let t = [];
  for (let { pos: r, mount: i, frag: s } of n) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), l = o + i.tree.length, a = Math.max(s.from, o), c = Math.min(s.to, l);
    if (i.overlay) {
      let u = i.overlay.map((f) => new Ur(f.from + r, f.to + r)), h = YP(e, u, a, c);
      for (let f = 0, d = a; ; f++) {
        let p = f == h.length, m = p ? c : h[f].from;
        if (m > d && t.push(new Hs(d, m, i.tree, -o, s.from >= d || s.openStart, s.to <= m || s.openEnd)), p)
          break;
        d = h[f].to;
      }
    } else
      t.push(new Hs(a, c, i.tree, -o, s.from >= o || s.openStart, s.to <= l || s.openEnd));
  }
  return t;
}
let I4 = [], z9 = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < n.length; e++)
    (e % 2 ? z9 : I4).push(t = t + n[e]);
})();
function JP(n) {
  if (n < 768) return !1;
  for (let e = 0, t = I4.length; ; ) {
    let r = e + t >> 1;
    if (n < I4[r]) t = r;
    else if (n >= z9[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function Wv(n) {
  return n >= 127462 && n <= 127487;
}
const jv = 8205;
function XP(n, e, t = !0, r = !0) {
  return (t ? _9 : ZP)(n, e, r);
}
function _9(n, e, t) {
  if (e == n.length) return e;
  e && F9(n.charCodeAt(e)) && H9(n.charCodeAt(e - 1)) && e--;
  let r = Rg(n, e);
  for (e += Uv(r); e < n.length; ) {
    let i = Rg(n, e);
    if (r == jv || i == jv || t && JP(i))
      e += Uv(i), r = i;
    else if (Wv(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && Wv(Rg(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function ZP(n, e, t) {
  for (; e > 0; ) {
    let r = _9(n, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function Rg(n, e) {
  let t = n.charCodeAt(e);
  if (!H9(t) || e + 1 == n.length) return t;
  let r = n.charCodeAt(e + 1);
  return F9(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function F9(n) {
  return n >= 56320 && n < 57344;
}
function H9(n) {
  return n >= 55296 && n < 56320;
}
function Uv(n) {
  return n < 65536 ? 1 : 2;
}
class Xe {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = qc(this, e, t);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), up.from(i, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = qc(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), up.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new qh(this), s = new qh(e);
    for (let o = t, l = t; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new qh(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new $9(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new V9(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Xe.empty : e.length <= 32 ? new Bt(e) : up.from(Bt.split(e, []));
  }
}
class Bt extends Xe {
  constructor(e, t = QP(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((t ? r : l) >= e)
        return new eL(i, l, r, o);
      i = l + 1, r++;
    }
  }
  decompose(e, t, r, i) {
    let s = e <= 0 && t >= this.length ? this : new Bt(Gv(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), l = hp(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        r.push(new Bt(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        r.push(new Bt(l.slice(0, a)), new Bt(l.slice(a)));
      }
    } else
      r.push(s);
  }
  replace(e, t, r) {
    if (!(r instanceof Bt))
      return super.replace(e, t, r);
    [e, t] = qc(this, e, t);
    let i = hp(this.text, hp(r.text, Gv(this.text, 0, e)), t), s = this.length + r.length - (t - e);
    return i.length <= 32 ? new Bt(i, s) : up.from(Bt.split(i, []), s);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = qc(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (i += r), e < a && t > s && (i += l.slice(Math.max(0, e - s), t - s)), s = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (t.push(new Bt(r, i)), r = [], i = -1);
    return i > -1 && t.push(new Bt(r, i)), t;
  }
}
let up = class Ha extends Xe {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, a = r + o.lines - 1;
      if ((t ? a : l) >= e)
        return o.lineInner(e, t, r, i);
      i = l + 1, r = a + 1;
    }
  }
  decompose(e, t, r, i) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && t >= o) {
        let c = i & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
        o >= e && a <= t && !c ? r.push(l) : l.decompose(e - o, t - o, r, c);
      }
      o = a + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = qc(this, e, t), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && t <= l) {
          let a = o.replace(e - s, t - s, r), c = this.lines - o.lines + a.lines;
          if (a.lines < c >> 4 && a.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = a, new Ha(u, this.length - (t - e) + r.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = qc(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (i += r), e < a && t > o && (i += l.sliceString(e - o, t - o, r)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Ha))
      return 0;
    let r = 0, [i, s, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, s += t) {
      if (i == o || s == l)
        return r;
      let a = this.children[i], c = e.children[s];
      if (a != c)
        return r + a.scanIdentical(c, t);
      r += a.length + 1;
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e)
      r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new Bt(d, t);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, l = [], a = 0, c = -1, u = [];
    function h(d) {
      let p;
      if (d.lines > s && d instanceof Ha)
        for (let m of d.children)
          h(m);
      else d.lines > o && (a > o || !a) ? (f(), l.push(d)) : d instanceof Bt && a && (p = u[u.length - 1]) instanceof Bt && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, u[u.length - 1] = new Bt(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > i && f(), a += d.lines, c += d.length + 1, u.push(d));
    }
    function f() {
      a != 0 && (l.push(u.length == 1 ? u[0] : Ha.from(u, c)), c = -1, a = u.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), l.length == 1 ? l[0] : new Ha(l, t);
  }
};
Xe.empty = /* @__PURE__ */ new Bt([""], 0);
function QP(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function hp(n, e, t = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < n.length && i <= r; s++) {
    let l = n[s], a = i + l.length;
    a >= t && (a > r && (l = l.slice(0, r - i)), i < t && (l = l.slice(t - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = a + 1;
  }
  return e;
}
function Gv(n, e, t) {
  return hp(n, [""], e, t);
}
class qh {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof Bt ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, l = i instanceof Bt ? i.text.length : i.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof Bt) {
        let a = i.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[o + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof Bt ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class $9 {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new qh(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class V9 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Xe.prototype[Symbol.iterator] = function() {
  return this.iter();
}, qh.prototype[Symbol.iterator] = $9.prototype[Symbol.iterator] = V9.prototype[Symbol.iterator] = function() {
  return this;
});
class eL {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function qc(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
function gn(n, e, t = !0, r = !0) {
  return XP(n, e, t, r);
}
function tL(n) {
  return n >= 56320 && n < 57344;
}
function nL(n) {
  return n >= 55296 && n < 56320;
}
function er(n, e) {
  let t = n.charCodeAt(e);
  if (!nL(t) || e + 1 == n.length)
    return t;
  let r = n.charCodeAt(e + 1);
  return tL(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function e3(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function Wi(n) {
  return n < 65536 ? 1 : 2;
}
const D4 = /\r\n?|\n/;
var mn = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(mn || (mn = {}));
class Xi {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    N4(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new Xi(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : q9(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : R4(this, e, t);
  }
  mapPos(e, t = -1, r = mn.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], c = i + l;
      if (a < 0) {
        if (c > e)
          return s + (e - i);
        s += l;
      } else {
        if (r != mn.Simple && c >= e && (r == mn.TrackDel && i < e && c > e || r == mn.TrackBefore && i < e || r == mn.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !l)
          return e == i || t < 0 ? s : s + a;
        s += a;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let s = this.sections[r++], o = this.sections[r++], l = i + s;
      if (o >= 0 && i <= t && l >= e)
        return i < e && l > t ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Xi(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Xi(e);
  }
}
class Yt extends Xi {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return N4(this, (t, r, i, s, o) => e = e.replace(i, i + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return R4(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < t.length; i += 2) {
      let o = t[i], l = t[i + 1];
      if (l >= 0) {
        t[i] = l, t[i + 1] = o;
        let a = i >> 1;
        for (; r.length < a; )
          r.push(Xe.empty);
        r.push(o ? e.slice(s, s + o) : Xe.empty);
      }
      s += o;
    }
    return new Yt(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : q9(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : R4(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    N4(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Xi.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], i = [], s = new vf(this);
    e: for (let o = 0, l = 0; ; ) {
      let a = o == e.length ? 1e9 : e[o++];
      for (; l < a || l == a && s.len == 0; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, a - l);
        kn(i, u, -1);
        let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        kn(t, u, h), h > 0 && Do(r, t, s.text), s.forward(u), l += u;
      }
      let c = e[o++];
      for (; l < c; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, c - l);
        kn(t, u, -1), kn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), l += u;
      }
    }
    return {
      changes: new Yt(t, r),
      filtered: Xi.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let i = [], s = [], o = 0, l = null;
    function a(u = !1) {
      if (!u && !i.length)
        return;
      o < t && kn(i, t - o, -1);
      let h = new Yt(i, s);
      l = l ? l.compose(h.map(l)) : h, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof Yt) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        a(), l = l ? l.compose(u.map(l)) : u;
      } else {
        let { from: h, to: f = h, insert: d } = u;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? Xe.of(d.split(r || D4)) : d : Xe.empty, m = p.length;
        if (h == f && m == 0)
          return;
        h < o && a(), h > o && kn(i, h - o, -1), kn(i, f - h, m), Do(s, i, p), o = f;
      }
    }
    return c(e), a(!l), l;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Yt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(Xe.empty);
          r[i] = Xe.of(s.slice(1)), t.push(s[0], r[i].length);
        }
      }
    }
    return new Yt(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Yt(e, t);
  }
}
function kn(n, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = n.length - 2;
  i >= 0 && t <= 0 && t == n[i + 1] ? n[i] += e : i >= 0 && e == 0 && n[i] == 0 ? n[i + 1] += t : r ? (n[i] += e, n[i + 1] += t) : n.push(e, t);
}
function Do(n, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < r; )
      n.push(Xe.empty);
    n.push(t);
  }
}
function N4(n, e, t) {
  let r = n.inserted;
  for (let i = 0, s = 0, o = 0; o < n.sections.length; ) {
    let l = n.sections[o++], a = n.sections[o++];
    if (a < 0)
      i += l, s += l;
    else {
      let c = i, u = s, h = Xe.empty;
      for (; c += l, u += a, a && r && (h = h.append(r[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        l = n.sections[o++], a = n.sections[o++];
      e(i, c, s, u, h), i = c, s = u;
    }
  }
}
function R4(n, e, t, r = !1) {
  let i = [], s = r ? [] : null, o = new vf(n), l = new vf(e);
  for (let a = -1; ; ) {
    if (o.done && l.len || l.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && l.ins == -1) {
      let c = Math.min(o.len, l.len);
      kn(i, c, -1), o.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !t))) {
      let c = l.len;
      for (kn(i, l.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && a < o.i && o.len <= u && (kn(i, 0, o.ins), s && Do(s, i, o.text), a = o.i), o.forward(u), c -= u;
      }
      l.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (l.ins == -1) {
          let h = Math.min(u, l.len);
          c += h, u -= h, l.forward(h);
        } else if (l.ins == 0 && l.len < u)
          u -= l.len, l.next();
        else
          break;
      kn(i, c, a < o.i ? o.ins : 0), s && a < o.i && Do(s, i, o.text), a = o.i, o.forward(o.len - u);
    } else {
      if (o.done && l.done)
        return s ? Yt.createSet(i, s) : Xi.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function q9(n, e, t = !1) {
  let r = [], i = t ? [] : null, s = new vf(n), o = new vf(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? Yt.createSet(r, i) : Xi.create(r);
    if (s.ins == 0)
      kn(r, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      kn(r, 0, o.ins, l), i && Do(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), c = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          kn(r, a, u, l), i && u && Do(i, r, o.text);
        } else o.ins == -1 ? (kn(r, s.off ? 0 : s.len, a, l), i && Do(i, r, s.textBit(a))) : (kn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && Do(i, r, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || r.length > c), s.forward2(a), o.forward(a);
      }
    }
  }
}
class vf {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Xe.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? Xe.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
let d0 = class P4 {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new P4(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return G.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return G.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return G.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new P4(e, t, r);
  }
};
class G {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : G.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new G([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return G.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, G.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new G(e.ranges.map((t) => d0.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new G([G.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return G.normalized(e.slice(), t);
      r = s.to;
    }
    return new G(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, i) {
    return d0.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, i) {
    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return t < e ? d0.create(t, e, 48 | s) : d0.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((i, s) => i.from - s.from), t = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        i <= t && t--, e.splice(--i, 2, s.anchor > s.head ? G.range(a, l) : G.range(l, a));
      }
    }
    return new G(e, t);
  }
}
function W9(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let t3 = 0;
class he {
  constructor(e, t, r, i, s) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = i, this.id = t3++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new he(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : n3), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new fp([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new fp(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new fp(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function n3(n, e) {
  return n == e || n.length == e.length && n.every((t, r) => t === e[r]);
}
class fp {
  constructor(e, t, r, i) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = i, this.id = t3++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? a = !0 : h == "selection" ? c = !0 : (((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = r(h), 1;
      },
      update(h, f) {
        if (a && f.docChanged || c && (f.docChanged || f.selection) || L4(h, u)) {
          let d = r(h);
          if (l ? !Kv(d, h.values[o], i) : !i(d, h.values[o]))
            return h.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let m = dm(f, p);
          if (this.dependencies.every((g) => g instanceof he ? f.facet(g) === h.facet(g) : g instanceof sn ? f.field(g, !1) == h.field(g, !1) : !0) || (l ? Kv(d = r(h), m, i) : i(d = r(h), m)))
            return h.values[o] = m, 0;
        } else
          d = r(h);
        return h.values[o] = d, 1;
      }
    };
  }
}
function Kv(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function L4(n, e) {
  let t = !1;
  for (let r of e)
    Wh(n, r) & 1 && (t = !0);
  return t;
}
function rL(n, e, t) {
  let r = t.map((a) => n[a.id]), i = t.map((a) => a.type), s = r.filter((a) => !(a & 1)), o = n[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = dm(a, r[u]);
      if (i[u] == 2)
        for (let f of h)
          c.push(f);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of r)
        Wh(a, c);
      return a.values[o] = l(a), 1;
    },
    update(a, c) {
      if (!L4(a, s))
        return 0;
      let u = l(a);
      return e.compare(u, a.values[o]) ? 0 : (a.values[o] = u, 1);
    },
    reconfigure(a, c) {
      let u = L4(a, r), h = c.config.facets[e.id], f = c.facet(e);
      if (h && !u && n3(t, h))
        return a.values[o] = f, 0;
      let d = l(a);
      return e.compare(d, f) ? (a.values[o] = f, 0) : (a.values[o] = d, 1);
    }
  };
}
const p0 = /* @__PURE__ */ he.define({ static: !0 });
class sn {
  constructor(e, t, r, i, s) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new sn(t3++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(p0).find((r) => r.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[t], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, i) => {
        let s = r.facet(p0), o = i.facet(p0), l;
        return (l = s.find((a) => a.field == this)) && l != o.find((a) => a.field == this) ? (r.values[t] = l.create(r), 1) : i.config.address[this.id] != null ? (r.values[t] = i.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, p0.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Tl = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function qu(n) {
  return (e) => new j9(e, n);
}
const el = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ qu(Tl.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ qu(Tl.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ qu(Tl.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ qu(Tl.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ qu(Tl.lowest)
};
class j9 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Wc {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new B4(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Wc.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class B4 {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
let Yv = class U9 {
  constructor(e, t, r, i, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of iL(e, t, o))
      f instanceof sn ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let l = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let f of i)
      l[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let u = r == null ? void 0 : r.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, m = u && u[f] || [];
      if (d.every(
        (g) => g.type == 0
        /* Provider.Static */
      ))
        if (l[p.id] = a.length << 1 | 1, n3(m, d))
          a.push(r.facet(p));
        else {
          let g = p.combine(d.map((b) => b.value));
          a.push(r && p.compare(g, r.facet(p)) ? r.facet(p) : g);
        }
      else {
        for (let g of d)
          g.type == 0 ? (l[g.id] = a.length << 1 | 1, a.push(g.value)) : (l[g.id] = c.length << 1, c.push((b) => g.dynamicSlot(b)));
        l[p.id] = c.length << 1, c.push((g) => rL(g, p, d));
      }
    }
    let h = c.map((f) => f(l));
    return new U9(e, o, h, l, a, s);
  }
};
function iL(n, e, t) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = i.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let c = r[a].indexOf(o);
      c > -1 && r[a].splice(c, 1), o instanceof B4 && t.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let c of o)
        s(c, l);
    else if (o instanceof B4) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, l);
    } else if (o instanceof j9)
      s(o.inner, o.prec);
    else if (o instanceof sn)
      r[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof fp)
      r[l].push(o), o.facet.extensions && s(o.facet.extensions, Tl.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, l);
    }
  }
  return s(n, Tl.default), r.reduce((o, l) => o.concat(l));
}
function Wh(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = n.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  n.status[t] = 4;
  let i = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | i;
}
function dm(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const G9 = /* @__PURE__ */ he.define(), z4 = /* @__PURE__ */ he.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), K9 = /* @__PURE__ */ he.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), Y9 = /* @__PURE__ */ he.define(), J9 = /* @__PURE__ */ he.define(), X9 = /* @__PURE__ */ he.define(), Z9 = /* @__PURE__ */ he.define({
  combine: (n) => n.length ? n[0] : !1
});
class to {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new sL();
  }
}
class sL {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new to(this, e);
  }
}
class oL {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new ze(this, e);
  }
}
class ze {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new ze(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new oL(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(t);
      s && r.push(s);
    }
    return r;
  }
}
ze.reconfigure = /* @__PURE__ */ ze.define();
ze.appendConfig = /* @__PURE__ */ ze.define();
let zn = class sh {
  constructor(e, t, r, i, s, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && W9(r, t.newLength), s.some((l) => l.type == sh.time) || (this.annotations = s.concat(sh.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, i, s, o) {
    return new sh(e, t, r, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(sh.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
};
zn.time = /* @__PURE__ */ to.define();
zn.userEvent = /* @__PURE__ */ to.define();
zn.addToHistory = /* @__PURE__ */ to.define();
zn.remote = /* @__PURE__ */ to.define();
function lL(n, e) {
  let t = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      s = n[r++], o = n[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function Q9(n, e, t) {
  var r;
  let i, s, o;
  return t ? (i = e.changes, s = Yt.empty(e.changes.length), o = n.changes.compose(e.changes)) : (i = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = n.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: ze.mapEffects(n.effects, i).concat(ze.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function _4(n, e, t) {
  let r = e.selection, i = rc(e.annotations);
  return e.userEvent && (i = i.concat(zn.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Yt ? e.changes : Yt.of(e.changes || [], t, n.facet(K9)),
    selection: r && (r instanceof G ? r : G.single(r.anchor, r.head)),
    effects: rc(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function eS(n, e, t) {
  let r = _4(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    r = Q9(r, _4(n, e[s], o ? r.changes.newLength : n.doc.length), o);
  }
  let i = zn.create(n, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return cL(t ? aL(i) : i);
}
function aL(n) {
  let e = n.startState, t = !0;
  for (let i of e.facet(Y9)) {
    let s = i(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : lL(t, s));
  }
  if (t !== !0) {
    let i, s;
    if (t === !1)
      s = n.changes.invertedDesc, i = Yt.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = zn.create(e, i, n.selection && n.selection.map(s), ze.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let r = e.facet(J9);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](n);
    s instanceof zn ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof zn ? n = s[0] : n = eS(e, rc(s), !1);
  }
  return n;
}
function cL(n) {
  let e = n.startState, t = e.facet(X9), r = n;
  for (let i = t.length - 1; i >= 0; i--) {
    let s = t[i](n);
    s && Object.keys(s).length && (r = Q9(r, _4(e, s, n.changes.newLength), !0));
  }
  return r == n ? n : zn.create(e, n.changes, n.selection, r.effects, r.annotations, r.scrollIntoView);
}
const uL = [];
function rc(n) {
  return n == null ? uL : Array.isArray(n) ? n : [n];
}
var St = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(St || (St = {}));
const hL = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let F4;
try {
  F4 = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function fL(n) {
  if (F4)
    return F4.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "Â€" && (t.toUpperCase() != t.toLowerCase() || hL.test(t)))
      return !0;
  }
  return !1;
}
function dL(n) {
  return (e) => {
    if (!/\S/.test(e))
      return St.Space;
    if (fL(e))
      return St.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return St.Word;
    return St.Other;
  };
}
let Ct = class fi {
  constructor(e, t, r, i, s, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Wh(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Wh(this, r), dm(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return eS(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: i } = t;
    for (let l of e.effects)
      l.is(Wc.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((a, c) => i.set(c, a)), t = null), i.set(l.value.compartment, l.value.extension)) : l.is(ze.reconfigure) ? (t = null, r = l.value) : l.is(ze.appendConfig) && (t = null, r = rc(r).concat(l.value));
    let s;
    t ? s = e.startState.values.slice() : (t = Yv.resolve(r, i, this), s = new fi(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, c) => c.reconfigure(a, this), null).values);
    let o = e.startState.facet(z4) ? e.newSelection : e.newSelection.asSingle();
    new fi(t, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: G.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), i = this.changes(r.changes), s = [r.range], o = rc(r.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let a = e(t.ranges[l]), c = this.changes(a.changes), u = c.map(i);
      for (let f = 0; f < l; f++)
        s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(a.range.map(h)), i = i.compose(u), o = ze.mapEffects(o, u).concat(ze.mapEffects(rc(a.effects), h));
    }
    return {
      changes: i,
      selection: G.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Yt ? e : Yt.of(e, this.doc.length, this.facet(fi.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Xe.of(e.split(this.facet(fi.lineSeparator) || D4));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Wh(this, t), dm(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof sn && this.config.address[i.id] != null && (t[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], l = e[s];
          i.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return fi.create({
      doc: e.doc,
      selection: G.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Yv.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof Xe ? e.doc : Xe.of((e.doc || "").split(t.staticFacet(fi.lineSeparator) || D4)), i = e.selection ? e.selection instanceof G ? e.selection : G.single(e.selection.anchor, e.selection.head) : G.single(0);
    return W9(i, r.length), t.staticFacet(z4) || (i = i.asSingle()), new fi(t, r, i, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(fi.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(fi.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Z9);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(fi.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > t.length ? r : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let i = [];
    for (let s of this.facet(G9))
      for (let o of s(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return dL(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, l = e - r;
    for (; o > 0; ) {
      let a = gn(t, o, !1);
      if (s(t.slice(a, o)) != St.Word)
        break;
      o = a;
    }
    for (; l < i; ) {
      let a = gn(t, l);
      if (s(t.slice(l, a)) != St.Word)
        break;
      l = a;
    }
    return o == l ? null : G.range(o + r, l + r);
  }
};
Ct.allowMultipleSelections = z4;
Ct.tabSize = /* @__PURE__ */ he.define({
  combine: (n) => n.length ? n[0] : 4
});
Ct.lineSeparator = K9;
Ct.readOnly = Z9;
Ct.phrases = /* @__PURE__ */ he.define({
  compare(n, e) {
    let t = Object.keys(n), r = Object.keys(e);
    return t.length == r.length && t.every((i) => n[i] == e[i]);
  }
});
Ct.languageData = G9;
Ct.changeFilter = Y9;
Ct.transactionFilter = J9;
Ct.transactionExtender = X9;
Wc.reconfigure = /* @__PURE__ */ ze.define();
function ls(n, e, t = {}) {
  let r = {};
  for (let i of n)
    for (let s of Object.keys(i)) {
      let o = i[s], l = r[s];
      if (l === void 0)
        r[s] = o;
      else if (!(l === o || o === void 0)) if (Object.hasOwnProperty.call(t, s))
        r[s] = t[s](l, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class la {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return wf.create(e, t, this);
  }
}
la.prototype.startSide = la.prototype.endSide = 0;
la.prototype.point = !1;
la.prototype.mapMode = mn.TrackDel;
class wf {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new wf(e, t, r);
  }
}
function H4(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class r3 {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, c = s[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == o)
        return c >= 0 ? o : l;
      c >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, t, r, i) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], i = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], u = this.from[a] + e, h = this.to[a] + e, f, d;
      if (u == h) {
        let p = t.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = t.mapPos(u, c.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(u, c.startSide), d = t.mapPos(h, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (l = Math.max(l, d - f)), r.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: r.length ? new r3(i, s, r, l) : null, pos: o };
  }
}
class Ze {
  constructor(e, t, r, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, r, i) {
    return new Ze(e, t, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(H4)), this.isEmpty)
      return t.length ? Ze.of(t) : this;
    let l = new tS(this, null, -1).goto(0), a = 0, c = [], u = new Us();
    for (; l.value || a < t.length; )
      if (a < t.length && (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0) {
        let h = t[a++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && u.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (u.addInner(l.from, l.to, l.value) || c.push(wf.create(l.from, l.to, l.value))), l.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? Ze.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], c = e.touchesRange(l, l + a.length);
      if (c === !1)
        i = Math.max(i, a.maxPoint), t.push(a), r.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: u, pos: h } = a.map(l, e);
        u && (i = Math.max(i, u.maxPoint), t.push(u), r.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new Ze(r, t, s || Ze.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return xf.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return xf.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = Jv(o, l, r), c = new Wu(o, a, s), u = new Wu(l, a, s);
    r.iterGaps((h, f, d) => Xv(c, h, u, f, d, i)), r.empty && r.length == 0 && Xv(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = Jv(s, o), a = new Wu(s, l, 0).goto(r), c = new Wu(o, l, 0).goto(r);
    for (; ; ) {
      if (a.to != c.to || !$4(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, i, s = -1) {
    let o = new Wu(e, null, s).goto(t), l = t, a = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < t ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, a);
        i.point(l, c, o.point, u, h, o.pointRank), a = Math.min(o.openEnd(c), u.length);
      } else c > l && (i.span(l, c, o.active, a), a = o.openEnd(c));
      if (o.to > r)
        return a + (o.point && o.to > r ? 1 : 0);
      l = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new Us();
    for (let i of e instanceof wf ? [e] : t ? pL(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Ze.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != Ze.empty; i = i.nextLayer)
        t = new Ze(i.chunkPos, i.chunk, t, Math.max(i.maxPoint, t.maxPoint));
    return t;
  }
}
Ze.empty = /* @__PURE__ */ new Ze([], [], null, -1);
function pL(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t];
      if (H4(e, r) > 0)
        return n.slice().sort(H4);
      e = r;
    }
  return n;
}
Ze.empty.nextLayer = Ze.empty;
class Us {
  finishChunk(e) {
    this.chunks.push(new r3(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new Us())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Ze.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Ze.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function Jv(n, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = r.get(s.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == s.chunkPos[o] && !(t != null && t.touchesRange(l, l + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class tS {
  constructor(e, t, r, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class xf {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new tS(o, t, r, s));
    return i.length == 1 ? i[0] : new xf(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Pg(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Pg(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Pg(this.heap, 0);
    }
  }
}
function Pg(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= n.length)
      break;
    let i = n[r];
    if (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && (i = n[r + 1], r++), t.compare(i) < 0)
      break;
    n[r] = t, n[e] = i, e = r;
  }
}
class Wu {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = xf.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    m0(this.active, e), m0(this.activeTo, e), m0(this.activeRank, e), this.minActive = Zv(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || i - this.activeTo[t]) > 0; )
      t++;
    g0(this.active, t, r), g0(this.activeTo, t, i), g0(this.activeRank, t, s), e && g0(e, t, this.cursor.from), this.minActive = Zv(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && m0(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function Xv(n, e, t, r, i, s) {
  n.goto(e), t.goto(r);
  let o = r + i, l = r, a = r - e;
  for (; ; ) {
    let c = n.to + a - t.to, u = c || n.endSide - t.endSide, h = u < 0 ? n.to + a : t.to, f = Math.min(h, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && $4(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(l, f, n.point, t.point) : f > l && !$4(n.active, t.active) && s.compareRange(l, f, n.active, t.active), h > o)
      break;
    (c || n.openEnd != t.openEnd) && s.boundChange && s.boundChange(h), l = h, u <= 0 && n.next(), u >= 0 && t.next();
  }
}
function $4(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function m0(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++)
    n[t] = n[t + 1];
  n.pop();
}
function g0(n, e, t) {
  for (let r = n.length - 1; r >= e; r--)
    n[r + 1] = n[r];
  n[e] = t;
}
function Zv(n, e) {
  let t = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && (t = i, r = e[i]);
  return t;
}
function fu(n, e, t = n.length) {
  let r = 0;
  for (let i = 0; i < t && i < n.length; )
    n.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = gn(n, i));
  return r;
}
function V4(n, e, t, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == n.length)
      break;
    s += n.charCodeAt(i) == 9 ? t - s % t : 1, i = gn(n, i);
  }
  return r === !0 ? -1 : n.length;
}
const q4 = "Í¼", Qv = typeof Symbol > "u" ? "__" + q4 : Symbol.for(q4), W4 = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), e6 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class qo {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && l == null) return a.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((m) => o.map((g) => m.replace(/&/, g))).reduce((m, g) => m.concat(g)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!h) throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, u, f);
        } else p != null && u.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && a.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = e6[Qv] || 1;
    return e6[Qv] = e + 1, q4 + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let i = e[W4], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new mL(e, s), i.mount(Array.isArray(t) ? t : [t], e);
  }
}
let t6 = /* @__PURE__ */ new Map();
class mL {
  constructor(e, t) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = t6.get(r);
      if (s) return e[W4] = s;
      this.sheet = new i.CSSStyleSheet(), t6.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[W4] = this;
  }
  mount(e, t) {
    let r = this.sheet, i = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = this.modules.indexOf(l);
      if (a < s && a > -1 && (this.modules.splice(a, 1), s--, a = -1), a == -1) {
        if (this.modules.splice(s++, 0, l), r) for (let c = 0; c < l.rules.length; c++)
          r.insertRule(l.rules[c], i++);
      } else {
        for (; s < a; ) i += this.modules[s++].rules.length;
        i += l.rules.length, s++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let a = 0; a < this.modules.length; a++)
        o += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = o;
      let l = t.head || t;
      this.styleTag.parentNode != l && l.insertBefore(this.styleTag, l.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var Gs = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, kf = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, gL = typeof navigator < "u" && /Mac/.test(navigator.platform), yL = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var dn = 0; dn < 10; dn++) Gs[48 + dn] = Gs[96 + dn] = String(dn);
for (var dn = 1; dn <= 24; dn++) Gs[dn + 111] = "F" + dn;
for (var dn = 65; dn <= 90; dn++)
  Gs[dn] = String.fromCharCode(dn + 32), kf[dn] = String.fromCharCode(dn);
for (var Lg in Gs) kf.hasOwnProperty(Lg) || (kf[Lg] = Gs[Lg]);
function nS(n) {
  var e = gL && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || yL && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? kf : Gs)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function lt() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      typeof i == "string" ? n.setAttribute(r, i) : i != null && (n[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) rS(n, arguments[e]);
  return n;
}
function rS(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    n.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) rS(n, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Sf(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function j4(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function dp(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return j4(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function Cf(n) {
  return n.nodeType == 3 ? ca(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function jh(n, e, t, r) {
  return t ? n6(n, e, t, r, -1) || n6(n, e, t, r, 1) : !1;
}
function aa(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function pm(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function n6(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : ts(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = aa(n) + (i < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = i < 0 ? ts(n) : 0;
    } else
      return !1;
  }
}
function ts(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function d1(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function bL(n) {
  let e = n.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function iS(n, e) {
  let t = e.width / n.offsetWidth, r = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - n.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function vL(n, e, t, r, i, s, o, l) {
  let a = n.ownerDocument, c = a.defaultView || window;
  for (let u = n, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f, d = u == a.body, p = 1, m = 1;
      if (d)
        f = bL(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let w = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: m } = iS(u, w)), f = {
          left: w.left,
          right: w.left + u.clientWidth * p,
          top: w.top,
          bottom: w.top + u.clientHeight * m
        };
      }
      let g = 0, b = 0;
      if (i == "nearest")
        e.top < f.top ? (b = e.top - (f.top + o), t > 0 && e.bottom > f.bottom + b && (b = e.bottom - f.bottom + o)) : e.bottom > f.bottom && (b = e.bottom - f.bottom + o, t < 0 && e.top - b < f.top && (b = e.top - (f.top + o)));
      else {
        let w = e.bottom - e.top, k = f.bottom - f.top;
        b = (i == "center" && w <= k ? e.top + w / 2 - k / 2 : i == "start" || i == "center" && t < 0 ? e.top - o : e.bottom - k + o) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (g = e.left - (f.left + s), t > 0 && e.right > f.right + g && (g = e.right - f.right + s)) : e.right > f.right && (g = e.right - f.right + s, t < 0 && e.left < f.left + g && (g = e.left - (f.left + s))) : g = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, g || b)
        if (d)
          c.scrollBy(g, b);
        else {
          let w = 0, k = 0;
          if (b) {
            let T = u.scrollTop;
            u.scrollTop += b / m, k = (u.scrollTop - T) * m;
          }
          if (g) {
            let T = u.scrollLeft;
            u.scrollLeft += g / p, w = (u.scrollLeft - T) * p;
          }
          e = {
            left: e.left - w,
            top: e.top - k,
            right: e.right - w,
            bottom: e.bottom - k
          }, w && Math.abs(w - g) < 1 && (r = "nearest"), k && Math.abs(k - b) < 1 && (i = "nearest");
        }
      if (d)
        break;
      (e.top < f.top || e.bottom > f.bottom || e.left < f.left || e.right > f.right) && (e = {
        left: Math.max(e.left, f.left),
        right: Math.min(e.right, f.right),
        top: Math.max(e.top, f.top),
        bottom: Math.min(e.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function wL(n) {
  let e = n.ownerDocument, t, r;
  for (let i = n.parentNode; i && !(i == e.body || t && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !t && i.scrollWidth > i.clientWidth && (t = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: t, y: r };
}
class xL {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? ts(t) : 0), r, Math.min(e.focusOffset, r ? ts(r) : 0));
  }
  set(e, t, r, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = i;
  }
}
let Ba = null;
function sS(n) {
  if (n.setActive)
    return n.setActive();
  if (Ba)
    return n.focus(Ba);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(Ba == null ? {
    get preventScroll() {
      return Ba = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ba) {
    Ba = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], i = e[t++], s = e[t++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let r6;
function ca(n, e, t = e) {
  let r = r6 || (r6 = document.createRange());
  return r.setEnd(n, t), r.setStart(n, e), r;
}
function ic(n, e, t, r) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, n.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return o.synthetic = !0, n.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function kL(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function oS(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function SL(n, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, ts(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (t = i, r = ts(t));
    } else {
      if (t == n)
        return !0;
      r = aa(t), t = t.parentNode;
    }
}
function lS(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function aS(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = ts(t);
    } else if (t.parentNode && !pm(t))
      r = aa(t), t = t.parentNode;
    else
      return null;
  }
}
function cS(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !pm(t))
      r = aa(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class Sn {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new Sn(e.parentNode, aa(e), t);
  }
  static after(e, t) {
    return new Sn(e.parentNode, aa(e) + 1, t);
  }
}
const i3 = [];
class ut {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let l = ut.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, t && !t.written && t.node == r && s != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = i6(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && t && t.node == r && (t.written = !0); s; )
        s = i6(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let i = ts(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !ut.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = r, u = r; a < this.children.length; a++) {
      let h = this.children[a], f = c + h.length;
      if (c < e && f > t)
        return h.domBoundsAround(e, t, c);
      if (f >= e && i == -1 && (i = a, s = c), c > t && h.dom.parentNode == this.dom) {
        o = a, l = u;
        break;
      }
      u = f, c = f + h.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = i3) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new uS(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
ut.prototype.breakAfter = 0;
function i6(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class uS {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function hS(n, e, t, r, i, s, o, l, a) {
  let { children: c } = n, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(t, i, s.length ? h : null, t == 0, l, a))) {
    if (r < c.length) {
      let d = c[r];
      d && (i < d.length || d.breakAfter && (h != null && h.breakAfter)) ? (e == r && (d = d.split(i), i = 0), !f && h && d.merge(0, i, h, !0, 0, a) ? s[s.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, a), s.push(d))) : d != null && d.breakAfter && (h ? h.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, t > 0 && (!o && s.length && u.merge(t, u.length, s[0], !1, l, 0) ? u.breakAfter = s.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, l, 0), e++)); e < r && s.length; )
      if (c[r - 1].become(s[s.length - 1]))
        r--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < r || s.length) && n.replaceChildren(e, r, s);
  }
}
function fS(n, e, t, r, i, s) {
  let o = n.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: c, off: u } = o.findPos(e, -1), h = e - t;
  for (let f of r)
    h += f.length;
  n.length += h, hS(n, c, u, l, a, r, 0, i, s);
}
let tr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, U4 = typeof document < "u" ? document : { documentElement: { style: {} } };
const G4 = /* @__PURE__ */ /Edge\/(\d+)/.exec(tr.userAgent), dS = /* @__PURE__ */ /MSIE \d/.test(tr.userAgent), K4 = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(tr.userAgent), p1 = !!(dS || K4 || G4), s6 = !p1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(tr.userAgent), Bg = !p1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(tr.userAgent), CL = "webkitFontSmoothing" in U4.documentElement.style, pS = !p1 && /* @__PURE__ */ /Apple Computer/.test(tr.vendor), o6 = pS && (/* @__PURE__ */ /Mobile\/\w+/.test(tr.userAgent) || tr.maxTouchPoints > 2);
var ae = {
  mac: o6 || /* @__PURE__ */ /Mac/.test(tr.platform),
  windows: /* @__PURE__ */ /Win/.test(tr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(tr.platform),
  ie: p1,
  ie_version: dS ? U4.documentMode || 6 : K4 ? +K4[1] : G4 ? +G4[1] : 0,
  gecko: s6,
  gecko_version: s6 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(tr.userAgent) || [0, 0])[1] : 0,
  chrome: !!Bg,
  chrome_version: Bg ? +Bg[1] : 0,
  ios: o6,
  android: /* @__PURE__ */ /Android\b/.test(tr.userAgent),
  safari: pS,
  webkit_version: CL ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(tr.userAgent) || [0, 0])[1] : 0,
  tabSize: U4.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const ML = 256;
class ki extends ut {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof ki) || this.length - (t - e) + r.length > ML || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new ki(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Sn(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return TL(this.dom, e, t);
  }
}
class Ks extends ut {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (oS(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof Ks && r.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (fS(this, e, t, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, i = -1, s = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && t.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = s), r = a, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Ks(this.mark, t, o);
  }
  domAtPos(e) {
    return mS(this, e);
  }
  coordsAt(e, t) {
    return yS(this, e, t);
  }
}
function TL(n, e, t) {
  let r = n.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? ae.chrome || ae.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : t < 0 ? i-- : s < r && s++;
  let l = ca(n, i, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return ae.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? d1(a, o < 0) : a || null;
}
class No extends ut {
  static create(e, t, r) {
    return new No(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = No.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof No) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof No && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Xe.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : Xe.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Sn.before(this.dom) : Sn.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return d1(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class jc extends ut {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof jc && e.side == this.side;
  }
  split() {
    return new jc(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Sn.before(this.dom) : Sn.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Xe.empty;
  }
  get isHidden() {
    return !0;
  }
}
ki.prototype.children = No.prototype.children = jc.prototype.children = i3;
function mS(n, e) {
  let t = n.dom, { children: r } = n, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new Sn(t, 0);
}
function gS(n, e, t) {
  let r, { children: i } = n;
  t > 0 && e instanceof Ks && i.length && (r = i[i.length - 1]) instanceof Ks && r.mark.eq(e.mark) ? gS(r, e.children[0], t - 1) : (i.push(e), e.setParent(n)), n.length += e.length;
}
function yS(n, e, t) {
  let r = null, i = -1, s = null, o = -1;
  function l(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let d = c.children[h], p = f + d.length;
      p >= u && (d.children.length ? l(d, u - f) : (!s || s.isHidden && (t > 0 || OL(s, d))) && (p > u || f == p && d.getSide() > 0) ? (s = d, o = u - f) : (f < u || f == p && d.getSide() < 0 && !d.isHidden) && (r = d, i = u - f)), f = p;
    }
  }
  l(n, e);
  let a = (t < 0 ? r : s) || r || s;
  return a ? a.coordsAt(Math.max(0, a == r ? i : o), t) : AL(n);
}
function AL(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = Cf(e);
  return t[t.length - 1] || null;
}
function OL(n, e) {
  let t = n.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function Y4(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const l6 = /* @__PURE__ */ Object.create(null);
function mm(n, e, t) {
  if (n == e)
    return !0;
  n || (n = l6), e || (e = l6);
  let r = Object.keys(n), i = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != i.length - (t && i.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != t && (i.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function J4(n, e, t) {
  let r = !1;
  if (e)
    for (let i in e)
      t && i in t || (r = !0, i == "style" ? n.style.cssText = "" : n.removeAttribute(i));
  if (t)
    for (let i in t)
      e && e[i] == t[i] || (r = !0, i == "style" ? n.style.cssText = t[i] : n.setAttribute(i, t[i]));
  return r;
}
function EL(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
let no = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var _n = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(_n || (_n = {}));
let Se = class extends la {
  constructor(e, t, r, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Od(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Wo(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = bS(e, t);
      r = (s ? t ? -3e8 : -1 : 5e8) - 1, i = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Wo(e, r, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Ed(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Ze.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
};
Se.none = Ze.empty;
class Od extends Se {
  constructor(e) {
    let { start: t, end: r } = bS(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof Od && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && mm(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
Od.prototype.point = !1;
class Ed extends Se {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ed && this.spec.class == e.spec.class && mm(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Ed.prototype.mapMode = mn.TrackBefore;
Ed.prototype.point = !0;
class Wo extends Se {
  constructor(e, t, r, i, s, o) {
    super(t, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? t <= 0 ? mn.TrackBefore : mn.TrackAfter : mn.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? _n.WidgetRange : this.startSide <= 0 ? _n.WidgetBefore : _n.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Wo && IL(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Wo.prototype.point = !0;
function bS(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n;
  return t == null && (t = n.inclusive), r == null && (r = n.inclusive), { start: t ?? e, end: r ?? e };
}
function IL(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function pp(n, e, t, r = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + r >= n ? t[i] = Math.max(t[i], e) : t.push(n, e);
}
class Vt extends ut {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, i, s, o) {
    if (r) {
      if (!(r instanceof Vt))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), fS(this, e, t, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new Vt();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: i } = this.childPos(e);
    i && (t.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    mm(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    gS(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = Y4(t, this.attrs || {})), r && (this.attrs = Y4({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return mS(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (oS(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (J4(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let i = this.dom.lastChild;
    for (; i && ut.get(i) instanceof Ks; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = ut.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!ae.ios || !this.children.some((s) => s instanceof ki))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof ki) || /[^ -~]/.test(r.text))
        return null;
      let i = Cf(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, t = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = yS(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof Vt && this.children.length == 0 && e.children.length == 0 && mm(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= t) {
        if (s instanceof Vt)
          return s;
        if (o > t)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class $s extends ut {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof $s) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Sn.before(this.dom) : Sn.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new $s(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return i3;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Xe.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof $s && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof X4 ? null : d1(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class X4 extends no {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class Uh {
  constructor(e, t, r, i) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof $s && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Vt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(y0(new jc(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof $s) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: l, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (l) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, e), s = Math.min(
        i,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(y0(new ki(this.text.slice(this.textOff, this.textOff + s)), t), r), this.atCursorPos = !0, this.textOff += s, e -= s, r = i <= s ? 0 : t.length;
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof Wo) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (r instanceof Wo)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new $s(r.widget || Uc.block, l, r));
      else {
        let a = No.create(r.widget || Uc.inline, l, l ? 0 : r.startSide), c = this.atCursorPos && !a.isEditable && s <= i.length && (e < t || r.startSide > 0), u = !a.isEditable && (e < t || s > i.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(y0(new jc(1), i), s), s = i.length + Math.max(0, s - i.length)), h.append(y0(a, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < t || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, r, i, s) {
    let o = new Uh(e, t, r, s);
    return o.openEnd = Ze.spans(i, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function y0(n, e) {
  for (let t of e)
    n = new Ks(t, [n], n.length);
  return n;
}
class Uc extends no {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
Uc.inline = /* @__PURE__ */ new Uc("span");
Uc.block = /* @__PURE__ */ new Uc("div");
var wt = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(wt || (wt = {}));
const ua = wt.LTR, s3 = wt.RTL;
function vS(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const DL = /* @__PURE__ */ vS("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), NL = /* @__PURE__ */ vS("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Z4 = /* @__PURE__ */ Object.create(null), Li = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  Z4[e] = t, Z4[t] = -e;
}
function wS(n) {
  return n <= 247 ? DL[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? NL[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const RL = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ro {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? s3 : ua;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function xS(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let r = n[t], i = e[t];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !xS(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const at = [];
function PL(n, e, t, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, l = s < r.length ? r[s].from : t, a = s ? 256 : i;
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = wS(n.charCodeAt(c));
      f == 512 ? f = u : f == 8 && h == 4 && (f = 16), at[c] = f == 4 ? 2 : f, f & 7 && (h = f), u = f;
    }
    for (let c = o, u = a, h = a; c < l; c++) {
      let f = at[c];
      if (f == 128)
        c < l - 1 && u == at[c + 1] && u & 24 ? f = at[c] = u : at[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && at[d] == 64; )
          d++;
        let p = c && u == 8 || d < t && at[d] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let m = c; m < d; m++)
          at[m] = p;
        c = d - 1;
      } else f == 8 && h == 1 && (at[c] = 1);
      u = f, f & 7 && (h = f);
    }
  }
}
function LL(n, e, t, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : t;
    for (let h = c, f, d, p; h < u; h++)
      if (d = Z4[f = n.charCodeAt(h)])
        if (d < 0) {
          for (let m = l - 3; m >= 0; m -= 3)
            if (Li[m + 1] == -d) {
              let g = Li[m + 2], b = g & 2 ? i : g & 4 ? g & 1 ? s : i : 0;
              b && (at[h] = at[Li[m]] = b), l = m;
              break;
            }
        } else {
          if (Li.length == 189)
            break;
          Li[l++] = h, Li[l++] = f, Li[l++] = a;
        }
      else if ((p = at[h]) == 2 || p == 1) {
        let m = p == i;
        a = m ? 0 : 1;
        for (let g = l - 3; g >= 0; g -= 3) {
          let b = Li[g + 2];
          if (b & 2)
            break;
          if (m)
            Li[g + 2] |= 2;
          else {
            if (b & 4)
              break;
            Li[g + 2] |= 4;
          }
        }
      }
  }
}
function BL(n, e, t, r) {
  for (let i = 0, s = r; i <= t.length; i++) {
    let o = i ? t[i - 1].to : n, l = i < t.length ? t[i].from : e;
    for (let a = o; a < l; ) {
      let c = at[a];
      if (c == 256) {
        let u = a + 1;
        for (; ; )
          if (u == l) {
            if (i == t.length)
              break;
            u = t[i++].to, l = i < t.length ? t[i].from : e;
          } else if (at[u] == 256)
            u++;
          else
            break;
        let h = s == 1, f = (u < e ? at[u] : r) == 1, d = h == f ? h ? 1 : 2 : r;
        for (let p = u, m = i, g = m ? t[m - 1].to : n; p > a; )
          p == g && (p = t[--m].from, g = m ? t[m - 1].to : n), at[--p] = d;
        a = u;
      } else
        s = c, a++;
    }
  }
}
function Q4(n, e, t, r, i, s, o) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, c = 0; a < t; ) {
      let u = !0, h = !1;
      if (c == s.length || a < s[c].from) {
        let m = at[a];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c < s.length && p == s[c].from) {
          if (h)
            break e;
          let m = s[c];
          if (!u)
            for (let g = m.to, b = c + 1; ; ) {
              if (g == t)
                break e;
              if (b < s.length && s[b].from == g)
                g = s[b++].to;
              else {
                if (at[g] == l)
                  break e;
                break;
              }
            }
          if (c++, f)
            f.push(m);
          else {
            m.from > a && o.push(new Ro(a, m.from, d));
            let g = m.direction == ua != !(d % 2);
            ey(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.to;
          }
          p = m.to;
        } else {
          if (p == t || (u ? at[p] != l : at[p] == l))
            break;
          p++;
        }
      f ? Q4(n, a, p, r + 1, i, f, o) : a < p && o.push(new Ro(a, p, d)), a = p;
    }
  else
    for (let a = t, c = s.length; a > e; ) {
      let u = !0, h = !1;
      if (!c || a > s[c - 1].to) {
        let m = at[a - 1];
        m != l && (u = !1, h = m == 16);
      }
      let f = !u && l == 1 ? [] : null, d = u ? r : r + 1, p = a;
      e: for (; ; )
        if (c && p == s[c - 1].to) {
          if (h)
            break e;
          let m = s[--c];
          if (!u)
            for (let g = m.from, b = c; ; ) {
              if (g == e)
                break e;
              if (b && s[b - 1].to == g)
                g = s[--b].from;
              else {
                if (at[g - 1] == l)
                  break e;
                break;
              }
            }
          if (f)
            f.push(m);
          else {
            m.to < a && o.push(new Ro(m.to, a, d));
            let g = m.direction == ua != !(d % 2);
            ey(n, g ? r + 1 : r, i, m.inner, m.from, m.to, o), a = m.from;
          }
          p = m.from;
        } else {
          if (p == e || (u ? at[p - 1] != l : at[p - 1] == l))
            break;
          p--;
        }
      f ? Q4(n, p, a, r + 1, i, f, o) : p < a && o.push(new Ro(p, a, d)), a = p;
    }
}
function ey(n, e, t, r, i, s, o) {
  let l = e % 2 ? 2 : 1;
  PL(n, i, s, r, l), LL(n, i, s, r, l), BL(i, s, r, l), Q4(n, i, s, e, t, r, o);
}
function zL(n, e, t) {
  if (!n)
    return [new Ro(0, 0, e == s3 ? 1 : 0)];
  if (e == ua && !t.length && !RL.test(n))
    return kS(n.length);
  if (t.length)
    for (; n.length > at.length; )
      at[at.length] = 256;
  let r = [], i = e == ua ? 0 : 1;
  return ey(n, i, i, t, 0, n.length, r), r;
}
function kS(n) {
  return [new Ro(0, n, 0)];
}
let SS = "";
function _L(n, e, t, r, i) {
  var s;
  let o = r.head - n.from, l = Ro.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), a = e[l], c = a.side(i, t);
  if (o == c) {
    let f = l += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    a = e[l = f], o = a.side(!i, t), c = a.side(i, t);
  }
  let u = gn(n.text, o, a.forward(i, t));
  (u < a.from || u > a.to) && (u = c), SS = n.text.slice(Math.min(o, u), Math.max(o, u));
  let h = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < a.level ? G.cursor(h.side(!i, t) + n.from, h.forward(i, t) ? 1 : -1, h.level) : G.cursor(u + n.from, a.forward(i, t) ? -1 : 1, a.level);
}
function FL(n, e, t) {
  for (let r = e; r < t; r++) {
    let i = wS(n.charCodeAt(r));
    if (i == 1)
      return ua;
    if (i == 2 || i == 4)
      return s3;
  }
  return ua;
}
const CS = /* @__PURE__ */ he.define(), MS = /* @__PURE__ */ he.define(), TS = /* @__PURE__ */ he.define(), AS = /* @__PURE__ */ he.define(), ty = /* @__PURE__ */ he.define(), OS = /* @__PURE__ */ he.define(), ES = /* @__PURE__ */ he.define(), o3 = /* @__PURE__ */ he.define(), l3 = /* @__PURE__ */ he.define(), IS = /* @__PURE__ */ he.define({
  combine: (n) => n.some((e) => e)
}), DS = /* @__PURE__ */ he.define({
  combine: (n) => n.some((e) => e)
}), NS = /* @__PURE__ */ he.define();
class sc {
  constructor(e, t = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new sc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new sc(G.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const b0 = /* @__PURE__ */ ze.define({ map: (n, e) => n.map(e) }), RS = /* @__PURE__ */ ze.define();
function rr(n, e, t) {
  let r = n.facet(AS);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Ls = /* @__PURE__ */ he.define({ combine: (n) => n.length ? n[0] : !0 });
let HL = 0;
const ec = /* @__PURE__ */ he.define({
  combine(n) {
    return n.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (n[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class jt {
  constructor(e, t, r, i, s) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(ec.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(ec.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = t || {};
    return new jt(HL++, e, r, i, (l) => {
      let a = [];
      return o && a.push(Mf.of((c) => {
        let u = c.plugin(l);
        return u ? o(u) : Se.none;
      })), s && a.push(s(l)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return jt.define((r, i) => new e(r, i), t);
  }
}
class zg {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (rr(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        rr(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        rr(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const PS = /* @__PURE__ */ he.define(), a3 = /* @__PURE__ */ he.define(), Mf = /* @__PURE__ */ he.define(), LS = /* @__PURE__ */ he.define(), Id = /* @__PURE__ */ he.define(), BS = /* @__PURE__ */ he.define();
function a6(n, e) {
  let t = n.state.facet(BS);
  if (!t.length)
    return t;
  let r = t.map((s) => s instanceof Function ? s(n) : s), i = [];
  return Ze.spans(r, e.from, e.to, {
    point() {
    },
    span(s, o, l, a) {
      let c = s - e.from, u = o - e.from, h = i;
      for (let f = l.length - 1; f >= 0; f--, a--) {
        let d = l[f].spec.bidiIsolate, p;
        if (d == null && (d = FL(e.text, c, u)), a > 0 && h.length && (p = h[h.length - 1]).to == c && p.direction == d)
          p.to = u, h = p.inner;
        else {
          let m = { from: c, to: u, direction: d, inner: [] };
          h.push(m), h = m.inner;
        }
      }
    }
  }), i;
}
const zS = /* @__PURE__ */ he.define();
function c3(n) {
  let e = 0, t = 0, r = 0, i = 0;
  for (let s of n.state.facet(zS)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: i };
}
const oh = /* @__PURE__ */ he.define();
class Xr {
  constructor(e, t, r, i) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new Xr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i], c = o - l, u = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < u; ) {
        let h = t[s], f = t[s + 1], d = Math.max(l, h), p = Math.min(u, f);
        if (d <= p && new Xr(d + c, p + c, d, p).addToSet(r), f > u)
          break;
        s += 2;
      }
      if (!a)
        return r;
      new Xr(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), o = a.toA, l = a.toB;
    }
  }
}
class gm {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Yt.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, a) => i.push(new Xr(s, o, l, a))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new gm(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class c6 extends ut {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = Se.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Vt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Xr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? i = this.domChanged.newSel.head : !GL(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? VL(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new Xr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (ae.ie || ae.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = jL(o, l, e.changes);
    return r = Xr.extendWithRanges(r, a), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = ae.chrome || ae.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof $s && o.widget instanceof X4 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: u, toB: h } = l, f, d, p, m;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let T = Uh.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), M = Uh.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = T.breakAtStart, p = T.openStart, m = M.openEnd;
        let C = this.compositionView(r);
        M.breakAtStart ? C.breakAfter = 1 : M.content.length && C.merge(C.length, C.length, M.content[0], !1, M.openStart, 0) && (C.breakAfter = M.content[0].breakAfter, M.content.shift()), T.content.length && C.merge(0, 0, T.content[T.content.length - 1], !0, 0, T.openEnd) && T.content.pop(), f = T.content.concat(C).concat(M.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: m } = Uh.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: g, off: b } = s.findPos(c, 1), { i: w, off: k } = s.findPos(a, -1);
      hS(this, w, k, g, b, f, d, p, m);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(RS) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new ki(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: i } of e.marks)
      t = new Ks(i, [t], t.length);
    let r = new Vt();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (a) => a.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let l = ut.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    t(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], t(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && !(this.view.state.facet(Ls) || this.dom.tabIndex > -1) && dp(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (ae.gecko && l.empty && !this.hasComposition && $L(a)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(h, a.node.childNodes[a.offset] || null)), a = c = new Sn(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!jh(a.node, a.offset, u.anchorNode, u.anchorOffset) || !jh(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, l)) && (this.view.observer.ignore(() => {
      ae.android && ae.chrome && this.dom.contains(u.focusNode) && UL(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Sf(this.view.root);
      if (h) if (l.empty) {
        if (ae.gecko) {
          let f = qL(a.node, a.offset);
          if (f && f != 3) {
            let d = (f == 1 ? aS : cS)(a.node, a.offset);
            d && (a = new Sn(d.node, d.offset));
          }
        }
        h.collapse(a.node, a.offset), l.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = l.bidiLevel);
      } else if (h.extend) {
        h.collapse(a.node, a.offset);
        try {
          h.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), h.removeAllRanges(), h.addRange(f);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new Sn(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Sn(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && jh(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Sf(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = Vt.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    r.collapse(u.node, u.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && r.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let s = ut.get(t.childNodes[i]);
      s instanceof Vt && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = ut.get(t.childNodes[i]);
      s instanceof Vt && (r = s.domAtPos(s.length));
    }
    return r ? new Sn(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = ut.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (r < i.length || i instanceof Vt)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, c = a - l.length;
      if (a < e)
        break;
      if (c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || l instanceof Vt && !(r instanceof Vt && t >= 0)))
        r = l, i = c;
      else if (r && c == e && a == e && l instanceof $s && Math.abs(t) < 2) {
        if (l.deco.startSide < 0)
          break;
        o && (r = null);
      }
      s = c;
    }
    return r ? r.coordsAt(e - i, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), i = this.children[t];
    if (!(i instanceof Vt))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      r = a;
    }
    if (!(i instanceof ki))
      return null;
    let s = gn(i.text, r);
    if (s == r)
      return null;
    let o = ca(i.dom, r, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == wt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], f = c + h.length;
      if (f > i)
        break;
      if (c >= r) {
        let d = h.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = h.dom.lastChild, m = p ? Cf(p) : [];
          if (m.length) {
            let g = m[m.length - 1], b = a ? g.right - d.left : d.right - g.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? wt.RTL : wt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Vt) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Cf(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new uS(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == t.viewports.length ? null : t.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let l = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(Se.replace({
          widget: new X4(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return Se.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(Mf).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), r = !1, i = this.view.state.facet(LS).map((s, o) => {
      let l = typeof s == "function";
      return l && (r = !0), l ? s(this.view) : s;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, t.push(Ze.join(i))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(NS))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        rr(this.view.state, u, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!r)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = c3(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    vL(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == wt.LTR);
  }
}
function $L(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function _S(n, e) {
  let t = n.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = aS(t.focusNode, t.focusOffset), i = cS(t.focusNode, t.focusOffset), s = r || i;
  if (i && r && i.node != r.node) {
    let l = ut.get(i.node);
    if (!l || l instanceof ki && l.text != i.node.nodeValue)
      s = i;
    else if (n.docView.lastCompositionAfterCursor) {
      let a = ut.get(r.node);
      !a || a instanceof ki && a.text != r.node.nodeValue || (s = i);
    }
  }
  if (n.docView.lastCompositionAfterCursor = s != r, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function VL(n, e, t) {
  let r = _S(n, t);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, l = i.nodeValue;
  if (/[\n\r]/.test(l) || n.state.doc.sliceString(r.from, r.to) != l)
    return null;
  let a = e.invertedDesc, c = new Xr(a.mapPos(s), a.mapPos(o), s, o), u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = ut.get(h);
    if (f instanceof Ks)
      u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof Vt || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: c, text: i, marks: u, line: h };
      if (h != n.contentDOM)
        u.push({ node: h, deco: new Od({
          inclusive: !0,
          attributes: EL(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function qL(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let WL = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    pp(e, t, this.changes);
  }
  comparePoint(e, t) {
    pp(e, t, this.changes);
  }
  boundChange(e) {
    pp(e, e, this.changes);
  }
};
function jL(n, e, t) {
  let r = new WL();
  return Ze.compare(n, e, t, r), r.changes;
}
function UL(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function GL(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (t = !0);
  }), t;
}
function KL(n, e, t = 1) {
  let r = n.charCategorizer(e), i = n.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return G.cursor(e);
  s == 0 ? t = 1 : s == i.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = gn(i.text, s, !1) : l = gn(i.text, s);
  let a = r(i.text.slice(o, l));
  for (; o > 0; ) {
    let c = gn(i.text, o, !1);
    if (r(i.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < i.length; ) {
    let c = gn(i.text, l);
    if (r(i.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return G.range(o + i.from, l + i.from);
}
function YL(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function JL(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function _g(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function u6(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function h6(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function ny(n, e, t) {
  let r, i, s, o, l = !1, a, c, u, h;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let m = Cf(p);
    for (let g = 0; g < m.length; g++) {
      let b = m[g];
      i && _g(i, b) && (b = u6(h6(b, i.bottom), i.top));
      let w = YL(e, b), k = JL(t, b);
      if (w == 0 && k == 0)
        return p.nodeType == 3 ? f6(p, e, t) : ny(p, e, t);
      (!r || o > k || o == k && s > w) && (r = p, i = b, s = w, o = k, l = w ? e < b.left ? g > 0 : g < m.length - 1 : !0), w == 0 ? t > b.bottom && (!u || u.bottom < b.bottom) ? (a = p, u = b) : t < b.top && (!h || h.top > b.top) && (c = p, h = b) : u && _g(u, b) ? u = h6(u, b.bottom) : h && _g(h, b) && (h = u6(h, b.top));
    }
  }
  if (u && u.bottom >= t ? (r = a, i = u) : h && h.top <= t && (r = c, i = h), !r)
    return { node: n, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return f6(r, f, t);
  if (l && r.contentEditable != "false")
    return ny(r, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function f6(n, e, t) {
  let r = n.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < r; l++) {
    let a = ca(n, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let u = a[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2, d = f;
        if ((ae.chrome || ae.gecko) && ca(n, l).getBoundingClientRect().left == u.right && (d = !f), h <= 0)
          return { node: n, offset: l + (d ? 1 : 0) };
        i = l + (d ? 1 : 0), s = h;
      }
    }
  }
  return { node: n, offset: i > -1 ? i : o > 0 ? n.nodeValue.length : 0 };
}
function FS(n, e, t, r = -1) {
  var i, s;
  let o = n.contentDOM.getBoundingClientRect(), l = o.top + n.viewState.paddingTop, a, { docHeight: c } = n.viewState, { x: u, y: h } = e, f = h - l;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let T = n.viewState.heightOracle.textHeight / 2, M = !1; a = n.elementAtHeight(f), a.type != _n.Text; )
    for (; f = r > 0 ? a.bottom + T : a.top - T, !(f >= 0 && f <= c); ) {
      if (M)
        return t ? null : 0;
      M = !0, r = -r;
    }
  h = l + f;
  let d = a.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : d6(n, o, a, u, h);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : d6(n, o, a, u, h);
  let p = n.dom.ownerDocument, m = n.root.elementFromPoint ? n.root : p, g = m.elementFromPoint(u, h);
  g && !n.contentDOM.contains(g) && (g = null), g || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), g = m.elementFromPoint(u, h), g && !n.contentDOM.contains(g) && (g = null));
  let b, w = -1;
  if (g && ((i = n.docView.nearest(g)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let T = p.caretPositionFromPoint(u, h);
      T && ({ offsetNode: b, offset: w } = T);
    } else if (p.caretRangeFromPoint) {
      let T = p.caretRangeFromPoint(u, h);
      T && ({ startContainer: b, startOffset: w } = T);
    }
    b && (!n.contentDOM.contains(b) || ae.safari && XL(b, w, u) || ae.chrome && ZL(b, w, u)) && (b = void 0), b && (w = Math.min(ts(b), w));
  }
  if (!b || !n.docView.dom.contains(b)) {
    let T = Vt.find(n.docView, d);
    if (!T)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: w } = ny(T.dom, u, h));
  }
  let k = n.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let T = k.dom.getBoundingClientRect();
    return e.y < T.top || e.y <= T.bottom && e.x <= (T.left + T.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, w) + k.posAtStart;
}
function d6(n, e, t, r, i) {
  let s = Math.round((r - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, a = Math.floor((i - t.top - (n.defaultLineHeight - l) * 0.5) / l);
    s += a * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + V4(o, s, n.state.tabSize);
}
function HS(n, e, t) {
  let r, i = n;
  if (n.nodeType != 3 || e != (r = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = i.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = i.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      i = o;
    }
  }
  return ca(n, r - 1, r).getBoundingClientRect().right > t;
}
function XL(n, e, t) {
  return HS(n, e, t);
}
function ZL(n, e, t) {
  if (e != 0)
    return HS(n, e, t);
  for (let i = n; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = n.nodeType == 1 ? n.getBoundingClientRect() : ca(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function ry(n, e, t) {
  let r = n.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let s of r.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!i || s.type == _n.Text && (i.type != s.type || (t < 0 ? s.from < e : s.to > e))) && (i = s);
      }
    }
    return i || r;
  }
  return r;
}
function QL(n, e, t, r) {
  let i = ry(n, e.head, e.assoc || -1), s = !r || i.type != _n.Text || !(n.lineWrapping || i.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), l = n.textDirectionAt(i.from), a = n.posAtCoords({
      x: t == (l == wt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return G.cursor(a, t ? -1 : 1);
  }
  return G.cursor(t ? i.to : i.from, t ? -1 : 1);
}
function p6(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head), s = n.bidiSpans(i), o = n.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let c = _L(i, s, o, l, t), u = SS;
    if (!c) {
      if (i.number == (t ? n.state.doc.lines : 1))
        return l;
      u = `
`, i = n.state.doc.line(i.number + (t ? 1 : -1)), s = n.bidiSpans(i), c = n.visualLineSide(i, !t);
    }
    if (a) {
      if (!a(u))
        return l;
    } else {
      if (!r)
        return c;
      a = r(u);
    }
    l = c;
  }
}
function eB(n, e, t) {
  let r = n.state.charCategorizer(e), i = r(t);
  return (s) => {
    let o = r(s);
    return i == St.Space && (i = o), i == o;
  };
}
function tB(n, e, t, r) {
  let i = e.head, s = t ? 1 : -1;
  if (i == (t ? n.state.doc.length : 0))
    return G.cursor(i, e.assoc);
  let o = e.goalColumn, l, a = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(i, e.assoc || -1), u = n.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = n.viewState.lineBlockAt(i);
    o == null && (o = Math.min(a.right - a.left, n.defaultCharacterWidth * (i - d.from))), l = (s < 0 ? d.top : d.bottom) + u;
  }
  let h = a.left + o, f = r ?? n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, m = FS(n, { x: h, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? m < i : m > i)) {
      let g = n.docView.coordsForChar(m), b = !g || p < g.top ? -1 : 1;
      return G.cursor(m, b, void 0, o);
    }
  }
}
function Gh(n, e, t) {
  for (; ; ) {
    let r = 0;
    for (let i of n)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = r || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, r = a;
        }
      });
    if (!r)
      return e;
  }
}
function $S(n, e) {
  let t = null;
  for (let r = 0; r < e.ranges.length; r++) {
    let i = e.ranges[r], s = null;
    if (i.empty) {
      let o = Gh(n, i.from, 0);
      o != i.from && (s = G.cursor(o, -1));
    } else {
      let o = Gh(n, i.from, -1), l = Gh(n, i.to, 1);
      (o != i.from || l != i.to) && (s = G.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
    }
    s && (t || (t = e.ranges.slice()), t[r] = s);
  }
  return t ? G.create(t, e.mainIndex) : e;
}
function Fg(n, e, t) {
  let r = Gh(n.state.facet(Id).map((i) => i(n)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : G.cursor(r, r < t.from ? 1 : -1);
}
const lh = "ï¿¿";
class nB {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Ct.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += lh;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == t)
        break;
      let l = ut.get(i), a = ut.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : pm(i)) || pm(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (l = i.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(r, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = ut.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (rB(e, r.node, r.offset) ? t : 0));
  }
}
function rB(n, e, t) {
  for (; ; ) {
    if (!e || t < ts(e))
      return !1;
    if (e == n)
      return !0;
    t = aa(e) + 1, e = e.parentNode;
  }
}
class m6 {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class iB {
  constructor(e, t, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let l = s || o ? [] : lB(e), a = new nB(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = aB(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !j4(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !j4(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset), u = e.viewport;
      if ((ae.ios || ae.chrome) && e.state.selection.main.empty && a != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(a, c), f = Math.max(a, c), d = u.from - h, p = u.to - f;
        (d == 0 || d == 1 || h == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (a = 0, c = e.state.doc.length);
      }
      this.newSel = G.single(c, a);
    }
  }
}
function VS(n, e) {
  let t, { newSel: r } = e, i = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = i.from, c = null;
    (s === 8 || ae.android && e.text.length < l - o) && (a = i.to, c = "end");
    let u = oB(n.state.doc.sliceString(o, l, lh), e.text, a - o, c);
    u && (ae.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == lh + lh && u.toB--, t = {
      from: o + u.from,
      to: o + u.toA,
      insert: Xe.of(e.text.slice(u.from, u.toB).split(lh))
    });
  } else r && (!n.hasFocus && n.state.facet(Ls) || r.main.eq(i)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !i.empty && r && r.main.empty ? t = { from: i.from, to: i.to, insert: n.state.doc.slice(i.from, i.to) } : (ae.mac || ae.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: Xe.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: n.state.doc.slice(i.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, i.to))
  } : ae.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && n.lineWrapping && (r && (r = G.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: Xe.of([" "]) }), t)
    return u3(n, t, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), l = n.inputState.lastSelectionOrigin, l == "select.pointer" && (r = $S(n.state.facet(Id).map((a) => a(n)), r))), n.dispatch({ selection: r, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function u3(n, e, t, r = -1) {
  if (ae.ios && n.inputState.flushIOSKey(e))
    return !0;
  let i = n.state.selection.main;
  if (ae.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && n.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && ic(n.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && ic(n.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && ic(n.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let o, l = () => o || (o = sB(n, e, t));
  return n.state.facet(OS).some((a) => a(n, e.from, e.to, s, l)) || n.dispatch(l()), !0;
}
function sB(n, e, t) {
  let r, i = n.state, s = i.selection.main, o = -1;
  if (e.from == e.to && e.from < s.from || e.from > s.to) {
    let a = e.from < s.from ? -1 : 1, c = a < 0 ? s.from : s.to, u = Gh(i.facet(Id).map((h) => h(n)), c, a);
    e.from == u && (o = u);
  }
  if (o > -1)
    r = {
      changes: e,
      selection: G.cursor(e.from + e.insert.length, -1)
    };
  else if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", c = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(n.state.toText(a + e.insert.sliceString(0, void 0, n.state.lineBreak) + c));
  } else {
    let a = i.changes(e), c = t && t.main.to <= a.newLength ? t.main : void 0;
    if (i.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let u = n.state.sliceDoc(e.from, e.to), h, f = t && _S(n, t.main.head);
      if (f) {
        let m = e.insert.length - (e.to - e.from);
        h = { from: f.from, to: f.to - m };
      } else
        h = n.state.doc.lineAt(s.head);
      let d = s.to - e.to, p = s.to - s.from;
      r = i.changeByRange((m) => {
        if (m.from == s.from && m.to == s.to)
          return { changes: a, range: c || m.map(a) };
        let g = m.to - d, b = g - u.length;
        if (m.to - m.from != p || n.state.sliceDoc(b, g) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        m.to >= h.from && m.from <= h.to)
          return { range: m };
        let w = i.changes({ from: b, to: g, insert: e.insert }), k = m.to - s.to;
        return {
          changes: w,
          range: c ? G.range(Math.max(0, c.anchor + k), Math.max(0, c.head + k)) : m.map(w)
        };
      });
    } else
      r = {
        changes: a,
        selection: c && i.selection.replaceRange(c)
      };
  }
  let l = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, l += ".compose", n.inputState.compositionFirstChange && (l += ".start", n.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: l, scrollIntoView: !0 });
}
function oB(n, e, t, r) {
  let i = Math.min(n.length, e.length), s = 0;
  for (; s < i && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && n.length == e.length)
    return null;
  let o = n.length, l = e.length;
  for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (r == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && n.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function lB(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new m6(t, r)), (i != t || s != r) && e.push(new m6(i, s))), e;
}
function aB(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, r = n.length == 2 ? n[1].pos : t;
  return t > -1 && r > -1 ? G.single(t + e, r + e) : null;
}
let cB = class {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, ae.safari && e.contentDOM.addEventListener("input", () => null), ae.gecko && MB(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !yB(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, t);
      for (let i of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (i(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = uB(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, l = r[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !t[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && WS.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), ae.android && ae.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return ae.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = qS.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || hB.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, ic(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : ae.safari && !ae.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function g6(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t);
    } catch (i) {
      rr(t.state, i);
    }
  };
}
function uB(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of n) {
    let i = r.spec, s = i && i.plugin.domEventHandlers, o = i && i.plugin.domEventObservers;
    if (s)
      for (let l in s) {
        let a = s[l];
        a && t(l).handlers.push(g6(r.value, a));
      }
    if (o)
      for (let l in o) {
        let a = o[l];
        a && t(l).observers.push(g6(r.value, a));
      }
  }
  for (let r in Si)
    t(r).handlers.push(Si[r]);
  for (let r in ti)
    t(r).observers.push(ti[r]);
  return e;
}
const qS = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], hB = "dthko", WS = [16, 17, 18, 20, 91, 92, 224, 225], v0 = 6;
function w0(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function fB(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class dB {
  constructor(e, t, r, i) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = wL(e.contentDOM), this.atoms = e.state.facet(Id).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Ct.allowMultipleSelections) && pB(e, t), this.dragging = gB(e, t) && GS(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && fB(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, i = 0, s = 0, o = this.view.win.innerWidth, l = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: l } = this.scrollParents.y.getBoundingClientRect());
    let a = c3(this.view);
    e.clientX - a.left <= i + v0 ? t = -w0(i - e.clientX) : e.clientX + a.right >= o - v0 && (t = w0(e.clientX - o)), e.clientY - a.top <= s + v0 ? r = -w0(s - e.clientY) : e.clientY + a.bottom >= l - v0 && (r = w0(e.clientY - l)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: t } = this, r = $S(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function pB(n, e) {
  let t = n.state.facet(CS);
  return t.length ? t[0](e) : ae.mac ? e.metaKey : e.ctrlKey;
}
function mB(n, e) {
  let t = n.state.facet(MS);
  return t.length ? t[0](e) : ae.mac ? !e.altKey : !e.ctrlKey;
}
function gB(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let r = Sf(n.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function yB(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = ut.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const Si = /* @__PURE__ */ Object.create(null), ti = /* @__PURE__ */ Object.create(null), jS = ae.ie && ae.ie_version < 15 || ae.ios && ae.webkit_version < 604;
function bB(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), US(n, t.value);
  }, 50);
}
function m1(n, e, t) {
  for (let r of n.facet(e))
    t = r(t, n);
  return t;
}
function US(n, e) {
  e = m1(n.state, o3, e);
  let { state: t } = n, r, i = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (iy != null && t.selection.ranges.every((a) => a.empty) && iy == s.toString()) {
    let a = -1;
    r = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == a)
        return { range: c };
      a = u.from;
      let h = t.toText((o ? s.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: G.cursor(c.from + h.length)
      };
    });
  } else o ? r = t.changeByRange((a) => {
    let c = s.line(i++);
    return {
      changes: { from: a.from, to: a.to, insert: c.text },
      range: G.cursor(a.from + c.length)
    };
  }) : r = t.replaceSelection(s);
  n.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
ti.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
Si.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
ti.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
ti.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Si.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of n.state.facet(TS))
    if (t = r(n, e), t)
      break;
  if (!t && e.button == 0 && (t = xB(n, e)), t) {
    let r = !n.hasFocus;
    n.inputState.startMouseSelection(new dB(n, e, t, r)), r && n.observer.ignore(() => {
      sS(n.contentDOM);
      let s = n.root.activeElement;
      s && !s.contains(n.contentDOM) && s.blur();
    });
    let i = n.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function y6(n, e, t, r) {
  if (r == 1)
    return G.cursor(e, t);
  if (r == 2)
    return KL(n.state, e, t);
  {
    let i = Vt.find(n.docView, e), s = n.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < n.state.doc.length && l == s.to && l++, G.range(o, l);
  }
}
let b6 = (n, e, t) => e >= t.top && e <= t.bottom && n >= t.left && n <= t.right;
function vB(n, e, t, r) {
  let i = Vt.find(n.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && b6(t, r, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && b6(t, r, l) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function v6(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: vB(n, t, e.clientX, e.clientY) };
}
const wB = ae.ie && ae.ie_version <= 11;
let w6 = null, x6 = 0, k6 = 0;
function GS(n) {
  if (!wB)
    return n.detail;
  let e = w6, t = k6;
  return w6 = n, k6 = Date.now(), x6 = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (x6 + 1) % 3 : 1;
}
function xB(n, e) {
  let t = v6(n, e), r = GS(e), i = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let a = v6(n, s), c, u = y6(n, a.pos, a.bias, r);
      if (t.pos != a.pos && !o) {
        let h = y6(n, t.pos, t.bias, r), f = Math.min(h.from, u.from), d = Math.max(h.to, u.to);
        u = f < u.from ? G.range(f, d) : G.range(d, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : l && r == 1 && i.ranges.length > 1 && (c = kB(i, a.pos)) ? c : l ? i.addRange(u) : G.create([u]);
    }
  };
}
function kB(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t];
    if (r <= e && i >= e)
      return G.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
Si.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= t.to || o <= t.from) && (t = G.range(s, o));
    }
  }
  let { inputState: r } = n;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", m1(n.state, l3, n.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Si.dragend = (n) => (n.inputState.draggedContent = null, !1);
function S6(n, e, t, r) {
  if (t = m1(n.state, o3, t), !t)
    return;
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = r && s && mB(n, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: t }, a = n.state.changes(o ? [o, l] : l);
  n.focus(), n.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
Si.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), i = 0, s = () => {
      ++i == t.length && S6(n, e, r.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return S6(n, e, r, !0), !0;
  }
  return !1;
};
Si.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = jS ? null : e.clipboardData;
  return t ? (US(n, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (bB(n), !1);
};
function SB(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), n.focus();
  }, 50);
}
function CB(n) {
  let e = [], t = [], r = !1;
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > i && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: m1(n, l3, e.join(n.lineBreak)), ranges: t, linewise: r };
}
let iy = null;
Si.copy = Si.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = CB(n.state);
  if (!t && !i)
    return !1;
  iy = i ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = jS ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (SB(n, t), !1);
};
const KS = /* @__PURE__ */ to.define();
function YS(n, e) {
  let t = [];
  for (let r of n.facet(ES)) {
    let i = r(n, e);
    i && t.push(i);
  }
  return t.length ? n.update({ effects: t, annotations: KS.of(!0) }) : null;
}
function JS(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = YS(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
ti.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), JS(n);
};
ti.blur = (n) => {
  n.observer.clearSelectionRange(), JS(n);
};
ti.compositionstart = ti.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
ti.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, ae.chrome && ae.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
ti.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
Si.beforeinput = (n, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && n.observer.editContext) {
    let s = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let l = o[0], a = n.posAtDOM(l.startContainer, l.startOffset), c = n.posAtDOM(l.endContainer, l.endOffset);
      return u3(n, { from: a, to: c, insert: n.state.toText(s) }, null), !0;
    }
  }
  let i;
  if (ae.chrome && ae.android && (i = qS.find((s) => s.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return ae.ios && e.inputType == "deleteContentForward" && n.observer.flushSoon(), ae.safari && e.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => ti.compositionend(n, e), 20), !1;
};
const C6 = /* @__PURE__ */ new Set();
function MB(n) {
  C6.has(n) || (C6.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const M6 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let Gc = !1;
function T6() {
  Gc = !1;
}
class TB {
  constructor(e) {
    this.lineWrapping = e, this.doc = Xe.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return M6.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, i, s, o) {
    let l = M6.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = r, this.textHeight = i, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return a;
  }
}
class AB {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class ji {
  /**
  @internal
  */
  constructor(e, t, r, i, s) {
    this.from = e, this.length = t, this.top = r, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? _n.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Wo ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new ji(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var vt = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(vt || (vt = {}));
const mp = 1e-3;
class Fn {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > mp && (Gc = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return Fn.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, i) {
    let s = this, o = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: u, toB: h } = i[l], f = s.lineAt(a, vt.ByPosNoHeight, r.setDoc(t), 0, 0), d = f.to >= c ? f : s.lineAt(c, vt.ByPosNoHeight, r, 0, 0);
      for (h += d.to - c, c = d.to; l > 0 && f.from <= i[l - 1].toA; )
        a = i[l - 1].fromA, u = i[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, vt.ByPosNoHeight, r, 0, 0));
      u += f.from - a, a = f.from;
      let p = h3.build(r.setDoc(o), e, u, h);
      s = ym(s, s.replace(a, c, p));
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new kr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (t == r)
        if (i > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), r += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), r += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[t++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new OB(Fn.of(e.slice(0, t)), o, Fn.of(e.slice(r)));
  }
}
function ym(n, e) {
  return n == e ? n : (n.constructor != e.constructor && (Gc = !0), e);
}
Fn.prototype.size = 1;
class XS extends Fn {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, i) {
    return new ji(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, t, r, i, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class kr extends XS {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, i) {
    return new ji(i, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof kr || i instanceof fn && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof fn ? i = new kr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Fn.of(r);
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class fn extends Fn {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, i = e.doc.lineAt(t + this.length).number, s = i - r + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, t, r, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, i);
    if (t.lineWrapping) {
      let c = i + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = t.doc.lineAt(c), h = l + u.length * a, f = Math.max(r, e - h / 2);
      return new ji(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / l))), { from: u, length: h } = t.doc.line(s + c);
      return new ji(u, h, r + l * c, l, 0);
    }
  }
  lineAt(e, t, r, i, s) {
    if (t == vt.ByHeight)
      return this.blockAt(e, r, i, s);
    if (t == vt.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new ji(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(r, s), c = r.doc.lineAt(e), u = l + c.length * a, h = c.number - o, f = i + l * h + a * (c.from - s - h);
    return new ji(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, t, r, i, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(r, s);
    for (let u = e, h = i; u <= t; ) {
      let f = r.doc.lineAt(u);
      if (u == e) {
        let p = f.number - l;
        h += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new ji(f.from, f.length, h, d, 0)), h += d, u = f.to + 1;
    }
  }
  replace(e, t, r) {
    let i = this.length - t;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof fn ? r[r.length - 1] = new fn(s.length + i) : r.push(null, new fn(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof fn ? r[0] = new fn(e + s.length) : r.unshift(new fn(e - 1), null);
    }
    return Fn.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new fn(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new fn(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, i) {
    let s = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let o = [], l = Math.max(t, i.from), a = -1;
      for (i.from > t && o.push(new fn(i.from - t - 1).updateHeight(e, t)); l <= s && i.more; ) {
        let u = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        a == -1 ? a = h : Math.abs(h - a) >= mp && (a = -2);
        let f = new kr(u, h);
        f.outdated = !1, o.push(f), l += u + 1;
      }
      l <= s && o.push(null, new fn(s - l).updateHeight(e, l));
      let c = Fn.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= mp || Math.abs(a - this.heightMetrics(e, t).perLine) >= mp) && (Gc = !0), ym(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class OB extends Fn {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, t, r, i) : this.right.blockAt(e, t, s, i + this.left.length + this.break);
  }
  lineAt(e, t, r, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, a = t == vt.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, t, r, i, s) : this.right.lineAt(e, t, r, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let u = t == vt.ByPosNoHeight ? vt.ByPosNoHeight : vt.ByPos;
    return a ? c.join(this.right.lineAt(l, u, r, o, l)) : this.left.lineAt(l, u, r, i, s).join(c);
  }
  forEachLine(e, t, r, i, s, o) {
    let l = i + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, r, i, s, o), t >= a && this.right.forEachLine(e, t, r, l, a, o);
    else {
      let c = this.lineAt(a, vt.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, l, a, o);
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of r)
      s.push(l);
    if (e > 0 && A6(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), A6(s, l);
    }
    return Fn.of(s);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Fn.of(this.break ? [e, null, t] : [e, t]) : (this.left = ym(this.left, e), this.right = ym(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return i && i.from <= t + s.length && i.more ? a = s = s.updateHeight(e, t, r, i) : s.updateHeight(e, t, r), i && i.from <= l + o.length && i.more ? a = o = o.updateHeight(e, l, r, i) : o.updateHeight(e, l, r), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function A6(n, e) {
  let t, r;
  n[e] == null && (t = n[e - 1]) instanceof fn && (r = n[e + 1]) instanceof fn && n.splice(e - 1, 3, new fn(t.length + 1 + r.length));
}
const EB = 5;
class h3 {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof kr ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new kr(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new XS(o, i, r)) : (o || s || i >= EB) && this.addLineDeco(i, s, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new kr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new fn(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof kr)
      return e;
    let t = new kr(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof kr) && !this.isCovered ? this.nodes.push(new kr(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof kr && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, i) {
    let s = new h3(r, e);
    return Ze.spans(t, r, i, s, 0), s.finish(r);
  }
}
function IB(n, e, t) {
  let r = new DB();
  return Ze.compare(n, e, t, r, 0), r.changes;
}
class DB {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, i) {
    (e < t || r && r.heightRelevant || i && i.heightRelevant) && pp(e, t, this.changes, 5);
  }
}
function NB(n, e) {
  let t = n.getBoundingClientRect(), r = n.ownerDocument, i = r.defaultView || window, s = Math.max(0, t.left), o = Math.min(i.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(i.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = Math.min(c == n.parentNode ? i.innerHeight : a, f.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function RB(n) {
  let e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function PB(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Hg {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.size = r, this.displaySize = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = t[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return Se.replace({
      widget: new LB(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class LB extends no {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class O6 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = E6, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = wt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(a3).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new TB(t), this.stateDeco = e.facet(Mf).filter((r) => typeof r != "function"), this.heightMap = Fn.empty().applyChanges(this.stateDeco, Xe.empty, this.heightOracle.setDoc(e.doc), [new Xr(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Se.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new x0(s, o));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? E6 : new f3(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(ah(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(Mf).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = Xr.extendWithRanges(i, IB(r, this.stateDeco, e ? e.changes : Yt.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    T6(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || Gc) && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let c = a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(DS) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? wt.RTL : wt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (l.width && l.height) {
      let { scaleX: T, scaleY: M } = iS(t, l);
      (T > 5e-3 && Math.abs(this.scaleX - T) > 5e-3 || M > 5e-3 && Math.abs(this.scaleY - M) > 5e-3) && (this.scaleX = T, this.scaleY = M, c |= 16, o = a = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = lS(e.scrollDOM);
    let p = (this.printing ? PB : NB)(t, this.paddingTop), m = p.top - this.pixelViewport.top, g = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (a = !0)), !this.inView && !this.scrollTarget && !RB(e.dom))
      return 0;
    let w = l.width;
    if ((this.contentDOMWidth != w || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), a) {
      let T = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(T) && (o = !0), o || i.lineWrapping && Math.abs(w - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: M, charWidth: C, textHeight: I } = e.docView.measureTextSize();
        o = M > 0 && i.refresh(s, M, C, I, Math.max(5, w / C), T), o && (e.docView.minWidth = 0, c |= 16);
      }
      m > 0 && g > 0 ? u = Math.max(m, g) : m < 0 && g < 0 && (u = Math.min(m, g)), T6();
      for (let M of this.viewports) {
        let C = M.from == this.viewport.from ? T : e.docView.measureVisibleLineHeights(M);
        this.heightMap = (o ? Fn.empty().applyChanges(this.stateDeco, Xe.empty, this.heightOracle, [new Xr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new AB(M.from, C));
      }
      Gc && (c |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new x0(i.lineAt(o - r * 1e3, vt.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, vt.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, vt.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? f = h.top : f = h.bottom - u, a = new x0(i.lineAt(f - 1e3 / 2, vt.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, vt.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new x0(this.heightMap.lineAt(r, vt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, vt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, vt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, vt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || r.push(new Hg(t.mapPos(i.from), t.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != wt.LTR && !r)
      return [];
    let l = [], a = (u, h, f, d) => {
      if (h - u < s)
        return;
      let p = this.state.selection.main, m = [p.from];
      p.empty || m.push(p.to);
      for (let b of m)
        if (b > u && b < h) {
          a(u, b - 10, f, d), a(b + 10, h, f, d);
          return;
        }
      let g = zB(e, (b) => b.from >= f.from && b.to <= f.to && Math.abs(b.from - u) < s && Math.abs(b.to - h) < s && !m.some((w) => b.from < w && b.to > w));
      if (!g) {
        if (h < f.to && t && r && t.visibleRanges.some((k) => k.from <= h && k.to >= h)) {
          let k = t.moveToLineBoundary(G.cursor(h), !1, !0).head;
          k > u && (h = k);
        }
        let b = this.gapSize(f, u, h, d), w = r || b < 2e6 ? b : 2e6;
        g = new Hg(u, h, b, w);
      }
      l.push(g);
    }, c = (u) => {
      if (u.length < o || u.type != _n.Text)
        return;
      let h = BB(u.from, u.to, this.stateDeco);
      if (h.total < o)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, d, p;
      if (r) {
        let m = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, b;
        if (f != null) {
          let w = S0(h, f), k = ((this.visibleBottom - this.visibleTop) / 2 + m) / u.height;
          g = w - k, b = w + k;
        } else
          g = (this.visibleTop - u.top - m) / u.height, b = (this.visibleBottom - u.top + m) / u.height;
        d = k0(h, g), p = k0(h, b);
      } else {
        let m = h.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, b = 0;
        if (m > 2e6)
          for (let C of e)
            C.from >= u.from && C.from < u.to && C.size != C.displaySize && C.from * this.heightOracle.charWidth + b < this.pixelViewport.left && (b = C.size - C.displaySize);
        let w = this.pixelViewport.left + b, k = this.pixelViewport.right + b, T, M;
        if (f != null) {
          let C = S0(h, f), I = ((k - w) / 2 + g) / m;
          T = C - I, M = C + I;
        } else
          T = (w - g) / m, M = (k + g) / m;
        d = k0(h, T), p = k0(h, M);
      }
      d > u.from && a(u.from, d, u, h), p < u.to && a(p, u.to, u, h);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return l;
  }
  gapSize(e, t, r, i) {
    let s = S0(i, r) - S0(i, t);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Hg.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Se.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    Ze.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        r.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let s = 0; s < r.length && !(i & 8); s++) {
        let o = this.visibleRanges[s], l = r[s];
        (o.from != l.from || o.to != l.to) && (i |= 4, e && e.mapPos(o.from, -1) == l.from && e.mapPos(o.to, 1) == l.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || ah(this.heightMap.lineAt(e, vt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || ah(this.heightMap.lineAt(this.scaler.fromDOM(e), vt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return ah(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class x0 {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function BB(n, e, t) {
  let r = [], i = n, s = 0;
  return Ze.spans(t, n, e, {
    span() {
    },
    point(o, l) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function k0({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(n * t);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (r <= l)
      return s + r;
    r -= l;
  }
}
function S0(n, e) {
  let t = 0;
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r;
      break;
    }
    t += i - r;
  }
  return t / n.total;
}
function zB(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const E6 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class f3 {
  constructor(e, t, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: l, to: a }) => {
      let c = t.lineAt(l, vt.ByPos, e, 0, 0).top, u = t.lineAt(a, vt.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: l, to: a, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof f3 ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function ah(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), r = e.toDOM(n.bottom);
  return new ji(n.from, n.length, t, r - t, Array.isArray(n._content) ? n._content.map((i) => ah(i, e)) : n._content);
}
const C0 = /* @__PURE__ */ he.define({ combine: (n) => n.join(" ") }), sy = /* @__PURE__ */ he.define({ combine: (n) => n.indexOf(!0) > -1 }), oy = /* @__PURE__ */ qo.newName(), ZS = /* @__PURE__ */ qo.newName(), QS = /* @__PURE__ */ qo.newName(), eC = { "&light": "." + ZS, "&dark": "." + QS };
function ly(n, e, t) {
  return new qo(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return n;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : n + " " + r;
    }
  });
}
const _B = /* @__PURE__ */ ly("." + oy, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, eC), FB = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, $g = ae.ie && ae.ie_version <= 11;
let HB = class {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new xL(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (ae.ie && ae.ie_version <= 11 || ae.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && ae.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(ae.chrome && ae.chrome_version < 126) && (this.editContext = new VB(e), e.state.facet(Ls) && (e.contentDOM.editContext = this.editContext.editContext)), $g && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Ls) ? r.root.activeElement != this.dom : !dp(this.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (ae.ie && ae.ie_version <= 11 || ae.android && ae.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && jh(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Sf(e.root);
    if (!t)
      return !1;
    let r = ae.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && $B(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = dp(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && SL(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, FB), $g && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), $g && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && ic(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), i = this.selectionChanged && dp(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new iB(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = VS(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = I6(t, e.previousSibling || e.target.previousSibling, -1), i = I6(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Ls) != e.state.facet(Ls) && (e.view.contentDOM.editContext = e.state.facet(Ls) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function I6(n, e, t) {
  for (; e; ) {
    let r = ut.get(e);
    if (r && r.parent == n)
      return r;
    let i = e.parentNode;
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function D6(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.docView.domAtPos(n.state.selection.main.anchor);
  return jh(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function $B(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return D6(n, i);
  }
  let t = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", r, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", r, !0), t ? D6(n, t) : null;
}
class VB {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: s, head: o } = i, l = this.toEditorPos(r.updateRangeStart), a = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: l, drifted: !1 });
      let c = { from: l, to: a, insert: Xe.of(r.text.split(`
`)) };
      if (c.from == this.from && s < this.from ? c.from = s : c.to == this.to && s > this.to && (c.to = s), c.from == c.to && !c.insert.length) {
        let u = G.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        u.main.eq(i) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      if ((ae.mac || ae.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: l, to: a, insert: Xe.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let u = this.to - this.from + (c.to - c.from + c.insert.length);
        u3(e, c, G.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), c.from < c.to && !c.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(t.text.slice(Math.max(0, r.updateRangeStart - 1), Math.min(t.text.length, r.updateRangeStart + 1))) && this.handlers.compositionend(r);
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], s = null;
      for (let o = this.toEditorPos(r.rangeStart), l = this.toEditorPos(r.rangeEnd); o < l; o++) {
        let a = e.coordsForChar(o);
        s = a && new DOMRect(a.left, a.top, a.right - a.left, a.bottom - a.top) || s || new DOMRect(), i.push(s);
      }
      t.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let s of r.getTextFormats()) {
        let o = s.underlineStyle, l = s.underlineThickness;
        if (!/none/i.test(o) && !/none/i.test(l)) {
          let a = this.toEditorPos(s.rangeStart), c = this.toEditorPos(s.rangeEnd);
          if (a < c) {
            let u = `text-decoration: underline ${/^[a-z]/.test(o) ? o + " " : o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${/thin/i.test(l) ? 1 : 2}px`;
            i.push(Se.mark({ attributes: { style: u } }).range(a, c));
          }
        }
      }
      e.dispatch({ effects: RS.of(Se.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = Sf(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((s, o, l, a, c) => {
      if (r)
        return;
      let u = c.length - (o - s);
      if (i && o >= i.to)
        if (i.from == s && i.to == o && i.insert.eq(c)) {
          i = this.pendingContextChange = null, t += u, this.to += u;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (s += t, o += t, o <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += u;
      }
      t += u;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), i = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
let de = class ay {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((s) => r(s, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || kL(e.parent) || document, this.viewState = new O6(e.state || Ct.create(e)), e.scrollTo && e.scrollTo.is(b0) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(ec).map((i) => new zg(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new HB(this), this.inputState = new cB(this), this.inputState.ensureHandlers(this.plugins), this.docView = new c6(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof zn ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(KS)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = YS(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(Ct.phrases) != this.state.facet(Ct.phrases))
      return this.setState(s);
    i = gm.create(this, s, e), i.flags |= l;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new sc(d.empty ? d : G.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(b0) && (h = d.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = bm.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(oh) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(C0) != i.state.facet(C0) && (this.viewState.mustMeasureContent = !0), (t || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(ty))
        try {
          f(i);
        } catch (d) {
          rr(this.state, d, "update listener");
        }
    (a || u) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), u && !VS(this, u) && c.force && ic(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new O6(e), this.plugins = e.facet(ec).map((r) => new zg(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new c6(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(ec), r = e.state.facet(ec);
    if (t != r) {
      let i = [];
      for (let s of r) {
        let o = t.indexOf(s);
        if (o < 0)
          i.push(new zg(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          rr(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (lS(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return rr(this.state, p), N6;
          }
        }), h = gm.create(this, this.state, []), f = !1;
        h.flags |= a, t ? t.flags |= a : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h), f && this.docViewUpdate());
        for (let d = 0; d < c.length; d++)
          if (u[d] != N6)
            try {
              let p = c[d];
              p.write && p.write(u[d], this);
            } catch (p) {
              rr(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(ty))
        l(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return oy + " " + (this.state.facet(sy) ? QS : ZS) + " " + this.state.facet(C0);
  }
  updateAttrs() {
    let e = R6(this, PS, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Ls) ? "true" : "false",
      class: "cm-content",
      style: `${ae.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), R6(this, a3, t);
    let r = this.observer.ignore(() => {
      let i = J4(this.contentDOM, this.contentAttrs, t), s = J4(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(ay.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(oh);
    let e = this.state.facet(ay.cspNonce);
    qo.mount(this.root, this.styleModules.concat(_B).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return Fg(this, e, p6(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return Fg(this, e, p6(this, e, t, (r) => eB(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[t ? r.length - 1 : 0];
    return G.cursor(s.side(t, i) + e.from, s.forward(!t, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return QL(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return Fg(this, e, tB(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), FS(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Ro.find(s, e - i.from, -1, t)];
    return d1(r, o.dir == wt.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(IS) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > qB)
      return kS(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || xS(s.isolates, r = a6(this, e))))
        return s.order;
    r || (r = a6(this, e));
    let i = zL(e.text, t, r);
    return this.bidiCache.push(new bm(e.from, e.to, t, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || ae.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      sS(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return b0.of(new sc(typeof e == "number" ? G.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return b0.of(new sc(G.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return jt.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return jt.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = qo.newName(), i = [C0.of(r), oh.of(ly(`.${r}`, e))];
    return t && t.dark && i.push(sy.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return el.lowest(oh.of(ly("." + oy, e, eC)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), i = r && ut.get(r) || ut.get(e);
    return ((t = i == null ? void 0 : i.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
};
de.styleModule = oh;
de.inputHandler = OS;
de.clipboardInputFilter = o3;
de.clipboardOutputFilter = l3;
de.scrollHandler = NS;
de.focusChangeEffect = ES;
de.perLineTextDirection = IS;
de.exceptionSink = AS;
de.updateListener = ty;
de.editable = Ls;
de.mouseSelectionStyle = TS;
de.dragMovesSelection = MS;
de.clickAddsSelectionRange = CS;
de.decorations = Mf;
de.outerDecorations = LS;
de.atomicRanges = Id;
de.bidiIsolatedRanges = BS;
de.scrollMargins = zS;
de.darkTheme = sy;
de.cspNonce = /* @__PURE__ */ he.define({ combine: (n) => n.length ? n[0] : "" });
de.contentAttributes = a3;
de.editorAttributes = PS;
de.lineWrapping = /* @__PURE__ */ de.contentAttributes.of({ class: "cm-lineWrapping" });
de.announce = /* @__PURE__ */ ze.define();
const qB = 4096, N6 = {};
class bm {
  constructor(e, t, r, i, s, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : wt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !t.touchesRange(o.from, o.to) && r.push(new bm(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function R6(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(n) : s;
    o && Y4(o, t);
  }
  return t;
}
const WB = ae.mac ? "mac" : ae.windows ? "win" : ae.linux ? "linux" : "key";
function jB(n, e) {
  const t = n.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, l;
  for (let a = 0; a < t.length - 1; ++a) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), l && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function M0(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const UB = /* @__PURE__ */ el.default(/* @__PURE__ */ de.domEventHandlers({
  keydown(n, e) {
    return nC(tC(e.state), n, e, "editor");
  }
})), du = /* @__PURE__ */ he.define({ enables: UB }), P6 = /* @__PURE__ */ new WeakMap();
function tC(n) {
  let e = n.facet(du), t = P6.get(e);
  return t || P6.set(e, t = YB(e.reduce((r, i) => r.concat(i), []))), t;
}
function GB(n, e, t) {
  return nC(tC(n.state), e, n, t);
}
let Mo = null;
const KB = 4e3;
function YB(n, e = WB) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let a = r[o];
    if (a == null)
      r[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, c, u) => {
    var h, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((b) => jB(b, e));
    for (let b = 1; b < p.length; b++) {
      let w = p.slice(0, b).join(" ");
      i(w, !0), d[w] || (d[w] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let T = Mo = { view: k, prefix: w, scope: o };
          return setTimeout(() => {
            Mo == T && (Mo = null);
          }, KB), !0;
        }]
      });
    }
    let m = p.join(" ");
    i(m, !1);
    let g = d[m] || (d[m] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    a && g.run.push(a), c && (g.preventDefault = !0), u && (g.stopPropagation = !0);
  };
  for (let o of n) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of l) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let f in u)
          u[f].run.push((d) => h(d, cy));
      }
    let a = o[e] || o.key;
    if (a)
      for (let c of l)
        s(c, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let cy = null;
function nC(n, e, t, r) {
  cy = e;
  let i = nS(e), s = er(i, 0), o = Wi(s) == i.length && i != " ", l = "", a = !1, c = !1, u = !1;
  Mo && Mo.view == t && Mo.scope == r && (l = Mo.prefix + " ", WS.indexOf(e.keyCode) < 0 && (c = !0, Mo = null));
  let h = /* @__PURE__ */ new Set(), f = (g) => {
    if (g) {
      for (let b of g.run)
        if (!h.has(b) && (h.add(b), b(t)))
          return g.stopPropagation && (u = !0), !0;
      g.preventDefault && (g.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, d = n[r], p, m;
  return d && (f(d[l + M0(i, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ae.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(ae.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (p = Gs[e.keyCode]) && p != i ? (f(d[l + M0(p, e, !0)]) || e.shiftKey && (m = kf[e.keyCode]) != i && m != p && f(d[l + M0(m, e, !1)])) && (a = !0) : o && e.shiftKey && f(d[l + M0(i, e, !0)]) && (a = !0), !a && f(d._any) && (a = !0)), c && (a = !0), a && u && e.stopPropagation(), cy = null, a;
}
class Dd {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, i, s) {
    this.className = e, this.left = t, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = rC(e);
      return [new Dd(t, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return JB(e, t, r);
  }
}
function rC(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == wt.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function L6(n, e, t, r) {
  let i = n.coordsAtPos(e, t * 2);
  if (!i)
    return r;
  let s = n.dom.getBoundingClientRect(), o = (i.top + i.bottom) / 2, l = n.posAtCoords({ x: s.left + 1, y: o }), a = n.posAtCoords({ x: s.right - 1, y: o });
  return l == null || a == null ? r : { from: Math.max(r.from, Math.min(l, a)), to: Math.min(r.to, Math.max(l, a)) };
}
function JB(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let r = Math.max(t.from, n.viewport.from), i = Math.min(t.to, n.viewport.to), s = n.textDirection == wt.LTR, o = n.contentDOM, l = o.getBoundingClientRect(), a = rC(n), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = l.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), f = l.right - (u ? parseInt(u.paddingRight) : 0), d = ry(n, r, 1), p = ry(n, i, -1), m = d.type == _n.Text ? d : null, g = p.type == _n.Text ? p : null;
  if (m && (n.lineWrapping || d.widgetLineBreaks) && (m = L6(n, r, 1, m)), g && (n.lineWrapping || p.widgetLineBreaks) && (g = L6(n, i, -1, g)), m && g && m.from == g.from && m.to == g.to)
    return w(k(t.from, t.to, m));
  {
    let M = m ? k(t.from, null, m) : T(d, !1), C = g ? k(null, t.to, g) : T(p, !0), I = [];
    return (m || d).to < (g || p).from - (m && g ? 1 : 0) || d.widgetLineBreaks > 1 && M.bottom + n.defaultLineHeight / 2 < C.top ? I.push(b(h, M.bottom, f, C.top)) : M.bottom < C.top && n.elementAtHeight((M.bottom + C.top) / 2).type == _n.Text && (M.bottom = C.top = (M.bottom + C.top) / 2), w(M).concat(I).concat(w(C));
  }
  function b(M, C, I, _) {
    return new Dd(e, M - a.left, C - a.top, I - M, _ - C);
  }
  function w({ top: M, bottom: C, horizontal: I }) {
    let _ = [];
    for (let F = 0; F < I.length; F += 2)
      _.push(b(I[F], M, I[F + 1], C));
    return _;
  }
  function k(M, C, I) {
    let _ = 1e9, F = -1e9, L = [];
    function $(te, ie, Ce, Oe, Re) {
      let Be = n.coordsAtPos(te, te == I.to ? -2 : 2), D = n.coordsAtPos(Ce, Ce == I.from ? 2 : -2);
      !Be || !D || (_ = Math.min(Be.top, D.top, _), F = Math.max(Be.bottom, D.bottom, F), Re == wt.LTR ? L.push(s && ie ? h : Be.left, s && Oe ? f : D.right) : L.push(!s && Oe ? h : D.left, !s && ie ? f : Be.right));
    }
    let B = M ?? I.from, se = C ?? I.to;
    for (let te of n.visibleRanges)
      if (te.to > B && te.from < se)
        for (let ie = Math.max(te.from, B), Ce = Math.min(te.to, se); ; ) {
          let Oe = n.state.doc.lineAt(ie);
          for (let Re of n.bidiSpans(Oe)) {
            let Be = Re.from + Oe.from, D = Re.to + Oe.from;
            if (Be >= Ce)
              break;
            D > ie && $(Math.max(Be, ie), M == null && Be <= B, Math.min(D, Ce), C == null && D >= se, Re.dir);
          }
          if (ie = Oe.to + 1, ie >= Ce)
            break;
        }
    return L.length == 0 && $(B, M == null, se, C == null, n.textDirection), { top: _, bottom: F, horizontal: L };
  }
  function T(M, C) {
    let I = l.top + (C ? M.top : M.bottom);
    return { top: I, bottom: I, horizontal: [] };
  }
}
function XB(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class ZB {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(gp) != e.state.facet(gp) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(gp);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !XB(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[r].constructor && i.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e, ae.ios && (this.dom.style.display = this.dom.firstChild ? "" : "none");
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const gp = /* @__PURE__ */ he.define();
function iC(n) {
  return [
    jt.define((e) => new ZB(e, n)),
    gp.of(n)
  ];
}
const Tf = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function sC(n = {}) {
  return [
    Tf.of(n),
    QB,
    ez,
    tz,
    DS.of(!0)
  ];
}
function oC(n) {
  return n.startState.facet(Tf) != n.state.facet(Tf);
}
const QB = /* @__PURE__ */ iC({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(Tf), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty || t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : G.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of Dd.forRange(n, o, l))
          r.push(a);
      }
    }
    return r;
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = oC(n);
    return t && B6(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    B6(e.state, n);
  },
  class: "cm-cursorLayer"
});
function B6(n, e) {
  e.style.animationDuration = n.facet(Tf).cursorBlinkRate + "ms";
}
const ez = /* @__PURE__ */ iC({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : Dd.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || oC(n);
  },
  class: "cm-selectionLayer"
}), tz = /* @__PURE__ */ el.highest(/* @__PURE__ */ de.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), lC = /* @__PURE__ */ ze.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), ch = /* @__PURE__ */ sn.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, r) => r.is(lC) ? r.value : t, n);
  }
}), nz = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(ch);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(ch) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(ch), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let r = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(ch) != n && this.view.dispatch({ effects: lC.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function rz() {
  return [ch, nz];
}
function z6(n, e, t, r, i) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, r), o = t, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function iz(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let r = [];
  for (let { from: i, to: s } of t)
    i = Math.max(n.state.doc.lineAt(i).from, i - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class sz {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (l, a, c, u) => i(u, c, c + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, c, u) => {
        let h = r(l, a, c);
        h && u(c, c + l[0].length, h);
      };
    else if (r)
      this.addMatch = (l, a, c, u) => u(c, c + l[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Us(), r = t.add.bind(t);
    for (let { from: i, to: s } of iz(e, this.maxLength))
      z6(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a >= e.view.viewport.from && l <= e.view.viewport.to && (r = Math.min(l, r), i = Math.max(a, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), r, i) : t;
  }
  updateRange(e, t, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), l = Math.min(s.to, i);
      if (l >= o) {
        let a = e.state.doc.lineAt(o), c = a.to < l ? e.state.doc.lineAt(l) : a, u = Math.max(s.from, a.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              u = o;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              h = l;
              break;
            }
        }
        let f = [], d, p = (m, g, b) => f.push(b.range(m, g));
        if (a == c)
          for (this.regexp.lastIndex = u - a.from; (d = this.regexp.exec(a.text)) && d.index < h - a.from; )
            this.addMatch(d, e, d.index + a.from, p);
        else
          z6(e.state.doc, this.regexp, u, h, (m, g) => this.addMatch(g, e, m, p));
        t = t.update({ filterFrom: u, filterTo: h, filter: (m, g) => m < u || g > h, add: f });
      }
    }
    return t;
  }
}
const uy = /x/.unicode != null ? "gu" : "g", oz = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, uy), lz = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Vg = null;
function az() {
  var n;
  if (Vg == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Vg = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return Vg || !1;
}
const yp = /* @__PURE__ */ he.define({
  combine(n) {
    let e = ls(n, {
      render: null,
      specialChars: oz,
      addSpecialChars: null
    });
    return (e.replaceTabs = !az()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, uy)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, uy)), e;
  }
});
function cz(n = {}) {
  return [yp.of(n), uz()];
}
let _6 = null;
function uz() {
  return _6 || (_6 = jt.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = Se.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(yp)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new sz({
        regexp: n.specialChars,
        decoration: (e, t, r) => {
          let { doc: i } = t.state, s = er(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), l = t.state.tabSize, a = fu(o.text, l, r - o.from);
            return Se.replace({
              widget: new pz((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = Se.replace({ widget: new dz(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(yp);
      n.startState.facet(yp) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const hz = "â€¢";
function fz(n) {
  return n >= 32 ? hz : n == 10 ? "â¤" : String.fromCharCode(9216 + n);
}
class dz extends no {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = fz(this.code), r = e.state.phrase("Control character") + " " + (lz[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, t);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = t, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class pz extends no {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function mz() {
  return yz;
}
const gz = /* @__PURE__ */ Se.line({ class: "cm-activeLine" }), yz = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let r of n.state.selection.ranges) {
      let i = n.lineBlockAt(r.head);
      i.from > e && (t.push(gz.range(i.from)), e = i.from);
    }
    return Se.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), hy = 2e3;
function bz(n, e, t) {
  let r = Math.min(e.line, t.line), i = Math.max(e.line, t.line), s = [];
  if (e.off > hy || t.off > hy || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a);
      c.length <= l && s.push(G.range(c.from + o, c.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let a = r; a <= i; a++) {
      let c = n.doc.line(a), u = V4(c.text, o, n.tabSize, !0);
      if (u < 0)
        s.push(G.cursor(c.to));
      else {
        let h = V4(c.text, l, n.tabSize);
        s.push(G.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function vz(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function F6(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = n.state.doc.lineAt(t), i = t - r.from, s = i > hy ? -1 : i == r.length ? vz(n, e.clientX) : fu(r.text, n.state.tabSize, t - r.from);
  return { line: r.number, col: s, off: i };
}
function wz(n, e) {
  let t = F6(n, e), r = n.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(t.line).from), o = i.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = F6(n, i);
      if (!l)
        return r;
      let a = bz(n.state, t, l);
      return a.length ? o ? G.create(a.concat(r.ranges)) : G.create(a) : r;
    }
  } : null;
}
function xz(n) {
  let e = (t) => t.altKey && t.button == 0;
  return de.mouseSelectionStyle.of((t, r) => e(r) ? wz(t, r) : null);
}
const kz = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, Sz = { style: "cursor: crosshair" };
function Cz(n = {}) {
  let [e, t] = kz[n.key || "Alt"], r = jt.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    r,
    de.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? Sz : null;
    })
  ];
}
const ju = "-10000px";
class aC {
  constructor(e, t, r, i) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));
  }
  update(e, t) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = t ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let c = s[a], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0)
          o[a] = this.createTooltipView(c, a ? o[a - 1] : null), l && (l[a] = !!c.above);
        else {
          let h = o[a] = this.tooltipViews[u];
          l && (l[a] = t[u]), h.update && h.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (this.removeTooltipView(a), (r = a.destroy) === null || r === void 0 || r.call(a));
    return t && (l.forEach((a, c) => t[c] = a), t.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function Mz(n) {
  let e = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const qg = /* @__PURE__ */ he.define({
  combine: (n) => {
    var e, t, r;
    return {
      position: ae.ios ? "absolute" : ((e = n.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || Mz
    };
  }
}), H6 = /* @__PURE__ */ new WeakMap(), d3 = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(qg);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new aC(n, p3, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, r = n.state.facet(qg);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", t.dom.appendChild(i);
    }
    return t.dom.style.position = this.position, t.dom.style.top = ju, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (n = r.destroy) === null || n === void 0 || n.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (ae.gecko)
        t = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == ju && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (n = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = c3(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let l = this.manager.tooltipViews[o];
        return l.getCoords ? l.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(qg).tooltipSpace(this.view),
      scaleX: n,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: i, scaleY: s } = n, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: u } = c, h = n.pos[l], f = n.size[l];
      if (!h || a.clip !== !1 && (h.bottom <= Math.max(t.top, r.top) || h.top >= Math.min(t.bottom, r.bottom) || h.right < Math.max(t.left, r.left) - 0.1 || h.left > Math.min(t.right, r.right) + 0.1)) {
        u.style.top = ju;
        continue;
      }
      let d = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, m = f.right - f.left, g = (e = H6.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, b = c.offset || Az, w = this.view.textDirection == wt.LTR, k = f.width > r.right - r.left ? w ? r.left : r.right - f.width : w ? Math.max(r.left, Math.min(h.left - (d ? 14 : 0) + b.x, r.right - m)) : Math.min(Math.max(r.left, h.left - m + (d ? 14 : 0) - b.x), r.right - m), T = this.above[l];
      !a.strictSide && (T ? h.top - g - p - b.y < r.top : h.bottom + g + p + b.y > r.bottom) && T == r.bottom - h.bottom > h.top - r.top && (T = this.above[l] = !T);
      let M = (T ? h.top - r.top : r.bottom - h.bottom) - p;
      if (M < g && c.resize !== !1) {
        if (M < this.view.defaultLineHeight) {
          u.style.top = ju;
          continue;
        }
        H6.set(c, g), u.style.height = (g = M) / s + "px";
      } else u.style.height && (u.style.height = "");
      let C = T ? h.top - g - p - b.y : h.bottom + p + b.y, I = k + m;
      if (c.overlap !== !0)
        for (let _ of o)
          _.left < I && _.right > k && _.top < C + g && _.bottom > C && (C = T ? _.top - g - 2 - p : _.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = (C - n.parent.top) / s + "px", $6(u, (k - n.parent.left) / i)) : (u.style.top = C / s + "px", $6(u, k / i)), d) {
        let _ = h.left + (w ? b.x : -b.x) - (k + 14 - 7);
        d.style.left = _ / i + "px";
      }
      c.overlap !== !0 && o.push({ left: k, top: C, right: I, bottom: C + g }), u.classList.toggle("cm-tooltip-above", T), u.classList.toggle("cm-tooltip-below", !T), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = ju;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function $6(n, e) {
  let t = parseInt(n.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (n.style.left = e + "px");
}
const Tz = /* @__PURE__ */ de.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Az = { x: 0, y: 0 }, p3 = /* @__PURE__ */ he.define({
  enables: [d3, Tz]
}), vm = /* @__PURE__ */ he.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class g1 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new g1(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new aC(e, vm, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (t === void 0)
          t = i;
        else if (t !== i)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const Oz = /* @__PURE__ */ p3.compute([vm], (n) => {
  let e = n.facet(vm);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: g1.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class Ez {
  constructor(e, t, r, i, s) {
    this.view = e, this.source = t, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof No)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(t), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || t.y < l.top || t.y > l.bottom || t.x < l.left - e.defaultCharacterWidth || t.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = a && a.dir == wt.RTL ? -1 : 1;
      s = t.x < l.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let l = this.pending = { pos: i };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && !(Array.isArray(a) && !a.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(a) ? a : [a]) }));
      }, (a) => rr(e.state, a, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(d3), t = e ? e.manager.tooltips.findIndex((r) => r.create == g1.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !Iz(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, l = (r = (t = i[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == l ? this.view.posAtCoords(this.lastMove) != o : !Dz(this.view, o, l, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const T0 = 4;
function Iz(n, e) {
  let { left: t, right: r, top: i, bottom: s } = n.getBoundingClientRect(), o;
  if (o = n.querySelector(".cm-tooltip-arrow")) {
    let l = o.getBoundingClientRect();
    i = Math.min(l.top, i), s = Math.max(l.bottom, s);
  }
  return e.clientX >= t - T0 && e.clientX <= r + T0 && e.clientY >= i - T0 && e.clientY <= s + T0;
}
function Dz(n, e, t, r, i, s) {
  let o = n.scrollDOM.getBoundingClientRect(), l = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let a = n.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= t;
}
function Nz(n, e = {}) {
  let t = ze.define(), r = sn.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let l of i) {
          let a = s.changes.mapPos(l.pos, -1, mn.TrackDel);
          if (a != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), l);
            c.pos = a, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        i = o;
      }
      for (let o of s.effects)
        o.is(t) && (i = o.value), o.is(Rz) && (i = []);
      return i;
    },
    provide: (i) => vm.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      jt.define((i) => new Ez(
        i,
        n,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      Oz
    ]
  };
}
function cC(n, e) {
  let t = n.plugin(d3);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const Rz = /* @__PURE__ */ ze.define(), V6 = /* @__PURE__ */ he.define({
  combine(n) {
    let e, t;
    for (let r of n)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Af(n, e) {
  let t = n.plugin(uC), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const uC = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(Of), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(V6);
    this.top = new A0(n, !0, e.topContainer), this.bottom = new A0(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(V6);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new A0(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new A0(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(Of);
    if (t != this.input) {
      let r = t.filter((a) => a), i = [], s = [], o = [], l = [];
      for (let a of r) {
        let c = this.specs.indexOf(a), u;
        c < 0 ? (u = a(n.view), l.push(u)) : (u = this.panels[c], u.update && u.update(n)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => de.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class A0 {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = q6(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = q6(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function q6(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const Of = /* @__PURE__ */ he.define({
  enables: uC
});
class Ys extends la {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
Ys.prototype.elementClass = "";
Ys.prototype.toDOM = void 0;
Ys.prototype.mapMode = mn.TrackBefore;
Ys.prototype.startSide = Ys.prototype.endSide = -1;
Ys.prototype.point = !0;
const bp = /* @__PURE__ */ he.define(), Pz = /* @__PURE__ */ he.define(), Lz = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Ze.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, Kh = /* @__PURE__ */ he.define();
function Bz(n) {
  return [hC(), Kh.of({ ...Lz, ...n })];
}
const W6 = /* @__PURE__ */ he.define({
  combine: (n) => n.some((e) => e)
});
function hC(n) {
  return [
    zz
  ];
}
const zz = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.view = n, this.domAfter = null, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(Kh).map((e) => new U6(n, e)), this.fixed = !n.state.facet(W6);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    if (n.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(W6) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let t = Ze.iter(this.view.state.facet(bp), this.view.viewport.from), r = [], i = this.gutters.map((s) => new _z(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == _n.Text && o) {
            fy(t, r, l.from);
            for (let a of i)
              a.line(this.view, l, r);
            o = !1;
          } else if (l.widget)
            for (let a of i)
              a.widget(this.view, l);
      } else if (s.type == _n.Text) {
        fy(t, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    n && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(n) {
    let e = n.startState.facet(Kh), t = n.state.facet(Kh), r = n.docChanged || n.heightChanged || n.viewportChanged || !Ze.eq(n.startState.facet(bp), n.state.facet(bp), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(n) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new U6(this.view, s)) : (this.gutters[o].update(n), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (n) => de.scrollMargins.of((e) => {
    let t = e.plugin(n);
    if (!t || t.gutters.length == 0 || !t.fixed)
      return null;
    let r = t.dom.offsetWidth * e.scaleX, i = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == wt.LTR ? { left: r, right: i } : { right: r, left: i };
  })
});
function j6(n) {
  return Array.isArray(n) ? n : [n];
}
function fy(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class _z {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = Ze.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: i } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new fC(e, o, s, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let i = [];
    fy(this.cursor, i, t.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, t, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, i);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), i = r ? [r] : null;
    for (let s of e.state.facet(Pz)) {
      let o = s(e, t.widget, t);
      o && (i || (i = [])).push(o);
    }
    i && this.addElement(e, t, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class U6 {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    this.markers = j6(t.markers(e)), t.initialSpacer && (this.spacer = new fC(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = j6(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !Ze.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class fC {
  constructor(e, t, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, i);
  }
  update(e, t, r, i) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), Fz(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, c = !1;
      if (a) {
        let u = a.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(a)) {
            l = h, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Fz(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const Hz = /* @__PURE__ */ he.define(), $z = /* @__PURE__ */ he.define(), tc = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let i in t) {
          let s = r[i], o = t[i];
          r[i] = s ? (l, a, c) => s(l, a, c) || o(l, a, c) : o;
        }
        return r;
      }
    });
  }
});
class Wg extends Ys {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function jg(n, e) {
  return n.state.facet(tc).formatNumber(e, n.state);
}
const Vz = /* @__PURE__ */ Kh.compute([tc], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Hz);
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM) ? null : new Wg(jg(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let i of e.state.facet($z)) {
      let s = i(e, t, r);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(tc) != e.state.facet(tc),
  initialSpacer(e) {
    return new Wg(jg(e, G6(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = jg(t.view, G6(t.view.state.doc.lines));
    return r == e.number ? e : new Wg(r);
  },
  domEventHandlers: n.facet(tc).domEventHandlers,
  side: "before"
}));
function qz(n = {}) {
  return [
    tc.of(n),
    hC(),
    Vz
  ];
}
function G6(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const Wz = /* @__PURE__ */ new class extends Ys {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), jz = /* @__PURE__ */ bp.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.head).from;
    i > t && (t = i, e.push(Wz.range(i)));
  }
  return Ze.of(e);
});
function Uz() {
  return jz;
}
let Gz = 0;
class qr {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.set = t, this.base = r, this.modified = i, this.id = Gz++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof qr && (t = e), t != null && t.base)
      throw new Error("Can not derive from a modified tag");
    let i = new qr(r, [], null, []);
    if (i.set.push(i), t)
      for (let s of t.set)
        i.set.push(s);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new wm(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : wm.get(r.base || r, r.modified.concat(t).sort((i, s) => i.id - s.id));
  }
}
let Kz = 0;
class wm {
  constructor(e) {
    this.name = e, this.instances = [], this.id = Kz++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((l) => l.base == e && Yz(t, l.modified));
    if (r)
      return r;
    let i = [], s = new qr(e.name, i, e, t);
    for (let l of t)
      l.instances.push(s);
    let o = Jz(t);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          i.push(wm.get(l, a));
    return s;
  }
}
function Yz(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r]);
}
function Jz(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(n[t]));
  return e.sort((t, r) => r.length - t.length);
}
function Xz(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    Array.isArray(r) || (r = [r]);
    for (let i of t.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let h = 0; ; ) {
          if (l == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let d = i[h++];
          if (h == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(h);
        }
        let a = s.length - 1, c = s[a];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new xm(r, o, a > 0 ? s.slice(0, a) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return dC.add(e);
}
const dC = new We();
class xm {
  constructor(e, t, r, i) {
    this.tags = e, this.mode = t, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
xm.empty = new xm([], 2, null);
function pC(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let a of l.set) {
          let c = t[a.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function Zz(n, e) {
  let t = null;
  for (let r of n) {
    let i = r.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function Qz(n, e, t, r = 0, i = n.length) {
  let s = new e_(r, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class e_ {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, i, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= r || a <= t)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i, u = t_(e) || xm.empty, h = Zz(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(t, l), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(We.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + l, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(f.tree.type)), m = e.firstChild();
      for (let g = 0, b = l; ; g++) {
        let w = g < f.overlay.length ? f.overlay[g] : null, k = w ? w.from + l : a, T = Math.max(t, b), M = Math.min(r, k);
        if (T < M && m)
          for (; e.from < M && (this.highlightRange(e, T, M, i, s), this.startSpan(Math.min(M, e.to), c), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!w || k > r)
          break;
        b = w.to + l, b > t && (this.highlightRange(d.cursor(), Math.max(t, w.from + l), Math.min(r, b), "", p), this.startSpan(Math.min(r, b), c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function t_(n) {
  let e = n.type.prop(dC);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const oe = qr.define, O0 = oe(), wo = oe(), K6 = oe(wo), Y6 = oe(wo), xo = oe(), E0 = oe(xo), Ug = oe(xo), _i = oe(), fl = oe(_i), Bi = oe(), zi = oe(), dy = oe(), Uu = oe(dy), I0 = oe(), j = {
  /**
  A comment.
  */
  comment: O0,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: oe(O0),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: oe(O0),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: oe(O0),
  /**
  Any kind of identifier.
  */
  name: wo,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: oe(wo),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: K6,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: oe(K6),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: Y6,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: oe(Y6),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: oe(wo),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: oe(wo),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: oe(wo),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: oe(wo),
  /**
  A literal value.
  */
  literal: xo,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: E0,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: oe(E0),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: oe(E0),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: oe(E0),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Ug,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: oe(Ug),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: oe(Ug),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: oe(xo),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: oe(xo),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: oe(xo),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: oe(xo),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: oe(xo),
  /**
  A language keyword.
  */
  keyword: Bi,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: oe(Bi),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: oe(Bi),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: oe(Bi),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: oe(Bi),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: oe(Bi),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: oe(Bi),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: oe(Bi),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: oe(Bi),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: oe(Bi),
  /**
  An operator.
  */
  operator: zi,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: oe(zi),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: oe(zi),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: oe(zi),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: oe(zi),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: oe(zi),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: oe(zi),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: oe(zi),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: oe(zi),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: oe(zi),
  /**
  Program or markup punctuation.
  */
  punctuation: dy,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: oe(dy),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Uu,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: oe(Uu),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: oe(Uu),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: oe(Uu),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: oe(Uu),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: _i,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: fl,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: oe(fl),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: oe(fl),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: oe(fl),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: oe(fl),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: oe(fl),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: oe(fl),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: oe(_i),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: oe(_i),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: oe(_i),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: oe(_i),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: oe(_i),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: oe(_i),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: oe(_i),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: oe(_i),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: oe(),
  /**
  Deleted text.
  */
  deleted: oe(),
  /**
  Changed text.
  */
  changed: oe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: oe(),
  /**
  Metadata or meta-instruction.
  */
  meta: I0,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: oe(I0),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: oe(I0),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: oe(I0),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: qr.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: qr.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: qr.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: qr.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: qr.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: qr.defineModifier("special")
};
for (let n in j) {
  let e = j[n];
  e instanceof qr && (e.name = n);
}
pC([
  { tag: j.link, class: "tok-link" },
  { tag: j.heading, class: "tok-heading" },
  { tag: j.emphasis, class: "tok-emphasis" },
  { tag: j.strong, class: "tok-strong" },
  { tag: j.keyword, class: "tok-keyword" },
  { tag: j.atom, class: "tok-atom" },
  { tag: j.bool, class: "tok-bool" },
  { tag: j.url, class: "tok-url" },
  { tag: j.labelName, class: "tok-labelName" },
  { tag: j.inserted, class: "tok-inserted" },
  { tag: j.deleted, class: "tok-deleted" },
  { tag: j.literal, class: "tok-literal" },
  { tag: j.string, class: "tok-string" },
  { tag: j.number, class: "tok-number" },
  { tag: [j.regexp, j.escape, j.special(j.string)], class: "tok-string2" },
  { tag: j.variableName, class: "tok-variableName" },
  { tag: j.local(j.variableName), class: "tok-variableName tok-local" },
  { tag: j.definition(j.variableName), class: "tok-variableName tok-definition" },
  { tag: j.special(j.variableName), class: "tok-variableName2" },
  { tag: j.definition(j.propertyName), class: "tok-propertyName tok-definition" },
  { tag: j.typeName, class: "tok-typeName" },
  { tag: j.namespace, class: "tok-namespace" },
  { tag: j.className, class: "tok-className" },
  { tag: j.macroName, class: "tok-macroName" },
  { tag: j.propertyName, class: "tok-propertyName" },
  { tag: j.operator, class: "tok-operator" },
  { tag: j.comment, class: "tok-comment" },
  { tag: j.meta, class: "tok-meta" },
  { tag: j.invalid, class: "tok-invalid" },
  { tag: j.punctuation, class: "tok-punctuation" }
]);
var Gg;
const El = /* @__PURE__ */ new We();
function mC(n) {
  return he.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const n_ = /* @__PURE__ */ new We();
class Gr {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, Ct.prototype.hasOwnProperty("tree") || Object.defineProperty(Ct.prototype, "tree", { get() {
      return yn(this);
    } }), this.parser = t, this.extension = [
      jo.of(this),
      Ct.languageData.of((s, o, l) => {
        let a = J6(s, o, l), c = a.type.prop(El);
        if (!c)
          return [];
        let u = s.facet(c), h = a.type.prop(n_);
        if (h) {
          let f = a.resolve(o - a.from, l);
          for (let d of h)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return J6(e, t, r).type.prop(El) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(jo);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(El) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(We.mounted);
      if (l) {
        if (l.tree.prop(El) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              r.push({ from: a.from + o, to: a.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = r.length;
          if (i(l.tree, l.overlay[0].from + o), r.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let c = s.children[a];
        c instanceof mt && i(c, s.positions[a] + o);
      }
    };
    return i(yn(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Gr.setState = /* @__PURE__ */ ze.define();
function J6(n, e, t) {
  let r = n.facet(jo), i = yn(n).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, t, Et.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class py extends Gr {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = mC(e.languageData);
    return new py(t, e.parser.configure({
      props: [El.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new py(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function yn(n) {
  let e = n.field(Gr.state, !1);
  return e ? e.tree : mt.empty;
}
class r_ {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let Gu = null, my = class gy {
  constructor(e, t, r = [], i, s, o, l, a) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new gy(e, t, [], mt.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new r_(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != mt.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(Hs.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(Hs.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = Gu;
    Gu = this;
    try {
      return e();
    } finally {
      Gu = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = X6(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, u, h, f) => a.push({ fromA: c, toA: u, fromB: h, toB: f })), r = Hs.applyChanges(r, a), i = mt.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && l.push({ from: u, to: h });
        }
      }
    }
    return new gy(this.parser, t, r, i, s, o, l, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = X6(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends B9 {
      createParse(t, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = Gu;
            if (a) {
              for (let c of i)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new mt(Nr.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Gu;
  }
};
function X6(n, e, t) {
  return Hs.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Kc {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new Kc(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = my.create(e.facet(jo).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new Kc(r);
  }
}
Gr.state = /* @__PURE__ */ sn.define({
  create: Kc.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(Gr.setState))
        return t.value;
    return e.startState.facet(jo) != e.state.facet(jo) ? Kc.init(e.state) : n.apply(e);
  }
});
let gC = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (gC = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const Kg = typeof navigator < "u" && (!((Gg = navigator.scheduling) === null || Gg === void 0) && Gg.isInputPending) ? () => navigator.scheduling.isInputPending() : null, i_ = /* @__PURE__ */ jt.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Gr.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Gr.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = gC(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(Gr.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Kg ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && r.doc.length > i + 1e3, a = s.context.work(() => Kg && Kg() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Gr.setState.of(new Kc(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => rr(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), jo = /* @__PURE__ */ he.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    Gr.state,
    i_,
    de.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class s_ {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class H {
  constructor(e, t, r, i, s, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new H(e.name, (e.alias || []).concat(e.name).map((i) => i.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let i of e)
      if (i.filename && i.filename.test(t))
        return i;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let i of e)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let i of e)
      if (i.alias.some((s) => s == t))
        return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = t.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + s.length])))
            return i;
        }
    return null;
  }
}
const o_ = /* @__PURE__ */ he.define(), y1 = /* @__PURE__ */ he.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function ha(n) {
  let e = n.facet(y1);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function Ef(n, e) {
  let t = "", r = n.tabSize, i = n.facet(y1)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    t += i;
  return t;
}
function m3(n, e) {
  n instanceof Ct && (n = new b1(n));
  for (let r of n.state.facet(o_)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = yn(n.state);
  return t.length >= e ? l_(n, t, e) : null;
}
class b1 {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = ha(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return fu(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const yC = /* @__PURE__ */ new We();
function l_(n, e, t) {
  let r = e.resolveStack(t), i = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let s = [];
    for (let o = i; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return bC(r, n, t);
}
function bC(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = c_(r.node);
    if (i)
      return i(g3.create(e, t, r));
  }
  return 0;
}
function a_(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function c_(n) {
  let e = n.type.prop(yC);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(We.closedBy))) {
    let i = n.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => vC(o, !0, 1, void 0, s && !a_(o) ? i.from : void 0);
  }
  return n.parent == null ? u_ : null;
}
function u_() {
  return 0;
}
class g3 extends b1 {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new g3(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (h_(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return bC(this.context.next, this.base, this.pos);
  }
}
function h_(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function f_(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = t.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r)
      return null;
    if (!a.type.isSkipped) {
      if (a.from >= o)
        return null;
      let c = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    l = a.to;
  }
}
function Xoe({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => vC(r, e, t, n);
}
function vC(n, e, t, r, i) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, l = r && s.slice(o, o + r.length) == r || i == n.pos + o, a = e ? f_(n) : null;
  return a ? l ? n.column(a.from) : n.column(a.to) : n.baseIndent + (l ? 0 : n.unit * t);
}
const Zoe = (n) => n.baseIndent;
function Qoe({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const d_ = 200;
function p_() {
  return Ct.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + d_)
      return n;
    let s = t.sliceString(i.from, r);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, l = -1, a = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == l)
        continue;
      l = u.from;
      let h = m3(o, u.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], d = Ef(o, h);
      f != d && a.push({ from: u.from, to: u.from + f.length, insert: d });
    }
    return a.length ? [n, { changes: a, sequential: !0 }] : n;
  });
}
const m_ = /* @__PURE__ */ he.define(), g_ = /* @__PURE__ */ new We();
function ele(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function y_(n, e, t) {
  let r = yn(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= t || l.from > t)
      continue;
    if (s && l.from < e)
      break;
    let a = l.type.prop(g_);
    if (a && (l.to < r.length - 50 || r.length == n.doc.length || !b_(l))) {
      let c = a(l, n);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function b_(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function km(n, e, t) {
  for (let r of n.facet(m_)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return y_(n, e, t);
}
function wC(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const v1 = /* @__PURE__ */ ze.define({ map: wC }), Nd = /* @__PURE__ */ ze.define({ map: wC });
function xC(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const fa = /* @__PURE__ */ sn.define({
  create() {
    return Se.none;
  },
  update(n, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, r) => n = Z6(n, t, r)), n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(v1) && !v_(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(CC), i = r ? Se.replace({ widget: new T_(r(e.state, t.value)) }) : Q6;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(Nd) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (n = Z6(n, e.selection.main.head)), n;
  },
  provide: (n) => de.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Q6.range(r, i));
    }
    return Se.set(e, !0);
  }
});
function Z6(n, e, t = e) {
  let r = !1;
  return n.between(e, t, (i, s) => {
    i < t && s > e && (r = !0);
  }), r ? n.update({
    filterFrom: e,
    filterTo: t,
    filter: (i, s) => i >= t || s <= e
  }) : n;
}
function Sm(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(fa, !1)) === null || r === void 0 || r.between(e, t, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function v_(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, s) => {
    i == e && s == t && (r = !0);
  }), r;
}
function kC(n, e) {
  return n.field(fa, !1) ? e : e.concat(ze.appendConfig.of(MC()));
}
const w_ = (n) => {
  for (let e of xC(n)) {
    let t = km(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: kC(n.state, [v1.of(t), SC(n, t)]) }), !0;
  }
  return !1;
}, x_ = (n) => {
  if (!n.state.field(fa, !1))
    return !1;
  let e = [];
  for (let t of xC(n)) {
    let r = Sm(n.state, t.from, t.to);
    r && e.push(Nd.of(r), SC(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function SC(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return de.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const k_ = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), s = km(e, i.from, i.to);
    s && t.push(v1.of(s)), r = (s ? n.lineBlockAt(s.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: kC(n.state, t) }), !!t.length;
}, S_ = (n) => {
  let e = n.state.field(fa, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(Nd.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, C_ = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: w_ },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: x_ },
  { key: "Ctrl-Alt-[", run: k_ },
  { key: "Ctrl-Alt-]", run: S_ }
], M_ = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "â€¦"
}, CC = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, M_);
  }
});
function MC(n) {
  return [fa, E_];
}
function TC(n, e) {
  let { state: t } = n, r = t.facet(CC), i = (o) => {
    let l = n.lineBlockAt(n.posAtDOM(o.target)), a = Sm(n.state, l.from, l.to);
    a && n.dispatch({ effects: Nd.of(a) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const Q6 = /* @__PURE__ */ Se.replace({ widget: /* @__PURE__ */ new class extends no {
  toDOM(n) {
    return TC(n, null);
  }
}() });
class T_ extends no {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return TC(e, this.value);
  }
}
const A_ = {
  openText: "âŒ„",
  closedText: "â€º",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Yg extends Ys {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function O_(n = {}) {
  let e = { ...A_, ...n }, t = new Yg(e, !0), r = new Yg(e, !1), i = jt.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(jo) != o.state.facet(jo) || o.startState.field(fa, !1) != o.state.field(fa, !1) || yn(o.startState) != yn(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new Us();
      for (let a of o.viewportLineBlocks) {
        let c = Sm(o.state, a.from, a.to) ? r : km(o.state, a.from, a.to) ? t : null;
        c && l.add(a.from, a.from, c);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    Bz({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || Ze.empty;
      },
      initialSpacer() {
        return new Yg(e, !1);
      },
      domEventHandlers: {
        ...s,
        click: (o, l, a) => {
          if (s.click && s.click(o, l, a))
            return !0;
          let c = Sm(o.state, l.from, l.to);
          if (c)
            return o.dispatch({ effects: Nd.of(c) }), !0;
          let u = km(o.state, l.from, l.to);
          return u ? (o.dispatch({ effects: v1.of(u) }), !0) : !1;
        }
      }
    }),
    MC()
  ];
}
const E_ = /* @__PURE__ */ de.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Rd {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(l) {
      let a = qo.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, o = t.scope;
    this.scope = o instanceof Gr ? (l) => l.prop(El) == o.data : o ? (l) => l == o : void 0, this.style = pC(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new qo(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Rd(e, t || {});
  }
}
const yy = /* @__PURE__ */ he.define(), AC = /* @__PURE__ */ he.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function Jg(n) {
  let e = n.facet(yy);
  return e.length ? e : n.facet(AC);
}
function OC(n, e) {
  let t = [D_], r;
  return n instanceof Rd && (n.module && t.push(de.styleModule.of(n.module)), r = n.themeType), e != null && e.fallback ? t.push(AC.of(n)) : r ? t.push(yy.computeN([de.darkTheme], (i) => i.facet(de.darkTheme) == (r == "dark") ? [n] : [])) : t.push(yy.of(n)), t;
}
class I_ {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = yn(e.state), this.decorations = this.buildDeco(e, Jg(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = yn(e.state), r = Jg(e.state), i = r != Jg(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !i && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return Se.none;
    let r = new Us();
    for (let { from: i, to: s } of e.visibleRanges)
      Qz(this.tree, t, (o, l, a) => {
        r.add(o, l, this.markCache[a] || (this.markCache[a] = Se.mark({ class: a })));
      }, i, s);
    return r.finish();
  }
}
const D_ = /* @__PURE__ */ el.high(/* @__PURE__ */ jt.fromClass(I_, {
  decorations: (n) => n.decorations
})), N_ = /* @__PURE__ */ Rd.define([
  {
    tag: j.meta,
    color: "#404740"
  },
  {
    tag: j.link,
    textDecoration: "underline"
  },
  {
    tag: j.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: j.emphasis,
    fontStyle: "italic"
  },
  {
    tag: j.strong,
    fontWeight: "bold"
  },
  {
    tag: j.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: j.keyword,
    color: "#708"
  },
  {
    tag: [j.atom, j.bool, j.url, j.contentSeparator, j.labelName],
    color: "#219"
  },
  {
    tag: [j.literal, j.inserted],
    color: "#164"
  },
  {
    tag: [j.string, j.deleted],
    color: "#a11"
  },
  {
    tag: [j.regexp, j.escape, /* @__PURE__ */ j.special(j.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ j.definition(j.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ j.local(j.variableName),
    color: "#30a"
  },
  {
    tag: [j.typeName, j.namespace],
    color: "#085"
  },
  {
    tag: j.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ j.special(j.variableName), j.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ j.definition(j.propertyName),
    color: "#00c"
  },
  {
    tag: j.comment,
    color: "#940"
  },
  {
    tag: j.invalid,
    color: "#f00"
  }
]), R_ = /* @__PURE__ */ de.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), EC = 1e4, IC = "()[]{}", DC = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, {
      afterCursor: !0,
      brackets: IC,
      maxScanDistance: EC,
      renderMatch: B_
    });
  }
}), P_ = /* @__PURE__ */ Se.mark({ class: "cm-matchingBracket" }), L_ = /* @__PURE__ */ Se.mark({ class: "cm-nonmatchingBracket" });
function B_(n) {
  let e = [], t = n.matched ? P_ : L_;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const z_ = /* @__PURE__ */ sn.define({
  create() {
    return Se.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(DC);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = Gi(e.state, i.head, -1, r) || i.head > 0 && Gi(e.state, i.head - 1, 1, r) || r.afterCursor && (Gi(e.state, i.head, 1, r) || i.head < e.state.doc.length && Gi(e.state, i.head + 1, -1, r));
      s && (t = t.concat(r.renderMatch(s, e.state)));
    }
    return Se.set(t, !0);
  },
  provide: (n) => de.decorations.from(n)
}), __ = [
  z_,
  R_
];
function F_(n = {}) {
  return [DC.of(n), __];
}
const H_ = /* @__PURE__ */ new We();
function by(n, e, t) {
  let r = n.prop(e < 0 ? We.openedBy : We.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function vy(n) {
  let e = n.type.prop(H_);
  return e ? e(n.node) : n;
}
function Gi(n, e, t, r = {}) {
  let i = r.maxScanDistance || EC, s = r.brackets || IC, o = yn(n), l = o.resolveInner(e, t);
  for (let a = l; a; a = a.parent) {
    let c = by(a.type, t, s);
    if (c && a.from < a.to) {
      let u = vy(a);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return $_(n, e, t, a, u, c, s);
    }
  }
  return V_(n, e, t, o, l.type, i, s);
}
function $_(n, e, t, r, i, s, o) {
  let l = r.parent, a = { from: i.from, to: i.to }, c = 0, u = l == null ? void 0 : l.cursor();
  if (u && (t < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (t < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = vy(u);
          return { start: a, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (by(u.type, t, o))
          c++;
        else if (by(u.type, -t, o)) {
          if (c == 0) {
            let h = vy(u);
            return {
              start: a,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: a, matched: !1 };
}
function V_(n, e, t, r, i, s, o) {
  let l = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let d = u.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let m = t > 0 ? 0 : d.length - 1, g = t > 0 ? d.length : -1; m != g; m += t) {
      let b = o.indexOf(d[m]);
      if (!(b < 0 || r.resolveInner(p + m, 1).type != i))
        if (b % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: p + m, to: p + m + 1 }, matched: b >> 1 == a >> 1 };
          h--;
        }
    }
    t > 0 && (f += d.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function ew(n, e, t, r = 0, i = 0) {
  e == null && (e = n.search(/[^\s\u00a0]/), e == -1 && (e = n.length));
  let s = i;
  for (let o = r; o < e; o++)
    n.charCodeAt(o) == 9 ? s += t - s % t : s++;
  return s;
}
class NC {
  /**
  Create a stream.
  */
  constructor(e, t, r, i) {
    this.string = e, this.tabSize = t, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e instanceof RegExp ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = ew(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : ew(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, r) {
    if (typeof e == "string") {
      let i = (o) => r ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return i(s) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && t !== !1 && (this.pos += i[0].length), i);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function q_(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || W_,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || v3,
    mergeTokens: n.mergeTokens !== !1
  };
}
function W_(n) {
  if (typeof n != "object")
    return n;
  let e = {};
  for (let t in n) {
    let r = n[t];
    e[t] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const tw = /* @__PURE__ */ new WeakMap();
class y3 extends Gr {
  constructor(e) {
    let t = mC(e.languageData), r = q_(e), i, s = new class extends B9 {
      createParse(o, l, a) {
        return new U_(i, o, l, a);
      }
    }();
    super(t, s, [], e.name), this.topNode = Y_(t, this), i = this, this.streamParser = r, this.stateAfter = new We({ perNode: !0 }), this.tokenTable = e.tokenTable ? new BC(r.tokenTable) : K_;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new y3(e);
  }
  /**
  @internal
  */
  getIndent(e) {
    let t, { overrideIndentation: r } = e.options;
    r && (t = tw.get(e.state), t != null && t < e.pos - 1e4 && (t = void 0));
    let i = b3(this, e.node.tree, e.node.from, e.node.from, t ?? e.pos), s, o;
    if (i ? (o = i.state, s = i.pos + 1) : (o = this.streamParser.startState(e.unit), s = e.node.from), e.pos - s > 1e4)
      return null;
    for (; s < e.pos; ) {
      let a = e.state.doc.lineAt(s), c = Math.min(e.pos, a.to);
      if (a.length) {
        let u = r ? r(a.from) : -1, h = new NC(a.text, e.state.tabSize, e.unit, u < 0 ? void 0 : u);
        for (; h.pos < c - a.from; )
          PC(this.streamParser.token, h, o);
      } else
        this.streamParser.blankLine(o, e.unit);
      if (c == e.pos)
        break;
      s = a.to + 1;
    }
    let l = e.lineAt(e.pos);
    return r && t == null && tw.set(e.state, l.from), this.streamParser.indent(o, /^\s*(.*)/.exec(l.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function b3(n, e, t, r, i) {
  let s = t >= r && t + e.length <= i && e.prop(n.stateAfter);
  if (s)
    return { state: n.streamParser.copyState(s), pos: t + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let l = e.children[o], a = t + e.positions[o], c = l instanceof mt && a < i && b3(n, l, a, r, i);
    if (c)
      return c;
  }
  return null;
}
function RC(n, e, t, r, i) {
  if (i && t <= 0 && r >= e.length)
    return e;
  !i && t == 0 && e.type == n.topNode && (i = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], l = e.children[s], a;
    if (o < r && l instanceof mt) {
      if (!(a = RC(n, l, t - o, r - o, i)))
        break;
      return i ? new mt(e.type, e.children.slice(0, s).concat(a), e.positions.slice(0, s + 1), o + a.length) : a;
    }
  }
  return null;
}
function j_(n, e, t, r, i) {
  for (let s of e) {
    let o = s.from + (s.openStart ? 25 : 0), l = s.to - (s.openEnd ? 25 : 0), a = o <= t && l > t && b3(n, s.tree, 0 - s.offset, t, l), c;
    if (a && a.pos <= r && (c = RC(n, s.tree, t + s.offset, a.pos + s.offset, !1)))
      return { state: a.state, tree: c };
  }
  return { state: n.streamParser.startState(i ? ha(i) : 4), tree: mt.empty };
}
class U_ {
  constructor(e, t, r, i) {
    this.lang = e, this.input = t, this.fragments = r, this.ranges = i, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = i[i.length - 1].to;
    let s = my.get(), o = i[0].from, { state: l, tree: a } = j_(e, r, o, this.to, s == null ? void 0 : s.state);
    this.state = l, this.parsedPos = this.chunkStart = o + a.length;
    for (let c = 0; c < a.children.length; c++)
      this.chunks.push(a.children[c]), this.chunkPos.push(a.positions[c]);
    s && this.parsedPos < s.viewport.from - 1e5 && i.some((c) => c.from <= s.viewport.from && c.to >= s.viewport.from) && (this.state = this.lang.streamParser.startState(ha(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = my.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), r = Math.min(
      t,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let r = t.indexOf(`
`);
      r > -1 && (t = t.slice(0, r));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), r = e + t.length;
    for (let i = this.rangeIndex; ; ) {
      let s = this.ranges[i].to;
      if (s >= r || (t = t.slice(0, s - (r - t.length)), i++, i == this.ranges.length))
        break;
      let o = this.ranges[i].from, l = this.lineAfter(o);
      t += l, r = o + l.length;
    }
    return { line: t, end: r };
  }
  skipGapsTo(e, t, r) {
    for (; ; ) {
      let i = this.ranges[this.rangeIndex].to, s = e + t;
      if (r > 0 ? i > s : i >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      t += o - i;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, r, i) {
    let s = 4;
    if (this.ranges.length > 1) {
      i = this.skipGapsTo(t, i, 1), t += i;
      let l = this.chunk.length;
      i = this.skipGapsTo(r, i, -1), r += i, s += this.chunk.length - l;
    }
    let o = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && s == 4 && o >= 0 && this.chunk[o] == e && this.chunk[o + 2] == t ? this.chunk[o + 2] = r : this.chunk.push(e, t, r, s), i;
  }
  parseLine(e) {
    let { line: t, end: r } = this.nextLine(), i = 0, { streamParser: s } = this.lang, o = new NC(t, e ? e.state.tabSize : 4, e ? ha(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let l = PC(s.token, o, this.state);
        if (l && (i = this.emitToken(this.lang.tokenTable.resolve(l), this.parsedPos + o.start, this.parsedPos + o.pos, i)), o.start > 1e4)
          break;
      }
    this.parsedPos = r, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = mt.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: G_,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    e = new mt(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new mt(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function PC(n, e, t) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = n(e, t);
    if (e.pos > e.start)
      return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const v3 = /* @__PURE__ */ Object.create(null), If = [Nr.none], G_ = /* @__PURE__ */ new J5(If), nw = [], rw = /* @__PURE__ */ Object.create(null), LC = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  LC[n] = /* @__PURE__ */ zC(v3, e);
class BC {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), LC);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = zC(this.extra, e)) : 0;
  }
}
const K_ = /* @__PURE__ */ new BC(v3);
function Xg(n, e) {
  nw.indexOf(n) > -1 || (nw.push(n), console.warn(e));
}
function zC(n, e) {
  let t = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let c of l.split(".")) {
      let u = n[c] || j[c];
      u ? typeof u == "function" ? a.length ? a = a.map(u) : Xg(c, `Modifier ${c} used at start of tag`) : a.length ? Xg(c, `Tag ${c} used as modifier`) : a = Array.isArray(u) ? u : [u] : Xg(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of a)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((l) => l.id), s = rw[i];
  if (s)
    return s.id;
  let o = rw[i] = Nr.define({
    id: If.length,
    name: r,
    props: [Xz({ [r]: t })]
  });
  return If.push(o), o.id;
}
function Y_(n, e) {
  let t = Nr.define({ id: If.length, name: "Document", props: [
    El.add(() => n),
    yC.add(() => (r) => e.getIndent(r))
  ], top: !0 });
  return If.push(t), t;
}
wt.RTL, wt.LTR;
function K(n) {
  return new s_(y3.define(n));
}
function uo(n) {
  return import("./index-Y5yrDMvs.mjs").then((e) => e.sql({ dialect: e[n] }));
}
const J_ = [
  // New-style language modes
  /* @__PURE__ */ H.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./index-d-VzE6gu.mjs").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./index-d-VzE6gu.mjs").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return uo("Cassandra");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./index-AGqe6zjt.mjs").then((n) => n.css());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./index-Ch8aYbVP.mjs").then((n) => n.go());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./index-0roPOpGX.mjs").then((n) => n.html());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./index-DqoACQwU.mjs").then((n) => n.java());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./index-CqXkm2lk.mjs").then((n) => n.javascript());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./index-yHsAkuNI.mjs").then((n) => n.json());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./index-CqXkm2lk.mjs").then((n) => n.javascript({ jsx: !0 }));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./index--6Ik17pE.mjs").then((n) => n.less());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./index-CxsE6_OZ.mjs").then((n) => n.liquid());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "MariaDB SQL",
    load() {
      return uo("MariaSQL");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./index-pCFuWFBR.mjs").then((n) => n.markdown());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "MS SQL",
    load() {
      return uo("MSSQL");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "MySQL",
    load() {
      return uo("MySQL");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./index-BoVQf-mv.mjs").then((n) => n.php());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return uo("PLSQL");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "PostgreSQL",
    load() {
      return uo("PostgreSQL");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./index-CQeJpkuI.mjs").then((n) => n.python());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./index-D4tnl3Jo.mjs").then((n) => n.rust());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./index-DhDt2D25.mjs").then((n) => n.sass({ indented: !0 }));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./index-DhDt2D25.mjs").then((n) => n.sass());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return uo("StandardSQL");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SQLite",
    load() {
      return uo("SQLite");
    }
  }),
  /* @__PURE__ */ H.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./index-CqXkm2lk.mjs").then((n) => n.javascript({ jsx: !0, typescript: !0 }));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./index-CqXkm2lk.mjs").then((n) => n.javascript({ typescript: !0 }));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./index-BwXFI_61.mjs").then((n) => n.wast());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./index-r150Zk-S.mjs").then((n) => n.xml());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./index-CYeHXc7W.mjs").then((n) => n.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  /* @__PURE__ */ H.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-B2DGVGxc.mjs").then((n) => K(n.apl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-2LVJmxlE.mjs").then((n) => K(n.asciiArmor));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-jKiBa2Ya.mjs").then((n) => K(n.asn1({})));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-DS281yxp.mjs").then((n) => K(n.asterisk));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-C_p9pTT8.mjs").then((n) => K(n.brainfuck));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-BlTKFDRj.mjs").then((n) => K(n.cobol));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.csharp));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-CCKyeQKf.mjs").then((n) => K(n.clojure));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-CCKyeQKf.mjs").then((n) => K(n.clojure));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-BkF-NPzE.mjs").then((n) => K(n.gss));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-CuaCgAKt.mjs").then((n) => K(n.cmake));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-BVCvwO8I.mjs").then((n) => K(n.coffeeScript));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-D_kxz07b.mjs").then((n) => K(n.commonLisp));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-BMq4Fwjl.mjs").then((n) => K(n.cypher));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-BkR3uSy8.mjs").then((n) => K(n.cython));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-D309uH6_.mjs").then((n) => K(n.crystal));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-BZcgY6La.mjs").then((n) => K(n.d));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.dart));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-Cg9d_RX2.mjs").then((n) => K(n.diff));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-BmicwmnY.mjs").then((n) => K(n.dockerFile));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-CtLokQ-U.mjs").then((n) => K(n.dtd));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-QYeExnWK.mjs").then((n) => K(n.dylan));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "EBNF",
    load() {
      return import("./ebnf-DUPDuY4r.mjs").then((n) => K(n.ebnf));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-CiXN-g_D.mjs").then((n) => K(n.ecl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-CCKyeQKf.mjs").then((n) => K(n.clojure));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-yQhjl4T1.mjs").then((n) => K(n.eiffel));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-CNT9vbN0.mjs").then((n) => K(n.elm));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-CFOYdy9e.mjs").then((n) => K(n.erlang));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Esper",
    load() {
      return import("./sql-CfG5lQ3l.mjs").then((n) => K(n.esper));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-CYi8BYN3.mjs").then((n) => K(n.factor));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "FCL",
    load() {
      return import("./fcl-CPC2WYrI.mjs").then((n) => K(n.fcl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-BmxRyE9S.mjs").then((n) => K(n.forth));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-9bvPyrOW.mjs").then((n) => K(n.fortran));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-BSnXJBGA.mjs").then((n) => K(n.fSharp));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-cpmYfFX2.mjs").then((n) => K(n.gas));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-CJuwpceU.mjs").then((n) => K(n.gherkin));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-DZeT_VM-.mjs").then((n) => K(n.groovy));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-Bvt3Qq1t.mjs").then((n) => K(n.haskell));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-70NVW1pR.mjs").then((n) => K(n.haxe));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-70NVW1pR.mjs").then((n) => K(n.hxml));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "HTTP",
    load() {
      return import("./http-D9LttvKF.mjs").then((n) => K(n.http));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-B6TRFYjl.mjs").then((n) => K(n.idl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-C2yteZeJ.mjs").then((n) => K(n.jsonld));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-DnB6dQmV.mjs").then((n) => K(n.jinja2));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-DpvXAuO6.mjs").then((n) => K(n.julia));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.kotlin));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-CanGTf8u.mjs").then((n) => K(n.liveScript));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-XplVlWi_.mjs").then((n) => K(n.lua));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-CFBPAOaF.mjs").then((n) => K(n.mirc));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-jaRHnSxC.mjs").then((n) => K(n.mathematica));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-vUgVs--1.mjs").then((n) => K(n.modelica));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-CQoS1kWX.mjs").then((n) => K(n.mumps));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-BctzC1hL.mjs").then((n) => K(n.mbox));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-zDPm3Z74.mjs").then((n) => K(n.nginx));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-DYWPgAyk.mjs").then((n) => K(n.nsis));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-CsNjv2QF.mjs").then((n) => K(n.ntriples));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.objectiveC));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.objectiveCpp));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-BSnXJBGA.mjs").then((n) => K(n.oCaml));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-C8PmmSRH.mjs").then((n) => K(n.octave));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-Ce8aN8oE.mjs").then((n) => K(n.oz));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-De0D6mP7.mjs").then((n) => K(n.pascal));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-B4bSCe1C.mjs").then((n) => K(n.perl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-D24Z8EXi.mjs").then((n) => K(n.pig));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-DkYVfTzP.mjs").then((n) => K(n.powerShell));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-Dn9wna3M.mjs").then((n) => K(n.properties));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-BPIjwpzm.mjs").then((n) => K(n.protobuf));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-DNXUX8Xe.mjs").then((n) => K(n.pug));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-nyd4dhjf.mjs").then((n) => K(n.puppet));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-DyHZGnqm.mjs").then((n) => K(n.q));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-LKEuhEGI.mjs").then((n) => K(n.r));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-IznJm2Xc.mjs").then((n) => K(n.rpmChanges));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-IznJm2Xc.mjs").then((n) => K(n.rpmSpec));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-CcYfvIk6.mjs").then((n) => K(n.ruby));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-7E8yHoCW.mjs").then((n) => K(n.sas));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.scala));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-DjibxsNh.mjs").then((n) => K(n.scheme));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-C0C2sNA_.mjs").then((n) => K(n.shell));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-Bwz7vjP5.mjs").then((n) => K(n.sieve));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-Bhddl2pB.mjs").then((n) => K(n.smalltalk));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Solr",
    load() {
      return import("./solr-BNlsLglM.mjs").then((n) => K(n.solr));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-BSnXJBGA.mjs").then((n) => K(n.sml));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-FarWu_Gb.mjs").then((n) => K(n.sparql));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-C-cy4P5N.mjs").then((n) => K(n.spreadsheet));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => K(n.squirrel));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-CAdqWld3.mjs").then((n) => K(n.stylus));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-DSxqR9R6.mjs").then((n) => K(n.swift));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "sTeX",
    load() {
      return import("./stex-Du4h4KAU.mjs").then((n) => K(n.stex));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-Du4h4KAU.mjs").then((n) => K(n.stex));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-CiS1jyi5.mjs").then((n) => K(n.verilog));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-xfoLljhY.mjs").then((n) => K(n.tcl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-D1AWE-pc.mjs").then((n) => K(n.textile));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-5wqsXtSk.mjs").then((n) => K(n.tiddlyWiki));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-__Kn3CeS.mjs").then((n) => K(n.tiki));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-DWAmxCjl.mjs").then((n) => K(n.toml));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-D2UO-fKf.mjs").then((n) => K(n.troff));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-Bsa4sfRm.mjs").then((n) => K(n.ttcn));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-Bac_acMi.mjs").then((n) => K(n.ttcnCfg));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-xwJUxoPV.mjs").then((n) => K(n.turtle));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-CjfDENEo.mjs").then((n) => K(n.webIDL));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-c2kQGd6-.mjs").then((n) => K(n.vb));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-1f_Dhg5H.mjs").then((n) => K(n.vbScript));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-DJd0pTTC.mjs").then((n) => K(n.velocity));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-CiS1jyi5.mjs").then((n) => K(n.verilog));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-T9HkrbI2.mjs").then((n) => K(n.vhdl));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-BUQdORAS.mjs").then((n) => K(n.xQuery));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-C0absKBh.mjs").then((n) => K(n.yacas));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-Pki2zAjW.mjs").then((n) => K(n.z80));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-Cpl0NYLN.mjs").then((n) => K(n.mscgen));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "XÃ¹",
    extensions: ["xu"],
    load() {
      return import("./mscgen-Cpl0NYLN.mjs").then((n) => K(n.xu));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-Cpl0NYLN.mjs").then((n) => K(n.msgenny));
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./index-BAu9nf-3.mjs").then((n) => n.vue());
    }
  }),
  /* @__PURE__ */ H.of({
    name: "Angular Template",
    load() {
      return import("./index-7CGUz7HD.mjs").then((n) => n.angular());
    }
  })
], X_ = "#e5c07b", iw = "#e06c75", Z_ = "#56b6c2", Q_ = "#ffffff", vp = "#abb2bf", wy = "#7d8799", eF = "#61afef", tF = "#98c379", sw = "#d19a66", nF = "#c678dd", rF = "#21252b", ow = "#2c313a", lw = "#282c34", Zg = "#353a42", iF = "#3E4451", aw = "#528bff", sF = /* @__PURE__ */ de.theme({
  "&": {
    color: vp,
    backgroundColor: lw
  },
  ".cm-content": {
    caretColor: aw
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: aw },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: iF },
  ".cm-panels": { backgroundColor: rF, color: vp },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: lw,
    color: wy,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: ow
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: Zg
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Zg,
    borderBottomColor: Zg
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: ow,
      color: vp
    }
  }
}, { dark: !0 }), oF = /* @__PURE__ */ Rd.define([
  {
    tag: j.keyword,
    color: nF
  },
  {
    tag: [j.name, j.deleted, j.character, j.propertyName, j.macroName],
    color: iw
  },
  {
    tag: [/* @__PURE__ */ j.function(j.variableName), j.labelName],
    color: eF
  },
  {
    tag: [j.color, /* @__PURE__ */ j.constant(j.name), /* @__PURE__ */ j.standard(j.name)],
    color: sw
  },
  {
    tag: [/* @__PURE__ */ j.definition(j.name), j.separator],
    color: vp
  },
  {
    tag: [j.typeName, j.className, j.number, j.changed, j.annotation, j.modifier, j.self, j.namespace],
    color: X_
  },
  {
    tag: [j.operator, j.operatorKeyword, j.url, j.escape, j.regexp, j.link, /* @__PURE__ */ j.special(j.string)],
    color: Z_
  },
  {
    tag: [j.meta, j.comment],
    color: wy
  },
  {
    tag: j.strong,
    fontWeight: "bold"
  },
  {
    tag: j.emphasis,
    fontStyle: "italic"
  },
  {
    tag: j.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: j.link,
    color: wy,
    textDecoration: "underline"
  },
  {
    tag: j.heading,
    fontWeight: "bold",
    color: iw
  },
  {
    tag: [j.atom, j.bool, /* @__PURE__ */ j.special(j.variableName)],
    color: sw
  },
  {
    tag: [j.processingInstruction, j.string, j.inserted],
    color: tF
  },
  {
    tag: j.invalid,
    color: Q_
  }
]), lF = [sF, /* @__PURE__ */ OC(oF)];
function hn(n) {
  this.content = n;
}
hn.prototype = {
  constructor: hn,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) â†’ ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) â†’ OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
    return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new hn(s);
  },
  // :: (string) â†’ OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new hn(t);
  },
  // :: (string, any) â†’ OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new hn([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) â†’ OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new hn(t);
  },
  // :: (string, string, any) â†’ OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(n);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new hn(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) â†’ OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = hn.from(n), n.size ? new hn(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) â†’ OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = hn.from(n), n.size ? new hn(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) â†’ OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = hn.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () â†’ Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
hn.from = function(n) {
  if (n instanceof hn) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new hn(e);
};
function _C(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), s = e.child(r);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let o = _C(i.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function FC(n, e, t, r) {
  for (let i = n.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: r };
    let o = n.child(--i), l = e.child(--s), a = o.nodeSize;
    if (o == l) {
      t -= a, r -= a;
      continue;
    }
    if (!o.sameMarkup(l))
      return { a: t, b: r };
    if (o.isText && o.text != l.text) {
      let c = 0, u = Math.min(o.text.length, l.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == l.text[l.text.length - c - 1]; )
        c++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || l.content.size) {
      let c = FC(o.content, l.content, t - 1, r - 1);
      if (c)
        return c;
    }
    t -= a, r -= a;
  }
}
class Y {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, s) {
    for (let o = 0, l = 0; l < t; o++) {
      let a = this.content[o], c = l + a.nodeSize;
      if (c > e && r(a, i + l, s || null, o) !== !1 && a.content.size) {
        let u = l + 1;
        a.nodesBetween(Math.max(0, e - u), Math.min(a.content.size, t - u), r, i + u);
      }
      l = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (l, a) => {
      let c = l.isText ? l.text.slice(Math.max(e, a) - a, t - a) : l.isLeaf ? i ? typeof i == "function" ? i(l) : i : l.type.spec.leafText ? l.type.spec.leafText(l) : "" : "";
      l.isBlock && (l.isLeaf && c || l.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new Y(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let l = this.content[s], a = o + l.nodeSize;
        a > e && ((o < e || a > t) && (l.isText ? l = l.cut(Math.max(0, e - o), Math.min(l.text.length, t - o)) : l = l.cut(Math.max(0, e - o - 1), Math.min(l.content.size, t - o - 1))), r.push(l), i += l.nodeSize), o = a;
      }
    return new Y(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? Y.empty : e == 0 && t == this.content.length ? this : new Y(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new Y(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new Y([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new Y(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return _C(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return FC(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return D0(0, e);
    if (e == this.size)
      return D0(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t), s = r + i.nodeSize;
      if (s >= e)
        return s == e ? D0(t + 1, s) : D0(t, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return Y.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Y(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return Y.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new Y(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return Y.empty;
    if (e instanceof Y)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new Y([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Y.empty = new Y([], 0);
const Qg = { index: 0, offset: 0 };
function D0(n, e) {
  return Qg.index = n, Qg.offset = e, Qg;
}
function Cm(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!Cm(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !Cm(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
class $e {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Cm(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = r.create(t.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return $e.none;
    if (e instanceof $e)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
}
$e.none = [];
class Mm extends Error {
}
let ue = class $a {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmentâ€”i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = $C(this.content, e + this.openStart, t);
    return r && new $a(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new $a(HC(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return $a.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new $a(Y.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new $a(e, r, i);
  }
};
ue.empty = new ue(Y.empty, 0, 0);
function HC(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: l } = n.findIndex(t);
  if (i == e || s.isText) {
    if (l != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, s.copy(HC(s.content, e - i - 1, t - i - 1)));
}
function $C(n, e, t, r) {
  let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let l = $C(o.content, e - s - 1, t, o);
  return l && n.replaceChild(i, o.copy(l));
}
function aF(n, e, t) {
  if (t.openStart > n.depth)
    throw new Mm("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new Mm("Inconsistent open depths");
  return VC(n, e, t, 0);
}
function VC(n, e, t, r) {
  let i = n.index(r), s = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = VC(n, e, t, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, l = o.content;
      return Xl(o, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: o, end: l } = cF(t, n);
      return Xl(s, WC(n, o, l, e, r));
    }
  else return Xl(s, Tm(n, e, r));
}
function qC(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new Mm("Cannot join " + e.type.name + " onto " + n.type.name);
}
function xy(n, e, t) {
  let r = n.node(t);
  return qC(r, e.node(t)), r;
}
function Jl(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function Yh(n, e, t, r) {
  let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (Jl(n.nodeAfter, r), s++));
  for (let l = s; l < o; l++)
    Jl(i.child(l), r);
  e && e.depth == t && e.textOffset && Jl(e.nodeBefore, r);
}
function Xl(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function WC(n, e, t, r, i) {
  let s = n.depth > i && xy(n, e, i + 1), o = r.depth > i && xy(t, r, i + 1), l = [];
  return Yh(null, n, i, l), s && o && e.index(i) == t.index(i) ? (qC(s, o), Jl(Xl(s, WC(n, e, t, r, i + 1)), l)) : (s && Jl(Xl(s, Tm(n, e, i + 1)), l), Yh(e, t, i, l), o && Jl(Xl(o, Tm(t, r, i + 1)), l)), Yh(r, null, i, l), new Y(l);
}
function Tm(n, e, t) {
  let r = [];
  if (Yh(null, n, t, r), n.depth > t) {
    let i = xy(n, e, t + 1);
    Jl(Xl(i, Tm(n, e, t + 1)), r);
  }
  return Yh(e, null, t, r), new Y(r);
}
function cF(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(Y.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class Df {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parentâ€”text nodes are â€˜flatâ€™ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return $e.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let l = r;
      r = i, i = l;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new jC(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, s = t;
    for (let o = e; ; ) {
      let { index: l, offset: a } = o.content.findIndex(s), c = s - a;
      if (r.push(o, l, i + a), !c || (o = o.child(l), o.isText))
        break;
      s = c - 1, i += a + 1;
    }
    return new Df(t, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = cw.get(e);
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == t)
          return o;
      }
    else
      cw.set(e, r = new uF());
    let i = r.elts[r.i] = Df.resolve(e, t);
    return r.i = (r.i + 1) % hF, i;
  }
}
class uF {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const hF = 12, cw = /* @__PURE__ */ new WeakMap();
class jC {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const fF = /* @__PURE__ */ Object.create(null);
let Vs = class ky {
  /**
  @internal
  */
  constructor(e, t, r, i = $e.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || Y.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && Cm(this.attrs, t || e.defaultAttrs || fF) && $e.sameSet(this.marks, r || $e.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new ky(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new ky(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return ue.empty;
    let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), l = i.start(o), c = i.node(o).content.cut(i.pos - l, s.pos - l);
    return new ue(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return aF(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Df.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Df.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), UC(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = Y.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), l = o && o.matchFragment(this.content, t);
    if (!l || !l.validEnd)
      return !1;
    for (let a = i; a < s; a++)
      if (!this.type.allowsMarks(r.child(a).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = $e.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!$e.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = Y.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r);
    return s.type.checkAttrs(s.attrs), s;
  }
};
Vs.prototype.text = void 0;
let dF = class Sy extends Vs {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : UC(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Sy(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Sy(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function UC(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class da {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new pF(e, t);
    if (r.next == null)
      return da.empty;
    let i = GC(r);
    r.next && r.err("Unexpected trailing text");
    let s = xF(wF(i));
    return kF(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let s = t; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function s(o, l) {
      let a = o.matchFragment(e, r);
      if (a && (!t || a.validEnd))
        return Y.from(l.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: h } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let f = s(h, l.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let l = i; l.type; l = l.via)
          o.push(l.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: l, next: a } = s.next[o];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || a.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_â€‹th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
da.empty = new da(!0);
class pF {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function GC(n) {
  let e = [];
  do
    e.push(mF(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function mF(n) {
  let e = [];
  do
    e.push(gF(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function gF(n) {
  let e = vF(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = yF(n, e);
    else
      break;
  return e;
}
function uw(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function yF(n, e) {
  let t = uw(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = uw(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function bF(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let s in t) {
    let o = t[s];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function vF(n) {
  if (n.eat("(")) {
    let e = GC(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = bF(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function wF(n) {
  let e = [[]];
  return i(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, l, a) {
    let c = { term: a, to: l };
    return e[o].push(c), c;
  }
  function i(o, l) {
    o.forEach((a) => a.to = l);
  }
  function s(o, l) {
    if (o.type == "choice")
      return o.exprs.reduce((a, c) => a.concat(s(c, l)), []);
    if (o.type == "seq")
      for (let a = 0; ; a++) {
        let c = s(o.exprs[a], l);
        if (a == o.exprs.length - 1)
          return c;
        i(c, l = t());
      }
    else if (o.type == "star") {
      let a = t();
      return r(l, a), i(s(o.expr, a), a), [r(a)];
    } else if (o.type == "plus") {
      let a = t();
      return i(s(o.expr, l), a), i(s(o.expr, a), a), [r(a)];
    } else {
      if (o.type == "opt")
        return [r(l)].concat(s(o.expr, l));
      if (o.type == "range") {
        let a = l;
        for (let c = 0; c < o.min; c++) {
          let u = t();
          i(s(o.expr, a), u), a = u;
        }
        if (o.max == -1)
          i(s(o.expr, a), a);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t();
            r(a, u), i(s(o.expr, a), u), a = u;
          }
        return [r(a)];
      } else {
        if (o.type == "name")
          return [r(l, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function KC(n, e) {
  return e - n;
}
function hw(n, e) {
  let t = [];
  return r(e), t.sort(KC);
  function r(i) {
    let s = n[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    t.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: l, to: a } = s[o];
      !l && t.indexOf(a) == -1 && r(a);
    }
  }
}
function xF(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(hw(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: l, to: a }) => {
        if (!l)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == l && (c = i[u][1]);
        hw(n, a).forEach((u) => {
          c || i.push([l, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[r.join(",")] = new da(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let l = i[o][1].sort(KC);
      s.next.push({ type: i[o][0], next: e[l.join(",")] || t(l) });
    }
    return s;
  }
}
function kF(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], s = !i.validEnd, o = [];
    for (let l = 0; l < i.next.length; l++) {
      let { type: a, next: c } = i.next[l];
      o.push(a.name), s && !(a.isText || a.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function YC(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function JC(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let s = n[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function XC(n, e, t, r) {
  for (let i in e)
    if (!(i in n))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in n) {
    let s = n[i];
    s.validate && s.validate(e[i]);
  }
}
function ZC(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new CF(n, r, e[r]);
  return t;
}
let Am = class QC {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = ZC(e, r.attrs), this.defaultAttrs = YC(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == da.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : JC(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Vs(this, this.computeAttrs(e), Y.from(t), $e.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = Y.from(t), this.checkContent(t), new Vs(this, this.computeAttrs(e), t, $e.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = Y.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(Y.empty, !0);
    return s ? new Vs(this, e, t.append(s), $e.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    XC(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : $e.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new QC(s, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function SF(n, e, t) {
  let r = t.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`);
  };
}
class CF {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? SF(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class w1 {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = ZC(e, i.attrs), this.excluded = null;
    let s = YC(this.attrs);
    this.instance = s ? new $e(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new $e(this, JC(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new w1(s, i++, t, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    XC(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class eM {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = hn.from(e.nodes), t.marks = hn.from(e.marks || {}), this.nodes = Am.compile(this.spec.nodes, this), this.marks = w1.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", l = s.spec.marks;
      if (s.contentMatch = r[o] || (r[o] = da.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = l == "_" ? null : l ? fw(this, l.split(" ")) : l == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : fw(this, o.split(" "));
    }
    this.nodeFromJSON = (i) => Vs.fromJSON(this, i), this.markFromJSON = (i) => $e.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Am) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new dF(r, r.defaultAttrs, e, $e.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function fw(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = n.marks[i], o = s;
    if (s)
      t.push(s);
    else
      for (let l in n.marks) {
        let a = n.marks[l];
        (i == "_" || a.spec.group && a.spec.group.split(" ").indexOf(i) > -1) && t.push(o = a);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function MF(n) {
  return n.tag != null;
}
function TF(n) {
  return n.style != null;
}
class pa {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((i) => {
      if (MF(i))
        this.tags.push(i);
      else if (TF(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new pw(this, t, !1);
    return r.addAll(e, $e.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new pw(this, t, !0);
    return r.addAll(e, $e.none, t.from, t.to), ue.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (EF(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], l = o.style;
      if (!(l.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let a = o.getAttrs(t);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let l = t[o];
        if ((l.priority == null ? 50 : l.priority) < s)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = mw(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = mw(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new pa(e, pa.schemaRules(e)));
  }
}
const tM = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, AF = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, nM = { ol: !0, ul: !0 }, Nf = 1, Cy = 2, Jh = 4;
function dw(n, e, t) {
  return e != null ? (e ? Nf : 0) | (e === "full" ? Cy : 0) : n && n.whitespace == "pre" ? Nf | Cy : t & ~Jh;
}
class N0 {
  constructor(e, t, r, i, s, o) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = $e.none, this.match = s || (o & Jh ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(Y.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Nf)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = Y.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(Y.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !tM.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class pw {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, s, o = dw(null, t.preserveWhitespace, 0) | (r ? Jh : 0);
    i ? s = new N0(i.type, i.attrs, $e.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new N0(null, null, $e.none, !0, null, o) : s = new N0(e.schema.topNodeType, null, $e.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, s = i.options & Cy ? "full" : this.localPreserveWS || (i.options & Nf) > 0;
    if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s)
        s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], l = e.previousSibling;
        (!o || l && l.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let i = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), l;
    nM.hasOwnProperty(o) && this.parser.normalizeLists && OF(e);
    let a = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r));
    e: if (a ? a.ignore : AF.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!a || a.skip || a.closeParent) {
      a && a.closeParent ? this.open = Math.max(0, this.open - 1) : a && a.skip.nodeType && (e = a.skip);
      let c, u = this.needsBlock;
      if (tM.hasOwnProperty(o))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let h = a && a.skip ? t : this.readStyles(e, t);
      h && this.addAll(e, h), c && this.sync(s), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, t);
      c && this.addElementByRule(e, a, c, a.consuming === !1 ? l : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o)
          for (let l = void 0; ; ) {
            let a = this.parser.matchStyle(s, o, this, l);
            if (!a)
              break;
            if (a.ignore)
              return null;
            if (a.clearMark ? t = t.filter((c) => !a.clearMark(c)) : t = t.concat(this.parser.schema.marks[a.mark].create(a.attrs)), a.consuming === !1)
              l = a;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, i) {
    let s, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let a = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        a && (s = !0, r = a);
      }
    else {
      let a = this.parser.schema.marks[t.mark];
      r = r.concat(a.create(t.attrs));
    }
    let l = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((a) => this.insertNode(a, r, !1));
    else {
      let a = e;
      typeof t.contentElement == "string" ? a = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? a = t.contentElement(e) : t.contentElement && (a = t.contentElement), this.findAround(e, a, !0), this.addAll(a, r), this.findAround(e, a, !1);
    }
    s && this.sync(l) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, i) {
    let s = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, l = i == null ? null : e.childNodes[i]; o != l; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let i, s;
    for (let o = this.open, l = 0; o >= 0; o--) {
      let a = this.nodes[o], c = a.findWrapping(e);
      if (c && (!i || i.length > c.length + l) && (i = c, s = a, !c.length))
        break;
      if (a.solid) {
        if (r)
          break;
        l += 2;
      }
    }
    if (!i)
      return null;
    this.sync(s);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (t = this.enterInner(s, null, t));
    }
    let i = this.findPlace(e, t, r);
    if (i) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let o = $e.none;
      for (let l of i.concat(e.marks))
        (s.type ? s.type.allowsMarkType(l.type) : gw(l.type, e.type)) && (o = l.addToSet(o));
      return s.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, i) {
    let s = this.findPlace(e.create(t), r, !1);
    return s && (s = this.enterInner(e, t, r, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, t, r, i = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let l = dw(e, s, o.options);
    o.options & Jh && o.content.length == 0 && (l |= Jh);
    let a = $e.none;
    return r = r.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : gw(c.type, e)) ? (a = c.addToSet(a), !1) : !0), this.nodes.push(new N0(e, t, a, i, null, l)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= Nf);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (l, a) => {
      for (; l >= 0; l--) {
        let c = t[l];
        if (c == "") {
          if (l == t.length - 1 || l == 0)
            continue;
          for (; a >= s; a--)
            if (o(l - 1, a))
              return !0;
          return !1;
        } else {
          let u = a > 0 || a == 0 && i ? this.nodes[a].type : r && a >= s ? r.node(a - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          a--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function OF(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && nM.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function EF(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function mw(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function gw(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let s = [], o = (l) => {
      s.push(l);
      for (let a = 0; a < l.edgeCount; a++) {
        let { type: c, next: u } = l.edge(a);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class Sa {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = e2(t).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let l = 0, a = 0;
        for (; l < s.length && a < o.marks.length; ) {
          let c = o.marks[a];
          if (!this.marks[c.type.name]) {
            a++;
            continue;
          }
          if (!c.eq(s[l][0]) || c.type.spec.spanning === !1)
            break;
          l++, a++;
        }
        for (; l < s.length; )
          i = s.pop()[1];
        for (; a < o.marks.length; ) {
          let c = o.marks[a++], u = this.serializeMark(c, o.isInline, t);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = wp(e2(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && wp(e2(r), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, i) {
    return wp(e, t, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Sa(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = yw(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return yw(e.marks);
  }
}
function yw(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function e2(n) {
  return n.document || window.document;
}
const bw = /* @__PURE__ */ new WeakMap();
function IF(n) {
  let e = bw.get(n);
  return e === void 0 && bw.set(n, e = DF(n)), e;
}
function DF(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            t(r[i]);
      else
        for (let i in r)
          t(r[i]);
  }
  return t(n), e;
}
function wp(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (s = IF(r)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
  let l, a = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let h in c)
      if (c[h] != null) {
        let f = h.indexOf(" ");
        f > 0 ? a.setAttributeNS(h.slice(0, f), h.slice(f + 1), c[h]) : h == "style" && a.style ? a.style.cssText = c[h] : a.setAttribute(h, c[h]);
      }
  }
  for (let h = u; h < e.length; h++) {
    let f = e[h];
    if (f === 0) {
      if (h < e.length - 1 || h > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: a, contentDOM: a };
    } else {
      let { dom: d, contentDOM: p } = wp(n, f, t, r);
      if (a.appendChild(d), p) {
        if (l)
          throw new RangeError("Multiple content holes");
        l = p;
      }
    }
  }
  return { dom: a, contentDOM: l };
}
const rM = 65535, iM = Math.pow(2, 16);
function NF(n, e) {
  return n + e * iM;
}
function vw(n) {
  return n & rM;
}
function RF(n) {
  return (n - (n & rM)) / iM;
}
const sM = 1, oM = 2, xp = 4, lM = 8;
class My {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & lM) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (sM | xp)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (oM | xp)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & xp) > 0;
  }
}
class Cr {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Cr.empty)
      return Cr.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = vw(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + RF(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? i : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = this.ranges[l + o], h = a + c;
      if (e <= h) {
        let f = c ? e == a ? -1 : e == h ? 1 : t : t, d = a + i + (f < 0 ? 0 : u);
        if (r)
          return d;
        let p = e == (t < 0 ? a : h) ? null : NF(l / 3, e - a), m = e == a ? oM : e == h ? sM : xp;
        return (t < 0 ? e != a : e != h) && (m |= lM), new My(d, m, p);
      }
      i += u - c;
    }
    return r ? e + i : new My(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = vw(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let a = this.ranges[l] - (this.inverted ? r : 0);
      if (a > e)
        break;
      let c = this.ranges[l + s], u = a + c;
      if (e <= u && l == i * 3)
        return !0;
      r += this.ranges[l + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], l = o - (this.inverted ? s : 0), a = o + (this.inverted ? 0 : s), c = this.ranges[i + t], u = this.ranges[i + r];
      e(l, l + c, a, a + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Cr(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Cr.empty : new Cr(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Cr.empty = new Cr([]);
class Rf {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, i = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new Rf(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Rf();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this._maps[s], l = o.mapResult(e, t);
      if (l.recover != null) {
        let a = this.getMirror(s);
        if (a != null && a > s && a < this.to) {
          s = a, e = this._maps[a].recover(l.recover);
          continue;
        }
      }
      i |= l.delInfo, e = l.pos;
    }
    return r ? e : new My(e, i, null);
  }
}
const t2 = /* @__PURE__ */ Object.create(null);
class An {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Cr.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = t2[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in t2)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return t2[e] = t, t.prototype.jsonID = e, t;
  }
}
class qt {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new qt(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new qt(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return qt.ok(e.replace(t, r, i));
    } catch (s) {
      if (s instanceof Mm)
        return qt.fail(s.message);
      throw s;
    }
  }
}
function w3(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i);
    s.content.size && (s = s.copy(w3(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
  }
  return Y.fromArray(r);
}
class Bs extends An {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new ue(w3(t.content, (o, l) => !o.isAtom || !l.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return qt.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new Ki(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Bs(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Bs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Bs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Bs(t.from, t.to, e.markFromJSON(t.mark));
  }
}
An.jsonID("addMark", Bs);
class Ki extends An {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new ue(w3(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return qt.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Bs(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Ki(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ki && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ki(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Ki(t.from, t.to, e.markFromJSON(t.mark));
  }
}
An.jsonID("removeMark", Ki);
class Po extends An {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return qt.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return qt.fromReplace(e, this.pos, this.pos + 1, new ue(Y.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new Po(this.pos, t.marks[i]);
        return new Po(this.pos, this.mark);
      }
    }
    return new ma(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Po(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Po(t.pos, e.markFromJSON(t.mark));
  }
}
An.jsonID("addNodeMark", Po);
class ma extends An {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return qt.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return qt.fromReplace(e, this.pos, this.pos + 1, new ue(Y.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Po(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new ma(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new ma(t.pos, e.markFromJSON(t.mark));
  }
}
An.jsonID("removeNodeMark", ma);
class tn extends An {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`â€”the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Ty(e, this.from, this.to) ? qt.fail("Structure replace would overwrite content") : qt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Cr([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new tn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new tn(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof tn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? ue.empty : new ue(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new tn(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? ue.empty : new ue(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new tn(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new tn(t.from, t.to, ue.fromJSON(e, t.slice), !!t.structure);
  }
}
An.jsonID("replace", tn);
class Tn extends An {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, s, o, l = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = l;
  }
  apply(e) {
    if (this.structure && (Ty(e, this.from, this.gapFrom) || Ty(e, this.gapTo, this.to)))
      return qt.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return qt.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? qt.fromReplace(e, this.from, this.to, r) : qt.fail("Content does not fit in gap");
  }
  getMap() {
    return new Cr([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Tn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new Tn(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Tn(t.from, t.to, t.gapFrom, t.gapTo, ue.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
An.jsonID("replaceAround", Tn);
function Ty(n, e, t) {
  let r = n.resolve(e), i = t - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function PF(n, e, t, r) {
  let i = [], s = [], o, l;
  n.doc.nodesBetween(e, t, (a, c, u) => {
    if (!a.isInline)
      return;
    let h = a.marks;
    if (!r.isInSet(h) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), d = Math.min(c + a.nodeSize, t), p = r.addToSet(h);
      for (let m = 0; m < h.length; m++)
        h[m].isInSet(p) || (o && o.to == f && o.mark.eq(h[m]) ? o.to = d : i.push(o = new Ki(f, d, h[m])));
      l && l.to == f ? l.to = d : s.push(l = new Bs(f, d, r));
    }
  }), i.forEach((a) => n.step(a)), s.forEach((a) => n.step(a));
}
function LF(n, e, t, r) {
  let i = [], s = 0;
  n.doc.nodesBetween(e, t, (o, l) => {
    if (!o.isInline)
      return;
    s++;
    let a = null;
    if (r instanceof w1) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (a || (a = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(o.marks) && (a = [r]) : a = o.marks;
    if (a && a.length) {
      let c = Math.min(l + o.nodeSize, t);
      for (let u = 0; u < a.length; u++) {
        let h = a[u], f;
        for (let d = 0; d < i.length; d++) {
          let p = i[d];
          p.step == s - 1 && h.eq(i[d].style) && (f = p);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: h, from: Math.max(l, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => n.step(new Ki(o.from, o.to, o.style)));
}
function x3(n, e, t, r = t.contentMatch, i = !0) {
  let s = n.doc.nodeAt(e), o = [], l = e + 1;
  for (let a = 0; a < s.childCount; a++) {
    let c = s.child(a), u = l + c.nodeSize, h = r.matchType(c.type);
    if (!h)
      o.push(new tn(l, u, ue.empty));
    else {
      r = h;
      for (let f = 0; f < c.marks.length; f++)
        t.allowsMarkType(c.marks[f].type) || n.step(new Ki(l, u, c.marks[f]));
      if (i && c.isText && t.whitespace != "pre") {
        let f, d = /\r?\n|\r/g, p;
        for (; f = d.exec(c.text); )
          p || (p = new ue(Y.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new tn(l + f.index, l + f.index + f[0].length, p));
      }
    }
    l = u;
  }
  if (!r.validEnd) {
    let a = r.fillBefore(Y.empty, !0);
    n.replace(l, l, new ue(a, 0, 0));
  }
  for (let a = o.length - 1; a >= 0; a--)
    n.step(o[a]);
}
function BF(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function x1(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(s, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !BF(i, s, o))
      break;
  }
  return null;
}
function zF(n, e, t) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), l = i.after(s + 1), a = o, c = l, u = Y.empty, h = 0;
  for (let p = s, m = !1; p > t; p--)
    m || r.index(p) > 0 ? (m = !0, u = Y.from(r.node(p).copy(u)), h++) : a--;
  let f = Y.empty, d = 0;
  for (let p = s, m = !1; p > t; p--)
    m || i.after(p + 1) < i.end(p) ? (m = !0, f = Y.from(i.node(p).copy(f)), d++) : c++;
  n.step(new Tn(a, c, o, l, new ue(u.append(f), h, d), u.size - h, !0));
}
function k3(n, e, t = null, r = n) {
  let i = _F(n, e), s = i && FF(r, e);
  return s ? i.map(ww).concat({ type: e, attrs: t }).concat(s.map(ww)) : null;
}
function ww(n) {
  return { type: n, attrs: null };
}
function _F(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(r, i, o) ? s : null;
}
function FF(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let a = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = r; a && c < i; c++)
    a = a.matchType(t.child(c).type);
  return !a || !a.validEnd ? null : o;
}
function HF(n, e, t) {
  let r = Y.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let l = t[o].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = Y.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, s = e.end;
  n.step(new Tn(i, s, i, s, new ue(r, 0, 0), t.length, !0));
}
function $F(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, l) => {
    let a = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, a) && VF(n.doc, n.mapping.slice(s).map(l), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let d = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        d && !p ? c = !1 : !d && p && (c = !0);
      }
      c === !1 && cM(n, o, l, s), x3(n, n.mapping.slice(s).map(l, 1), r, void 0, c === null);
      let u = n.mapping.slice(s), h = u.map(l, 1), f = u.map(l + o.nodeSize, 1);
      return n.step(new Tn(h, f, h + 1, f - 1, new ue(Y.from(r.create(a, null, o.marks)), 0, 0), 1, !0)), c === !0 && aM(n, o, l, s), !1;
    }
  });
}
function aM(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, l = /\r?\n|\r/g;
      for (; o = l.exec(i.text); ) {
        let a = n.mapping.slice(r).map(t + 1 + s + o.index);
        n.replaceWith(a, a + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function cM(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + s);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function VF(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function qF(n, e, t, r, i) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(r, null, i || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Tn(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new ue(Y.from(o), 0, 0), 1, !0));
}
function Xh(n, e, t = 1, r) {
  let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) {
    let h = i.node(c), f = i.index(c);
    if (h.type.spec.isolating)
      return !1;
    let d = h.content.cutByIndex(f, h.childCount), p = r && r[u + 1];
    p && (d = d.replaceChild(0, p.type.create(p.attrs)));
    let m = r && r[u] || h;
    if (!h.canReplace(f + 1, h.childCount) || !m.type.validContent(d))
      return !1;
  }
  let l = i.indexAfter(s), a = r && r[0];
  return i.node(s).canReplaceWith(l, l, a ? a.type : i.node(s + 1).type);
}
function WF(n, e, t = 1, r) {
  let i = n.doc.resolve(e), s = Y.empty, o = Y.empty;
  for (let l = i.depth, a = i.depth - t, c = t - 1; l > a; l--, c--) {
    s = Y.from(i.node(l).copy(s));
    let u = r && r[c];
    o = Y.from(u ? u.type.create(u.attrs, o) : i.node(l).copy(o));
  }
  n.step(new tn(e, e, new ue(s.append(o), t, t), !0));
}
function k1(n, e) {
  let t = n.resolve(e), r = t.index();
  return UF(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function jF(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function UF(n, e) {
  return !!(n && e && !n.isLeaf && jF(n, e));
}
function GF(n, e, t) {
  let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
  if (i && o.inlineContent) {
    let u = o.whitespace == "pre", h = !!o.contentMatch.matchType(i);
    u && !h ? r = !1 : !u && h && (r = !0);
  }
  let l = n.steps.length;
  if (r === !1) {
    let u = n.doc.resolve(e + t);
    cM(n, u.node(), u.before(), l);
  }
  o.inlineContent && x3(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null);
  let a = n.mapping.slice(l), c = a.map(e - t);
  if (n.step(new tn(c, a.map(e + t, -1), ue.empty, !0)), r === !0) {
    let u = n.doc.resolve(c);
    aM(n, u.node(), u.before(), n.steps.length);
  }
  return n;
}
function KF(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function YF(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let l = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, a = r.index(o) + (l > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(a, a, i);
      else {
        let h = c.contentMatchAt(a).findWrapping(i.firstChild.type);
        u = h && c.canReplaceWith(a, a, h[0]);
      }
      if (u)
        return l == 0 ? r.pos : l < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function S1(n, e, t = e, r = ue.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), s = n.resolve(t);
  return uM(i, s, r) ? new tn(e, t, r) : new JF(i, s, r).fit();
}
function uM(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class JF {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = Y.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = Y.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, l = i.depth;
    for (; o && l && s.childCount == 1; )
      s = s.firstChild.content, o--, l--;
    let a = new ue(s, o, l);
    return e > -1 ? new Tn(r.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || r.pos != this.$to.pos ? new tn(r.pos, i.pos, a) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = n2(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: a, match: c } = this.frontier[l], u, h = null;
          if (t == 1 && (o ? c.matchType(o.type) || (h = c.fillBefore(Y.from(o), !1)) : s && a.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, inject: h };
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: l, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = n2(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new ue(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = n2(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new ue(uh(e, t - 1, 1), t - 1, s ? t - 1 : r);
    } else
      this.unplaced = new ue(uh(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let m = 0; m < s.length; m++)
        this.openFrontierNode(s[m]);
    let o = this.unplaced, l = r ? r.content : o.content, a = o.openStart - e, c = 0, u = [], { match: h, type: f } = this.frontier[t];
    if (i) {
      for (let m = 0; m < i.childCount; m++)
        u.push(i.child(m));
      h = h.matchFragment(i);
    }
    let d = l.size + e - (o.content.size - o.openEnd);
    for (; c < l.childCount; ) {
      let m = l.child(c), g = h.matchType(m.type);
      if (!g)
        break;
      c++, (c > 1 || a == 0 || m.content.size) && (h = g, u.push(hM(m.mark(f.allowedMarks(m.marks)), c == 1 ? a : 0, c == l.childCount ? d : -1)));
    }
    let p = c == l.childCount;
    p || (d = -1), this.placed = hh(this.placed, t, Y.from(u)), this.frontier[t].match = h, p && d < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let m = 0, g = l; m < d; m++) {
      let b = g.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
    }
    this.unplaced = p ? e == 0 ? ue.empty : new ue(uh(o.content, e - 1, 1), e - 1, d < 0 ? o.openEnd : e - 1) : new ue(uh(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !r2(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = r2(e, t, i, r, s);
      if (o) {
        for (let l = t - 1; l >= 0; l--) {
          let { match: a, type: c } = this.frontier[l], u = r2(e, l, c, a, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = hh(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = hh(this.placed, this.depth, Y.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(Y.empty, !0);
    t.childCount && (this.placed = hh(this.placed, this.frontier.length, t));
  }
}
function uh(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(uh(n.firstChild.content, e - 1, t)));
}
function hh(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(hh(n.lastChild.content, e - 1, t)));
}
function n2(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function hM(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, hM(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(Y.empty, !0)))), n.copy(r);
}
function r2(n, e, t, r, i) {
  let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let l = r.fillBefore(s.content, !0, o);
  return l && !XF(t, s.content, o) ? l : null;
}
function XF(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function ZF(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function QF(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), s = n.doc.resolve(t);
  if (uM(i, s, r))
    return n.step(new tn(e, t, r));
  let o = dM(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let l = -(i.depth + 1);
  o.unshift(l);
  for (let f = i.depth, d = i.pos - 1; f > 0; f--, d--) {
    let p = i.node(f).type.spec;
    if (p.defining || p.definingAsContext || p.isolating)
      break;
    o.indexOf(f) > -1 ? l = f : i.before(f) == d && o.splice(1, 0, -f);
  }
  let a = o.indexOf(l), c = [], u = r.openStart;
  for (let f = r.content, d = 0; ; d++) {
    let p = f.firstChild;
    if (c.push(p), d == r.openStart)
      break;
    f = p.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let d = c[f], p = ZF(d.type);
    if (p && !d.sameMarkup(i.node(Math.abs(l) - 1)))
      u = f;
    else if (p || !d.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let d = (f + u + 1) % (r.openStart + 1), p = c[d];
    if (p)
      for (let m = 0; m < o.length; m++) {
        let g = o[(m + a) % o.length], b = !0;
        g < 0 && (b = !1, g = -g);
        let w = i.node(g - 1), k = i.index(g - 1);
        if (w.canReplaceWith(k, k, p.type, p.marks))
          return n.replace(i.before(g), b ? s.after(g) : t, new ue(fM(r.content, 0, r.openStart, d), d, r.openEnd));
      }
  }
  let h = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); f--) {
    let d = o[f];
    d < 0 || (e = i.before(d), t = s.after(d));
  }
}
function fM(n, e, t, r, i) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(fM(s.content, e + 1, t, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore(Y.empty, !0));
  }
  return n;
}
function eH(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = KF(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new ue(Y.from(r), 0, 0));
}
function tH(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), s = dM(r, i);
  for (let o = 0; o < s.length; o++) {
    let l = s[o], a = o == s.length - 1;
    if (a && l == 0 || r.node(l).type.contentMatch.validEnd)
      return n.delete(r.start(l), i.end(l));
    if (l > 0 && (a || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
      return n.delete(r.before(l), i.after(l));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function dM(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = n.start(i);
    if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class oc extends An {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return qt.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      r[s] = t.attrs[s];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return qt.fromReplace(e, this.pos, this.pos + 1, new ue(Y.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Cr.empty;
  }
  invert(e) {
    return new oc(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new oc(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new oc(t.pos, t.attr, t.value);
  }
}
An.jsonID("attr", oc);
class Pf extends An {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return qt.ok(r);
  }
  getMap() {
    return Cr.empty;
  }
  invert(e) {
    return new Pf(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new Pf(t.attr, t.value);
  }
}
An.jsonID("docAttr", Pf);
let Yc = class extends Error {
};
Yc = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
Yc.prototype = Object.create(Error.prototype);
Yc.prototype.constructor = Yc;
Yc.prototype.name = "TransformError";
class pM {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Rf();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new Yc(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = ue.empty) {
    let i = S1(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new ue(Y.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, ue.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return QF(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return eH(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return tH(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return zF(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return GF(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return HF(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return $F(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return qF(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new oc(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new Pf(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Po(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof $e)
      t.isInSet(r.marks) && this.step(new ma(e, t));
    else {
      let i = r.marks, s, o = [];
      for (; s = t.isInSet(i); )
        o.push(new ma(e, s)), i = s.removeFromSet(i);
      for (let l = o.length - 1; l >= 0; l--)
        this.step(o[l]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return WF(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return PF(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return LF(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return x3(this, e, t, r), this;
  }
}
const i2 = /* @__PURE__ */ Object.create(null);
class Pe {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new mM(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = ue.empty) {
    let r = t.content.lastChild, i = null;
    for (let l = 0; l < t.openEnd; l++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let l = 0; l < o.length; l++) {
      let { $from: a, $to: c } = o[l], u = e.mapping.slice(s);
      e.replaceRange(u.map(a.pos), u.map(c.pos), l ? ue.empty : t), l == 0 && Sw(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: l } = i[s], a = e.mapping.slice(r), c = a.map(o.pos), u = a.map(l.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), Sw(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new ge(e) : Va(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? Va(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : Va(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new or(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Va(e, e, 0, 0, 1) || new or(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Va(e, e, e.content.size, e.childCount, -1) || new or(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = i2[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in i2)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return i2[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ge.between(this.$anchor, this.$head).getBookmark();
  }
}
Pe.prototype.visible = !0;
class mM {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let xw = !1;
function kw(n) {
  !xw && !n.parent.inlineContent && (xw = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class ge extends Pe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    kw(e), kw(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return Pe.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new ge(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = ue.empty) {
    if (super.replace(e, t), t == ue.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ge && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new C1(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ge(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = Pe.findFrom(t, r, !0) || Pe.findFrom(t, -r, !0);
      if (s)
        t = s.$head;
      else
        return Pe.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (Pe.findFrom(e, -r, !0) || Pe.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new ge(e, t);
  }
}
Pe.jsonID("text", ge);
class C1 {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new C1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ge.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class ve extends Pe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return r ? Pe.near(s) : new ve(s);
  }
  content() {
    return new ue(Y.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof ve && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new S3(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new ve(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new ve(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
ve.prototype.visible = !1;
Pe.jsonID("node", ve);
class S3 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new C1(r, r) : new S3(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && ve.isSelectable(r) ? new ve(t) : Pe.near(t);
  }
}
class or extends Pe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = ue.empty) {
    if (t == ue.empty) {
      e.delete(0, e.doc.content.size);
      let r = Pe.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new or(e);
  }
  map(e) {
    return new or(e);
  }
  eq(e) {
    return e instanceof or;
  }
  getBookmark() {
    return nH;
  }
}
Pe.jsonID("all", or);
const nH = {
  map() {
    return this;
  },
  resolve(n) {
    return new or(n);
  }
};
function Va(n, e, t, r, i, s = !1) {
  if (e.inlineContent)
    return ge.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let l = e.child(o);
    if (l.isAtom) {
      if (!s && ve.isSelectable(l))
        return ve.create(n, t - (i < 0 ? l.nodeSize : 0));
    } else {
      let a = Va(n, l, t + i, i < 0 ? l.childCount : 0, i, s);
      if (a)
        return a;
    }
    t += l.nodeSize * i;
  }
  return null;
}
function Sw(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof tn || i instanceof Tn))
    return;
  let s = n.mapping.maps[r], o;
  s.forEach((l, a, c, u) => {
    o == null && (o = u);
  }), n.setSelection(Pe.near(n.doc.resolve(o), t));
}
const Cw = 1, R0 = 2, Mw = 4;
class rH extends pM {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | Cw) & ~R0, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & Cw) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= R0, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return $e.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & R0) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~R0, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || $e.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(Pe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= Mw, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & Mw) > 0;
  }
}
function Tw(n, e) {
  return !e || !n ? n : n.bind(e);
}
class fh {
  constructor(e, t, r) {
    this.name = e, this.init = Tw(t.init, r), this.apply = Tw(t.apply, r);
  }
}
const iH = [
  new fh("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new fh("selection", {
    init(n, e) {
      return n.selection || Pe.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new fh("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new fh("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class s2 {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = iH.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new fh(r.key, r.spec.state, r));
    });
  }
}
class Il {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let l = this.config.plugins[o];
        if (l.spec.appendTransaction) {
          let a = i ? i[o].n : 0, c = i ? i[o].state : this, u = a < t.length && l.spec.appendTransaction.call(l, a ? t.slice(a) : t, c, r);
          if (u && r.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), r = r.applyInner(u), s = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!s)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Il(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new rH(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new s2(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Il(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new s2(this.schema, e.plugins), r = t.fields, i = new Il(t);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new s2(e.schema, e.plugins), s = new Il(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = Vs.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = Pe.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let a = r[l], c = a.spec.state;
            if (a.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) {
              s[o.name] = c.fromJSON.call(a, e, t[l], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function gM(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = gM(i, e, {})), t[r] = i;
  }
  return t;
}
class xt {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && gM(e.props, this, this.props), this.key = e.key ? e.key.key : yM("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const o2 = /* @__PURE__ */ Object.create(null);
function yM(n) {
  return n in o2 ? n + "$" + ++o2[n] : (o2[n] = 0, n + "$");
}
class kt {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = yM(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
class ar {
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, t, r = {}) {
    this.match = e, this.match = e, this.handler = typeof t == "string" ? sH(t) : t, this.undoable = r.undoable !== !1, this.inCode = r.inCode || !1, this.inCodeMark = r.inCodeMark !== !1;
  }
}
function sH(n) {
  return function(e, t, r, i) {
    let s = n;
    if (t[1]) {
      let o = t[0].lastIndexOf(t[1]);
      s += t[0].slice(o + t[1].length), r += o;
      let l = r - i;
      l > 0 && (s = t[0].slice(o - l, o) + s, r = i);
    }
    return e.tr.insertText(s, r, i);
  };
}
const oH = (n, e) => {
  let t = n.plugins;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], s;
    if (i.spec.isInputRules && (s = i.getState(n))) {
      if (e) {
        let o = n.tr, l = s.transform;
        for (let a = l.steps.length - 1; a >= 0; a--)
          o.step(l.steps[a].invert(l.docs[a]));
        if (s.text) {
          let a = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, a));
        } else
          o.delete(s.from, s.to);
        e(o);
      }
      return !0;
    }
  }
  return !1;
};
new ar(/--$/, "â€”", { inCodeMark: !1 });
new ar(/\.\.\.$/, "â€¦", { inCodeMark: !1 });
new ar(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "â€œ", { inCodeMark: !1 });
new ar(/"$/, "â€", { inCodeMark: !1 });
new ar(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "â€˜", { inCodeMark: !1 });
new ar(/'$/, "â€™", { inCodeMark: !1 });
function C3(n, e, t = null, r) {
  return new ar(n, (i, s, o, l) => {
    let a = t instanceof Function ? t(s) : t, c = i.tr.delete(o, l), u = c.doc.resolve(o), h = u.blockRange(), f = h && k3(h, e, a);
    if (!f)
      return null;
    c.wrap(h, f);
    let d = c.doc.resolve(o - 1).nodeBefore;
    return d && d.type == e && k1(c.doc, o - 1) && (!r || r(s, d)) && c.join(o - 1), c;
  });
}
function M3(n, e, t = null) {
  return new ar(n, (r, i, s, o) => {
    let l = r.doc.resolve(s), a = t instanceof Function ? t(i) : t;
    return l.node(-1).canReplaceWith(l.index(-1), l.indexAfter(-1), e) ? r.tr.delete(s, o).setBlockType(s, s, e, a) : null;
  });
}
var cr = /* @__PURE__ */ ((n) => (n.docTypeError = "docTypeError", n.contextNotFound = "contextNotFound", n.timerNotFound = "timerNotFound", n.ctxCallOutOfScope = "ctxCallOutOfScope", n.createNodeInParserFail = "createNodeInParserFail", n.stackOverFlow = "stackOverFlow", n.parserMatchError = "parserMatchError", n.serializerMatchError = "serializerMatchError", n.getAtomFromSchemaFail = "getAtomFromSchemaFail", n.expectDomTypeError = "expectDomTypeError", n.callCommandBeforeEditorView = "callCommandBeforeEditorView", n.missingRootElement = "missingRootElement", n.missingNodeInSchema = "missingNodeInSchema", n.missingMarkInSchema = "missingMarkInSchema", n.ctxNotBind = "ctxNotBind", n.missingYjsDoc = "missingYjsDoc", n))(cr || {});
class Rr extends Error {
  constructor(e, t) {
    super(t), this.name = "MilkdownError", this.code = e;
  }
}
const lH = (n, e) => typeof e == "function" ? "[Function]" : e, M1 = (n) => JSON.stringify(n, lH);
function aH(n) {
  return new Rr(
    cr.docTypeError,
    `Doc type error, unsupported type: ${M1(n)}`
  );
}
function cH(n) {
  return new Rr(
    cr.contextNotFound,
    `Context "${n}" not found, do you forget to inject it?`
  );
}
function uH(n) {
  return new Rr(
    cr.timerNotFound,
    `Timer "${n}" not found, do you forget to record it?`
  );
}
function T1() {
  return new Rr(
    cr.ctxCallOutOfScope,
    "Should not call a context out of the plugin."
  );
}
function hH(n, e, t) {
  const i = `Cannot create node for ${"name" in n ? n.name : n}`, s = (u) => {
    if (u == null) return "null";
    if (Array.isArray(u))
      return `[${u.map(s).join(", ")}]`;
    if (typeof u == "object")
      return "toJSON" in u && typeof u.toJSON == "function" ? JSON.stringify(u.toJSON()) : "spec" in u ? JSON.stringify(u.spec) : JSON.stringify(u);
    if (typeof u == "string" || typeof u == "number" || typeof u == "boolean")
      return JSON.stringify(u);
    if (typeof u == "function")
      return `[Function: ${u.name || "anonymous"}]`;
    try {
      return String(u);
    } catch {
      return "[Unserializable]";
    }
  }, o = ["[Description]", i], l = ["[Attributes]", e], a = [
    "[Content]",
    (t ?? []).map((u) => u ? typeof u == "object" && "type" in u ? `${u}` : s(u) : "null")
  ], c = [o, l, a].reduce(
    (u, [h, f]) => {
      const d = `${h}: ${s(f)}.`;
      return u.concat(d);
    },
    []
  );
  return new Rr(
    cr.createNodeInParserFail,
    c.join(`
`)
  );
}
function bM() {
  return new Rr(
    cr.stackOverFlow,
    "Stack over flow, cannot pop on an empty stack."
  );
}
function fH(n) {
  return new Rr(
    cr.parserMatchError,
    `Cannot match target parser for node: ${M1(n)}.`
  );
}
function dH(n) {
  return new Rr(
    cr.serializerMatchError,
    `Cannot match target serializer for node: ${M1(n)}.`
  );
}
function pH(n, e) {
  return new Rr(
    cr.getAtomFromSchemaFail,
    `Cannot get ${n}: ${e} from schema.`
  );
}
function Ai(n) {
  return new Rr(
    cr.expectDomTypeError,
    `Expect to be a dom, but get: ${M1(n)}.`
  );
}
function l2() {
  return new Rr(
    cr.callCommandBeforeEditorView,
    "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
  );
}
function mH(n) {
  return new Rr(
    cr.missingNodeInSchema,
    `Missing node in schema, milkdown cannot find "${n}" in schema.`
  );
}
function gH(n) {
  return new Rr(
    cr.missingMarkInSchema,
    `Missing mark in schema, milkdown cannot find "${n}" in schema.`
  );
}
const Uo = typeof navigator < "u" ? navigator : null, Aw = typeof document < "u" ? document : null, tl = Uo && Uo.userAgent || "", Ay = /Edge\/(\d+)/.exec(tl), vM = /MSIE \d/.exec(tl), Oy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(tl), A1 = !!(vM || Oy || Ay), yH = vM ? document.documentMode : Oy ? +Oy[1] : Ay ? +Ay[1] : 0, wM = !A1 && /gecko\/(\d+)/i.test(tl), bH = wM && +(/Firefox\/(\d+)/.exec(tl) || [0, 0])[1], Ey = !A1 && /Chrome\/(\d+)/.exec(tl), vH = !!Ey, wH = Ey ? +Ey[1] : 0, xM = !A1 && !!Uo && /Apple Computer/.test(Uo.vendor), kM = xM && (/Mobile\/\w+/.test(tl) || !!Uo && Uo.maxTouchPoints > 2), xH = kM || (Uo ? /Mac/.test(Uo.platform) : !1), kH = /Android \d/.test(tl), SM = !!Aw && "webkitFontSmoothing" in Aw.documentElement.style, SH = SM ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
var P0 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  android: kH,
  chrome: vH,
  chrome_version: wH,
  gecko: wM,
  gecko_version: bH,
  ie: A1,
  ie_version: yH,
  ios: kM,
  mac: xH,
  safari: xM,
  webkit: SM,
  webkit_version: SH
});
function a2(n, e, t, r, i, s) {
  if (n.composing) return !1;
  const o = n.state, l = o.doc.resolve(e);
  if (l.parent.type.spec.code) return !1;
  const a = l.parent.textBetween(
    Math.max(0, l.parentOffset - 500),
    l.parentOffset,
    void 0,
    "ï¿¼"
  ) + r;
  for (let c of i) {
    const u = c, h = u.match.exec(a), f = h && h[0] && u.handler(o, h, e - (h[0].length - r.length), t);
    if (f)
      return u.undoable !== !1 && f.setMeta(s, { transform: f, from: e, to: t, text: r }), n.dispatch(f), !0;
  }
  return !1;
}
const CH = new kt("MILKDOWN_CUSTOM_INPUTRULES");
function MH({ rules: n }) {
  const e = new xt({
    key: CH,
    isInputRules: !0,
    state: {
      init() {
        return null;
      },
      apply(t, r) {
        const i = t.getMeta(this);
        return i || (t.selectionSet || t.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(t, r, i, s) {
        return a2(t, r, i, s, n, e);
      },
      handleDOMEvents: {
        compositionend: (t) => (setTimeout(() => {
          const { $cursor: r } = t.state.selection;
          r && a2(t, r.pos, r.pos, "", n, e);
        }), !1)
      },
      handleKeyDown(t, r) {
        if (r.key !== "Enter") return !1;
        const { $cursor: i } = t.state.selection;
        return i ? a2(t, i.pos, i.pos, `
`, n, e) : !1;
      }
    }
  });
  return e;
}
function Pd(n, e, t = {}) {
  return new ar(n, (r, i, s, o) => {
    var l, a, c, u;
    const { tr: h } = r, f = i.length;
    let d = i[f - 1], p = i[0], m = [], g = o;
    const b = {
      group: d,
      fullMatch: p,
      start: s,
      end: o
    }, w = (l = t.updateCaptured) == null ? void 0 : l.call(t, b);
    if (Object.assign(b, w), { group: d, fullMatch: p, start: s, end: o } = b, p === null || (d == null ? void 0 : d.trim()) === "") return null;
    if (d) {
      const k = p.search(/\S/), T = s + p.indexOf(d), M = T + d.length;
      m = (a = h.storedMarks) != null ? a : [], M < o && h.delete(M, o), T > s && h.delete(s + k, T), g = s + k + d.length;
      const C = (c = t.getAttr) == null ? void 0 : c.call(t, i);
      h.addMark(s, g, e.create(C)), h.setStoredMarks(m), (u = t.beforeDispatch) == null || u.call(t, { match: i, start: s, end: o, tr: h });
    }
    return h;
  });
}
function TH(n, e, t = {}) {
  return new ar(n, (r, i, s, o) => {
    var l, a, c;
    const { tr: u } = r;
    let h = i[1], f = i[0];
    const d = {
      group: h,
      fullMatch: f,
      start: s,
      end: o
    }, p = (l = t.updateCaptured) == null ? void 0 : l.call(t, d);
    if (Object.assign(d, p), { group: h, fullMatch: f, start: s, end: o } = d, f === null || !h || h.trim() === "") return null;
    const m = (a = t.getAttr) == null ? void 0 : a.call(t, i), g = e.createAndFill(m);
    return g && (u.replaceRangeWith(
      e.isBlock ? u.doc.resolve(s).before() : s,
      o,
      g
    ), (c = t.beforeDispatch) == null || c.call(t, {
      match: [f, h ?? ""],
      start: s,
      end: o,
      tr: u
    })), u;
  });
}
var AH = Object.defineProperty, OH = Object.defineProperties, EH = Object.getOwnPropertyDescriptors, Ow = Object.getOwnPropertySymbols, IH = Object.prototype.hasOwnProperty, DH = Object.prototype.propertyIsEnumerable, Ew = (n, e, t) => e in n ? AH(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, NH = (n, e) => {
  for (var t in e || (e = {}))
    IH.call(e, t) && Ew(n, t, e[t]);
  if (Ow)
    for (var t of Ow(e))
      DH.call(e, t) && Ew(n, t, e[t]);
  return n;
}, RH = (n, e) => OH(n, EH(e));
function Iw(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function O1(n, e, t) {
  const i = n.state.doc.content.size, s = Iw(e, 0, i), o = Iw(t, 0, i), l = n.coordsAtPos(s), a = n.coordsAtPos(o, -1), c = Math.min(l.top, a.top), u = Math.max(l.bottom, a.bottom), h = Math.min(l.left, a.left), f = Math.max(l.right, a.right), d = f - h, p = u - c, b = {
    top: c,
    bottom: u,
    left: h,
    right: f,
    width: d,
    height: p,
    x: h,
    y: c
  };
  return RH(NH({}, b), {
    toJSON: () => b
  });
}
function CM(n) {
  return Object.assign(Object.create(n), n).setTime(Date.now());
}
function PH(n, e) {
  return Array.isArray(n) && n.includes(e.type) || e.type === n;
}
function LH(n) {
  if (n.content.childCount === 1) {
    const e = n.content.firstChild;
    if ((e == null ? void 0 : e.type.name) === "text" && e.marks.length === 0) return e;
    if ((e == null ? void 0 : e.type.name) === "paragraph" && e.childCount === 1) {
      const t = e.firstChild;
      if ((t == null ? void 0 : t.type.name) === "text" && t.marks.length === 0) return t;
    }
  }
  return !1;
}
function Zi(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t -= 1) {
      const r = e.node(t);
      if (n(r)) {
        const i = e.before(t), s = e.after(t);
        return {
          from: i,
          to: s,
          node: r
        };
      }
    }
  };
}
function BH(n, e) {
  return Zi((t) => t.type === e)(n);
}
function zH(n, e) {
  const t = e.nodes[n];
  if (!t) throw pH("node", n);
  return t;
}
function MM(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t--) {
      const r = e.node(t);
      if (n(r))
        return {
          pos: t > 0 ? e.before(t) : 0,
          start: e.start(t),
          depth: t,
          node: r
        };
    }
  };
}
function _H(n) {
  return (e) => MM(n)(e.$from);
}
function FH(n, e) {
  if (!(n instanceof ve)) return;
  const { node: t, $from: r } = n;
  if (PH(e, t))
    return {
      node: t,
      pos: r.pos,
      start: r.start(r.depth),
      depth: r.depth
    };
}
const TM = (n, e) => {
  const { selection: t, doc: r } = n;
  if (t instanceof ve)
    return {
      hasNode: t.node.type === e,
      pos: t.from,
      target: t.node
    };
  const { from: i, to: s } = t;
  let o = !1, l = -1, a = null;
  return r.nodesBetween(i, s, (c, u) => a ? !1 : c.type === e ? (o = !0, l = u, a = c, !1) : !0), {
    hasNode: o,
    pos: l,
    target: a
  };
};
class AM {
  constructor() {
    this.sliceMap = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      if (!t) {
        const r = typeof e == "string" ? e : e.name;
        throw cH(r);
      }
      return t;
    }, this.remove = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      t && this.sliceMap.delete(t.type.id);
    }, this.has = (e) => typeof e == "string" ? [...this.sliceMap.values()].some((t) => t.type.name === e) : this.sliceMap.has(e.id);
  }
}
var mi, Os, mc;
class HH {
  /// @internal
  constructor(e, t, r) {
    ee(this, mi);
    /// @internal
    ee(this, Os);
    ee(this, mc);
    W(this, mi, []), W(this, mc, () => {
      N(this, mi).forEach((i) => i(N(this, Os)));
    }), this.set = (i) => {
      W(this, Os, i), N(this, mc).call(this);
    }, this.get = () => N(this, Os), this.update = (i) => {
      W(this, Os, i(N(this, Os))), N(this, mc).call(this);
    }, this.type = r, W(this, Os, t), e.set(r.id, this);
  }
  /// Add a watcher for changes in the slice.
  /// Returns a function to remove the watcher.
  on(e) {
    return N(this, mi).push(e), () => {
      W(this, mi, N(this, mi).filter((t) => t !== e));
    };
  }
  /// Add a one-time watcher for changes in the slice.
  /// The watcher will be removed after it is called.
  /// Returns a function to remove the watcher.
  once(e) {
    const t = this.on((r) => {
      e(r), t();
    });
    return t;
  }
  /// Remove a watcher.
  off(e) {
    W(this, mi, N(this, mi).filter((t) => t !== e));
  }
  /// Remove all watchers.
  offAll() {
    W(this, mi, []);
  }
}
mi = new WeakMap(), Os = new WeakMap(), mc = new WeakMap();
class $H {
  /// Create a slice type with a default value and a name.
  /// The name should be unique in the container.
  constructor(e, t) {
    this.id = Symbol(`Context-${t}`), this.name = t, this._defaultValue = e, this._typeInfo = () => {
      throw T1();
    };
  }
  /// Create a slice with a container.
  /// You can also pass a value to override the default value.
  create(e, t = this._defaultValue) {
    return new HH(e, t, this);
  }
}
const Ge = (n, e) => new $H(n, e);
var ed, td, nd, Bl, gc, Oo, yc, bc, vc;
class VH {
  /// Create an inspector with container, clock and metadata.
  constructor(e, t, r) {
    /// @internal
    ee(this, ed);
    /// @internal
    ee(this, td);
    /// @internal
    ee(this, nd);
    ee(this, Bl);
    ee(this, gc);
    ee(this, Oo);
    ee(this, yc);
    ee(this, bc);
    ee(this, vc);
    W(this, Bl, /* @__PURE__ */ new Set()), W(this, gc, /* @__PURE__ */ new Set()), W(this, Oo, /* @__PURE__ */ new Map()), W(this, yc, /* @__PURE__ */ new Map()), this.read = () => ({
      metadata: N(this, ed),
      injectedSlices: [...N(this, Bl)].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: N(this, bc).call(this, i)
      })),
      consumedSlices: [...N(this, gc)].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: N(this, bc).call(this, i)
      })),
      recordedTimers: [...N(this, Oo)].map(
        ([i, { duration: s }]) => ({
          name: i.name,
          duration: s,
          status: N(this, vc).call(this, i)
        })
      ),
      waitTimers: [...N(this, yc)].map(([i, { duration: s }]) => ({
        name: i.name,
        duration: s,
        status: N(this, vc).call(this, i)
      }))
    }), this.onRecord = (i) => {
      N(this, Oo).set(i, { start: Date.now(), duration: 0 });
    }, this.onClear = (i) => {
      N(this, Oo).delete(i);
    }, this.onDone = (i) => {
      const s = N(this, Oo).get(i);
      s && (s.duration = Date.now() - s.start);
    }, this.onWait = (i, s) => {
      const o = Date.now();
      s.finally(() => {
        N(this, yc).set(i, { duration: Date.now() - o });
      }).catch(console.error);
    }, this.onInject = (i) => {
      N(this, Bl).add(i);
    }, this.onRemove = (i) => {
      N(this, Bl).delete(i);
    }, this.onUse = (i) => {
      N(this, gc).add(i);
    }, W(this, bc, (i) => N(this, td).get(i).get()), W(this, vc, (i) => N(this, nd).get(i).status), W(this, td, e), W(this, nd, t), W(this, ed, r);
  }
}
ed = new WeakMap(), td = new WeakMap(), nd = new WeakMap(), Bl = new WeakMap(), gc = new WeakMap(), Oo = new WeakMap(), yc = new WeakMap(), bc = new WeakMap(), vc = new WeakMap();
var Es, Is, rd, Hr;
const av = class av {
  /// Create a ctx object with container and clock.
  constructor(e, t, r) {
    /// @internal
    ee(this, Es);
    /// @internal
    ee(this, Is);
    /// @internal
    ee(this, rd);
    /// @internal
    ee(this, Hr);
    this.produce = (i) => i && Object.keys(i).length ? new av(N(this, Es), N(this, Is), { ...i }) : this, this.inject = (i, s) => {
      var l;
      const o = i.create(N(this, Es).sliceMap);
      return s != null && o.set(s), (l = N(this, Hr)) == null || l.onInject(i), this;
    }, this.remove = (i) => {
      var s;
      return N(this, Es).remove(i), (s = N(this, Hr)) == null || s.onRemove(i), this;
    }, this.record = (i) => {
      var s;
      return i.create(N(this, Is).store), (s = N(this, Hr)) == null || s.onRecord(i), this;
    }, this.clearTimer = (i) => {
      var s;
      return N(this, Is).remove(i), (s = N(this, Hr)) == null || s.onClear(i), this;
    }, this.isInjected = (i) => N(this, Es).has(i), this.isRecorded = (i) => N(this, Is).has(i), this.use = (i) => {
      var s;
      return (s = N(this, Hr)) == null || s.onUse(i), N(this, Es).get(i);
    }, this.get = (i) => this.use(i).get(), this.set = (i, s) => this.use(i).set(s), this.update = (i, s) => this.use(i).update(s), this.timer = (i) => N(this, Is).get(i), this.done = (i) => {
      var s;
      this.timer(i).done(), (s = N(this, Hr)) == null || s.onDone(i);
    }, this.wait = (i) => {
      var o;
      const s = this.timer(i).start();
      return (o = N(this, Hr)) == null || o.onWait(i, s), s;
    }, this.waitTimers = async (i) => {
      await Promise.all(this.get(i).map((s) => this.wait(s)));
    }, W(this, Es, e), W(this, Is, t), W(this, rd, r), r && W(this, Hr, new VH(e, t, r));
  }
  /// Get metadata of the ctx.
  get meta() {
    return N(this, rd);
  }
  /// Get the inspector of the ctx.
  get inspector() {
    return N(this, Hr);
  }
};
Es = new WeakMap(), Is = new WeakMap(), rd = new WeakMap(), Hr = new WeakMap();
let Iy = av;
class qH {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = this.store.get(e.id);
      if (!t) throw uH(e.name);
      return t;
    }, this.remove = (e) => {
      this.store.delete(e.id);
    }, this.has = (e) => this.store.has(e.id);
  }
}
var wc, Eo, xc, Ds, kc, id;
class WH {
  /// @internal
  constructor(e, t) {
    ee(this, wc);
    ee(this, Eo);
    /// @internal
    ee(this, xc);
    ee(this, Ds);
    ee(this, kc);
    ee(this, id);
    W(this, wc, null), W(this, Eo, null), W(this, Ds, "pending"), this.start = () => (N(this, wc) ?? W(this, wc, new Promise((r, i) => {
      W(this, Eo, (s) => {
        s instanceof CustomEvent && s.detail.id === N(this, xc) && (W(this, Ds, "resolved"), N(this, kc).call(this), s.stopImmediatePropagation(), r());
      }), N(this, id).call(this, () => {
        N(this, Ds) === "pending" && W(this, Ds, "rejected"), N(this, kc).call(this), i(new Error(`Timing ${this.type.name} timeout.`));
      }), W(this, Ds, "pending"), addEventListener(this.type.name, N(this, Eo));
    })), N(this, wc)), this.done = () => {
      const r = new CustomEvent(this.type.name, {
        detail: { id: N(this, xc) }
      });
      dispatchEvent(r);
    }, W(this, kc, () => {
      N(this, Eo) && removeEventListener(this.type.name, N(this, Eo));
    }), W(this, id, (r) => {
      setTimeout(() => {
        r();
      }, this.type.timeout);
    }), W(this, xc, Symbol(t.name)), this.type = t, e.set(t.id, this);
  }
  /// The status of the timer.
  /// Can be `pending`, `resolved` or `rejected`.
  get status() {
    return N(this, Ds);
  }
}
wc = new WeakMap(), Eo = new WeakMap(), xc = new WeakMap(), Ds = new WeakMap(), kc = new WeakMap(), id = new WeakMap();
class jH {
  /// Create a timer type with a name and a timeout.
  /// The name should be unique in the clock.
  constructor(e, t = 3e3) {
    this.create = (r) => new WH(r, this), this.id = Symbol(`Timer-${e}`), this.name = e, this.timeout = t;
  }
}
const ro = (n, e = 3e3) => new jH(n, e), UH = {};
function T3(n, e) {
  const t = UH, r = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0;
  return OM(n, r, i);
}
function OM(n, e, t) {
  if (GH(n)) {
    if ("value" in n)
      return n.type === "html" && !t ? "" : n.value;
    if (e && "alt" in n && n.alt)
      return n.alt;
    if ("children" in n)
      return Dw(n.children, e, t);
  }
  return Array.isArray(n) ? Dw(n, e, t) : "";
}
function Dw(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; )
    r[i] = OM(n[i], e, t);
  return r.join("");
}
function GH(n) {
  return !!(n && typeof n == "object");
}
const Nw = document.createElement("i");
function A3(n) {
  const e = "&" + n + ";";
  Nw.innerHTML = e;
  const t = Nw.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    t.charCodeAt(t.length - 1) === 59 && n !== "semi" || t === e ? !1 : t
  );
}
function Or(n, e, t, r) {
  const i = n.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, t), n.splice(...o);
  else
    for (t && n.splice(e, t); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), n.splice(...o), s += 1e4, e += 1e4;
}
function Wr(n, e) {
  return n.length > 0 ? (Or(n, n.length, 0, e), n) : e;
}
const Rw = {}.hasOwnProperty;
function EM(n) {
  const e = {};
  let t = -1;
  for (; ++t < n.length; )
    KH(e, n[t]);
  return e;
}
function KH(n, e) {
  let t;
  for (t in e) {
    const i = (Rw.call(n, t) ? n[t] : void 0) || (n[t] = {}), s = e[t];
    let o;
    if (s)
      for (o in s) {
        Rw.call(i, o) || (i[o] = []);
        const l = s[o];
        YH(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(l) ? l : l ? [l] : []
        );
      }
  }
}
function YH(n, e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; )
    (e[t].add === "after" ? n : r).push(e[t]);
  Or(n, 0, 0, r);
}
function IM(n, e) {
  const t = Number.parseInt(n, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of C0, and C1 controls.
    t > 126 && t < 160 || // Lone high surrogates and low surrogates.
    t > 55295 && t < 57344 || // Noncharacters.
    t > 64975 && t < 65008 || /* eslint-disable no-bitwise */
    (t & 65535) === 65535 || (t & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    t > 1114111 ? "ï¿½" : String.fromCodePoint(t)
  );
}
function wi(n) {
  return n.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ln = nl(/[A-Za-z]/), ir = nl(/[\dA-Za-z]/), JH = nl(/[#-'*+\--9=?A-Z^-~]/);
function Om(n) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    n !== null && (n < 32 || n === 127)
  );
}
const Dy = nl(/\d/), XH = nl(/[\dA-Fa-f]/), ZH = nl(/[!-/:-@[-`{-~]/);
function ye(n) {
  return n !== null && n < -2;
}
function ht(n) {
  return n !== null && (n < 0 || n === 32);
}
function Ue(n) {
  return n === -2 || n === -1 || n === 32;
}
const E1 = nl(new RegExp("\\p{P}|\\p{S}", "u")), ga = nl(/\s/);
function nl(n) {
  return e;
  function e(t) {
    return t !== null && t > -1 && n.test(String.fromCharCode(t));
  }
}
function qe(n, e, t, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(a) {
    return Ue(a) ? (n.enter(t), l(a)) : e(a);
  }
  function l(a) {
    return Ue(a) && s++ < i ? (n.consume(a), l) : (n.exit(t), e(a));
  }
}
const QH = {
  tokenize: e$
};
function e$(n) {
  const e = n.attempt(this.parser.constructs.contentInitial, r, i);
  let t;
  return e;
  function r(l) {
    if (l === null) {
      n.consume(l);
      return;
    }
    return n.enter("lineEnding"), n.consume(l), n.exit("lineEnding"), qe(n, e, "linePrefix");
  }
  function i(l) {
    return n.enter("paragraph"), s(l);
  }
  function s(l) {
    const a = n.enter("chunkText", {
      contentType: "text",
      previous: t
    });
    return t && (t.next = a), t = a, o(l);
  }
  function o(l) {
    if (l === null) {
      n.exit("chunkText"), n.exit("paragraph"), n.consume(l);
      return;
    }
    return ye(l) ? (n.consume(l), n.exit("chunkText"), s) : (n.consume(l), o);
  }
}
const t$ = {
  tokenize: n$
}, Pw = {
  tokenize: r$
};
function n$(n) {
  const e = this, t = [];
  let r = 0, i, s, o;
  return l;
  function l(k) {
    if (r < t.length) {
      const T = t[r];
      return e.containerState = T[1], n.attempt(T[0].continuation, a, c)(k);
    }
    return c(k);
  }
  function a(k) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && w();
      const T = e.events.length;
      let M = T, C;
      for (; M--; )
        if (e.events[M][0] === "exit" && e.events[M][1].type === "chunkFlow") {
          C = e.events[M][1].end;
          break;
        }
      b(r);
      let I = T;
      for (; I < e.events.length; )
        e.events[I][1].end = {
          ...C
        }, I++;
      return Or(e.events, M + 1, 0, e.events.slice(T)), e.events.length = I, c(k);
    }
    return l(k);
  }
  function c(k) {
    if (r === t.length) {
      if (!i)
        return f(k);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return p(k);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, n.check(Pw, u, h)(k);
  }
  function u(k) {
    return i && w(), b(r), f(k);
  }
  function h(k) {
    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, p(k);
  }
  function f(k) {
    return e.containerState = {}, n.attempt(Pw, d, p)(k);
  }
  function d(k) {
    return r++, t.push([e.currentConstruct, e.containerState]), f(k);
  }
  function p(k) {
    if (k === null) {
      i && w(), b(0), n.consume(k);
      return;
    }
    return i = i || e.parser.flow(e.now()), n.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), m(k);
  }
  function m(k) {
    if (k === null) {
      g(n.exit("chunkFlow"), !0), b(0), n.consume(k);
      return;
    }
    return ye(k) ? (n.consume(k), g(n.exit("chunkFlow")), r = 0, e.interrupt = void 0, l) : (n.consume(k), m);
  }
  function g(k, T) {
    const M = e.sliceStream(k);
    if (T && M.push(null), k.previous = s, s && (s.next = k), s = k, i.defineSkip(k.start), i.write(M), e.parser.lazy[k.start.line]) {
      let C = i.events.length;
      for (; C--; )
        if (
          // The token starts before the line endingâ€¦
          i.events[C][1].start.offset < o && // â€¦and either is not ended yetâ€¦
          (!i.events[C][1].end || // â€¦or ends after it.
          i.events[C][1].end.offset > o)
        )
          return;
      const I = e.events.length;
      let _ = I, F, L;
      for (; _--; )
        if (e.events[_][0] === "exit" && e.events[_][1].type === "chunkFlow") {
          if (F) {
            L = e.events[_][1].end;
            break;
          }
          F = !0;
        }
      for (b(r), C = I; C < e.events.length; )
        e.events[C][1].end = {
          ...L
        }, C++;
      Or(e.events, _ + 1, 0, e.events.slice(I)), e.events.length = C;
    }
  }
  function b(k) {
    let T = t.length;
    for (; T-- > k; ) {
      const M = t[T];
      e.containerState = M[1], M[0].exit.call(e, n);
    }
    t.length = k;
  }
  function w() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function r$(n, e, t) {
  return qe(n, n.attempt(this.parser.constructs.document, e, t), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Jc(n) {
  if (n === null || ht(n) || ga(n))
    return 1;
  if (E1(n))
    return 2;
}
function I1(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const s = n[i].resolveAll;
    s && !r.includes(s) && (e = s(e, t), r.push(s));
  }
  return e;
}
const Ny = {
  name: "attention",
  resolveAll: i$,
  tokenize: s$
};
function i$(n, e) {
  let t = -1, r, i, s, o, l, a, c, u;
  for (; ++t < n.length; )
    if (n[t][0] === "enter" && n[t][1].type === "attentionSequence" && n[t][1]._close) {
      for (r = t; r--; )
        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:
        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {
          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))
            continue;
          a = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...n[r][1].end
          }, f = {
            ...n[t][1].start
          };
          Lw(h, -a), Lw(f, a), o = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...n[r][1].end
            }
          }, l = {
            type: a > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...n[t][1].start
            },
            end: f
          }, s = {
            type: a > 1 ? "strongText" : "emphasisText",
            start: {
              ...n[r][1].end
            },
            end: {
              ...n[t][1].start
            }
          }, i = {
            type: a > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...l.end
            }
          }, n[r][1].end = {
            ...o.start
          }, n[t][1].start = {
            ...l.end
          }, c = [], n[r][1].end.offset - n[r][1].start.offset && (c = Wr(c, [["enter", n[r][1], e], ["exit", n[r][1], e]])), c = Wr(c, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["enter", s, e]]), c = Wr(c, I1(e.parser.constructs.insideSpan.null, n.slice(r + 1, t), e)), c = Wr(c, [["exit", s, e], ["enter", l, e], ["exit", l, e], ["exit", i, e]]), n[t][1].end.offset - n[t][1].start.offset ? (u = 2, c = Wr(c, [["enter", n[t][1], e], ["exit", n[t][1], e]])) : u = 0, Or(n, r - 1, t - r + 3, c), t = r + c.length - u - 2;
          break;
        }
    }
  for (t = -1; ++t < n.length; )
    n[t][1].type === "attentionSequence" && (n[t][1].type = "data");
  return n;
}
function s$(n, e) {
  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Jc(r);
  let s;
  return o;
  function o(a) {
    return s = a, n.enter("attentionSequence"), l(a);
  }
  function l(a) {
    if (a === s)
      return n.consume(a), l;
    const c = n.exit("attentionSequence"), u = Jc(a), h = !u || u === 2 && i || t.includes(a), f = !i || i === 2 && u || t.includes(r);
    return c._open = !!(s === 42 ? h : h && (i || !f)), c._close = !!(s === 42 ? f : f && (u || !h)), e(a);
  }
}
function Lw(n, e) {
  n.column += e, n.offset += e, n._bufferIndex += e;
}
const o$ = {
  name: "autolink",
  tokenize: l$
};
function l$(n, e, t) {
  let r = 0;
  return i;
  function i(d) {
    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), s;
  }
  function s(d) {
    return Ln(d) ? (n.consume(d), o) : d === 64 ? t(d) : c(d);
  }
  function o(d) {
    return d === 43 || d === 45 || d === 46 || ir(d) ? (r = 1, l(d)) : c(d);
  }
  function l(d) {
    return d === 58 ? (n.consume(d), r = 0, a) : (d === 43 || d === 45 || d === 46 || ir(d)) && r++ < 32 ? (n.consume(d), l) : (r = 0, c(d));
  }
  function a(d) {
    return d === 62 ? (n.exit("autolinkProtocol"), n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : d === null || d === 32 || d === 60 || Om(d) ? t(d) : (n.consume(d), a);
  }
  function c(d) {
    return d === 64 ? (n.consume(d), u) : JH(d) ? (n.consume(d), c) : t(d);
  }
  function u(d) {
    return ir(d) ? h(d) : t(d);
  }
  function h(d) {
    return d === 46 ? (n.consume(d), r = 0, u) : d === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", n.enter("autolinkMarker"), n.consume(d), n.exit("autolinkMarker"), n.exit("autolink"), e) : f(d);
  }
  function f(d) {
    if ((d === 45 || ir(d)) && r++ < 63) {
      const p = d === 45 ? f : h;
      return n.consume(d), p;
    }
    return t(d);
  }
}
const Ld = {
  partial: !0,
  tokenize: a$
};
function a$(n, e, t) {
  return r;
  function r(s) {
    return Ue(s) ? qe(n, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || ye(s) ? e(s) : t(s);
  }
}
const DM = {
  continuation: {
    tokenize: u$
  },
  exit: h$,
  name: "blockQuote",
  tokenize: c$
};
function c$(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const l = r.containerState;
      return l.open || (n.enter("blockQuote", {
        _container: !0
      }), l.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), s;
    }
    return t(o);
  }
  function s(o) {
    return Ue(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), e) : (n.exit("blockQuotePrefix"), e(o));
  }
}
function u$(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return Ue(o) ? qe(n, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return n.attempt(DM, e, t)(o);
  }
}
function h$(n) {
  n.exit("blockQuote");
}
const NM = {
  name: "characterEscape",
  tokenize: f$
};
function f$(n, e, t) {
  return r;
  function r(s) {
    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(s), n.exit("escapeMarker"), i;
  }
  function i(s) {
    return ZH(s) ? (n.enter("characterEscapeValue"), n.consume(s), n.exit("characterEscapeValue"), n.exit("characterEscape"), e) : t(s);
  }
}
const RM = {
  name: "characterReference",
  tokenize: d$
};
function d$(n, e, t) {
  const r = this;
  let i = 0, s, o;
  return l;
  function l(h) {
    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), a;
  }
  function a(h) {
    return h === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(h), n.exit("characterReferenceMarkerNumeric"), c) : (n.enter("characterReferenceValue"), s = 31, o = ir, u(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(h), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), s = 6, o = XH, u) : (n.enter("characterReferenceValue"), s = 7, o = Dy, u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const f = n.exit("characterReferenceValue");
      return o === ir && !A3(r.sliceSerialize(f)) ? t(h) : (n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), n.exit("characterReference"), e);
    }
    return o(h) && i++ < s ? (n.consume(h), u) : t(h);
  }
}
const Bw = {
  partial: !0,
  tokenize: m$
}, zw = {
  concrete: !0,
  name: "codeFenced",
  tokenize: p$
};
function p$(n, e, t) {
  const r = this, i = {
    partial: !0,
    tokenize: M
  };
  let s = 0, o = 0, l;
  return a;
  function a(C) {
    return c(C);
  }
  function c(C) {
    const I = r.events[r.events.length - 1];
    return s = I && I[1].type === "linePrefix" ? I[2].sliceSerialize(I[1], !0).length : 0, l = C, n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), u(C);
  }
  function u(C) {
    return C === l ? (o++, n.consume(C), u) : o < 3 ? t(C) : (n.exit("codeFencedFenceSequence"), Ue(C) ? qe(n, h, "whitespace")(C) : h(C));
  }
  function h(C) {
    return C === null || ye(C) ? (n.exit("codeFencedFence"), r.interrupt ? e(C) : n.check(Bw, m, T)(C)) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {
      contentType: "string"
    }), f(C));
  }
  function f(C) {
    return C === null || ye(C) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), h(C)) : Ue(C) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), qe(n, d, "whitespace")(C)) : C === 96 && C === l ? t(C) : (n.consume(C), f);
  }
  function d(C) {
    return C === null || ye(C) ? h(C) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), p(C));
  }
  function p(C) {
    return C === null || ye(C) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), h(C)) : C === 96 && C === l ? t(C) : (n.consume(C), p);
  }
  function m(C) {
    return n.attempt(i, T, g)(C);
  }
  function g(C) {
    return n.enter("lineEnding"), n.consume(C), n.exit("lineEnding"), b;
  }
  function b(C) {
    return s > 0 && Ue(C) ? qe(n, w, "linePrefix", s + 1)(C) : w(C);
  }
  function w(C) {
    return C === null || ye(C) ? n.check(Bw, m, T)(C) : (n.enter("codeFlowValue"), k(C));
  }
  function k(C) {
    return C === null || ye(C) ? (n.exit("codeFlowValue"), w(C)) : (n.consume(C), k);
  }
  function T(C) {
    return n.exit("codeFenced"), e(C);
  }
  function M(C, I, _) {
    let F = 0;
    return L;
    function L(ie) {
      return C.enter("lineEnding"), C.consume(ie), C.exit("lineEnding"), $;
    }
    function $(ie) {
      return C.enter("codeFencedFence"), Ue(ie) ? qe(C, B, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ie) : B(ie);
    }
    function B(ie) {
      return ie === l ? (C.enter("codeFencedFenceSequence"), se(ie)) : _(ie);
    }
    function se(ie) {
      return ie === l ? (F++, C.consume(ie), se) : F >= o ? (C.exit("codeFencedFenceSequence"), Ue(ie) ? qe(C, te, "whitespace")(ie) : te(ie)) : _(ie);
    }
    function te(ie) {
      return ie === null || ye(ie) ? (C.exit("codeFencedFence"), I(ie)) : _(ie);
    }
  }
}
function m$(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? t(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
const c2 = {
  name: "codeIndented",
  tokenize: y$
}, g$ = {
  partial: !0,
  tokenize: b$
};
function y$(n, e, t) {
  const r = this;
  return i;
  function i(c) {
    return n.enter("codeIndented"), qe(n, s, "linePrefix", 5)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : t(c);
  }
  function o(c) {
    return c === null ? a(c) : ye(c) ? n.attempt(g$, o, a)(c) : (n.enter("codeFlowValue"), l(c));
  }
  function l(c) {
    return c === null || ye(c) ? (n.exit("codeFlowValue"), o(c)) : (n.consume(c), l);
  }
  function a(c) {
    return n.exit("codeIndented"), e(c);
  }
}
function b$(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? t(o) : ye(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : qe(n, s, "linePrefix", 5)(o);
  }
  function s(o) {
    const l = r.events[r.events.length - 1];
    return l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : ye(o) ? i(o) : t(o);
  }
}
const v$ = {
  name: "codeText",
  previous: x$,
  resolve: w$,
  tokenize: k$
};
function w$(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "codeTextData") {
        n[t][1].type = "codeTextPadding", n[e][1].type = "codeTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function x$(n) {
  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function k$(n, e, t) {
  let r = 0, i, s;
  return o;
  function o(h) {
    return n.enter("codeText"), n.enter("codeTextSequence"), l(h);
  }
  function l(h) {
    return h === 96 ? (n.consume(h), r++, l) : (n.exit("codeTextSequence"), a(h));
  }
  function a(h) {
    return h === null ? t(h) : h === 32 ? (n.enter("space"), n.consume(h), n.exit("space"), a) : h === 96 ? (s = n.enter("codeTextSequence"), i = 0, u(h)) : ye(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), a) : (n.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || ye(h) ? (n.exit("codeTextData"), a(h)) : (n.consume(h), c);
  }
  function u(h) {
    return h === 96 ? (n.consume(h), i++, u) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), e(h)) : (s.type = "codeTextData", c(h));
  }
}
class S$ {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, t) {
    const r = t ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, t, r) {
    const i = t || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Ku(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), Ku(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), Ku(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const t = this.left.splice(e, Number.POSITIVE_INFINITY);
        Ku(this.right, t.reverse());
      } else {
        const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        Ku(this.left, t.reverse());
      }
  }
}
function Ku(n, e) {
  let t = 0;
  if (e.length < 1e4)
    n.push(...e);
  else
    for (; t < e.length; )
      n.push(...e.slice(t, t + 1e4)), t += 1e4;
}
function PM(n) {
  const e = {};
  let t = -1, r, i, s, o, l, a, c;
  const u = new S$(n);
  for (; ++t < u.length; ) {
    for (; t in e; )
      t = e[t];
    if (r = u.get(t), t && r[1].type === "chunkFlow" && u.get(t - 1)[1].type === "listItemPrefix" && (a = r[1]._tokenizer.events, s = 0, s < a.length && a[s][1].type === "lineEndingBlank" && (s += 2), s < a.length && a[s][1].type === "content"))
      for (; ++s < a.length && a[s][1].type !== "content"; )
        a[s][1].type === "chunkText" && (a[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, C$(u, t)), t = e[t], c = !0);
    else if (r[1]._container) {
      for (s = t, i = void 0; s--; )
        if (o = u.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
        else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, l = u.slice(i, t), l.unshift(r), u.splice(i, t - i + 1, l));
    }
  }
  return Or(n, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function C$(n, e) {
  const t = n.get(e)[1], r = n.get(e)[2];
  let i = e - 1;
  const s = [];
  let o = t._tokenizer;
  o || (o = r.parser[t.contentType](t.start), t._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0));
  const l = o.events, a = [], c = {};
  let u, h, f = -1, d = t, p = 0, m = 0;
  const g = [m];
  for (; d; ) {
    for (; n.get(++i)[1] !== d; )
      ;
    s.push(i), d._tokenizer || (u = r.sliceStream(d), d.next || u.push(null), h && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = d, d = d.next;
  }
  for (d = t; ++f < l.length; )
    // Find a void token that includes a break.
    l[f][0] === "exit" && l[f - 1][0] === "enter" && l[f][1].type === l[f - 1][1].type && l[f][1].start.line !== l[f][1].end.line && (m = f + 1, g.push(m), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : g.pop(), f = g.length; f--; ) {
    const b = l.slice(g[f], g[f + 1]), w = s.pop();
    a.push([w, w + b.length - 1]), n.splice(w, 2, b);
  }
  for (a.reverse(), f = -1; ++f < a.length; )
    c[p + a[f][0]] = p + a[f][1], p += a[f][1] - a[f][0] - 1;
  return c;
}
const M$ = {
  resolve: A$,
  tokenize: O$
}, T$ = {
  partial: !0,
  tokenize: E$
};
function A$(n) {
  return PM(n), n;
}
function O$(n, e) {
  let t;
  return r;
  function r(l) {
    return n.enter("content"), t = n.enter("chunkContent", {
      contentType: "content"
    }), i(l);
  }
  function i(l) {
    return l === null ? s(l) : ye(l) ? n.check(T$, o, s)(l) : (n.consume(l), i);
  }
  function s(l) {
    return n.exit("chunkContent"), n.exit("content"), e(l);
  }
  function o(l) {
    return n.consume(l), n.exit("chunkContent"), t.next = n.enter("chunkContent", {
      contentType: "content",
      previous: t
    }), t = t.next, i;
  }
}
function E$(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), qe(n, s, "linePrefix");
  }
  function s(o) {
    if (o === null || ye(o))
      return t(o);
    const l = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && l && l[1].type === "linePrefix" && l[2].sliceSerialize(l[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);
  }
}
function LM(n, e, t, r, i, s, o, l, a) {
  const c = a || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(b) {
    return b === 60 ? (n.enter(r), n.enter(i), n.enter(s), n.consume(b), n.exit(s), f) : b === null || b === 32 || b === 41 || Om(b) ? t(b) : (n.enter(r), n.enter(o), n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), m(b));
  }
  function f(b) {
    return b === 62 ? (n.enter(s), n.consume(b), n.exit(s), n.exit(i), n.exit(r), e) : (n.enter(l), n.enter("chunkString", {
      contentType: "string"
    }), d(b));
  }
  function d(b) {
    return b === 62 ? (n.exit("chunkString"), n.exit(l), f(b)) : b === null || b === 60 || ye(b) ? t(b) : (n.consume(b), b === 92 ? p : d);
  }
  function p(b) {
    return b === 60 || b === 62 || b === 92 ? (n.consume(b), d) : d(b);
  }
  function m(b) {
    return !u && (b === null || b === 41 || ht(b)) ? (n.exit("chunkString"), n.exit(l), n.exit(o), n.exit(r), e(b)) : u < c && b === 40 ? (n.consume(b), u++, m) : b === 41 ? (n.consume(b), u--, m) : b === null || b === 32 || b === 40 || Om(b) ? t(b) : (n.consume(b), b === 92 ? g : m);
  }
  function g(b) {
    return b === 40 || b === 41 || b === 92 ? (n.consume(b), m) : m(b);
  }
}
function BM(n, e, t, r, i, s) {
  const o = this;
  let l = 0, a;
  return c;
  function c(d) {
    return n.enter(r), n.enter(i), n.consume(d), n.exit(i), n.enter(s), u;
  }
  function u(d) {
    return l > 999 || d === null || d === 91 || d === 93 && !a || // To do: remove in the future once weâ€™ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnâ€™t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? t(d) : d === 93 ? (n.exit(s), n.enter(i), n.consume(d), n.exit(i), n.exit(r), e) : ye(d) ? (n.enter("lineEnding"), n.consume(d), n.exit("lineEnding"), u) : (n.enter("chunkString", {
      contentType: "string"
    }), h(d));
  }
  function h(d) {
    return d === null || d === 91 || d === 93 || ye(d) || l++ > 999 ? (n.exit("chunkString"), u(d)) : (n.consume(d), a || (a = !Ue(d)), d === 92 ? f : h);
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (n.consume(d), l++, h) : h(d);
  }
}
function zM(n, e, t, r, i, s) {
  let o;
  return l;
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? (n.enter(r), n.enter(i), n.consume(f), n.exit(i), o = f === 40 ? 41 : f, a) : t(f);
  }
  function a(f) {
    return f === o ? (n.enter(i), n.consume(f), n.exit(i), n.exit(r), e) : (n.enter(s), c(f));
  }
  function c(f) {
    return f === o ? (n.exit(s), a(o)) : f === null ? t(f) : ye(f) ? (n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), qe(n, c, "linePrefix")) : (n.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === o || f === null || ye(f) ? (n.exit("chunkString"), c(f)) : (n.consume(f), f === 92 ? h : u);
  }
  function h(f) {
    return f === o || f === 92 ? (n.consume(f), u) : u(f);
  }
}
function Zh(n, e) {
  let t;
  return r;
  function r(i) {
    return ye(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), t = !0, r) : Ue(i) ? qe(n, r, t ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const I$ = {
  name: "definition",
  tokenize: N$
}, D$ = {
  partial: !0,
  tokenize: R$
};
function N$(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(d) {
    return n.enter("definition"), o(d);
  }
  function o(d) {
    return BM.call(
      r,
      n,
      l,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      t,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function l(d) {
    return i = wi(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), d === 58 ? (n.enter("definitionMarker"), n.consume(d), n.exit("definitionMarker"), a) : t(d);
  }
  function a(d) {
    return ht(d) ? Zh(n, c)(d) : c(d);
  }
  function c(d) {
    return LM(
      n,
      u,
      // Note: we donâ€™t need to reset the way `markdown-rs` does.
      t,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function u(d) {
    return n.attempt(D$, h, h)(d);
  }
  function h(d) {
    return Ue(d) ? qe(n, f, "whitespace")(d) : f(d);
  }
  function f(d) {
    return d === null || ye(d) ? (n.exit("definition"), r.parser.defined.push(i), e(d)) : t(d);
  }
}
function R$(n, e, t) {
  return r;
  function r(l) {
    return ht(l) ? Zh(n, i)(l) : t(l);
  }
  function i(l) {
    return zM(n, s, t, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(l);
  }
  function s(l) {
    return Ue(l) ? qe(n, o, "whitespace")(l) : o(l);
  }
  function o(l) {
    return l === null || ye(l) ? e(l) : t(l);
  }
}
const P$ = {
  name: "hardBreakEscape",
  tokenize: L$
};
function L$(n, e, t) {
  return r;
  function r(s) {
    return n.enter("hardBreakEscape"), n.consume(s), i;
  }
  function i(s) {
    return ye(s) ? (n.exit("hardBreakEscape"), e(s)) : t(s);
  }
}
const B$ = {
  name: "headingAtx",
  resolve: z$,
  tokenize: _$
};
function z$(n, e) {
  let t = n.length - 2, r = 3, i, s;
  return n[r][1].type === "whitespace" && (r += 2), t - 2 > r && n[t][1].type === "whitespace" && (t -= 2), n[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {
    type: "atxHeadingText",
    start: n[r][1].start,
    end: n[t][1].end
  }, s = {
    type: "chunkText",
    start: n[r][1].start,
    end: n[t][1].end,
    contentType: "text"
  }, Or(n, r, t - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), n;
}
function _$(n, e, t) {
  let r = 0;
  return i;
  function i(u) {
    return n.enter("atxHeading"), s(u);
  }
  function s(u) {
    return n.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (n.consume(u), o) : u === null || ht(u) ? (n.exit("atxHeadingSequence"), l(u)) : t(u);
  }
  function l(u) {
    return u === 35 ? (n.enter("atxHeadingSequence"), a(u)) : u === null || ye(u) ? (n.exit("atxHeading"), e(u)) : Ue(u) ? qe(n, l, "whitespace")(u) : (n.enter("atxHeadingText"), c(u));
  }
  function a(u) {
    return u === 35 ? (n.consume(u), a) : (n.exit("atxHeadingSequence"), l(u));
  }
  function c(u) {
    return u === null || u === 35 || ht(u) ? (n.exit("atxHeadingText"), l(u)) : (n.consume(u), c);
  }
}
const F$ = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], _w = ["pre", "script", "style", "textarea"], H$ = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: q$,
  tokenize: W$
}, $$ = {
  partial: !0,
  tokenize: U$
}, V$ = {
  partial: !0,
  tokenize: j$
};
function q$(n) {
  let e = n.length;
  for (; e-- && !(n[e][0] === "enter" && n[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && n[e - 2][1].type === "linePrefix" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;
}
function W$(n, e, t) {
  const r = this;
  let i, s, o, l, a;
  return c;
  function c(O) {
    return u(O);
  }
  function u(O) {
    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(O), h;
  }
  function h(O) {
    return O === 33 ? (n.consume(O), f) : O === 47 ? (n.consume(O), s = !0, m) : O === 63 ? (n.consume(O), i = 3, r.interrupt ? e : D) : Ln(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function f(O) {
    return O === 45 ? (n.consume(O), i = 2, d) : O === 91 ? (n.consume(O), i = 5, l = 0, p) : Ln(O) ? (n.consume(O), i = 4, r.interrupt ? e : D) : t(O);
  }
  function d(O) {
    return O === 45 ? (n.consume(O), r.interrupt ? e : D) : t(O);
  }
  function p(O) {
    const rt = "CDATA[";
    return O === rt.charCodeAt(l++) ? (n.consume(O), l === rt.length ? r.interrupt ? e : B : p) : t(O);
  }
  function m(O) {
    return Ln(O) ? (n.consume(O), o = String.fromCharCode(O), g) : t(O);
  }
  function g(O) {
    if (O === null || O === 47 || O === 62 || ht(O)) {
      const rt = O === 47, Le = o.toLowerCase();
      return !rt && !s && _w.includes(Le) ? (i = 1, r.interrupt ? e(O) : B(O)) : F$.includes(o.toLowerCase()) ? (i = 6, rt ? (n.consume(O), b) : r.interrupt ? e(O) : B(O)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(O) : s ? w(O) : k(O));
    }
    return O === 45 || ir(O) ? (n.consume(O), o += String.fromCharCode(O), g) : t(O);
  }
  function b(O) {
    return O === 62 ? (n.consume(O), r.interrupt ? e : B) : t(O);
  }
  function w(O) {
    return Ue(O) ? (n.consume(O), w) : L(O);
  }
  function k(O) {
    return O === 47 ? (n.consume(O), L) : O === 58 || O === 95 || Ln(O) ? (n.consume(O), T) : Ue(O) ? (n.consume(O), k) : L(O);
  }
  function T(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || ir(O) ? (n.consume(O), T) : M(O);
  }
  function M(O) {
    return O === 61 ? (n.consume(O), C) : Ue(O) ? (n.consume(O), M) : k(O);
  }
  function C(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? t(O) : O === 34 || O === 39 ? (n.consume(O), a = O, I) : Ue(O) ? (n.consume(O), C) : _(O);
  }
  function I(O) {
    return O === a ? (n.consume(O), a = null, F) : O === null || ye(O) ? t(O) : (n.consume(O), I);
  }
  function _(O) {
    return O === null || O === 34 || O === 39 || O === 47 || O === 60 || O === 61 || O === 62 || O === 96 || ht(O) ? M(O) : (n.consume(O), _);
  }
  function F(O) {
    return O === 47 || O === 62 || Ue(O) ? k(O) : t(O);
  }
  function L(O) {
    return O === 62 ? (n.consume(O), $) : t(O);
  }
  function $(O) {
    return O === null || ye(O) ? B(O) : Ue(O) ? (n.consume(O), $) : t(O);
  }
  function B(O) {
    return O === 45 && i === 2 ? (n.consume(O), Ce) : O === 60 && i === 1 ? (n.consume(O), Oe) : O === 62 && i === 4 ? (n.consume(O), Me) : O === 63 && i === 3 ? (n.consume(O), D) : O === 93 && i === 5 ? (n.consume(O), Be) : ye(O) && (i === 6 || i === 7) ? (n.exit("htmlFlowData"), n.check($$, _e, se)(O)) : O === null || ye(O) ? (n.exit("htmlFlowData"), se(O)) : (n.consume(O), B);
  }
  function se(O) {
    return n.check(V$, te, _e)(O);
  }
  function te(O) {
    return n.enter("lineEnding"), n.consume(O), n.exit("lineEnding"), ie;
  }
  function ie(O) {
    return O === null || ye(O) ? se(O) : (n.enter("htmlFlowData"), B(O));
  }
  function Ce(O) {
    return O === 45 ? (n.consume(O), D) : B(O);
  }
  function Oe(O) {
    return O === 47 ? (n.consume(O), o = "", Re) : B(O);
  }
  function Re(O) {
    if (O === 62) {
      const rt = o.toLowerCase();
      return _w.includes(rt) ? (n.consume(O), Me) : B(O);
    }
    return Ln(O) && o.length < 8 ? (n.consume(O), o += String.fromCharCode(O), Re) : B(O);
  }
  function Be(O) {
    return O === 93 ? (n.consume(O), D) : B(O);
  }
  function D(O) {
    return O === 62 ? (n.consume(O), Me) : O === 45 && i === 2 ? (n.consume(O), D) : B(O);
  }
  function Me(O) {
    return O === null || ye(O) ? (n.exit("htmlFlowData"), _e(O)) : (n.consume(O), Me);
  }
  function _e(O) {
    return n.exit("htmlFlow"), e(O);
  }
}
function j$(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return ye(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s) : t(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function U$(n, e, t) {
  return r;
  function r(i) {
    return n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), n.attempt(Ld, e, t);
  }
}
const G$ = {
  name: "htmlText",
  tokenize: K$
};
function K$(n, e, t) {
  const r = this;
  let i, s, o;
  return l;
  function l(D) {
    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(D), a;
  }
  function a(D) {
    return D === 33 ? (n.consume(D), c) : D === 47 ? (n.consume(D), M) : D === 63 ? (n.consume(D), k) : Ln(D) ? (n.consume(D), _) : t(D);
  }
  function c(D) {
    return D === 45 ? (n.consume(D), u) : D === 91 ? (n.consume(D), s = 0, p) : Ln(D) ? (n.consume(D), w) : t(D);
  }
  function u(D) {
    return D === 45 ? (n.consume(D), d) : t(D);
  }
  function h(D) {
    return D === null ? t(D) : D === 45 ? (n.consume(D), f) : ye(D) ? (o = h, Oe(D)) : (n.consume(D), h);
  }
  function f(D) {
    return D === 45 ? (n.consume(D), d) : h(D);
  }
  function d(D) {
    return D === 62 ? Ce(D) : D === 45 ? f(D) : h(D);
  }
  function p(D) {
    const Me = "CDATA[";
    return D === Me.charCodeAt(s++) ? (n.consume(D), s === Me.length ? m : p) : t(D);
  }
  function m(D) {
    return D === null ? t(D) : D === 93 ? (n.consume(D), g) : ye(D) ? (o = m, Oe(D)) : (n.consume(D), m);
  }
  function g(D) {
    return D === 93 ? (n.consume(D), b) : m(D);
  }
  function b(D) {
    return D === 62 ? Ce(D) : D === 93 ? (n.consume(D), b) : m(D);
  }
  function w(D) {
    return D === null || D === 62 ? Ce(D) : ye(D) ? (o = w, Oe(D)) : (n.consume(D), w);
  }
  function k(D) {
    return D === null ? t(D) : D === 63 ? (n.consume(D), T) : ye(D) ? (o = k, Oe(D)) : (n.consume(D), k);
  }
  function T(D) {
    return D === 62 ? Ce(D) : k(D);
  }
  function M(D) {
    return Ln(D) ? (n.consume(D), C) : t(D);
  }
  function C(D) {
    return D === 45 || ir(D) ? (n.consume(D), C) : I(D);
  }
  function I(D) {
    return ye(D) ? (o = I, Oe(D)) : Ue(D) ? (n.consume(D), I) : Ce(D);
  }
  function _(D) {
    return D === 45 || ir(D) ? (n.consume(D), _) : D === 47 || D === 62 || ht(D) ? F(D) : t(D);
  }
  function F(D) {
    return D === 47 ? (n.consume(D), Ce) : D === 58 || D === 95 || Ln(D) ? (n.consume(D), L) : ye(D) ? (o = F, Oe(D)) : Ue(D) ? (n.consume(D), F) : Ce(D);
  }
  function L(D) {
    return D === 45 || D === 46 || D === 58 || D === 95 || ir(D) ? (n.consume(D), L) : $(D);
  }
  function $(D) {
    return D === 61 ? (n.consume(D), B) : ye(D) ? (o = $, Oe(D)) : Ue(D) ? (n.consume(D), $) : F(D);
  }
  function B(D) {
    return D === null || D === 60 || D === 61 || D === 62 || D === 96 ? t(D) : D === 34 || D === 39 ? (n.consume(D), i = D, se) : ye(D) ? (o = B, Oe(D)) : Ue(D) ? (n.consume(D), B) : (n.consume(D), te);
  }
  function se(D) {
    return D === i ? (n.consume(D), i = void 0, ie) : D === null ? t(D) : ye(D) ? (o = se, Oe(D)) : (n.consume(D), se);
  }
  function te(D) {
    return D === null || D === 34 || D === 39 || D === 60 || D === 61 || D === 96 ? t(D) : D === 47 || D === 62 || ht(D) ? F(D) : (n.consume(D), te);
  }
  function ie(D) {
    return D === 47 || D === 62 || ht(D) ? F(D) : t(D);
  }
  function Ce(D) {
    return D === 62 ? (n.consume(D), n.exit("htmlTextData"), n.exit("htmlText"), e) : t(D);
  }
  function Oe(D) {
    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(D), n.exit("lineEnding"), Re;
  }
  function Re(D) {
    return Ue(D) ? qe(n, Be, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(D) : Be(D);
  }
  function Be(D) {
    return n.enter("htmlTextData"), o(D);
  }
}
const O3 = {
  name: "labelEnd",
  resolveAll: Z$,
  resolveTo: Q$,
  tokenize: eV
}, Y$ = {
  tokenize: tV
}, J$ = {
  tokenize: nV
}, X$ = {
  tokenize: rV
};
function Z$(n) {
  let e = -1;
  const t = [];
  for (; ++e < n.length; ) {
    const r = n[e][1];
    if (t.push(n[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return n.length !== t.length && Or(n, 0, n.length, t), n;
}
function Q$(n, e) {
  let t = n.length, r = 0, i, s, o, l;
  for (; t--; )
    if (i = n[t][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (n[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = t, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = t);
  const a = {
    type: n[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...n[s + r + 2][1].end
    },
    end: {
      ...n[o - 2][1].start
    }
  };
  return l = [["enter", a, e], ["enter", c, e]], l = Wr(l, n.slice(s + 1, s + r + 3)), l = Wr(l, [["enter", u, e]]), l = Wr(l, I1(e.parser.constructs.insideSpan.null, n.slice(s + r + 4, o - 3), e)), l = Wr(l, [["exit", u, e], n[o - 2], n[o - 1], ["exit", c, e]]), l = Wr(l, n.slice(o + 1)), l = Wr(l, [["exit", a, e]]), Or(n, s, n.length, l), n;
}
function eV(n, e, t) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return l;
  function l(f) {
    return s ? s._inactive ? h(f) : (o = r.parser.defined.includes(wi(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(f), n.exit("labelMarker"), n.exit("labelEnd"), a) : t(f);
  }
  function a(f) {
    return f === 40 ? n.attempt(Y$, u, o ? u : h)(f) : f === 91 ? n.attempt(J$, u, o ? c : h)(f) : o ? u(f) : h(f);
  }
  function c(f) {
    return n.attempt(X$, u, h)(f);
  }
  function u(f) {
    return e(f);
  }
  function h(f) {
    return s._balanced = !0, t(f);
  }
}
function tV(n, e, t) {
  return r;
  function r(h) {
    return n.enter("resource"), n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), i;
  }
  function i(h) {
    return ht(h) ? Zh(n, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? u(h) : LM(n, o, l, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function o(h) {
    return ht(h) ? Zh(n, a)(h) : u(h);
  }
  function l(h) {
    return t(h);
  }
  function a(h) {
    return h === 34 || h === 39 || h === 40 ? zM(n, c, t, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return ht(h) ? Zh(n, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), n.exit("resource"), e) : t(h);
  }
}
function nV(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return BM.call(r, n, s, o, "reference", "referenceMarker", "referenceString")(l);
  }
  function s(l) {
    return r.parser.defined.includes(wi(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(l) : t(l);
  }
  function o(l) {
    return t(l);
  }
}
function rV(n, e, t) {
  return r;
  function r(s) {
    return n.enter("reference"), n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), n.exit("reference"), e) : t(s);
  }
}
const iV = {
  name: "labelStartImage",
  resolveAll: O3.resolveAll,
  tokenize: sV
};
function sV(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(l), n.exit("labelImageMarker"), s;
  }
  function s(l) {
    return l === 91 ? (n.enter("labelMarker"), n.consume(l), n.exit("labelMarker"), n.exit("labelImage"), o) : t(l);
  }
  function o(l) {
    return l === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(l) : e(l);
  }
}
const oV = {
  name: "labelStartLink",
  resolveAll: O3.resolveAll,
  tokenize: lV
};
function lV(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : e(o);
  }
}
const u2 = {
  name: "lineEnding",
  tokenize: aV
};
function aV(n, e) {
  return t;
  function t(r) {
    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), qe(n, e, "linePrefix");
  }
}
const kp = {
  name: "thematicBreak",
  tokenize: cV
};
function cV(n, e, t) {
  let r = 0, i;
  return s;
  function s(c) {
    return n.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, l(c);
  }
  function l(c) {
    return c === i ? (n.enter("thematicBreakSequence"), a(c)) : r >= 3 && (c === null || ye(c)) ? (n.exit("thematicBreak"), e(c)) : t(c);
  }
  function a(c) {
    return c === i ? (n.consume(c), r++, a) : (n.exit("thematicBreakSequence"), Ue(c) ? qe(n, l, "whitespace")(c) : l(c));
  }
}
const Kn = {
  continuation: {
    tokenize: dV
  },
  exit: mV,
  name: "list",
  tokenize: fV
}, uV = {
  partial: !0,
  tokenize: gV
}, hV = {
  partial: !0,
  tokenize: pV
};
function fV(n, e, t) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return l;
  function l(d) {
    const p = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : Dy(d)) {
      if (r.containerState.type || (r.containerState.type = p, n.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return n.enter("listItemPrefix"), d === 42 || d === 45 ? n.check(kp, t, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return n.enter("listItemPrefix"), n.enter("listItemValue"), a(d);
    }
    return t(d);
  }
  function a(d) {
    return Dy(d) && ++o < 10 ? (n.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (n.exit("listItemValue"), c(d)) : t(d);
  }
  function c(d) {
    return n.enter("listItemMarker"), n.consume(d), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, n.check(
      Ld,
      // Canâ€™t be empty when interrupting.
      r.interrupt ? t : u,
      n.attempt(uV, f, h)
    );
  }
  function u(d) {
    return r.containerState.initialBlankLine = !0, s++, f(d);
  }
  function h(d) {
    return Ue(d) ? (n.enter("listItemPrefixWhitespace"), n.consume(d), n.exit("listItemPrefixWhitespace"), f) : t(d);
  }
  function f(d) {
    return r.containerState.size = s + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, e(d);
  }
}
function dV(n, e, t) {
  const r = this;
  return r.containerState._closeFlow = void 0, n.check(Ld, i, s);
  function i(l) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, qe(n, e, "listItemIndent", r.containerState.size + 1)(l);
  }
  function s(l) {
    return r.containerState.furtherBlankLines || !Ue(l) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(l)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(hV, e, o)(l));
  }
  function o(l) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, qe(n, n.attempt(Kn, e, t), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(l);
  }
}
function pV(n, e, t) {
  const r = this;
  return qe(n, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : t(s);
  }
}
function mV(n) {
  n.exit(this.containerState.type);
}
function gV(n, e, t) {
  const r = this;
  return qe(n, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !Ue(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : t(s);
  }
}
const Fw = {
  name: "setextUnderline",
  resolveTo: yV,
  tokenize: bV
};
function yV(n, e) {
  let t = n.length, r, i, s;
  for (; t--; )
    if (n[t][0] === "enter") {
      if (n[t][1].type === "content") {
        r = t;
        break;
      }
      n[t][1].type === "paragraph" && (i = t);
    } else
      n[t][1].type === "content" && n.splice(t, 1), !s && n[t][1].type === "definition" && (s = t);
  const o = {
    type: "setextHeading",
    start: {
      ...n[r][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  };
  return n[i][1].type = "setextHeadingText", s ? (n.splice(i, 0, ["enter", o, e]), n.splice(s + 1, 0, ["exit", n[r][1], e]), n[r][1].end = {
    ...n[s][1].end
  }) : n[r][1] = o, n.push(["exit", o, e]), n;
}
function bV(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length, h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (n.enter("setextHeadingLine"), i = c, o(c)) : t(c);
  }
  function o(c) {
    return n.enter("setextHeadingLineSequence"), l(c);
  }
  function l(c) {
    return c === i ? (n.consume(c), l) : (n.exit("setextHeadingLineSequence"), Ue(c) ? qe(n, a, "lineSuffix")(c) : a(c));
  }
  function a(c) {
    return c === null || ye(c) ? (n.exit("setextHeadingLine"), e(c)) : t(c);
  }
}
const vV = {
  tokenize: wV
};
function wV(n) {
  const e = this, t = n.attempt(
    // Try to parse a blank line.
    Ld,
    r,
    // Try to parse initial flow (essentially, only code).
    n.attempt(this.parser.constructs.flowInitial, i, qe(n, n.attempt(this.parser.constructs.flow, i, n.attempt(M$, i)), "linePrefix"))
  );
  return t;
  function r(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEndingBlank"), n.consume(s), n.exit("lineEndingBlank"), e.currentConstruct = void 0, t;
  }
  function i(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEnding"), n.consume(s), n.exit("lineEnding"), e.currentConstruct = void 0, t;
  }
}
const xV = {
  resolveAll: FM()
}, kV = _M("string"), SV = _M("text");
function _M(n) {
  return {
    resolveAll: FM(n === "text" ? CV : void 0),
    tokenize: e
  };
  function e(t) {
    const r = this, i = this.parser.constructs[n], s = t.attempt(i, o, l);
    return o;
    function o(u) {
      return c(u) ? s(u) : l(u);
    }
    function l(u) {
      if (u === null) {
        t.consume(u);
        return;
      }
      return t.enter("data"), t.consume(u), a;
    }
    function a(u) {
      return c(u) ? (t.exit("data"), s(u)) : (t.consume(u), a);
    }
    function c(u) {
      if (u === null)
        return !0;
      const h = i[u];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const d = h[f];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function FM(n) {
  return e;
  function e(t, r) {
    let i = -1, s;
    for (; ++i <= t.length; )
      s === void 0 ? t[i] && t[i][1].type === "data" && (s = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== s + 2 && (t[s][1].end = t[i - 1][1].end, t.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return n ? n(t, r) : t;
  }
}
function CV(n, e) {
  let t = 0;
  for (; ++t <= n.length; )
    if ((t === n.length || n[t][1].type === "lineEnding") && n[t - 1][1].type === "data") {
      const r = n[t - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, l = 0, a;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            l++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          a = !0, l++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && t === n.length && (l = 0), l) {
        const c = {
          type: t === n.length || a || l < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? o : r.start._bufferIndex + o,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - l,
            offset: r.end.offset - l
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(t, 0, ["enter", c, e], ["exit", c, e]), t += 2);
      }
      t++;
    }
  return n;
}
const MV = {
  42: Kn,
  43: Kn,
  45: Kn,
  48: Kn,
  49: Kn,
  50: Kn,
  51: Kn,
  52: Kn,
  53: Kn,
  54: Kn,
  55: Kn,
  56: Kn,
  57: Kn,
  62: DM
}, TV = {
  91: I$
}, AV = {
  [-2]: c2,
  [-1]: c2,
  32: c2
}, OV = {
  35: B$,
  42: kp,
  45: [Fw, kp],
  60: H$,
  61: Fw,
  95: kp,
  96: zw,
  126: zw
}, EV = {
  38: RM,
  92: NM
}, IV = {
  [-5]: u2,
  [-4]: u2,
  [-3]: u2,
  33: iV,
  38: RM,
  42: Ny,
  60: [o$, G$],
  91: oV,
  92: [P$, NM],
  93: O3,
  95: Ny,
  96: v$
}, DV = {
  null: [Ny, xV]
}, NV = {
  null: [42, 95]
}, RV = {
  null: []
}, PV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: NV,
  contentInitial: TV,
  disable: RV,
  document: MV,
  flow: OV,
  flowInitial: AV,
  insideSpan: DV,
  string: EV,
  text: IV
}, Symbol.toStringTag, { value: "Module" }));
function LV(n, e, t) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: t && t.line || 1,
    column: t && t.column || 1,
    offset: t && t.offset || 0
  };
  const i = {}, s = [];
  let o = [], l = [];
  const a = {
    attempt: I(M),
    check: I(C),
    consume: w,
    enter: k,
    exit: T,
    interrupt: I(C, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: m,
    events: [],
    now: p,
    parser: n,
    previous: null,
    sliceSerialize: f,
    sliceStream: d,
    write: h
  };
  let u = e.tokenize.call(c, a);
  return e.resolveAll && s.push(e), c;
  function h($) {
    return o = Wr(o, $), g(), o[o.length - 1] !== null ? [] : (_(e, 0), c.events = I1(s, c.events, c), c.events);
  }
  function f($, B) {
    return zV(d($), B);
  }
  function d($) {
    return BV(o, $);
  }
  function p() {
    const {
      _bufferIndex: $,
      _index: B,
      line: se,
      column: te,
      offset: ie
    } = r;
    return {
      _bufferIndex: $,
      _index: B,
      line: se,
      column: te,
      offset: ie
    };
  }
  function m($) {
    i[$.line] = $.column, L();
  }
  function g() {
    let $;
    for (; r._index < o.length; ) {
      const B = o[r._index];
      if (typeof B == "string")
        for ($ = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === $ && r._bufferIndex < B.length; )
          b(B.charCodeAt(r._bufferIndex));
      else
        b(B);
    }
  }
  function b($) {
    u = u($);
  }
  function w($) {
    ye($) ? (r.line++, r.column = 1, r.offset += $ === -3 ? 2 : 1, L()) : $ !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = $;
  }
  function k($, B) {
    const se = B || {};
    return se.type = $, se.start = p(), c.events.push(["enter", se, c]), l.push(se), se;
  }
  function T($) {
    const B = l.pop();
    return B.end = p(), c.events.push(["exit", B, c]), B;
  }
  function M($, B) {
    _($, B.from);
  }
  function C($, B) {
    B.restore();
  }
  function I($, B) {
    return se;
    function se(te, ie, Ce) {
      let Oe, Re, Be, D;
      return Array.isArray(te) ? (
        /* c8 ignore next 1 */
        _e(te)
      ) : "tokenize" in te ? (
        // Looks like a construct.
        _e([
          /** @type {Construct} */
          te
        ])
      ) : Me(te);
      function Me(Ke) {
        return Dt;
        function Dt(Pt) {
          const Zt = Pt !== null && Ke[Pt], on = Pt !== null && Ke.null, Lr = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Zt) ? Zt : Zt ? [Zt] : [],
            ...Array.isArray(on) ? on : on ? [on] : []
          ];
          return _e(Lr)(Pt);
        }
      }
      function _e(Ke) {
        return Oe = Ke, Re = 0, Ke.length === 0 ? Ce : O(Ke[Re]);
      }
      function O(Ke) {
        return Dt;
        function Dt(Pt) {
          return D = F(), Be = Ke, Ke.partial || (c.currentConstruct = Ke), Ke.name && c.parser.constructs.disable.null.includes(Ke.name) ? Le() : Ke.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.
            B ? Object.assign(Object.create(c), B) : c,
            a,
            rt,
            Le
          )(Pt);
        }
      }
      function rt(Ke) {
        return $(Be, D), ie;
      }
      function Le(Ke) {
        return D.restore(), ++Re < Oe.length ? O(Oe[Re]) : Ce;
      }
    }
  }
  function _($, B) {
    $.resolveAll && !s.includes($) && s.push($), $.resolve && Or(c.events, B, c.events.length - B, $.resolve(c.events.slice(B), c)), $.resolveTo && (c.events = $.resolveTo(c.events, c));
  }
  function F() {
    const $ = p(), B = c.previous, se = c.currentConstruct, te = c.events.length, ie = Array.from(l);
    return {
      from: te,
      restore: Ce
    };
    function Ce() {
      r = $, c.previous = B, c.currentConstruct = se, c.events.length = te, l = ie, L();
    }
  }
  function L() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function BV(n, e) {
  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  if (t === i)
    o = [n[t].slice(r, s)];
  else {
    if (o = n.slice(t, i), r > -1) {
      const l = o[0];
      typeof l == "string" ? o[0] = l.slice(r) : o.shift();
    }
    s > 0 && o.push(n[i].slice(0, s));
  }
  return o;
}
function zV(n, e) {
  let t = -1;
  const r = [];
  let i;
  for (; ++t < n.length; ) {
    const s = n[t];
    let o;
    if (typeof s == "string")
      o = s;
    else switch (s) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(s);
    }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
function _V(n) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      EM([PV, ...(n || {}).extensions || []])
    ),
    content: i(QH),
    defined: [],
    document: i(t$),
    flow: i(vV),
    lazy: {},
    string: i(kV),
    text: i(SV)
  };
  return r;
  function i(s) {
    return o;
    function o(l) {
      return LV(r, s, l);
    }
  }
}
function FV(n) {
  for (; !PM(n); )
    ;
  return n;
}
const Hw = /[\0\t\n\r]/g;
function HV() {
  let n = 1, e = "", t = !0, r;
  return i;
  function i(s, o, l) {
    const a = [];
    let c, u, h, f, d;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), h = 0, e = "", t && (s.charCodeAt(0) === 65279 && h++, t = void 0); h < s.length; ) {
      if (Hw.lastIndex = h, c = Hw.exec(s), f = c && c.index !== void 0 ? c.index : s.length, d = s.charCodeAt(f), !c) {
        e = s.slice(h);
        break;
      }
      if (d === 10 && h === f && r)
        a.push(-3), r = void 0;
      else
        switch (r && (a.push(-5), r = void 0), h < f && (a.push(s.slice(h, f)), n += f - h), d) {
          case 0: {
            a.push(65533), n++;
            break;
          }
          case 9: {
            for (u = Math.ceil(n / 4) * 4, a.push(-2); n++ < u; ) a.push(-1);
            break;
          }
          case 10: {
            a.push(-4), n = 1;
            break;
          }
          default:
            r = !0, n = 1;
        }
      h = f + 1;
    }
    return l && (r && a.push(-5), e && a.push(e), a.push(null)), a;
  }
}
const $V = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function HM(n) {
  return n.replace($V, VV);
}
function VV(n, e, t) {
  if (e)
    return e;
  if (t.charCodeAt(0) === 35) {
    const i = t.charCodeAt(1), s = i === 120 || i === 88;
    return IM(t.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return A3(t) || n;
}
function Qh(n) {
  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? $w(n.position) : "start" in n || "end" in n ? $w(n) : "line" in n || "column" in n ? Ry(n) : "";
}
function Ry(n) {
  return Vw(n && n.line) + ":" + Vw(n && n.column);
}
function $w(n) {
  return Ry(n && n.start) + "-" + Ry(n && n.end);
}
function Vw(n) {
  return n && typeof n == "number" ? n : 1;
}
const $M = {}.hasOwnProperty;
function qV(n, e, t) {
  return typeof e != "string" && (t = e, e = void 0), WV(t)(FV(_V(t).document().write(HV()(n, e, !0))));
}
function WV(n) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(In),
      autolinkProtocol: F,
      autolinkEmail: F,
      atxHeading: s(Br),
      blockQuote: s(on),
      characterEscape: F,
      characterReference: F,
      codeFenced: s(Lr),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(Lr, o),
      codeText: s(dr, o),
      codeTextData: F,
      data: F,
      codeFlowValue: F,
      definition: s(ci),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(vn),
      hardBreakEscape: s(zr),
      hardBreakTrailing: s(zr),
      htmlFlow: s(wn, o),
      htmlFlowData: F,
      htmlText: s(wn, o),
      htmlTextData: F,
      image: s(Un),
      label: o,
      link: s(In),
      listItem: s(cl),
      listItemValue: f,
      listOrdered: s(lo, h),
      listUnordered: s(lo),
      paragraph: s(Da),
      reference: O,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(Br),
      strong: s(ao),
      thematicBreak: s(ui)
    },
    exit: {
      atxHeading: a(),
      atxHeadingSequence: M,
      autolink: a(),
      autolinkEmail: Zt,
      autolinkProtocol: Pt,
      blockQuote: a(),
      characterEscapeValue: L,
      characterReferenceMarkerHexadecimal: Le,
      characterReferenceMarkerNumeric: Le,
      characterReferenceValue: Ke,
      characterReference: Dt,
      codeFenced: a(g),
      codeFencedFence: m,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: p,
      codeFlowValue: L,
      codeIndented: a(b),
      codeText: a(ie),
      codeTextData: L,
      data: L,
      definition: a(),
      definitionDestinationString: T,
      definitionLabelString: w,
      definitionTitleString: k,
      emphasis: a(),
      hardBreakEscape: a(B),
      hardBreakTrailing: a(B),
      htmlFlow: a(se),
      htmlFlowData: L,
      htmlText: a(te),
      htmlTextData: L,
      image: a(Oe),
      label: Be,
      labelText: Re,
      lineEnding: $,
      link: a(Ce),
      listItem: a(),
      listOrdered: a(),
      listUnordered: a(),
      paragraph: a(),
      referenceString: rt,
      resourceDestinationString: D,
      resourceTitleString: Me,
      resource: _e,
      setextHeading: a(_),
      setextHeadingLineSequence: I,
      setextHeadingText: C,
      strong: a(),
      thematicBreak: a()
    }
  };
  VM(e, (n || {}).mdastExtensions || []);
  const t = {};
  return r;
  function r(q) {
    let ne = {
      type: "root",
      children: []
    };
    const Ee = {
      stack: [ne],
      tokenStack: [],
      config: e,
      enter: l,
      exit: c,
      buffer: o,
      resume: u,
      data: t
    }, Fe = [];
    let Ye = -1;
    for (; ++Ye < q.length; )
      if (q[Ye][1].type === "listOrdered" || q[Ye][1].type === "listUnordered")
        if (q[Ye][0] === "enter")
          Fe.push(Ye);
        else {
          const ln = Fe.pop();
          Ye = i(q, ln, Ye);
        }
    for (Ye = -1; ++Ye < q.length; ) {
      const ln = e[q[Ye][0]];
      $M.call(ln, q[Ye][1].type) && ln[q[Ye][1].type].call(Object.assign({
        sliceSerialize: q[Ye][2].sliceSerialize
      }, Ee), q[Ye][1]);
    }
    if (Ee.tokenStack.length > 0) {
      const ln = Ee.tokenStack[Ee.tokenStack.length - 1];
      (ln[1] || qw).call(Ee, void 0, ln[0]);
    }
    for (ne.position = {
      start: ho(q.length > 0 ? q[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ho(q.length > 0 ? q[q.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ye = -1; ++Ye < e.transforms.length; )
      ne = e.transforms[Ye](ne) || ne;
    return ne;
  }
  function i(q, ne, Ee) {
    let Fe = ne - 1, Ye = -1, ln = !1, Dn, an, Qt, Nn;
    for (; ++Fe <= Ee; ) {
      const Ft = q[Fe];
      switch (Ft[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ft[0] === "enter" ? Ye++ : Ye--, Nn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ft[0] === "enter" && (Dn && !Nn && !Ye && !Qt && (Qt = Fe), Nn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Nn = void 0;
      }
      if (!Ye && Ft[0] === "enter" && Ft[1].type === "listItemPrefix" || Ye === -1 && Ft[0] === "exit" && (Ft[1].type === "listUnordered" || Ft[1].type === "listOrdered")) {
        if (Dn) {
          let pr = Fe;
          for (an = void 0; pr--; ) {
            const Gn = q[pr];
            if (Gn[1].type === "lineEnding" || Gn[1].type === "lineEndingBlank") {
              if (Gn[0] === "exit") continue;
              an && (q[an][1].type = "lineEndingBlank", ln = !0), Gn[1].type = "lineEnding", an = pr;
            } else if (!(Gn[1].type === "linePrefix" || Gn[1].type === "blockQuotePrefix" || Gn[1].type === "blockQuotePrefixWhitespace" || Gn[1].type === "blockQuoteMarker" || Gn[1].type === "listItemIndent")) break;
          }
          Qt && (!an || Qt < an) && (Dn._spread = !0), Dn.end = Object.assign({}, an ? q[an][1].start : Ft[1].end), q.splice(an || Fe, 0, ["exit", Dn, Ft[2]]), Fe++, Ee++;
        }
        if (Ft[1].type === "listItemPrefix") {
          const pr = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ft[1].start),
            // @ts-expect-error: weâ€™ll add `end` in a second.
            end: void 0
          };
          Dn = pr, q.splice(Fe, 0, ["enter", pr, Ft[2]]), Fe++, Ee++, Qt = void 0, Nn = !0;
        }
      }
    }
    return q[ne][1]._spread = ln, Ee;
  }
  function s(q, ne) {
    return Ee;
    function Ee(Fe) {
      l.call(this, q(Fe), Fe), ne && ne.call(this, Fe);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function l(q, ne, Ee) {
    this.stack[this.stack.length - 1].children.push(q), this.stack.push(q), this.tokenStack.push([ne, Ee || void 0]), q.position = {
      start: ho(ne.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function a(q) {
    return ne;
    function ne(Ee) {
      q && q.call(this, Ee), c.call(this, Ee);
    }
  }
  function c(q, ne) {
    const Ee = this.stack.pop(), Fe = this.tokenStack.pop();
    if (Fe)
      Fe[0].type !== q.type && (ne ? ne.call(this, q, Fe[0]) : (Fe[1] || qw).call(this, q, Fe[0]));
    else throw new Error("Cannot close `" + q.type + "` (" + Qh({
      start: q.start,
      end: q.end
    }) + "): itâ€™s not open");
    Ee.position.end = ho(q.end);
  }
  function u() {
    return T3(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(q) {
    if (this.data.expectingFirstListItemValue) {
      const ne = this.stack[this.stack.length - 2];
      ne.start = Number.parseInt(this.sliceSerialize(q), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.lang = q;
  }
  function p() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.meta = q;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function g() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.value = q.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function b() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.value = q.replace(/(\r?\n|\r)$/g, "");
  }
  function w(q) {
    const ne = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = ne, Ee.identifier = wi(this.sliceSerialize(q)).toLowerCase();
  }
  function k() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.title = q;
  }
  function T() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.url = q;
  }
  function M(q) {
    const ne = this.stack[this.stack.length - 1];
    if (!ne.depth) {
      const Ee = this.sliceSerialize(q).length;
      ne.depth = Ee;
    }
  }
  function C() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function I(q) {
    const ne = this.stack[this.stack.length - 1];
    ne.depth = this.sliceSerialize(q).codePointAt(0) === 61 ? 1 : 2;
  }
  function _() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function F(q) {
    const Ee = this.stack[this.stack.length - 1].children;
    let Fe = Ee[Ee.length - 1];
    (!Fe || Fe.type !== "text") && (Fe = Ri(), Fe.position = {
      start: ho(q.start),
      // @ts-expect-error: weâ€™ll add `end` later.
      end: void 0
    }, Ee.push(Fe)), this.stack.push(Fe);
  }
  function L(q) {
    const ne = this.stack.pop();
    ne.value += this.sliceSerialize(q), ne.position.end = ho(q.end);
  }
  function $(q) {
    const ne = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ee = ne.children[ne.children.length - 1];
      Ee.position.end = ho(q.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(ne.type) && (F.call(this, q), L.call(this, q));
  }
  function B() {
    this.data.atHardBreak = !0;
  }
  function se() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.value = q;
  }
  function te() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.value = q;
  }
  function ie() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.value = q;
  }
  function Ce() {
    const q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ne = this.data.referenceType || "shortcut";
      q.type += "Reference", q.referenceType = ne, delete q.url, delete q.title;
    } else
      delete q.identifier, delete q.label;
    this.data.referenceType = void 0;
  }
  function Oe() {
    const q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ne = this.data.referenceType || "shortcut";
      q.type += "Reference", q.referenceType = ne, delete q.url, delete q.title;
    } else
      delete q.identifier, delete q.label;
    this.data.referenceType = void 0;
  }
  function Re(q) {
    const ne = this.sliceSerialize(q), Ee = this.stack[this.stack.length - 2];
    Ee.label = HM(ne), Ee.identifier = wi(ne).toLowerCase();
  }
  function Be() {
    const q = this.stack[this.stack.length - 1], ne = this.resume(), Ee = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ee.type === "link") {
      const Fe = q.children;
      Ee.children = Fe;
    } else
      Ee.alt = ne;
  }
  function D() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.url = q;
  }
  function Me() {
    const q = this.resume(), ne = this.stack[this.stack.length - 1];
    ne.title = q;
  }
  function _e() {
    this.data.inReference = void 0;
  }
  function O() {
    this.data.referenceType = "collapsed";
  }
  function rt(q) {
    const ne = this.resume(), Ee = this.stack[this.stack.length - 1];
    Ee.label = ne, Ee.identifier = wi(this.sliceSerialize(q)).toLowerCase(), this.data.referenceType = "full";
  }
  function Le(q) {
    this.data.characterReferenceType = q.type;
  }
  function Ke(q) {
    const ne = this.sliceSerialize(q), Ee = this.data.characterReferenceType;
    let Fe;
    Ee ? (Fe = IM(ne, Ee === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Fe = A3(ne);
    const Ye = this.stack[this.stack.length - 1];
    Ye.value += Fe;
  }
  function Dt(q) {
    const ne = this.stack.pop();
    ne.position.end = ho(q.end);
  }
  function Pt(q) {
    L.call(this, q);
    const ne = this.stack[this.stack.length - 1];
    ne.url = this.sliceSerialize(q);
  }
  function Zt(q) {
    L.call(this, q);
    const ne = this.stack[this.stack.length - 1];
    ne.url = "mailto:" + this.sliceSerialize(q);
  }
  function on() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Lr() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function dr() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function ci() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function vn() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Br() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function zr() {
    return {
      type: "break"
    };
  }
  function wn() {
    return {
      type: "html",
      value: ""
    };
  }
  function Un() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function In() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function lo(q) {
    return {
      type: "list",
      ordered: q.type === "listOrdered",
      start: null,
      spread: q._spread,
      children: []
    };
  }
  function cl(q) {
    return {
      type: "listItem",
      spread: q._spread,
      checked: null,
      children: []
    };
  }
  function Da() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ao() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ri() {
    return {
      type: "text",
      value: ""
    };
  }
  function ui() {
    return {
      type: "thematicBreak"
    };
  }
}
function ho(n) {
  return {
    line: n.line,
    column: n.column,
    offset: n.offset
  };
}
function VM(n, e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t];
    Array.isArray(r) ? VM(n, r) : jV(n, r);
  }
}
function jV(n, e) {
  let t;
  for (t in e)
    if ($M.call(e, t))
      switch (t) {
        case "canContainEols": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "transforms": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[t];
          r && Object.assign(n[t], r);
          break;
        }
      }
}
function qw(n, e) {
  throw n ? new Error("Cannot close `" + n.type + "` (" + Qh({
    start: n.start,
    end: n.end
  }) + "): a different token (`" + e.type + "`, " + Qh({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + Qh({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function Py(n) {
  const e = this;
  e.parser = t;
  function t(r) {
    return qV(r, {
      ...e.data("settings"),
      ...n,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
const Ww = {}.hasOwnProperty;
function UV(n, e) {
  const t = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const l = r.handlers;
    if (i && Ww.call(i, n)) {
      const a = String(i[n]);
      o = Ww.call(l, a) ? l[a] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = t.handlers || {}, r.invalid = t.invalid, r.unknown = t.unknown, r;
}
const GV = {}.hasOwnProperty;
function qM(n, e) {
  let t = -1, r;
  if (e.extensions)
    for (; ++t < e.extensions.length; )
      qM(n, e.extensions[t]);
  for (r in e)
    if (GV.call(e, r))
      switch (r) {
        case "extensions":
          break;
        /* c8 ignore next 4 */
        case "unsafe": {
          jw(n[r], e[r]);
          break;
        }
        case "join": {
          jw(n[r], e[r]);
          break;
        }
        case "handlers": {
          KV(n[r], e[r]);
          break;
        }
        default:
          n.options[r] = e[r];
      }
  return n;
}
function jw(n, e) {
  e && n.push(...e);
}
function KV(n, e) {
  e && Object.assign(n, e);
}
function YV(n, e, t, r) {
  const i = t.enter("blockquote"), s = t.createTracker(r);
  s.move("> "), s.shift(2);
  const o = t.indentLines(
    t.containerFlow(n, s.current()),
    JV
  );
  return i(), o;
}
function JV(n, e, t) {
  return ">" + (t ? "" : " ") + n;
}
function WM(n, e) {
  return Uw(n, e.inConstruct, !0) && !Uw(n, e.notInConstruct, !1);
}
function Uw(n, e, t) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return t;
  let r = -1;
  for (; ++r < e.length; )
    if (n.includes(e[r]))
      return !0;
  return !1;
}
function Gw(n, e, t, r) {
  let i = -1;
  for (; ++i < t.unsafe.length; )
    if (t.unsafe[i].character === `
` && WM(t.stack, t.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function jM(n, e) {
  const t = String(n);
  let r = t.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = t.indexOf(e, i);
  return o;
}
function Ly(n, e) {
  return !!(e.options.fences === !1 && n.value && // If thereâ€™s no infoâ€¦
  !n.lang && // And thereâ€™s a non-whitespace characterâ€¦
  /[^ \r\n]/.test(n.value) && // And the value doesnâ€™t start or end in a blankâ€¦
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(n.value));
}
function XV(n) {
  const e = n.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function ZV(n, e, t, r) {
  const i = XV(t), s = n.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (Ly(n, t)) {
    const h = t.enter("codeIndented"), f = t.indentLines(s, QV);
    return h(), f;
  }
  const l = t.createTracker(r), a = i.repeat(Math.max(jM(s, i) + 1, 3)), c = t.enter("codeFenced");
  let u = l.move(a);
  if (n.lang) {
    const h = t.enter(`codeFencedLang${o}`);
    u += l.move(
      t.safe(n.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  if (n.lang && n.meta) {
    const h = t.enter(`codeFencedMeta${o}`);
    u += l.move(" "), u += l.move(
      t.safe(n.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...l.current()
      })
    ), h();
  }
  return u += l.move(`
`), s && (u += l.move(s + `
`)), u += l.move(a), c(), u;
}
function QV(n, e, t) {
  return (t ? "" : "    ") + n;
}
function E3(n) {
  const e = n.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function eq(n, e, t, r) {
  const i = E3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("definition");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("[");
  return c += a.move(
    t.safe(t.associationId(n), {
      before: c,
      after: "]",
      ...a.current()
    })
  ), c += a.move("]: "), l(), // If thereâ€™s no url, orâ€¦
  !n.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : `
`,
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), o(), c;
}
function tq(n) {
  const e = n.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function Go(n) {
  return "&#x" + n.toString(16).toUpperCase() + ";";
}
function Em(n, e, t) {
  const r = Jc(n), i = Jc(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    t === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
UM.peek = nq;
function UM(n, e, t, r) {
  const i = tq(t), s = t.enter("emphasis"), o = t.createTracker(r), l = o.move(i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = Em(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = Go(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = Em(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + Go(h));
  const d = o.move(i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function nq(n, e, t) {
  return t.options.emphasis || "*";
}
const D1 = (
  // Note: overloads in JSDoc canâ€™t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(n) {
    if (n == null)
      return oq;
    if (typeof n == "function")
      return N1(n);
    if (typeof n == "object")
      return Array.isArray(n) ? rq(n) : iq(n);
    if (typeof n == "string")
      return sq(n);
    throw new Error("Expected function, string, or object as test");
  }
);
function rq(n) {
  const e = [];
  let t = -1;
  for (; ++t < n.length; )
    e[t] = D1(n[t]);
  return N1(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function iq(n) {
  const e = (
    /** @type {Record<string, unknown>} */
    n
  );
  return N1(t);
  function t(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in n)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function sq(n) {
  return N1(e);
  function e(t) {
    return t && t.type === n;
  }
}
function N1(n) {
  return e;
  function e(t, r, i) {
    return !!(lq(t) && n.call(
      this,
      t,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function oq() {
  return !0;
}
function lq(n) {
  return n !== null && typeof n == "object" && "type" in n;
}
const GM = [], aq = !0, By = !1, zy = "skip";
function I3(n, e, t, r) {
  let i;
  typeof e == "function" && typeof t != "function" ? (r = t, t = e) : i = e;
  const s = D1(i), o = r ? -1 : 1;
  l(n, void 0, [])();
  function l(a, c, u) {
    const h = (
      /** @type {Record<string, unknown>} */
      a && typeof a == "object" ? a : {}
    );
    if (typeof h.type == "string") {
      const d = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (a.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let d = GM, p, m, g;
      if ((!e || s(a, c, u[u.length - 1] || void 0)) && (d = cq(t(a, u)), d[0] === By))
        return d;
      if ("children" in a && a.children) {
        const b = (
          /** @type {UnistParent} */
          a
        );
        if (b.children && d[0] !== zy)
          for (m = (r ? b.children.length : -1) + o, g = u.concat(b); m > -1 && m < b.children.length; ) {
            const w = b.children[m];
            if (p = l(w, m, g)(), p[0] === By)
              return p;
            m = typeof p[1] == "number" ? p[1] : m + o;
          }
      }
      return d;
    }
  }
}
function cq(n) {
  return Array.isArray(n) ? n : typeof n == "number" ? [aq, n] : n == null ? GM : [n];
}
function rl(n, e, t, r) {
  let i, s, o;
  typeof e == "function" && typeof t != "function" ? (s = void 0, o = e, i = t) : (s = e, o = t, i = r), I3(n, s, l, i);
  function l(a, c) {
    const u = c[c.length - 1], h = u ? u.children.indexOf(a) : void 0;
    return o(a, h, u);
  }
}
function KM(n, e) {
  let t = !1;
  return rl(n, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return t = !0, By;
  }), !!((!n.depth || n.depth < 3) && T3(n) && (e.options.setext || t));
}
function uq(n, e, t, r) {
  const i = Math.max(Math.min(6, n.depth || 1), 1), s = t.createTracker(r);
  if (KM(n, t)) {
    const u = t.enter("headingSetext"), h = t.enter("phrasing"), f = t.containerPhrasing(n, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole sizeâ€¦
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)â€¦
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), l = t.enter("headingAtx"), a = t.enter("phrasing");
  s.move(o + " ");
  let c = t.containerPhrasing(n, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(c) && (c = Go(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, t.options.closeAtx && (c += " " + o), a(), l(), c;
}
YM.peek = hq;
function YM(n) {
  return n.value || "";
}
function hq() {
  return "<";
}
JM.peek = fq;
function JM(n, e, t, r) {
  const i = E3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("image");
  let l = t.enter("label");
  const a = t.createTracker(r);
  let c = a.move("![");
  return c += a.move(
    t.safe(n.alt, { before: c, after: "]", ...a.current() })
  ), c += a.move("]("), l(), // If thereâ€™s no url but there is a titleâ€¦
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += a.move("<"), c += a.move(
    t.safe(n.url, { before: c, after: ">", ...a.current() })
  ), c += a.move(">")) : (l = t.enter("destinationRaw"), c += a.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...a.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += a.move(" " + i), c += a.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...a.current()
    })
  ), c += a.move(i), l()), c += a.move(")"), o(), c;
}
function fq() {
  return "!";
}
XM.peek = dq;
function XM(n, e, t, r) {
  const i = n.referenceType, s = t.enter("imageReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("![");
  const c = t.safe(n.alt, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function dq() {
  return "!";
}
ZM.peek = pq;
function ZM(n, e, t) {
  let r = n.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < t.unsafe.length; ) {
    const o = t.unsafe[s], l = t.compilePattern(o);
    let a;
    if (o.atBreak)
      for (; a = l.exec(r); ) {
        let c = a.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(a.index + 1);
      }
  }
  return i + r + i;
}
function pq() {
  return "`";
}
function QM(n, e) {
  const t = T3(n);
  return !!(!e.options.resourceLink && // If thereâ€™s a urlâ€¦
  n.url && // And thereâ€™s a no titleâ€¦
  !n.title && // And the content of `node` is a single text nodeâ€¦
  n.children && n.children.length === 1 && n.children[0].type === "text" && // And if the url is the same as the contentâ€¦
  (t === n.url || "mailto:" + t === n.url) && // And that starts w/ a protocolâ€¦
  /^[a-z][a-z+.-]+:/i.test(n.url) && // And that doesnâ€™t contain ASCII control codes (character escapes and
  // references donâ€™t work), space, or angle bracketsâ€¦
  !/[\0- <>\u007F]/.test(n.url));
}
eT.peek = mq;
function eT(n, e, t, r) {
  const i = E3(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.createTracker(r);
  let l, a;
  if (QM(n, t)) {
    const u = t.stack;
    t.stack = [], l = t.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      t.containerPhrasing(n, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), l(), t.stack = u, h;
  }
  l = t.enter("link"), a = t.enter("label");
  let c = o.move("[");
  return c += o.move(
    t.containerPhrasing(n, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), a(), // If thereâ€™s no url but there is a titleâ€¦
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (a = t.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    t.safe(n.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (a = t.enter("destinationRaw"), c += o.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...o.current()
    })
  )), a(), n.title && (a = t.enter(`title${s}`), c += o.move(" " + i), c += o.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), a()), c += o.move(")"), l(), c;
}
function mq(n, e, t) {
  return QM(n, t) ? "<" : "[";
}
tT.peek = gq;
function tT(n, e, t, r) {
  const i = n.referenceType, s = t.enter("linkReference");
  let o = t.enter("label");
  const l = t.createTracker(r);
  let a = l.move("[");
  const c = t.containerPhrasing(n, {
    before: a,
    after: "]",
    ...l.current()
  });
  a += l.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: a,
    after: "]",
    ...l.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? a += l.move(h + "]") : i === "shortcut" ? a = a.slice(0, -1) : a += l.move("]"), a;
}
function gq() {
  return "[";
}
function D3(n) {
  const e = n.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function yq(n) {
  const e = D3(n), t = n.options.bulletOther;
  if (!t)
    return e === "*" ? "-" : "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (t === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + t + "`) to be different"
    );
  return t;
}
function bq(n) {
  const e = n.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function nT(n) {
  const e = n.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function vq(n, e, t, r) {
  const i = t.enter("list"), s = t.bulletCurrent;
  let o = n.ordered ? bq(t) : D3(t);
  const l = n.ordered ? o === "." ? ")" : "." : yq(t);
  let a = e && t.bulletLastUsed ? o === t.bulletLastUsed : !1;
  if (!n.ordered) {
    const u = n.children ? n.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      t.stack[t.stack.length - 1] === "list" && t.stack[t.stack.length - 2] === "listItem" && t.stack[t.stack.length - 3] === "list" && t.stack[t.stack.length - 4] === "listItem" && // That are each the first child.
      t.indexStack[t.indexStack.length - 1] === 0 && t.indexStack[t.indexStack.length - 2] === 0 && t.indexStack[t.indexStack.length - 3] === 0 && (a = !0), nT(t) === o && u
    ) {
      let h = -1;
      for (; ++h < n.children.length; ) {
        const f = n.children[h];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          a = !0;
          break;
        }
      }
    }
  }
  a && (o = l), t.bulletCurrent = o;
  const c = t.containerFlow(n, r);
  return t.bulletLastUsed = o, t.bulletCurrent = s, i(), c;
}
function wq(n) {
  const e = n.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function xq(n, e, t, r) {
  const i = wq(t);
  let s = t.bulletCurrent || D3(t);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (t.options.incrementListMarker === !1 ? 0 : e.children.indexOf(n)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || n.spread)) && (o = Math.ceil(o / 4) * 4);
  const l = t.createTracker(r);
  l.move(s + " ".repeat(o - s.length)), l.shift(o);
  const a = t.enter("listItem"), c = t.indentLines(
    t.containerFlow(n, l.current()),
    u
  );
  return a(), c;
  function u(h, f, d) {
    return f ? (d ? "" : " ".repeat(o)) + h : (d ? s : s + " ".repeat(o - s.length)) + h;
  }
}
function kq(n, e, t, r) {
  const i = t.enter("paragraph"), s = t.enter("phrasing"), o = t.containerPhrasing(n, r);
  return s(), i(), o;
}
const Sq = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  D1([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function Cq(n, e, t, r) {
  return (n.children.some(function(o) {
    return Sq(o);
  }) ? t.containerPhrasing : t.containerFlow).call(t, n, r);
}
function Mq(n) {
  const e = n.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
rT.peek = Tq;
function rT(n, e, t, r) {
  const i = Mq(t), s = t.enter("strong"), o = t.createTracker(r), l = o.move(i + i);
  let a = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: l,
      ...o.current()
    })
  );
  const c = a.charCodeAt(0), u = Em(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (a = Go(c) + a.slice(1));
  const h = a.charCodeAt(a.length - 1), f = Em(r.after.charCodeAt(0), h, i);
  f.inside && (a = a.slice(0, -1) + Go(h));
  const d = o.move(i + i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, l + a + d;
}
function Tq(n, e, t) {
  return t.options.strong || "*";
}
function Aq(n, e, t, r) {
  return t.safe(n.value, r);
}
function Oq(n) {
  const e = n.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function Eq(n, e, t) {
  const r = (nT(t) + (t.options.ruleSpaces ? " " : "")).repeat(Oq(t));
  return t.options.ruleSpaces ? r.slice(0, -1) : r;
}
const N3 = {
  blockquote: YV,
  break: Gw,
  code: ZV,
  definition: eq,
  emphasis: UM,
  hardBreak: Gw,
  heading: uq,
  html: YM,
  image: JM,
  imageReference: XM,
  inlineCode: ZM,
  link: eT,
  linkReference: tT,
  list: vq,
  listItem: xq,
  paragraph: kq,
  root: Cq,
  strong: rT,
  text: Aq,
  thematicBreak: Eq
}, Iq = [Dq];
function Dq(n, e, t, r) {
  if (e.type === "code" && Ly(e, r) && (n.type === "list" || n.type === e.type && Ly(n, r)))
    return !1;
  if ("spread" in t && typeof t.spread == "boolean")
    return n.type === "paragraph" && // Two paragraphs.
    (n.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && KM(e, r)) ? void 0 : t.spread ? 1 : 0;
}
const dl = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], Nq = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: dl
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: dl
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: dl },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: dl
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: dl },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: dl },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: dl },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
];
function Rq(n) {
  return n.label || !n.identifier ? n.label || "" : HM(n.identifier);
}
function Pq(n) {
  if (!n._compiled) {
    const e = (n.atBreak ? "[\\r\\n][\\t ]*" : "") + (n.before ? "(?:" + n.before + ")" : "");
    n._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(n.character) ? "\\" : "") + n.character + (n.after ? "(?:" + n.after + ")" : ""),
      "g"
    );
  }
  return n._compiled;
}
function Lq(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = [];
  let o = -1, l = t.before, a;
  r.push(-1);
  let c = e.createTracker(t);
  for (; ++o < i.length; ) {
    const u = i[o];
    let h;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let p = e.handle.handlers[i[o + 1].type];
      p && p.peek && (p = p.peek), h = p ? p(i[o + 1], n, e, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      h = t.after;
    s.length > 0 && (l === "\r" || l === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), l = " ", c = e.createTracker(t), c.move(s.join("")));
    let f = e.handle(u, n, e, {
      ...c.current(),
      after: h,
      before: l
    });
    a && a === f.slice(0, 1) && (f = Go(a.charCodeAt(0)) + f.slice(1));
    const d = e.attentionEncodeSurroundingInfo;
    e.attentionEncodeSurroundingInfo = void 0, a = void 0, d && (s.length > 0 && d.before && l === s[s.length - 1].slice(-1) && (s[s.length - 1] = s[s.length - 1].slice(0, -1) + Go(l.charCodeAt(0))), d.after && (a = h)), c.move(f), s.push(f), l = f.slice(-1);
  }
  return r.pop(), s.join("");
}
function Bq(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = e.createTracker(t), o = [];
  let l = -1;
  for (r.push(-1); ++l < i.length; ) {
    const a = i[l];
    r[r.length - 1] = l, o.push(
      s.move(
        e.handle(a, n, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), a.type !== "list" && (e.bulletLastUsed = void 0), l < i.length - 1 && o.push(
      s.move(zq(a, i[l + 1], n, e))
    );
  }
  return r.pop(), o.join("");
}
function zq(n, e, t, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](n, e, t, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const _q = /\r?\n|\r/g;
function Fq(n, e) {
  const t = [];
  let r = 0, i = 0, s;
  for (; s = _q.exec(n); )
    o(n.slice(r, s.index)), t.push(s[0]), r = s.index + s[0].length, i++;
  return o(n.slice(r)), t.join("");
  function o(l) {
    t.push(e(l, i, !l));
  }
}
function Hq(n, e, t) {
  const r = (t.before || "") + (e || "") + (t.after || ""), i = [], s = [], o = {};
  let l = -1;
  for (; ++l < n.unsafe.length; ) {
    const u = n.unsafe[l];
    if (!WM(n.stack, u))
      continue;
    const h = n.compilePattern(u);
    let f;
    for (; f = h.exec(r); ) {
      const d = "before" in u || !!u.atBreak, p = "after" in u, m = f.index + (d ? f[1].length : 0);
      i.includes(m) ? (o[m].before && !d && (o[m].before = !1), o[m].after && !p && (o[m].after = !1)) : (i.push(m), o[m] = { before: d, after: p });
    }
  }
  i.sort($q);
  let a = t.before ? t.before.length : 0;
  const c = r.length - (t.after ? t.after.length : 0);
  for (l = -1; ++l < i.length; ) {
    const u = i[l];
    u < a || u >= c || u + 1 < c && i[l + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after || i[l - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after || (a !== u && s.push(Kw(r.slice(a, u), "\\")), a = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!t.encode || !t.encode.includes(r.charAt(u))) ? s.push("\\") : (s.push(Go(r.charCodeAt(u))), a++));
  }
  return s.push(Kw(r.slice(a, c), t.after)), s.join("");
}
function $q(n, e) {
  return n - e;
}
function Kw(n, e) {
  const t = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = n + e;
  let o = -1, l = 0, a;
  for (; a = t.exec(s); )
    r.push(a.index);
  for (; ++o < r.length; )
    l !== r[o] && i.push(n.slice(l, r[o])), i.push("\\"), l = r[o];
  return i.push(n.slice(l)), i.join("");
}
function Vq(n) {
  const e = n || {}, t = e.now || {};
  let r = e.lineShift || 0, i = t.line || 1, s = t.column || 1;
  return { move: a, current: o, shift: l };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function l(c) {
    r += c;
  }
  function a(c) {
    const u = c || "", h = u.split(/\r?\n|\r/g), f = h[h.length - 1];
    return i += h.length - 1, s = h.length === 1 ? s + f.length : 1 + f.length + r, u;
  }
}
function qq(n, e) {
  const t = e || {}, r = {
    associationId: Rq,
    containerPhrasing: Gq,
    containerFlow: Kq,
    createTracker: Vq,
    compilePattern: Pq,
    enter: s,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...N3 },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: Fq,
    indexStack: [],
    join: [...Iq],
    options: {},
    safe: Yq,
    stack: [],
    unsafe: [...Nq]
  };
  qM(r, t), r.options.tightDefinitions && r.join.push(Uq), r.handle = UV("type", {
    invalid: Wq,
    unknown: jq,
    handlers: r.handlers
  });
  let i = r.handle(n, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return i && i.charCodeAt(i.length - 1) !== 10 && i.charCodeAt(i.length - 1) !== 13 && (i += `
`), i;
  function s(o) {
    return r.stack.push(o), l;
    function l() {
      r.stack.pop();
    }
  }
}
function Wq(n) {
  throw new Error("Cannot handle value `" + n + "`, expected node");
}
function jq(n) {
  const e = (
    /** @type {Nodes} */
    n
  );
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function Uq(n, e) {
  if (n.type === "definition" && n.type === e.type)
    return 0;
}
function Gq(n, e) {
  return Lq(n, this, e);
}
function Kq(n, e) {
  return Bq(n, this, e);
}
function Yq(n, e) {
  return Hq(this, n, e);
}
function _y(n) {
  const e = this;
  e.compiler = t;
  function t(r) {
    return qq(r, {
      ...e.data("settings"),
      ...n,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("toMarkdownExtensions") || []
    });
  }
}
function Yw(n) {
  if (n)
    throw n;
}
function Jq(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var h2, Jw;
function Xq() {
  if (Jw) return h2;
  Jw = 1;
  var n = Object.prototype.hasOwnProperty, e = Object.prototype.toString, t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : e.call(c) === "[object Array]";
  }, s = function(c) {
    if (!c || e.call(c) !== "[object Object]")
      return !1;
    var u = n.call(c, "constructor"), h = c.constructor && c.constructor.prototype && n.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !u && !h)
      return !1;
    var f;
    for (f in c)
      ;
    return typeof f > "u" || n.call(c, f);
  }, o = function(c, u) {
    t && u.name === "__proto__" ? t(c, u.name, {
      enumerable: !0,
      configurable: !0,
      value: u.newValue,
      writable: !0
    }) : c[u.name] = u.newValue;
  }, l = function(c, u) {
    if (u === "__proto__")
      if (n.call(c, u)) {
        if (r)
          return r(c, u).value;
      } else return;
    return c[u];
  };
  return h2 = function a() {
    var c, u, h, f, d, p, m = arguments[0], g = 1, b = arguments.length, w = !1;
    for (typeof m == "boolean" && (w = m, m = arguments[1] || {}, g = 2), (m == null || typeof m != "object" && typeof m != "function") && (m = {}); g < b; ++g)
      if (c = arguments[g], c != null)
        for (u in c)
          h = l(m, u), f = l(c, u), m !== f && (w && f && (s(f) || (d = i(f))) ? (d ? (d = !1, p = h && i(h) ? h : []) : p = h && s(h) ? h : {}, o(m, { name: u, newValue: a(w, p, f) })) : typeof f < "u" && o(m, { name: u, newValue: f }));
    return m;
  }, h2;
}
var Zq = Xq();
const f2 = /* @__PURE__ */ Jq(Zq);
function Fy(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function Qq() {
  const n = [], e = { run: t, use: r };
  return e;
  function t(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    l(null, ...i);
    function l(a, ...c) {
      const u = n[++s];
      let h = -1;
      if (a) {
        o(a);
        return;
      }
      for (; ++h < i.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
      i = c, u ? eW(u, l)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n.push(i), e;
  }
}
function eW(n, e) {
  let t;
  return r;
  function r(...o) {
    const l = n.length > o.length;
    let a;
    l && o.push(i);
    try {
      a = n.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (l && t)
        throw u;
      return i(u);
    }
    l || (a && a.then && typeof a.then == "function" ? a.then(s, i) : a instanceof Error ? i(a) : s(a));
  }
  function i(o, ...l) {
    t || (t = !0, e(o, ...l));
  }
  function s(o) {
    i(null, o);
  }
}
class ur extends Error {
  /**
   * Create a message for `reason`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, t, r) {
    super(), typeof t == "string" && (r = t, t = void 0);
    let i = "", s = {}, o = !1;
    if (t && ("line" in t && "column" in t ? s = { place: t } : "start" in t && "end" in t ? s = { place: t } : "type" in t ? s = {
      ancestors: [t],
      place: t.position
    } : s = { ...t }), typeof e == "string" ? i = e : !s.cause && e && (o = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const a = r.indexOf(":");
      a === -1 ? s.ruleId = r : (s.source = r.slice(0, a), s.ruleId = r.slice(a + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const a = s.ancestors[s.ancestors.length - 1];
      a && (s.place = a.position);
    }
    const l = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = l ? l.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = l ? l.line : void 0, this.name = Qh(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
ur.prototype.file = "";
ur.prototype.name = "";
ur.prototype.reason = "";
ur.prototype.message = "";
ur.prototype.stack = "";
ur.prototype.column = void 0;
ur.prototype.line = void 0;
ur.prototype.ancestors = void 0;
ur.prototype.cause = void 0;
ur.prototype.fatal = void 0;
ur.prototype.place = void 0;
ur.prototype.ruleId = void 0;
ur.prototype.source = void 0;
const $i = { basename: tW, dirname: nW, extname: rW, join: iW, sep: "/" };
function tW(n, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  Bd(n);
  let t = 0, r = -1, i = n.length, s;
  if (e === void 0 || e.length === 0 || e.length > n.length) {
    for (; i--; )
      if (n.codePointAt(i) === 47) {
        if (s) {
          t = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : n.slice(t, r);
  }
  if (e === n)
    return "";
  let o = -1, l = e.length - 1;
  for (; i--; )
    if (n.codePointAt(i) === 47) {
      if (s) {
        t = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), l > -1 && (n.codePointAt(i) === e.codePointAt(l--) ? l < 0 && (r = i) : (l = -1, r = o));
  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);
}
function nW(n) {
  if (Bd(n), n.length === 0)
    return ".";
  let e = -1, t = n.length, r;
  for (; --t; )
    if (n.codePointAt(t) === 47) {
      if (r) {
        e = t;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? n.codePointAt(0) === 47 ? "/" : "." : e === 1 && n.codePointAt(0) === 47 ? "//" : n.slice(0, e);
}
function rW(n) {
  Bd(n);
  let e = n.length, t = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const l = n.codePointAt(e);
    if (l === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    t < 0 && (o = !0, t = e + 1), l === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === t - 1 && i === r + 1 ? "" : n.slice(i, t);
}
function iW(...n) {
  let e = -1, t;
  for (; ++e < n.length; )
    Bd(n[e]), n[e] && (t = t === void 0 ? n[e] : t + "/" + n[e]);
  return t === void 0 ? "." : sW(t);
}
function sW(n) {
  Bd(n);
  const e = n.codePointAt(0) === 47;
  let t = oW(n, !e);
  return t.length === 0 && !e && (t = "."), t.length > 0 && n.codePointAt(n.length - 1) === 47 && (t += "/"), e ? "/" + t : t;
}
function oW(n, e) {
  let t = "", r = 0, i = -1, s = 0, o = -1, l, a;
  for (; ++o <= n.length; ) {
    if (o < n.length)
      l = n.codePointAt(o);
    else {
      if (l === 47)
        break;
      l = 47;
    }
    if (l === 47) {
      if (!(i === o - 1 || s === 1)) if (i !== o - 1 && s === 2) {
        if (t.length < 2 || r !== 2 || t.codePointAt(t.length - 1) !== 46 || t.codePointAt(t.length - 2) !== 46) {
          if (t.length > 2) {
            if (a = t.lastIndexOf("/"), a !== t.length - 1) {
              a < 0 ? (t = "", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf("/")), i = o, s = 0;
              continue;
            }
          } else if (t.length > 0) {
            t = "", r = 0, i = o, s = 0;
            continue;
          }
        }
        e && (t = t.length > 0 ? t + "/.." : "..", r = 2);
      } else
        t.length > 0 ? t += "/" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else l === 46 && s > -1 ? s++ : s = -1;
  }
  return t;
}
function Bd(n) {
  if (typeof n != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n)
    );
}
const lW = { cwd: aW };
function aW() {
  return "/";
}
function Hy(n) {
  return !!(n !== null && typeof n == "object" && "href" in n && n.href && "protocol" in n && n.protocol && // @ts-expect-error: indexing is fine.
  n.auth === void 0);
}
function cW(n) {
  if (typeof n == "string")
    n = new URL(n);
  else if (!Hy(n)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (n.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return uW(n);
}
function uW(n) {
  if (n.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = n.pathname;
  let t = -1;
  for (; ++t < e.length; )
    if (e.codePointAt(t) === 37 && e.codePointAt(t + 1) === 50) {
      const r = e.codePointAt(t + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const d2 = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class hW {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` â€” `{value: options}`
   * *   `URL` â€” `{path: options}`
   * *   `VFile` â€” shallow copies its data over to the new file
   * *   `object` â€” all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let t;
    e ? Hy(e) ? t = { path: e } : typeof e == "string" || fW(e) ? t = { value: e } : t = e : t = {}, this.cwd = "cwd" in t ? "" : lW.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < d2.length; ) {
      const s = d2[r];
      s in t && t[s] !== void 0 && t[s] !== null && (this[s] = s === "history" ? [...t[s]] : t[s]);
    }
    let i;
    for (i in t)
      d2.includes(i) || (this[i] = t[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? $i.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    m2(e, "basename"), p2(e, "basename"), this.path = $i.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? $i.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    Xw(this.basename, "dirname"), this.path = $i.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? $i.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if thereâ€™s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (p2(e, "extname"), Xw(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = $i.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    Hy(e) && (e = cW(e)), m2(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? $i.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    m2(e, "stem"), p2(e, "stem"), this.path = $i.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, t, r) {
    const i = this.message(e, t, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, t, r) {
    const i = this.message(e, t, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > ðŸª¦ **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, t, r) {
    const i = new ur(
      // @ts-expect-error: the overloads are fine.
      e,
      t,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when itâ€™s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function p2(n, e) {
  if (n && n.includes($i.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + $i.sep + "`"
    );
}
function m2(n, e) {
  if (!n)
    throw new Error("`" + e + "` cannot be empty");
}
function Xw(n, e) {
  if (!n)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function fW(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
const dW = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(n) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[n], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  }
), pW = {}.hasOwnProperty;
class R3 extends dW {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Qq();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new R3()
    );
    let t = -1;
    for (; ++t < this.attachers.length; ) {
      const r = this.attachers[t];
      e.use(...r);
    }
    return e.data(f2(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, t) {
    return typeof e == "string" ? arguments.length === 2 ? (b2("data", this.frozen), this.namespace[e] = t, this) : pW.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (b2("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [t, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = t.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const t = L0(e), r = this.parser || this.Parser;
    return g2("parse", r), r(String(t), t);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, t) {
    const r = this;
    return this.freeze(), g2("process", this.parser || this.Parser), y2("process", this.compiler || this.Compiler), t ? i(void 0, t) : new Promise(i);
    function i(s, o) {
      const l = L0(e), a = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(l)
      );
      r.run(a, l, function(u, h, f) {
        if (u || !h || !f)
          return c(u);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), p = r.stringify(d, f);
        gW(p) ? f.value = p : f.result = p, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, h) {
        u || !h ? o(u) : s ? s(h) : t(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let t = !1, r;
    return this.freeze(), g2("processSync", this.parser || this.Parser), y2("processSync", this.compiler || this.Compiler), this.process(e, i), Qw("processSync", "process", t), r;
    function i(s, o) {
      t = !0, Yw(s), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, t, r) {
    Zw(e), this.freeze();
    const i = this.transformers;
    return !r && typeof t == "function" && (r = t, t = void 0), r ? s(void 0, r) : new Promise(s);
    function s(o, l) {
      const a = L0(t);
      i.run(e, a, c);
      function c(u, h, f) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || e
        );
        u ? l(u) : o ? o(d) : r(void 0, d, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, t) {
    let r = !1, i;
    return this.run(e, t, s), Qw("runSync", "run", r), i;
    function s(o, l) {
      Yw(o), i = l, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, t) {
    this.freeze();
    const r = L0(t), i = this.compiler || this.Compiler;
    return y2("stringify", i), Zw(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...t) {
    const r = this.attachers, i = this.namespace;
    if (b2("use", this.frozen), e != null) if (typeof e == "function")
      a(e, t);
    else if (typeof e == "object")
      Array.isArray(e) ? l(e) : o(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(c) {
      if (typeof c == "function")
        a(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          a(u, h);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      l(c.plugins), c.settings && (i.settings = f2(!0, i.settings, c.settings));
    }
    function l(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const h = c[u];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function a(c, u) {
      let h = -1, f = -1;
      for (; ++h < r.length; )
        if (r[h][0] === c) {
          f = h;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [d, ...p] = u;
        const m = r[f][1];
        Fy(m) && Fy(d) && (d = f2(!0, m, d)), r[f] = [c, d, ...p];
      }
    }
  }
}
const $y = new R3().freeze();
function g2(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `parser`");
}
function y2(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `compiler`");
}
function b2(n, e) {
  if (e)
    throw new Error(
      "Cannot call `" + n + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Zw(n) {
  if (!Fy(n) || typeof n.type != "string")
    throw new TypeError("Expected node, got `" + n + "`");
}
function Qw(n, e, t) {
  if (!t)
    throw new Error(
      "`" + n + "` finished async. Use `" + e + "` instead"
    );
}
function L0(n) {
  return mW(n) ? n : new hW(n);
}
function mW(n) {
  return !!(n && typeof n == "object" && "message" in n && "messages" in n);
}
function gW(n) {
  return typeof n == "string" || yW(n);
}
function yW(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
var iT = (n) => {
  throw TypeError(n);
}, sT = (n, e, t) => e.has(n) || iT("Cannot " + t), Ve = (n, e, t) => (sT(n, e, "read from private field"), t ? t.call(n) : e.get(n)), $t = (n, e, t) => e.has(n) ? iT("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), bt = (n, e, t, r) => (sT(n, e, "write to private field"), e.set(n, t), t), Fi, dh, Sp, Cp, Mp, ph, mh, ws, gh, Tp, Ap, yh, Op, bh, Ep, Ip, qa, xl, Dp, vh;
class oT {
}
class lT {
  constructor() {
    this.elements = [], this.size = () => this.elements.length, this.top = () => this.elements.at(-1), this.push = (e) => {
      var t;
      (t = this.top()) == null || t.push(e);
    }, this.open = (e) => {
      this.elements.push(e);
    }, this.close = () => {
      const e = this.elements.pop();
      if (!e) throw bM();
      return e;
    };
  }
}
class P3 extends oT {
  constructor(e, t, r) {
    super(), this.type = e, this.content = t, this.attrs = r;
  }
  push(e, ...t) {
    this.content.push(e, ...t);
  }
  pop() {
    return this.content.pop();
  }
  static create(e, t, r) {
    return new P3(e, t, r);
  }
}
const Vy = class extends lT {
  /// @internal
  constructor(e) {
    super(), $t(this, Fi), $t(this, dh), $t(this, Sp), $t(this, Cp), $t(this, Mp), $t(this, ph), $t(this, mh), bt(this, Fi, $e.none), bt(this, dh, (t) => t.isText), bt(this, Sp, (t, r) => {
      if (Ve(this, dh).call(this, t) && Ve(this, dh).call(this, r) && $e.sameSet(t.marks, r.marks))
        return this.schema.text(t.text + r.text, t.marks);
    }), bt(this, Cp, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.parseMarkdown.match(t));
      if (!r) throw fH(t);
      return r;
    }), bt(this, Mp, (t) => {
      const r = Ve(this, Cp).call(this, t);
      r.spec.parseMarkdown.runner(this, t, r);
    }), this.injectRoot = (t, r, i) => (this.openNode(r, i), this.next(t.children), this), this.openNode = (t, r) => (this.open(P3.create(t, [], r)), this), bt(this, ph, () => {
      bt(this, Fi, $e.none);
      const t = this.close();
      return Ve(this, mh).call(this, t.type, t.attrs, t.content);
    }), this.closeNode = () => {
      try {
        Ve(this, ph).call(this);
      } catch (t) {
        console.error(t);
      }
      return this;
    }, bt(this, mh, (t, r, i) => {
      const s = t.createAndFill(r, i, Ve(this, Fi));
      if (!s) throw hH(t, r, i);
      return this.push(s), s;
    }), this.addNode = (t, r, i) => {
      try {
        Ve(this, mh).call(this, t, r, i);
      } catch (s) {
        console.error(s);
      }
      return this;
    }, this.openMark = (t, r) => {
      const i = t.create(r);
      return bt(this, Fi, i.addToSet(Ve(this, Fi))), this;
    }, this.closeMark = (t) => (bt(this, Fi, t.removeFromSet(Ve(this, Fi))), this), this.addText = (t) => {
      try {
        const r = this.top();
        if (!r) throw bM();
        const i = r.pop(), s = this.schema.text(t, Ve(this, Fi));
        if (!i)
          return r.push(s), this;
        const o = Ve(this, Sp).call(this, i, s);
        return o ? (r.push(o), this) : (r.push(i, s), this);
      } catch (r) {
        return console.error(r), this;
      }
    }, this.build = () => {
      let t;
      do
        t = Ve(this, ph).call(this);
      while (this.size());
      return t;
    }, this.next = (t = []) => ([t].flat().forEach((r) => Ve(this, Mp).call(this, r)), this), this.toDoc = () => this.build(), this.run = (t, r) => {
      const i = t.runSync(
        t.parse(r),
        r
      );
      return this.next(i), this;
    }, this.schema = e;
  }
};
Fi = /* @__PURE__ */ new WeakMap();
dh = /* @__PURE__ */ new WeakMap();
Sp = /* @__PURE__ */ new WeakMap();
Cp = /* @__PURE__ */ new WeakMap();
Mp = /* @__PURE__ */ new WeakMap();
ph = /* @__PURE__ */ new WeakMap();
mh = /* @__PURE__ */ new WeakMap();
Vy.create = (n, e) => {
  const t = new Vy(n);
  return (r) => (t.run(e, r), t.toDoc());
};
let bW = Vy;
const qy = class extends oT {
  constructor(e, t, r, i = {}) {
    super(), this.type = e, this.children = t, this.value = r, this.props = i, this.push = (s, ...o) => {
      this.children || (this.children = []), this.children.push(s, ...o);
    }, this.pop = () => {
      var s;
      return (s = this.children) == null ? void 0 : s.pop();
    };
  }
};
qy.create = (n, e, t, r = {}) => new qy(n, e, t, r);
let e8 = qy;
const vW = (n) => Object.prototype.hasOwnProperty.call(n, "size"), Wy = class extends lT {
  /// @internal
  constructor(e) {
    super(), $t(this, ws), $t(this, gh), $t(this, Tp), $t(this, Ap), $t(this, yh), $t(this, Op), $t(this, bh), $t(this, Ep), $t(this, Ip), $t(this, qa), $t(this, xl), $t(this, Dp), $t(this, vh), bt(this, ws, $e.none), bt(this, gh, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.toMarkdown.match(t));
      if (!r) throw dH(t.type);
      return r;
    }), bt(this, Tp, (t) => Ve(this, gh).call(this, t).spec.toMarkdown.runner(this, t)), bt(this, Ap, (t, r) => Ve(this, gh).call(this, t).spec.toMarkdown.runner(this, t, r)), bt(this, yh, (t) => {
      const { marks: r } = t, i = (l) => l.type.spec.priority ?? 50;
      [...r].sort((l, a) => i(l) - i(a)).every((l) => !Ve(this, Ap).call(this, l, t)) && Ve(this, Tp).call(this, t), r.forEach((l) => Ve(this, vh).call(this, l));
    }), bt(this, Op, (t, r) => {
      var a;
      if (t.type === r || ((a = t.children) == null ? void 0 : a.length) !== 1) return t;
      const i = (c) => {
        var h;
        if (c.type === r) return c;
        if (((h = c.children) == null ? void 0 : h.length) !== 1) return null;
        const [u] = c.children;
        return u ? i(u) : null;
      }, s = i(t);
      if (!s) return t;
      const o = s.children ? [...s.children] : void 0, l = { ...t, children: o };
      return l.children = o, s.children = [l], s;
    }), bt(this, bh, (t) => {
      const { children: r } = t;
      return r && (t.children = r.reduce((i, s, o) => {
        if (o === 0) return [s];
        const l = i.at(-1);
        if (l && l.isMark && s.isMark) {
          s = Ve(this, Op).call(this, s, l.type);
          const { children: a, ...c } = s, { children: u, ...h } = l;
          if (s.type === l.type && a && u && JSON.stringify(c) === JSON.stringify(h)) {
            const f = {
              ...h,
              children: [...u, ...a]
            };
            return i.slice(0, -1).concat(Ve(this, bh).call(this, f));
          }
        }
        return i.concat(s);
      }, [])), t;
    }), bt(this, Ep, (t) => {
      const r = {
        ...t.props,
        type: t.type
      };
      return t.children && (r.children = t.children), t.value && (r.value = t.value), r;
    }), this.openNode = (t, r, i) => (this.open(e8.create(t, void 0, r, i)), this), bt(this, Ip, (t, r) => {
      let i = "", s = "";
      const o = t.children;
      let l = -1, a = -1;
      const c = (h) => {
        h && h.forEach((f, d) => {
          f.type === "text" && f.value && (l < 0 && (l = d), a = d);
        });
      };
      if (o) {
        c(o);
        const h = o == null ? void 0 : o[a], f = o == null ? void 0 : o[l];
        if (h && h.value.endsWith(" ")) {
          const d = h.value, p = d.trimEnd();
          s = d.slice(p.length), h.value = p;
        }
        if (f && f.value.startsWith(" ")) {
          const d = f.value, p = d.trimStart();
          i = d.slice(0, d.length - p.length), f.value = p;
        }
      }
      i.length && Ve(this, xl).call(this, "text", void 0, i);
      const u = r();
      return s.length && Ve(this, xl).call(this, "text", void 0, s), u;
    }), bt(this, qa, (t = !1) => {
      const r = this.close(), i = () => Ve(this, xl).call(this, r.type, r.children, r.value, r.props);
      return t ? Ve(this, Ip).call(this, r, i) : i();
    }), this.closeNode = () => (Ve(this, qa).call(this), this), bt(this, xl, (t, r, i, s) => {
      const o = e8.create(t, r, i, s), l = Ve(this, bh).call(this, Ve(this, Ep).call(this, o));
      return this.push(l), l;
    }), this.addNode = (t, r, i, s) => (Ve(this, xl).call(this, t, r, i, s), this), bt(this, Dp, (t, r, i, s) => t.isInSet(Ve(this, ws)) ? this : (bt(this, ws, t.addToSet(Ve(this, ws))), this.openNode(r, i, { ...s, isMark: !0 }))), bt(this, vh, (t) => {
      t.isInSet(Ve(this, ws)) && (bt(this, ws, t.type.removeFromSet(Ve(this, ws))), Ve(this, qa).call(this, !0));
    }), this.withMark = (t, r, i, s) => (Ve(this, Dp).call(this, t, r, i, s), this), this.closeMark = (t) => (Ve(this, vh).call(this, t), this), this.build = () => {
      let t = null;
      do
        t = Ve(this, qa).call(this);
      while (this.size());
      return t;
    }, this.next = (t) => vW(t) ? (t.forEach((r) => {
      Ve(this, yh).call(this, r);
    }), this) : (Ve(this, yh).call(this, t), this), this.toString = (t) => t.stringify(this.build()), this.run = (t) => (this.next(t), this), this.schema = e;
  }
};
ws = /* @__PURE__ */ new WeakMap();
gh = /* @__PURE__ */ new WeakMap();
Tp = /* @__PURE__ */ new WeakMap();
Ap = /* @__PURE__ */ new WeakMap();
yh = /* @__PURE__ */ new WeakMap();
Op = /* @__PURE__ */ new WeakMap();
bh = /* @__PURE__ */ new WeakMap();
Ep = /* @__PURE__ */ new WeakMap();
Ip = /* @__PURE__ */ new WeakMap();
qa = /* @__PURE__ */ new WeakMap();
xl = /* @__PURE__ */ new WeakMap();
Dp = /* @__PURE__ */ new WeakMap();
vh = /* @__PURE__ */ new WeakMap();
Wy.create = (n, e) => {
  const t = new Wy(n);
  return (r) => (t.run(r), t.toString(e));
};
let wW = Wy;
const L3 = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function aT(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const cT = (n, e, t) => {
  let r = aT(n, t);
  if (!r)
    return !1;
  let i = B3(r);
  if (!i) {
    let o = r.blockRange(), l = o && x1(o);
    return l == null ? !1 : (e && e(n.tr.lift(o, l).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (dT(n, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (Xc(s, "end") || ve.isSelectable(s)))
    for (let o = r.depth; ; o--) {
      let l = S1(n.doc, r.before(o), r.after(o), ue.empty);
      if (l && l.slice.size < l.to - l.from) {
        if (e) {
          let a = n.tr.step(l);
          a.setSelection(Xc(s, "end") ? Pe.findFrom(a.doc.resolve(a.mapping.map(i.pos, -1)), -1) : ve.create(a.doc, i.pos - s.nodeSize)), e(a.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, xW = (n, e, t) => {
  let r = aT(n, t);
  if (!r)
    return !1;
  let i = B3(r);
  return i ? kW(n, i, e) : !1;
};
function kW(n, e, t) {
  let r = e.nodeBefore, i = r, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let o = e.nodeAfter, l = o, a = e.pos + 1;
  for (; !l.isTextblock; a++) {
    if (l.type.spec.isolating)
      return !1;
    let u = l.firstChild;
    if (!u)
      return !1;
    l = u;
  }
  let c = S1(n.doc, s, a, ue.empty);
  if (!c || c.from != s || c instanceof tn && c.slice.size >= a - s)
    return !1;
  if (t) {
    let u = n.tr.step(c);
    u.setSelection(ge.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function Xc(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const uT = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    s = B3(r);
  }
  let o = s && s.nodeBefore;
  return !o || !ve.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(ve.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function B3(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function SW(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const CW = (n, e, t) => {
  let r = SW(n, t);
  if (!r)
    return !1;
  let i = hT(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (dT(n, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (Xc(s, "start") || ve.isSelectable(s))) {
    let o = S1(n.doc, r.before(), r.after(), ue.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let l = n.tr.step(o);
        l.setSelection(Xc(s, "start") ? Pe.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : ve.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, MW = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    s = hT(r);
  }
  let o = s && s.nodeAfter;
  return !o || !ve.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(ve.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function hT(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const TW = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function z3(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const fT = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), o = z3(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let l = t.after(), a = n.tr.replaceWith(l, l, o.createAndFill());
    a.setSelection(Pe.near(a.doc.resolve(l), 1)), e(a.scrollIntoView());
  }
  return !0;
}, AW = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof or || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = z3(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(o, s.createAndFill());
    l.setSelection(ge.create(l.doc, o + 1)), e(l.scrollIntoView());
  }
  return !0;
}, OW = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (Xh(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && x1(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function EW(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof ve && e.selection.node.isBlock)
      return !r.parentOffset || !Xh(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let s = [], o, l, a = !1, c = !1;
    for (let d = r.depth; ; d--)
      if (r.node(d).isBlock) {
        a = r.end(d) == r.pos + (r.depth - d), c = r.start(d) == r.pos - (r.depth - d), l = z3(r.node(d - 1).contentMatchAt(r.indexAfter(d - 1))), s.unshift(a && l ? { type: l } : null), o = d;
        break;
      } else {
        if (d == 1)
          return !1;
        s.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof ge || e.selection instanceof or) && u.deleteSelection();
    let h = u.mapping.map(r.pos), f = Xh(u.doc, h, s.length, s);
    if (f || (s[0] = l ? { type: l } : null, f = Xh(u.doc, h, s.length, s)), !f)
      return !1;
    if (u.split(h, s.length, s), !a && c && r.node(o).type != l) {
      let d = u.mapping.map(r.before(o)), p = u.doc.resolve(d);
      l && r.node(o - 1).canReplaceWith(p.index(), p.index() + 1, l) && u.setNodeMarkup(u.mapping.map(r.before(o)), l);
    }
    return t && t(u.scrollIntoView()), !0;
  };
}
const IW = EW(), DW = (n, e) => (e && e(n.tr.setSelection(new or(n.doc))), !0);
function NW(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || k1(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function dT(n, e, t, r) {
  let i = e.nodeBefore, s = e.nodeAfter, o, l, a = i.type.spec.isolating || s.type.spec.isolating;
  if (!a && NW(n, e, t))
    return !0;
  let c = !a && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (l = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && l.matchType(o[0] || s.type).validEnd) {
    if (t) {
      let d = e.pos + s.nodeSize, p = Y.empty;
      for (let b = o.length - 1; b >= 0; b--)
        p = Y.from(o[b].create(null, p));
      p = Y.from(i.copy(p));
      let m = n.tr.step(new Tn(e.pos - 1, d, e.pos, d, new ue(p, 1, 0), o.length, !0)), g = m.doc.resolve(d + 2 * o.length);
      g.nodeAfter && g.nodeAfter.type == i.type && k1(m.doc, g.pos) && m.join(g.pos), t(m.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || r > 0 && a ? null : Pe.findFrom(e, 1), h = u && u.$from.blockRange(u.$to), f = h && x1(h);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(h, f).scrollIntoView()), !0;
  if (c && Xc(s, "start", !0) && Xc(i, "end")) {
    let d = i, p = [];
    for (; p.push(d), !d.isTextblock; )
      d = d.lastChild;
    let m = s, g = 1;
    for (; !m.isTextblock; m = m.firstChild)
      g++;
    if (d.canReplace(d.childCount, d.childCount, m.content)) {
      if (t) {
        let b = Y.empty;
        for (let k = p.length - 1; k >= 0; k--)
          b = Y.from(p[k].copy(b));
        let w = n.tr.step(new Tn(e.pos - p.length, e.pos + s.nodeSize, e.pos + g, e.pos + s.nodeSize - g, new ue(b, p.length, 0), 0, !0));
        t(w.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function pT(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(ge.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const RW = pT(-1), PW = pT(1);
function _3(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), l = o && k3(o, n, e);
    return l ? (r && r(t.tr.wrap(o, l).scrollIntoView()), !0) : !1;
  };
}
function Lf(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: l } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, l, (a, c) => {
        if (i)
          return !1;
        if (!(!a.isTextblock || a.hasMarkup(n, e)))
          if (a.type == n)
            i = !0;
          else {
            let u = t.doc.resolve(c), h = u.index();
            i = u.parent.canReplaceWith(h, h + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: l }, $to: { pos: a } } = t.selection.ranges[o];
        s.setBlockType(l, a, n, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
function LW(n, e, t, r) {
  for (let i = 0; i < e.length; i++) {
    let { $from: s, $to: o } = e[i], l = s.depth == 0 ? n.inlineContent && n.type.allowsMarkType(t) : !1;
    if (n.nodesBetween(s.pos, o.pos, (a, c) => {
      if (l)
        return !1;
      l = a.inlineContent && a.type.allowsMarkType(t);
    }), l)
      return !0;
  }
  return !1;
}
function R1(n, e = null, t) {
  return function(r, i) {
    let { empty: s, $cursor: o, ranges: l } = r.selection;
    if (s && !o || !LW(r.doc, l, n))
      return !1;
    if (i)
      if (o)
        n.isInSet(r.storedMarks || o.marks()) ? i(r.tr.removeStoredMark(n)) : i(r.tr.addStoredMark(n.create(e)));
      else {
        let a, c = r.tr;
        a = !l.some((u) => r.doc.rangeHasMark(u.$from.pos, u.$to.pos, n));
        for (let u = 0; u < l.length; u++) {
          let { $from: h, $to: f } = l[u];
          if (!a)
            c.removeMark(h.pos, f.pos, n);
          else {
            let d = h.pos, p = f.pos, m = h.nodeAfter, g = f.nodeBefore, b = m && m.isText ? /^\s*/.exec(m.text)[0].length : 0, w = g && g.isText ? /\s*$/.exec(g.text)[0].length : 0;
            d + b < p && (d += b, p -= w), c.addMark(d, p, n.create(e));
          }
        }
        i(c.scrollIntoView());
      }
    return !0;
  };
}
function pu(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
let v2 = pu(L3, cT, uT), t8 = pu(L3, CW, MW);
const Ts = {
  Enter: pu(TW, AW, OW, IW),
  "Mod-Enter": fT,
  Backspace: v2,
  "Mod-Backspace": v2,
  "Shift-Backspace": v2,
  Delete: t8,
  "Mod-Delete": t8,
  "Mod-a": DW
}, mT = {
  "Ctrl-h": Ts.Backspace,
  "Alt-Backspace": Ts["Mod-Backspace"],
  "Ctrl-d": Ts.Delete,
  "Ctrl-Alt-Backspace": Ts["Mod-Delete"],
  "Alt-Delete": Ts["Mod-Delete"],
  "Alt-d": Ts["Mod-Delete"],
  "Ctrl-a": RW,
  "Ctrl-e": PW
};
for (let n in Ts)
  mT[n] = Ts[n];
const BW = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, zW = BW ? mT : Ts, _W = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), FW = typeof navigator < "u" && /Win/.test(navigator.platform);
function HW(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, s, o;
  for (let l = 0; l < e.length - 1; l++) {
    let a = e[l];
    if (/^(cmd|meta|m)$/i.test(a))
      o = !0;
    else if (/^a(lt)?$/i.test(a))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      i = !0;
    else if (/^s(hift)?$/i.test(a))
      s = !0;
    else if (/^mod$/i.test(a))
      _W ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + a);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function $W(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[HW(t)] = n[t];
  return e;
}
function w2(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function gT(n) {
  return new xt({ props: { handleKeyDown: F3(n) } });
}
function F3(n) {
  let e = $W(n);
  return function(t, r) {
    let i = nS(r), s, o = e[w2(i, r)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let l = e[w2(i, r, !1)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(FW && r.ctrlKey && r.altKey) && (s = Gs[r.keyCode]) && s != i) {
        let l = e[w2(s, r)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const pn = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, Zc = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let jy = null;
const Ms = function(n, e, t) {
  let r = jy || (jy = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, VW = function() {
  jy = null;
}, ya = function(n, e, t, r) {
  return t && (n8(n, e, t, r, -1) || n8(n, e, t, r, 1));
}, qW = /^(img|br|input|textarea|hr)$/i;
function n8(n, e, t, r, i) {
  for (var s; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : jr(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || zd(n) || qW.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = pn(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      let o = n.childNodes[e + (i < 0 ? -1 : 0)];
      if (o.nodeType == 1 && o.contentEditable == "false")
        if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        n = o, e = i < 0 ? jr(n) : 0;
    } else
      return !1;
  }
}
function jr(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function WW(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = jr(n);
    } else if (n.parentNode && !zd(n))
      e = pn(n), n = n.parentNode;
    else
      return null;
  }
}
function jW(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !zd(n))
      e = pn(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function UW(n, e, t) {
  for (let r = e == 0, i = e == jr(n); r || i; ) {
    if (n == t)
      return !0;
    let s = pn(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && s == 0, i = i && s == jr(n);
  }
}
function zd(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const P1 = function(n) {
  return n.focusNode && ya(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function Al(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function GW(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function KW(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(jr(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(jr(r.startContainer), r.startOffset) };
  }
}
const ns = typeof navigator < "u" ? navigator : null, r8 = typeof document < "u" ? document : null, il = ns && ns.userAgent || "", Uy = /Edge\/(\d+)/.exec(il), yT = /MSIE \d/.exec(il), Gy = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(il), lr = !!(yT || Gy || Uy), _o = yT ? document.documentMode : Gy ? +Gy[1] : Uy ? +Uy[1] : 0, Zr = !lr && /gecko\/(\d+)/i.test(il);
Zr && +(/Firefox\/(\d+)/.exec(il) || [0, 0])[1];
const Ky = !lr && /Chrome\/(\d+)/.exec(il), Cn = !!Ky, bT = Ky ? +Ky[1] : 0, Hn = !lr && !!ns && /Apple Computer/.test(ns.vendor), Qc = Hn && (/Mobile\/\w+/.test(il) || !!ns && ns.maxTouchPoints > 2), Vr = Qc || (ns ? /Mac/.test(ns.platform) : !1), YW = ns ? /Win/.test(ns.platform) : !1, zs = /Android \d/.test(il), _d = !!r8 && "webkitFontSmoothing" in r8.documentElement.style, JW = _d ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function XW(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function ys(n, e) {
  return typeof n == "number" ? n : n[e];
}
function ZW(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function i8(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = Zc(o);
      continue;
    }
    let l = o, a = l == s.body, c = a ? XW(s) : ZW(l), u = 0, h = 0;
    if (e.top < c.top + ys(r, "top") ? h = -(c.top - e.top + ys(i, "top")) : e.bottom > c.bottom - ys(r, "bottom") && (h = e.bottom - e.top > c.bottom - c.top ? e.top + ys(i, "top") - c.top : e.bottom - c.bottom + ys(i, "bottom")), e.left < c.left + ys(r, "left") ? u = -(c.left - e.left + ys(i, "left")) : e.right > c.right - ys(r, "right") && (u = e.right - c.right + ys(i, "right")), u || h)
      if (a)
        s.defaultView.scrollBy(u, h);
      else {
        let d = l.scrollLeft, p = l.scrollTop;
        h && (l.scrollTop += h), u && (l.scrollLeft += u);
        let m = l.scrollLeft - d, g = l.scrollTop - p;
        e = { left: e.left - m, top: e.top - g, right: e.right - m, bottom: e.bottom - g };
      }
    let f = a ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : Zc(o);
  }
}
function QW(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let l = n.root.elementFromPoint(s, o);
    if (!l || l == n.dom || !n.dom.contains(l))
      continue;
    let a = l.getBoundingClientRect();
    if (a.top >= t - 20) {
      r = l, i = a.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: vT(n.dom) };
}
function vT(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = Zc(r))
    ;
  return e;
}
function ej({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  wT(t, r == 0 ? 0 : r - e);
}
function wT(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: s } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let za = null;
function tj(n) {
  if (n.setActive)
    return n.setActive();
  if (za)
    return n.focus(za);
  let e = vT(n);
  n.focus(za == null ? {
    get preventScroll() {
      return za = { preventScroll: !0 }, !0;
    }
  } : void 0), za || (za = !1, wT(e, 0));
}
function xT(n, e) {
  let t, r = 2e8, i, s = 0, o = e.top, l = e.top, a, c;
  for (let u = n.firstChild, h = 0; u; u = u.nextSibling, h++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Ms(u).getClientRects();
    else
      continue;
    for (let d = 0; d < f.length; d++) {
      let p = f[d];
      if (p.top <= o && p.bottom >= l) {
        o = Math.max(p.bottom, o), l = Math.min(p.top, l);
        let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0;
        if (m < r) {
          t = u, r = m, i = m && t.nodeType == 3 ? {
            left: p.right < e.left ? p.right : p.left,
            top: e.top
          } : e, u.nodeType == 1 && m && (s = h + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
          continue;
        }
      } else p.top > e.top && !a && p.left <= e.left && p.right >= e.left && (a = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top });
      !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (s = h + 1);
    }
  }
  return !t && a && (t = a, i = c, r = 0), t && t.nodeType == 3 ? nj(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : xT(t, i);
}
function nj(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let s = go(r, 1);
    if (s.top != s.bottom && H3(e, s))
      return { node: n, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function H3(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function rj(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function ij(n, e, t) {
  let { node: r, offset: i } = xT(e, t), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, s);
}
function sj(n, e, t, r) {
  let i = -1;
  for (let s = e, o = !1; s != n.dom; ) {
    let l = n.docView.nearestDesc(s, !0), a;
    if (!l)
      return null;
    if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent || !l.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((a = l.dom.getBoundingClientRect()).width || a.height) && (l.node.isBlock && l.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(l.dom.nodeName) && (!o && a.left > r.left || a.top > r.top ? i = l.posBefore : (!o && a.right < r.left || a.bottom < r.top) && (i = l.posAfter), o = !0), !l.contentDOM && i < 0 && !l.node.isText))
      return (l.node.isBlock ? r.top < (a.top + a.bottom) / 2 : r.left < (a.left + a.right) / 2) ? l.posBefore : l.posAfter;
    s = l.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function kT(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let l = o.getClientRects();
        for (let a = 0; a < l.length; a++) {
          let c = l[a];
          if (H3(e, c))
            return kT(o, e, c);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return n;
}
function oj(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, s = KW(t, e.left, e.top);
  s && ({ node: r, offset: i } = s);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), l;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = n.dom.getBoundingClientRect();
    if (!H3(e, c) || (o = kT(n.dom, e, c), !o))
      return null;
  }
  if (Hn)
    for (let c = o; r && c; c = Zc(c))
      c.draggable && (r = void 0);
  if (o = rj(o, e), r) {
    if (Zr && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], h;
      u.nodeName == "IMG" && (h = u.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
    }
    let c;
    _d && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = sj(n, r, i, e));
  }
  l == null && (l = ij(n, o, e));
  let a = n.docView.nearestDesc(o, !0);
  return { pos: l, inside: a ? a.posAtStart - a.border : -1 };
}
function s8(n) {
  return n.top < n.bottom || n.left < n.right;
}
function go(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (s8(r))
      return r;
  }
  return Array.prototype.find.call(t, s8) || n.getBoundingClientRect();
}
const lj = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function ST(n, e, t) {
  let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = _d || Zr;
  if (r.nodeType == 3)
    if (o && (lj.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let a = go(Ms(r, i, i), t);
      if (Zr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = go(Ms(r, i - 1, i - 1), -1);
        if (c.top == a.top) {
          let u = go(Ms(r, i, i + 1), -1);
          if (u.top != a.top)
            return Yu(u, u.left < c.left);
        }
      }
      return a;
    } else {
      let a = i, c = i, u = t < 0 ? 1 : -1;
      return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (a--, u = 1) : t < 0 ? a-- : c++, Yu(go(Ms(r, a, c), u), u < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == jr(r))) {
      let a = r.childNodes[i - 1];
      if (a.nodeType == 1)
        return x2(a.getBoundingClientRect(), !1);
    }
    if (s == null && i < jr(r)) {
      let a = r.childNodes[i];
      if (a.nodeType == 1)
        return x2(a.getBoundingClientRect(), !0);
    }
    return x2(r.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == jr(r))) {
    let a = r.childNodes[i - 1], c = a.nodeType == 3 ? Ms(a, jr(a) - (o ? 0 : 1)) : a.nodeType == 1 && (a.nodeName != "BR" || !a.nextSibling) ? a : null;
    if (c)
      return Yu(go(c, 1), !1);
  }
  if (s == null && i < jr(r)) {
    let a = r.childNodes[i];
    for (; a.pmViewDesc && a.pmViewDesc.ignoreForCoords; )
      a = a.nextSibling;
    let c = a ? a.nodeType == 3 ? Ms(a, 0, o ? 0 : 1) : a.nodeType == 1 ? a : null : null;
    if (c)
      return Yu(go(c, -1), !0);
  }
  return Yu(go(r.nodeType == 3 ? Ms(r) : r, -t), t >= 0);
}
function Yu(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function x2(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function CT(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function aj(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return CT(n, e, () => {
    let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let l = n.docView.nearestDesc(s, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        s = l.contentDOM || l.dom;
        break;
      }
      s = l.dom.parentNode;
    }
    let o = ST(n, i.pos, 1);
    for (let l = s.firstChild; l; l = l.nextSibling) {
      let a;
      if (l.nodeType == 1)
        a = l.getClientRects();
      else if (l.nodeType == 3)
        a = Ms(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < a.length; c++) {
        let u = a[c];
        if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const cj = /[\u0590-\u08ac]/;
function uj(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, l = n.domSelection();
  return l ? !cj.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? s : o : CT(n, e, () => {
    let { focusNode: a, focusOffset: c, anchorNode: u, anchorOffset: h } = n.domSelectionRange(), f = l.caretBidiLevel;
    l.modify("move", t, "character");
    let d = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: p, focusOffset: m } = n.domSelectionRange(), g = p && !d.contains(p.nodeType == 1 ? p : p.parentNode) || a == p && c == m;
    try {
      l.collapse(u, h), a && (a != u || c != h) && l.extend && l.extend(a, c);
    } catch {
    }
    return f != null && (l.caretBidiLevel = f), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let o8 = null, l8 = null, a8 = !1;
function hj(n, e, t) {
  return o8 == e && l8 == t ? a8 : (o8 = e, l8 = t, a8 = t == "up" || t == "down" ? aj(n, e, t) : uj(n, e, t));
}
const Qr = 0, c8 = 1, Dl = 2, rs = 3;
class Fd {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = Qr, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > pn(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!t || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let l = i.children[o];
            if (l.size) {
              i = l;
              break;
            }
          }
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], l = s + o.size;
      if (l > e || o instanceof TT) {
        i = e - s;
        break;
      }
      s = l;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof MT && s.side >= 0; r--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? pn(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? pn(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, l = 0; ; l++) {
      let a = this.children[l], c = o + a.size;
      if (i == -1 && e <= c) {
        let u = o + a.border;
        if (e >= u && t <= c - a.border && a.node && a.contentDOM && this.contentDOM.contains(a.contentDOM))
          return a.parseRange(e, t, u);
        e = o;
        for (let h = l; h > 0; h--) {
          let f = this.children[h - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = pn(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > t || l == this.children.length - 1)) {
        t = c;
        for (let u = l + 1; u < this.children.length; u++) {
          let h = this.children[u];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = pn(h.dom);
            break;
          }
          t += h.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let d = 0, p = 0; d < this.children.length; d++) {
      let m = this.children[d], g = p + m.size;
      if (s > p && o < g)
        return m.setSelection(e - p - m.border, t - p - m.border, r, i);
      p = g;
    }
    let l = this.domFromPos(e, e ? -1 : 1), a = t == e ? l : this.domFromPos(t, t ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), h = !1;
    if ((Zr || Hn) && e == t) {
      let { node: d, offset: p } = l;
      if (d.nodeType == 3) {
        if (h = !!(p && d.nodeValue[p - 1] == `
`), h && p == d.nodeValue.length)
          for (let m = d, g; m; m = m.parentNode) {
            if (g = m.nextSibling) {
              g.nodeName == "BR" && (l = a = { node: g.parentNode, offset: pn(g) + 1 });
              break;
            }
            let b = m.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let m = d.childNodes[p - 1];
        h = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (Zr && u.focusNode && u.focusNode != a.node && u.focusNode.nodeType == 1) {
      let d = u.focusNode.childNodes[u.focusOffset];
      d && d.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && Hn) && ya(l.node, l.offset, u.anchorNode, u.anchorOffset) && ya(a.node, a.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == t) && !(h && Zr)) {
      c.collapse(l.node, l.offset);
      try {
        e != t && c.extend(a.node, a.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let p = l;
        l = a, a = p;
      }
      let d = document.createRange();
      d.setEnd(a.node, a.offset), d.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(d);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let l = r + s.border, a = o - s.border;
        if (e >= l && t <= a) {
          this.dirty = e == r || t == o ? Dl : c8, e == l && t == a && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = rs : s.markDirty(e - l, t - l);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Dl : rs;
      }
      r = o;
    }
    this.dirty = Dl;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? Dl : c8;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class MT extends Fd {
  constructor(e, t, r, i) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(o), o = l;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == Qr && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class fj extends Fd {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class ba extends Fd {
  constructor(e, t, r, i, s) {
    super(e, [], r, i), this.mark = t, this.spec = s;
  }
  static create(e, t, r, i) {
    let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
    return (!o || !o.dom) && (o = Sa.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new ba(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & rs || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != rs && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != Qr) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Qr;
    }
  }
  slice(e, t, r) {
    let i = ba.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    t < o && (s = Jy(s, t, o, r)), e > 0 && (s = Jy(s, 0, e, r));
    for (let l = 0; l < s.length; l++)
      s[l].parent = i;
    return i.children = s, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Fo extends Fd {
  constructor(e, t, r, i, s, o, l, a, c) {
    super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, s, o) {
    let l = s.nodeViews[t.type.name], a, c = l && l(t, s, () => {
      if (!a)
        return o;
      if (a.parent)
        return a.parent.posBeforeChild(a);
    }, r, i), u = c && c.dom, h = c && c.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: h } = Sa.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !h && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = ET(u, r, t), c ? a = new dj(e, t, r, i, u, h || null, f, c, s, o + 1) : t.isText ? new L1(e, t, r, i, u, f, s) : new Fo(e, t, r, i, u, h || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => Y.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == Qr && e.eq(this.node) && Im(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, l = s && s.pos < 0, a = new mj(this, o && o.node, e);
    bj(this.node, this.innerDeco, (c, u, h) => {
      c.spec.marks ? a.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !h && a.syncToMarks(u == this.node.childCount ? $e.none : this.node.child(u).marks, r, e), a.placeWidget(c, e, i);
    }, (c, u, h, f) => {
      a.syncToMarks(c.marks, r, e);
      let d;
      a.findNodeMatch(c, u, h, f) || l && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (d = a.findIndexWithChild(s.node)) > -1 && a.updateNodeAt(c, u, h, d, e) || a.updateNextNode(c, u, h, e, f, i) || a.addNode(c, u, h, e, i), i += c.nodeSize;
    }), a.syncToMarks([], r, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || this.dirty == Dl) && (o && this.protectLocalComposition(e, o), AT(this.contentDOM, this.children, e), Qc && vj(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof ge) || r < t || i > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, l = wj(this.node.content, o, r - t, i - t);
      return l < 0 ? null : { node: s, pos: l, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new fj(this, s, t, i);
    e.input.compositionNodes.push(o), this.children = Jy(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == rs || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Qr;
  }
  updateOuterDeco(e) {
    if (Im(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = OT(this.dom, this.nodeDOM, Yy(this.outerDeco, this.node, t), Yy(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function u8(n, e, t, r, i) {
  ET(r, e, n);
  let s = new Fo(void 0, n, e, t, r, r, r, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class L1 extends Fo {
  constructor(e, t, r, i, s, o, l) {
    super(e, t, r, i, s, null, o, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == rs || this.dirty != Qr && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Qr || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Qr, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new L1(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = rs);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class TT extends Fd {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Qr && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class dj extends Fo {
  constructor(e, t, r, i, s, o, l, a, c, u) {
    super(e, t, r, i, s, o, l, c, u), this.spec = a;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == rs)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, r);
      return s && this.updateInner(e, t, r, i), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function AT(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], l = o.dom;
    if (l.parentNode == n) {
      for (; l != r; )
        r = h8(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(l, r);
    if (o instanceof ba) {
      let a = r ? r.previousSibling : n.lastChild;
      AT(o.contentDOM, o.children, t), r = a ? a.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = h8(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const ef = function(n) {
  n && (this.nodeName = n);
};
ef.prototype = /* @__PURE__ */ Object.create(null);
const Nl = [new ef()];
function Yy(n, e, t) {
  if (n.length == 0)
    return Nl;
  let r = t ? Nl[0] : new ef(), i = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new ef(o.nodeName));
      for (let l in o) {
        let a = o[l];
        a != null && (t && i.length == 1 && i.push(r = new ef(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + a : l == "style" ? r.style = (r.style ? r.style + ";" : "") + a : l != "nodeName" && (r[l] = a));
      }
    }
  }
  return i;
}
function OT(n, e, t, r) {
  if (t == Nl && r == Nl)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], l = t[s];
    if (s) {
      let a;
      l && l.nodeName == o.nodeName && i != n && (a = i.parentNode) && a.nodeName.toLowerCase() == o.nodeName || (a = document.createElement(o.nodeName), a.pmIsDeco = !0, a.appendChild(i), l = Nl[0]), i = a;
    }
    pj(i, l || Nl[0], o);
  }
  return i;
}
function pj(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function ET(n, e, t) {
  return OT(n, n, Nl, Yy(e, t, n.nodeType != 1));
}
function Im(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function h8(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class mj {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = gj(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = Qr, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let a = this.index; a < Math.min(this.index + 3, this.top.children.length); a++) {
        let c = this.top.children[a];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          l = a;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let a = ba.create(this.top, e[s], t, r);
        this.top.children.splice(this.index, 0, a), this.top = a, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let l = this.index, a = Math.min(this.top.children.length, l + 5); l < a; l++) {
        let c = this.top.children[l];
        if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) {
          s = l;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == rs && o.dom == o.contentDOM && (o.dirty = Dl), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, s, o) {
    for (let l = this.index; l < this.top.children.length; l++) {
      let a = this.top.children[l];
      if (a instanceof Fo) {
        let c = this.preMatch.matched.get(a);
        if (c != null && c != s)
          return !1;
        let u = a.dom, h, f = this.isLocked(u) && !(e.isText && a.node && a.node.isText && a.nodeDOM.nodeValue == e.text && a.dirty != rs && Im(t, a.outerDeco));
        if (!f && a.update(e, t, r, i))
          return this.destroyBetween(this.index, l), a.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (h = this.recreateWrapper(a, e, t, r, i, o)))
          return this.destroyBetween(this.index, l), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Dl, h.updateChildren(i, o + 1), h.dirty = Qr), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, s, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !Im(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let l = Fo.create(this.top, t, r, i, s, o);
    if (l.contentDOM) {
      l.children = e.children, e.children = [];
      for (let a of l.children)
        a.parent = l;
    }
    return e.destroy(), l;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, s) {
    let o = Fo.create(this.top, e, t, r, i, s);
    o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new MT(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof ba; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof L1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Hn || Cn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new TT(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function gj(n, e) {
  let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; i > 0; ) {
    let l;
    for (; ; )
      if (r) {
        let c = t.children[r - 1];
        if (c instanceof ba)
          t = c, r = c.children.length;
        else {
          l = c, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let a = l.node;
    if (a) {
      if (a != n.child(i - 1))
        break;
      --i, s.set(l, i), o.push(l);
    }
  }
  return { index: i, matched: s, matches: o.reverse() };
}
function yj(n, e) {
  return n.type.side - e.type.side;
}
function bj(n, e, t, r) {
  let i = e.locals(n), s = 0;
  if (i.length == 0) {
    for (let c = 0; c < n.childCount; c++) {
      let u = n.child(c);
      r(u, i, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, l = [], a = null;
  for (let c = 0; ; ) {
    let u, h;
    for (; o < i.length && i[o].to == s; ) {
      let g = i[o++];
      g.widget && (u ? (h || (h = [u])).push(g) : u = g);
    }
    if (u)
      if (h) {
        h.sort(yj);
        for (let g = 0; g < h.length; g++)
          t(h[g], c, !!a);
      } else
        t(u, c, !!a);
    let f, d;
    if (a)
      d = -1, f = a, a = null;
    else if (c < n.childCount)
      d = c, f = n.child(c++);
    else
      break;
    for (let g = 0; g < l.length; g++)
      l[g].to <= s && l.splice(g--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      l.push(i[o++]);
    let p = s + f.nodeSize;
    if (f.isText) {
      let g = p;
      o < i.length && i[o].from < g && (g = i[o].from);
      for (let b = 0; b < l.length; b++)
        l[b].to < g && (g = l[b].to);
      g < p && (a = f.cut(g - s), f = f.cut(0, g - s), p = g, d = -1);
    } else
      for (; o < i.length && i[o].to < p; )
        o++;
    let m = f.isInline && !f.isLeaf ? l.filter((g) => !g.inline) : l.slice();
    r(f, m, e.forChild(s, f), d), s = p;
  }
}
function vj(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function wj(n, e, t, r) {
  for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
    let o = n.child(i++), l = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let a = o.text;
    for (; i < n.childCount; ) {
      let c = n.child(i++);
      if (s += c.nodeSize, !c.isText)
        break;
      a += c.text;
    }
    if (s >= t) {
      if (s >= r && a.slice(r - e.length - l, r - l) == e)
        return r - e.length;
      let c = l < r ? a.lastIndexOf(e, r - l - 1) : -1;
      if (c >= 0 && c + e.length + l >= t)
        return l + c;
      if (t == r && a.length >= r + e.length - l && a.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Jy(n, e, t, r, i) {
  let s = [];
  for (let o = 0, l = 0; o < n.length; o++) {
    let a = n[o], c = l, u = l += a.size;
    c >= t || u <= e ? s.push(a) : (c < e && s.push(a.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > t && s.push(a.slice(t - c, a.size, r)));
  }
  return s;
}
function $3(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let l = r.resolve(o), a, c;
  if (P1(t)) {
    for (a = o; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && ve.isSelectable(h) && i.parent && !(h.isInline && UW(t.focusNode, t.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new ve(o == f ? l : r.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let h = o, f = o;
      for (let d = 0; d < t.rangeCount; d++) {
        let p = t.getRangeAt(d);
        h = Math.min(h, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(p.endContainer, p.endOffset, -1));
      }
      if (h < 0)
        return null;
      [a, o] = f == n.state.selection.anchor ? [f, h] : [h, f], l = r.resolve(o);
    } else
      a = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (a < 0)
      return null;
  }
  let u = r.resolve(a);
  if (!c) {
    let h = e == "pointer" || n.state.selection.head < l.pos && !s ? 1 : -1;
    c = V3(n, u, l, h);
  }
  return c;
}
function IT(n) {
  return n.editable ? n.hasFocus() : NT(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function qs(n, e = !1) {
  let t = n.state.selection;
  if (DT(n, t), !!IT(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Cn) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && ya(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      kj(n);
    else {
      let { anchor: r, head: i } = t, s, o;
      f8 && !(t instanceof ge) && (t.$from.parent.inlineContent || (s = d8(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = d8(n, t.to))), n.docView.setSelection(r, i, n, e), f8 && (s && p8(s), o && p8(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && xj(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const f8 = Hn || Cn && bT < 63;
function d8(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
  if (Hn && i && i.contentEditable == "false")
    return k2(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return k2(i);
    if (s)
      return k2(s);
  }
}
function k2(n) {
  return n.contentEditable = "true", Hn && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function p8(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function xj(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!IT(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function kj(n) {
  let e = n.domSelection();
  if (!e)
    return;
  let t = n.cursorWrapper.dom, r = t.nodeName == "IMG";
  r ? e.collapse(t.parentNode, pn(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && lr && _o <= 11 && (t.disabled = !0, t.disabled = !1);
}
function DT(n, e) {
  if (e instanceof ve) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (m8(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    m8(n);
}
function m8(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function V3(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || ge.between(e, t, r);
}
function g8(n) {
  return n.editable && !n.hasFocus() ? !1 : NT(n);
}
function NT(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Sj(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return ya(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Xy(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && Pe.findFrom(s, e);
}
function ko(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function y8(n, e, t) {
  let r = n.state.selection;
  if (r instanceof ge)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return ko(n, new ge(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = Xy(n.state, e);
        return i && i instanceof ve ? ko(n, i) : !1;
      } else if (!(Vr && t.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let l = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = n.docView.descAt(l)) && !o.contentDOM ? ve.isSelectable(s) ? ko(n, new ve(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : _d ? ko(n, new ge(n.state.doc.resolve(e < 0 ? l : l + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof ve && r.node.isInline)
      return ko(n, new ge(e > 0 ? r.$to : r.$from));
    {
      let i = Xy(n.state, e);
      return i ? ko(n, i) : !1;
    }
  }
}
function Dm(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function tf(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function _a(n, e) {
  return e < 0 ? Cj(n) : Mj(n);
}
function Cj(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, s, o = !1;
  for (Zr && t.nodeType == 1 && r < Dm(t) && tf(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let l = t.childNodes[r - 1];
        if (tf(l, -1))
          i = t, s = --r;
        else if (l.nodeType == 3)
          t = l, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (RT(t))
        break;
      {
        let l = t.previousSibling;
        for (; l && tf(l, -1); )
          i = t.parentNode, s = pn(l), l = l.previousSibling;
        if (l)
          t = l, r = Dm(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? Zy(n, t, r) : i && Zy(n, i, s);
}
function Mj(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = Dm(t), s, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let l = t.childNodes[r];
      if (tf(l, 1))
        s = t, o = ++r;
      else
        break;
    } else {
      if (RT(t))
        break;
      {
        let l = t.nextSibling;
        for (; l && tf(l, 1); )
          s = l.parentNode, o = pn(l) + 1, l = l.nextSibling;
        if (l)
          t = l, r = 0, i = Dm(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && Zy(n, s, o);
}
function RT(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function Tj(n, e) {
  for (; n && e == n.childNodes.length && !zd(n); )
    e = pn(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function Aj(n, e) {
  for (; n && !e && !zd(n); )
    e = pn(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function Zy(n, e, t) {
  if (e.nodeType != 3) {
    let s, o;
    (o = Tj(e, t)) ? (e = o, t = 0) : (s = Aj(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (P1(r)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && qs(n);
  }, 50);
}
function b8(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(Cn || YW) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function v8(n, e, t) {
  let r = n.state.selection;
  if (r instanceof ge && !r.empty || t.indexOf("s") > -1 || Vr && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = Xy(n.state, e);
    if (o && o instanceof ve)
      return ko(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, l = r instanceof or ? Pe.near(o, e) : Pe.findFrom(o, e);
    return l ? ko(n, l) : !1;
  }
  return !1;
}
function w8(n, e) {
  if (!(n.state.selection instanceof ge))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function x8(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function Oj(n) {
  if (!Hn || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    x8(n, r, "true"), setTimeout(() => x8(n, r, "false"), 20);
  }
  return !1;
}
function Ej(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function Ij(n, e) {
  let t = e.keyCode, r = Ej(e);
  if (t == 8 || Vr && t == 72 && r == "c")
    return w8(n, -1) || _a(n, -1);
  if (t == 46 && !e.shiftKey || Vr && t == 68 && r == "c")
    return w8(n, 1) || _a(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || Vr && t == 66 && r == "c") {
    let i = t == 37 ? b8(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return y8(n, i, r) || _a(n, i);
  } else if (t == 39 || Vr && t == 70 && r == "c") {
    let i = t == 39 ? b8(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return y8(n, i, r) || _a(n, i);
  } else {
    if (t == 38 || Vr && t == 80 && r == "c")
      return v8(n, -1, r) || _a(n, -1);
    if (t == 40 || Vr && t == 78 && r == "c")
      return Oj(n) || v8(n, 1, r) || _a(n, 1);
    if (r == (Vr ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function q3(n, e) {
  n.someProp("transformCopied", (d) => {
    e = d(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let d = r.firstChild;
    t.push(d.type.name, d.attrs != d.type.defaultAttrs ? d.attrs : null), r = d.content;
  }
  let o = n.someProp("clipboardSerializer") || Sa.fromSchema(n.state.schema), l = FT(), a = l.createElement("div");
  a.appendChild(o.serializeFragment(r, { document: l }));
  let c = a.firstChild, u, h = 0;
  for (; c && c.nodeType == 1 && (u = _T[c.nodeName.toLowerCase()]); ) {
    for (let d = u.length - 1; d >= 0; d--) {
      let p = l.createElement(u[d]);
      for (; a.firstChild; )
        p.appendChild(a.firstChild);
      a.appendChild(p), h++;
    }
    c = a.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (d) => d(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: a, text: f, slice: e };
}
function PT(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, l;
  if (!t && !e)
    return null;
  let a = !!e && (r || s || !t);
  if (a) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, s || r, n);
    }), s)
      return l = new ue(Y.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", (f) => {
        l = f(l, n, !0);
      }), l;
    let h = n.someProp("clipboardTextParser", (f) => f(e, i, r, n));
    if (h)
      l = h;
    else {
      let f = i.marks(), { schema: d } = n.state, p = Sa.fromSchema(d);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((m) => {
        let g = o.appendChild(document.createElement("p"));
        m && g.appendChild(p.serializeNode(d.text(m, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = Pj(t), _d && Lj(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let h = +u[3]; h > 0; h--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || pa.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(a || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !Dj.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    l = Bj(k8(l, +u[1], +u[2]), u[4]);
  else if (l = ue.maxOpen(Nj(l.content, i), !0), l.openStart || l.openEnd) {
    let h = 0, f = 0;
    for (let d = l.content.firstChild; h < l.openStart && !d.type.spec.isolating; h++, d = d.firstChild)
      ;
    for (let d = l.content.lastChild; f < l.openEnd && !d.type.spec.isolating; f++, d = d.lastChild)
      ;
    l = k8(l, h, f);
  }
  return n.someProp("transformPasted", (h) => {
    l = h(l, n, a);
  }), l;
}
const Dj = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function Nj(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((l) => {
      if (!o)
        return;
      let a = i.findWrapping(l.type), c;
      if (!a)
        return o = null;
      if (c = o.length && s.length && BT(a, s, l, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = zT(o[o.length - 1], s.length));
        let u = LT(l, a);
        o.push(u), i = i.matchType(u.type), s = a;
      }
    }), o)
      return Y.from(o);
  }
  return n;
}
function LT(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, Y.from(n));
  return n;
}
function BT(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let s = BT(n, e, t, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(Y.from(LT(t, n, i + 1))));
  }
}
function zT(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, zT(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(Y.empty, !0);
  return n.copy(t.append(r));
}
function Qy(n, e, t, r, i, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, l = o.content;
  return n.childCount > 1 && (s = 0), i < r - 1 && (l = Qy(l, e, t, r, i + 1, s)), i >= t && (l = e < 0 ? o.contentMatchAt(0).fillBefore(l, s <= i).append(l) : l.append(o.contentMatchAt(o.childCount).fillBefore(Y.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(l));
}
function k8(n, e, t) {
  return e < n.openStart && (n = new ue(Qy(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new ue(Qy(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const _T = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let S8 = null;
function FT() {
  return S8 || (S8 = document.implementation.createHTMLDocument("title"));
}
let S2 = null;
function Rj(n) {
  let e = window.trustedTypes;
  return e ? (S2 || (S2 = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), S2.createHTML(n)) : n;
}
function Pj(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = FT().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && _T[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = Rj(n), i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function Lj(n) {
  let e = n.querySelectorAll(Cn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == "Â " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function Bj(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: s, openEnd: o } = n;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let a = t.nodes[r[l]];
    if (!a || a.hasRequiredAttrs())
      break;
    i = Y.from(a.create(r[l + 1], i)), s++, o++;
  }
  return new ue(i, s, o);
}
const $n = {}, Vn = {}, zj = { touchstart: !0, touchmove: !0 };
class _j {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function Fj(n) {
  for (let e in $n) {
    let t = $n[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      $j(n, r) && !W3(n, r) && (n.editable || !(r.type in Vn)) && t(n, r);
    }, zj[e] ? { passive: !0 } : void 0);
  }
  Hn && n.dom.addEventListener("input", () => null), e5(n);
}
function Lo(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function Hj(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function e5(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => W3(n, r));
  });
}
function W3(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function $j(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function Vj(n, e) {
  !W3(n, e) && $n[e.type] && (n.editable || !(e.type in Vn)) && $n[e.type](n, e);
}
Vn.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !$T(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(zs && Cn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), Qc && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, Al(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || Ij(n, t) ? t.preventDefault() : Lo(n, "key");
};
Vn.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
Vn.keypress = (n, e) => {
  let t = e;
  if ($T(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Vr && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof ge) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode), s = () => n.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i, s)) && n.dispatch(s()), t.preventDefault();
  }
};
function B1(n) {
  return { left: n.clientX, top: n.clientY };
}
function qj(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function j3(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let s = n.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (l) => o > s.depth ? l(n, t, s.nodeAfter, s.before(o), i, !0) : l(n, t, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function lc(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function Wj(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && ve.isSelectable(r) ? (lc(n, new ve(t)), !0) : !1;
}
function jj(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof ve && (r = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let l = o > s.depth ? s.nodeAfter : s.node(o);
    if (ve.isSelectable(l)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (lc(n, ve.create(n.state.doc, i)), !0) : !1;
}
function Uj(n, e, t, r, i) {
  return j3(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? jj(n, t) : Wj(n, t));
}
function Gj(n, e, t, r) {
  return j3(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function Kj(n, e, t, r) {
  return j3(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || Yj(n, t, r);
}
function Yj(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (lc(n, ge.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), l = i.before(s);
    if (o.inlineContent)
      lc(n, ge.create(r, l + 1, l + 1 + o.content.size));
    else if (ve.isSelectable(o))
      lc(n, ve.create(r, l));
    else
      continue;
    return !0;
  }
}
function U3(n) {
  return Nm(n);
}
const HT = Vr ? "metaKey" : "ctrlKey";
$n.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = U3(n), i = Date.now(), s = "singleClick";
  i - n.input.lastClick.time < 500 && qj(t, n.input.lastClick) && !t[HT] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button };
  let o = n.posAtCoords(B1(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new Jj(n, o, t, !!r)) : (s == "doubleClick" ? Gj : Kj)(n, o.pos, o.inside, t) ? t.preventDefault() : Lo(n, "pointer"));
};
class Jj {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[HT], this.allowDefault = r.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const l = i ? null : r.target, a = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = a && a.nodeDOM.nodeType == 1 ? a.nodeDOM : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof ve && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Zr && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Lo(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => qs(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(B1(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Lo(this.view, "pointer") : Uj(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Hn && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Cn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (lc(this.view, Pe.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Lo(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Lo(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
$n.touchstart = (n) => {
  n.input.lastTouch = Date.now(), U3(n), Lo(n, "pointer");
};
$n.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Lo(n, "pointer");
};
$n.contextmenu = (n) => U3(n);
function $T(n, e) {
  return n.composing ? !0 : Hn && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const Xj = zs ? 5e3 : -1;
Vn.compositionstart = Vn.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof ge && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), Nm(n, !0), n.markCursor = null;
    else if (Nm(n, !e.selection.empty), Zr && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let l = n.domSelection();
          l && l.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  VT(n, Xj);
};
Vn.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, VT(n, 20));
};
function VT(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => Nm(n), e));
}
function qT(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = Qj()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function Zj(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = WW(e.focusNode, e.focusOffset), r = jW(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode;
    if (t == s || r == s)
      return s;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function Qj() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function Nm(n, e = !1) {
  if (!(zs && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), qT(n), e || n.docView && n.docView.dirty) {
      let t = $3(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function eU(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Bf = lr && _o < 15 || Qc && JW < 604;
$n.copy = Vn.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let s = Bf ? null : t.clipboardData, o = r.content(), { dom: l, text: a } = q3(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", l.innerHTML), s.setData("text/plain", a)) : eU(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function tU(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function nU(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? zf(n, r.value, null, i, e) : zf(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function zf(n, e, t, r, i) {
  let s = PT(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (a) => a(n, i, s || ue.empty)))
    return !0;
  if (!s)
    return !1;
  let o = tU(s), l = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s);
  return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function WT(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
Vn.paste = (n, e) => {
  let t = e;
  if (n.composing && !zs)
    return;
  let r = Bf ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && zf(n, WT(r), r.getData("text/html"), i, t) ? t.preventDefault() : nU(n, t);
};
class jT {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const rU = Vr ? "altKey" : "ctrlKey";
function UT(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[rU];
}
$n.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, s = i.empty ? null : n.posAtCoords(B1(t)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof ve ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = ve.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let h = n.docView.nearestDesc(t.target, !0);
      h && h.node.type.spec.draggable && h != n.docView && (o = ve.create(n.state.doc, h.posBefore));
    }
  }
  let l = (o || n.state.selection).content(), { dom: a, text: c, slice: u } = q3(n, l);
  (!t.dataTransfer.files.length || !Cn || bT > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Bf ? "Text" : "text/html", a.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Bf || t.dataTransfer.setData("text/plain", c), n.dragging = new jT(u, UT(n, t), o);
};
$n.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
Vn.dragover = Vn.dragenter = (n, e) => e.preventDefault();
Vn.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(B1(t));
  if (!i)
    return;
  let s = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (p) => {
    o = p(o, n, !1);
  }) : o = PT(n, WT(t.dataTransfer), Bf ? null : t.dataTransfer.getData("text/html"), !1, s);
  let l = !!(r && UT(n, t));
  if (n.someProp("handleDrop", (p) => p(n, t, o || ue.empty, l))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let a = o ? YF(n.state.doc, s.pos, o) : s.pos;
  a == null && (a = s.pos);
  let c = n.state.tr;
  if (l) {
    let { node: p } = r;
    p ? p.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(a), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (h ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let d = c.doc.resolve(u);
  if (h && ve.isSelectable(o.content.firstChild) && d.nodeAfter && d.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new ve(d));
  else {
    let p = c.mapping.map(a);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, b, w) => p = w), c.setSelection(V3(n, d, c.doc.resolve(p)));
  }
  n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
};
$n.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && qs(n);
  }, 20));
};
$n.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
$n.beforeinput = (n, e) => {
  if (Cn && zs && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, Al(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in Vn)
  $n[n] = Vn[n];
function _f(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class Rm {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || Zl, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new Wt(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Rm && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && _f(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Ho {
  constructor(e, t) {
    this.attrs = e, this.spec = t || Zl;
  }
  map(e, t, r, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new Wt(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof Ho && _f(this.attrs, e.attrs) && _f(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ho;
  }
  destroy() {
  }
}
class G3 {
  constructor(e, t) {
    this.attrs = e, this.spec = t || Zl;
  }
  map(e, t, r, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new Wt(s.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof G3 && _f(this.attrs, e.attrs) && _f(this.spec, e.spec);
  }
  destroy() {
  }
}
class Wt {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new Wt(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new Wt(e, e, new Rm(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new Wt(e, t, new Ho(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new Wt(e, t, new G3(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Ho;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Rm;
  }
}
const Wa = [], Zl = {};
class ct {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : Wa, this.children = t.length ? t : Wa;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? Pm(t, e, 0, Zl) : xn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let l = this.local[o];
      l.from <= t && l.to >= e && (!s || s(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let l = this.children[o] + 1;
        this.children[o + 2].findInner(e - l, t - l, r, i + l, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == xn || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || Zl);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, s) {
    let o;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l].map(e, r, i);
      a && a.type.valid(t, a) ? (o || (o = [])).push(a) : s.onRemove && s.onRemove(this.local[l].spec);
    }
    return this.children.length ? iU(this.children, o || [], e, t, r, i, s) : o ? new ct(o.sort(Ql), Wa) : xn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == xn ? ct.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, s = 0;
    e.forEach((l, a) => {
      let c = a + r, u;
      if (u = KT(t, l, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < a; )
          s += 3;
        i[s] == a ? i[s + 2] = i[s + 2].addInner(l, u, c + 1) : i.splice(s, 0, a, a + l.nodeSize, Pm(u, l, c + 1, Zl)), s += 3;
      }
    });
    let o = GT(s ? YT(t) : t, -r);
    for (let l = 0; l < o.length; l++)
      o[l].type.valid(e, o[l]) || o.splice(l--, 1);
    return new ct(o.length ? this.local.concat(o).sort(Ql) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == xn ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, l = r[s] + t, a = r[s + 1] + t;
      for (let u = 0, h; u < e.length; u++)
        (h = e[u]) && h.from > l && h.to < a && (e[u] = null, (o || (o = [])).push(h));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, l + 1);
      c != xn ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let l = 0; l < i.length; l++)
            i[l].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new ct(i, r) : xn;
  }
  forChild(e, t) {
    if (this == xn)
      return this;
    if (t.isLeaf)
      return ct.empty;
    let r, i;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let a = this.local[l];
      if (a.from < o && a.to > s && a.type instanceof Ho) {
        let c = Math.max(s, a.from) - s, u = Math.min(o, a.to) - s;
        c < u && (i || (i = [])).push(a.copy(c, u));
      }
    }
    if (i) {
      let l = new ct(i.sort(Ql), Wa);
      return r ? new To([l, r]) : l;
    }
    return r || xn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof ct) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return K3(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == xn)
      return Wa;
    if (e.inlineContent || !this.local.some(Ho.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Ho || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
ct.empty = new ct([], []);
ct.removeOverlap = K3;
const xn = ct.empty;
class To {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, Zl));
    return To.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return ct.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != xn && (s instanceof To ? r = r.concat(s.members) : r.push(s));
    }
    return To.from(r);
  }
  eq(e) {
    if (!(e instanceof To) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? K3(r ? t : t.sort(Ql)) : Wa;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return xn;
      case 1:
        return e[0];
      default:
        return new To(e.every((t) => t instanceof ct) ? e : e.reduce((t, r) => t.concat(r instanceof ct ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function iU(n, e, t, r, i, s, o) {
  let l = n.slice();
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let h = 0;
    t.maps[c].forEach((f, d, p, m) => {
      let g = m - p - (d - f);
      for (let b = 0; b < l.length; b += 3) {
        let w = l[b + 1];
        if (w < 0 || f > w + u - h)
          continue;
        let k = l[b] + u - h;
        d >= k ? l[b + 1] = f <= k ? -2 : -1 : f >= u && g && (l[b] += g, l[b + 1] += g);
      }
      h += g;
    }), u = t.maps[c].map(u, -1);
  }
  let a = !1;
  for (let c = 0; c < l.length; c += 3)
    if (l[c + 1] < 0) {
      if (l[c + 1] == -2) {
        a = !0, l[c + 1] = -1;
        continue;
      }
      let u = t.map(n[c] + s), h = u - i;
      if (h < 0 || h >= r.content.size) {
        a = !0;
        continue;
      }
      let f = t.map(n[c + 1] + s, -1), d = f - i, { index: p, offset: m } = r.content.findIndex(h), g = r.maybeChild(p);
      if (g && m == h && m + g.nodeSize == d) {
        let b = l[c + 2].mapInner(t, g, u + 1, n[c] + s + 1, o);
        b != xn ? (l[c] = h, l[c + 1] = d, l[c + 2] = b) : (l[c + 1] = -2, a = !0);
      } else
        a = !0;
    }
  if (a) {
    let c = sU(l, n, e, t, i, s, o), u = Pm(c, r, 0, o);
    e = u.local;
    for (let h = 0; h < l.length; h += 3)
      l[h + 1] < 0 && (l.splice(h, 3), h -= 3);
    for (let h = 0, f = 0; h < u.children.length; h += 3) {
      let d = u.children[h];
      for (; f < l.length && l[f] < d; )
        f += 3;
      l.splice(f, 0, u.children[h], u.children[h + 1], u.children[h + 2]);
    }
  }
  return new ct(e.sort(Ql), l);
}
function GT(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new Wt(i.from + e, i.to + e, i.type));
  }
  return t;
}
function sU(n, e, t, r, i, s, o) {
  function l(a, c) {
    for (let u = 0; u < a.local.length; u++) {
      let h = a.local[u].map(r, i, c);
      h ? t.push(h) : o.onRemove && o.onRemove(a.local[u].spec);
    }
    for (let u = 0; u < a.children.length; u += 3)
      l(a.children[u + 2], a.children[u] + c + 1);
  }
  for (let a = 0; a < n.length; a += 3)
    n[a + 1] == -1 && l(n[a + 2], e[a] + s + 1);
  return t;
}
function KT(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
  return i;
}
function YT(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function Pm(n, e, t, r) {
  let i = [], s = !1;
  e.forEach((l, a) => {
    let c = KT(n, l, a + t);
    if (c) {
      s = !0;
      let u = Pm(c, l, t + a + 1, r);
      u != xn && i.push(a, a + l.nodeSize, u);
    }
  });
  let o = GT(s ? YT(n) : n, -t).sort(Ql);
  for (let l = 0; l < o.length; l++)
    o[l].type.valid(e, o[l]) || (r.onRemove && r.onRemove(o[l].spec), o.splice(l--, 1));
  return o.length || i.length ? new ct(o, i) : xn;
}
function Ql(n, e) {
  return n.from - e.from || n.to - e.to;
}
function K3(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), C8(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), C8(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function C8(n, e, t) {
  for (; e < n.length && Ql(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function C2(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != xn && e.push(r);
  }), n.cursorWrapper && e.push(ct.create(n.state.doc, [n.cursorWrapper.deco])), To.from(e);
}
const oU = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, lU = lr && _o <= 11;
class aU {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class cU {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new aU(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      lr && _o <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), lU && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, oU)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (g8(this.view)) {
      if (this.suppressingSelectionUpdates)
        return qs(this.view);
      if (lr && _o <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && ya(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = Zc(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = Zc(s))
      if (t.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && g8(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, l = !1, a = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let h = this.registerMutation(t[u], a);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (l = !0));
      }
    if (Zr && a.length) {
      let u = a.filter((h) => h.nodeName == "BR");
      if (u.length == 2) {
        let [h, f] = u;
        h.parentNode && h.parentNode.parentNode == f.parentNode ? f.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let f of u) {
          let d = f.parentNode;
          d && d.nodeName == "LI" && (!h || fU(e, h) != d) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && P1(r) && (c = $3(e)) && c.eq(Pe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, qs(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), uU(e)), this.handleDOMChange(s, o, l, a), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || qs(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let h = e.addedNodes[u];
        t.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (lr && _o <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: h, nextSibling: f } = e.addedNodes[u];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = i && i.parentNode == e.target ? pn(i) + 1 : 0, l = r.localPosFromDOM(e.target, o, -1), a = s && s.parentNode == e.target ? pn(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, a, 1);
      return { from: l, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let M8 = /* @__PURE__ */ new WeakMap(), T8 = !1;
function uU(n) {
  if (!M8.has(n) && (M8.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = Zr, T8)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), T8 = !0;
  }
}
function A8(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return ya(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function hU(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return A8(n, i);
  }
  let t;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? A8(n, t) : null;
}
function fU(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function dU(n, e, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: l } = n.docView.parseRange(e, t), a = n.domSelectionRange(), c, u = a.anchorNode;
  if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: a.anchorOffset }], P1(a) || c.push({ node: a.focusNode, offset: a.focusOffset })), Cn && n.input.lastKeyCode === 8)
    for (let g = s; g > i; g--) {
      let b = r.childNodes[g - 1], w = b.pmViewDesc;
      if (b.nodeName == "BR" && !w) {
        s = g;
        break;
      }
      if (!w || w.size)
        break;
    }
  let h = n.state.doc, f = n.someProp("domParser") || pa.fromSchema(n.state.schema), d = h.resolve(o), p = null, m = f.parse(r, {
    topNode: d.parent,
    topMatch: d.parent.contentMatchAt(d.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: d.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: pU,
    context: d
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = g), p = { anchor: g + o, head: b + o };
  }
  return { doc: m, sel: p, from: o, to: l };
}
function pU(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (Hn && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || Hn && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const mU = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function gU(n, e, t, r, i) {
  let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let I = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, _ = $3(n, I);
    if (_ && !n.state.selection.eq(_)) {
      if (Cn && zs && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (L) => L(n, Al(13, "Enter"))))
        return;
      let F = n.state.tr.setSelection(_);
      I == "pointer" ? F.setMeta("pointer", !0) : I == "key" && F.scrollIntoView(), s && F.setMeta("composition", s), n.dispatch(F);
    }
    return;
  }
  let o = n.state.doc.resolve(e), l = o.sharedDepth(t);
  e = o.before(l + 1), t = n.state.doc.resolve(t).after(l + 1);
  let a = n.state.selection, c = dU(n, e, t), u = n.state.doc, h = u.slice(c.from, c.to), f, d;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, d = "end") : (f = n.state.selection.from, d = "start"), n.input.lastKeyCode = null;
  let p = vU(h.content, c.doc.content, c.from, f, d);
  if (p && n.input.domChangeCount++, (Qc && n.input.lastIOSEnter > Date.now() - 225 || zs) && i.some((I) => I.nodeType == 1 && !mU.test(I.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", (I) => I(n, Al(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!p)
    if (r && a instanceof ge && !a.empty && a.$head.sameParent(a.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head))
      p = { start: a.from, endA: a.to, endB: a.to };
    else {
      if (c.sel) {
        let I = O8(n, n.state.doc, c.sel);
        if (I && !I.eq(n.state.selection)) {
          let _ = n.state.tr.setSelection(I);
          s && _.setMeta("composition", s), n.dispatch(_);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof ge && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), lr && _o <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == " Â " && (p.start--, p.endA--, p.endB--);
  let m = c.doc.resolveNoCache(p.start - c.from), g = c.doc.resolveNoCache(p.endB - c.from), b = u.resolve(p.start), w = m.sameParent(g) && m.parent.inlineContent && b.end() >= p.endA;
  if ((Qc && n.input.lastIOSEnter > Date.now() - 225 && (!w || i.some((I) => I.nodeName == "DIV" || I.nodeName == "P")) || !w && m.pos < c.doc.content.size && (!m.sameParent(g) || !m.parent.inlineContent) && m.pos < g.pos && !/\S/.test(c.doc.textBetween(m.pos, g.pos, "", ""))) && n.someProp("handleKeyDown", (I) => I(n, Al(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > p.start && bU(u, p.start, p.endA, m, g) && n.someProp("handleKeyDown", (I) => I(n, Al(8, "Backspace")))) {
    zs && Cn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  Cn && p.endB == p.start && (n.input.lastChromeDelete = Date.now()), zs && !w && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, g = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(I) {
      return I(n, Al(13, "Enter"));
    });
  }, 20));
  let k = p.start, T = p.endA, M = (I) => {
    let _ = I || n.state.tr.replace(k, T, c.doc.slice(p.start - c.from, p.endB - c.from));
    if (c.sel) {
      let F = O8(n, _.doc, c.sel);
      F && !(Cn && n.composing && F.empty && (p.start != p.endB || n.input.lastChromeDelete < Date.now() - 100) && (F.head == k || F.head == _.mapping.map(T) - 1) || lr && F.empty && F.head == k) && _.setSelection(F);
    }
    return s && _.setMeta("composition", s), _.scrollIntoView();
  }, C;
  if (w) {
    if (m.pos == g.pos) {
      lr && _o <= 11 && m.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => qs(n), 20));
      let I = M(n.state.tr.delete(k, T)), _ = u.resolve(p.start).marksAcross(u.resolve(p.endA));
      _ && I.ensureMarks(_), n.dispatch(I);
    } else if (
      // Adding or removing a mark
      p.endA == p.endB && (C = yU(m.parent.content.cut(m.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, p.endA - b.start())))
    ) {
      let I = M(n.state.tr);
      C.type == "add" ? I.addMark(k, T, C.mark) : I.removeMark(k, T, C.mark), n.dispatch(I);
    } else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let I = m.parent.textBetween(m.parentOffset, g.parentOffset), _ = () => M(n.state.tr.insertText(I, k, T));
      n.someProp("handleTextInput", (F) => F(n, k, T, I, _)) || n.dispatch(_());
    }
  } else
    n.dispatch(M());
}
function O8(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : V3(n, e.resolve(t.anchor), e.resolve(t.head));
}
function yU(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, l, a;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    l = i[0], o = "add", a = (u) => u.mark(l.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    l = s[0], o = "remove", a = (u) => u.mark(l.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(a(e.child(u)));
  if (Y.from(c).eq(n))
    return { mark: l, type: o };
}
function bU(n, e, t, r, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    M2(r, !0, !1) < i.pos
  )
    return !1;
  let s = n.resolve(e);
  if (!r.parent.isTextblock) {
    let l = s.nodeAfter;
    return l != null && t == e + l.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(M2(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || M2(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function M2(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let s = n.node(r).maybeChild(n.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function vU(n, e, t, r, i) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: l } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    r -= o + a - s;
  }
  if (o < s && n.size < e.size) {
    let a = r <= s && r >= o ? s - r : 0;
    s -= a, s && s < e.size && E8(e.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), l = s + (l - o), o = s;
  } else if (l < s) {
    let a = r <= s && r >= l ? s - r : 0;
    s -= a, s && s < n.size && E8(n.textBetween(s - 1, s + 1)) && (s += a ? 1 : -1), o = s + (o - l), l = s;
  }
  return { start: s, endA: o, endB: l };
}
function E8(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class Y3 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new _j(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(P8), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = N8(this), D8(this), this.nodeViews = R8(this), this.docView = u8(this.state.doc, I8(this), C2(this), this.dom, this), this.domObserver = new cU(this, (r, i, s, o) => gU(this, r, i, s, o)), this.domObserver.start(), Fj(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && e5(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(P8), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let i = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (qT(this), o = !0), this.state = e;
    let l = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (l || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let d = R8(this);
      xU(d, this.nodeViews) && (this.nodeViews = d, s = !0);
    }
    (l || t.handleDOMEvents != this._props.handleDOMEvents) && e5(this), this.editable = N8(this), D8(this);
    let a = C2(this), c = I8(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = s || !this.docView.matchesNode(e.doc, c, a);
    (h || !e.selection.eq(i.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && QW(this);
    if (o) {
      this.domObserver.stop();
      let d = h && (lr || Cn) && !this.composing && !i.selection.empty && !e.selection.empty && wU(i.selection, e.selection);
      if (h) {
        let p = Cn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = Zj(this)), (s || !this.docView.update(e.doc, c, a, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = u8(e.doc, c, a, this.dom, this)), p && !this.trackWrites && (d = !0);
      }
      d || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Sj(this)) ? qs(this, d) : (DT(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && ej(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof ve) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && i8(this, t.getBoundingClientRect(), e);
      } else
        i8(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let s = r.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
    }
    this.dragging = new jT(e.slice, e.move, i < 0 ? void 0 : ve.create(this.state.doc, i));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let l = this.directPlugins[o].props[e];
      if (l != null && (i = t ? t(l) : l))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let l = s[o].props[e];
        if (l != null && (i = t ? t(l) : l))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (lr) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && tj(this.dom), qs(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return oj(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return ST(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesâ€”for example when interpreting an event
  targetâ€”you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return hj(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return zf(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return zf(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return q3(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (Hj(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], C2(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, VW());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return Vj(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Hn && this.root.nodeType === 11 && GW(this.dom.ownerDocument) == this.dom && hU(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
Y3.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function I8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [Wt.node(0, n.state.doc.content.size, e)];
}
function D8(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: Wt.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function N8(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function wU(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function R8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function xU(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function P8(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
function sl(n, e) {
  return n.meta = {
    package: "@milkdown/core",
    group: "System",
    ...e
  }, n;
}
const JT = {
  text: (n, e, t, r) => {
    const i = n.value;
    return /^[^*_\\]*\s+$/.test(i) ? i : t.safe(i, { ...r, encode: [] });
  },
  strong: (n, e, t, r) => {
    const i = n.marker || t.options.strong || "*", s = t.enter("strong"), o = t.createTracker(r);
    let l = o.move(i + i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i + i), s(), l;
  },
  emphasis: (n, e, t, r) => {
    const i = n.marker || t.options.emphasis || "*", s = t.enter("emphasis"), o = t.createTracker(r);
    let l = o.move(i);
    return l += o.move(
      t.containerPhrasing(n, {
        before: l,
        after: i,
        ...o.current()
      })
    ), l += o.move(i), s(), l;
  }
}, pt = Ge({}, "editorView"), wh = Ge({}, "editorState"), T2 = Ge([], "initTimer"), t5 = Ge({}, "editor"), Ff = Ge([], "inputRules"), Ko = Ge([], "prosePlugins"), Hf = Ge(
  [],
  "remarkPlugins"
), $f = Ge([], "nodeView"), Vf = Ge([], "markView"), ea = Ge(
  $y().use(Py).use(_y),
  "remark"
), nf = Ge(
  {
    handlers: JT,
    encode: []
  },
  "remarkStringifyOptions"
), Np = ro("ConfigReady");
function kU(n) {
  const e = (t) => (t.record(Np), async () => (await n(t), t.done(Np), () => {
    t.clearTimer(Np);
  }));
  return sl(e, {
    displayName: "Config"
  }), e;
}
const ta = ro("InitReady");
function SU(n) {
  const e = (t) => (t.inject(t5, n).inject(Ko, []).inject(Hf, []).inject(Ff, []).inject($f, []).inject(Vf, []).inject(nf, {
    handlers: JT,
    encode: []
  }).inject(ea, $y().use(Py).use(_y)).inject(T2, [Np]).record(ta), async () => {
    await t.waitTimers(T2);
    const r = t.get(nf);
    return t.set(
      ea,
      $y().use(Py).use(_y, r)
    ), t.done(ta), () => {
      t.remove(t5).remove(Ko).remove(Hf).remove(Ff).remove($f).remove(Vf).remove(nf).remove(ea).remove(T2).clearTimer(ta);
    };
  });
  return sl(e, {
    displayName: "Init"
  }), e;
}
const ei = ro("SchemaReady"), A2 = Ge([], "schemaTimer"), Qi = Ge({}, "schema"), rf = Ge([], "nodes"), sf = Ge([], "marks");
function L8(n) {
  var e;
  return {
    ...n,
    parseDOM: (e = n.parseDOM) == null ? void 0 : e.map((t) => ({ priority: n.priority, ...t }))
  };
}
const XT = (n) => (n.inject(Qi, {}).inject(rf, []).inject(sf, []).inject(A2, [ta]).record(ei), async () => {
  await n.waitTimers(A2);
  const e = n.get(ea), r = n.get(Hf).reduce(
    (l, a) => l.use(a.plugin, a.options),
    e
  );
  n.set(ea, r);
  const i = Object.fromEntries(
    n.get(rf).map(([l, a]) => [l, L8(a)])
  ), s = Object.fromEntries(
    n.get(sf).map(([l, a]) => [l, L8(a)])
  ), o = new eM({ nodes: i, marks: s });
  return n.set(Qi, o), n.done(ei), () => {
    n.remove(Qi).remove(rf).remove(sf).remove(A2).clearTimer(ei);
  };
});
sl(XT, {
  displayName: "Schema"
});
var zl, $r;
class ZT {
  constructor() {
    ee(this, zl);
    ee(this, $r);
    W(this, zl, new AM()), W(this, $r, null), this.setCtx = (e) => {
      W(this, $r, e);
    }, this.chain = () => {
      if (N(this, $r) == null) throw l2();
      const e = N(this, $r), t = [], r = this.get.bind(this), i = {
        run: () => {
          const o = pu(...t), l = e.get(pt);
          return o(l.state, l.dispatch, l);
        },
        inline: (o) => (t.push(o), i),
        pipe: s.bind(this)
      };
      function s(o, l) {
        const a = r(o);
        return t.push(a(l)), i;
      }
      return i;
    };
  }
  get ctx() {
    return N(this, $r);
  }
  /// Register a command into the manager.
  create(e, t) {
    const r = e.create(N(this, zl).sliceMap);
    return r.set(t), r;
  }
  get(e) {
    return N(this, zl).get(e).get();
  }
  remove(e) {
    return N(this, zl).remove(e);
  }
  call(e, t) {
    if (N(this, $r) == null) throw l2();
    const i = this.get(e)(t), s = N(this, $r).get(pt);
    return i(s.state, s.dispatch, s);
  }
  /// Call an inline command.
  inline(e) {
    if (N(this, $r) == null) throw l2();
    const t = N(this, $r).get(pt);
    return e(t.state, t.dispatch, t);
  }
}
zl = new WeakMap(), $r = new WeakMap();
function CU(n = "cmdKey") {
  return Ge(() => () => !1, n);
}
const pe = Ge(new ZT(), "commands"), O2 = Ge([ei], "commandsTimer"), of = ro("CommandsReady"), QT = (n) => {
  const e = new ZT();
  return e.setCtx(n), n.inject(pe, e).inject(O2, [ei]).record(of), async () => (await n.waitTimers(O2), n.done(of), () => {
    n.remove(pe).remove(O2).clearTimer(of);
  });
};
sl(QT, {
  displayName: "Commands"
});
function MU(n) {
  const e = pu(
    oH,
    L3,
    xW,
    uT
  );
  return n.Backspace = e, n;
}
var _l, Yn;
class eA {
  constructor() {
    ee(this, _l);
    ee(this, Yn);
    W(this, _l, null), W(this, Yn, []), this.setCtx = (e) => {
      W(this, _l, e);
    }, this.add = (e) => (N(this, Yn).push(e), () => {
      W(this, Yn, N(this, Yn).filter((t) => t !== e));
    }), this.addObjectKeymap = (e) => {
      const t = [];
      return Object.entries(e).forEach(([r, i]) => {
        if (typeof i == "function") {
          const s = {
            key: r,
            onRun: () => i
          };
          N(this, Yn).push(s), t.push(() => {
            W(this, Yn, N(this, Yn).filter((o) => o !== s));
          });
        } else
          N(this, Yn).push(i), t.push(() => {
            W(this, Yn, N(this, Yn).filter((s) => s !== i));
          });
      }), () => {
        t.forEach((r) => r());
      };
    }, this.addBaseKeymap = () => {
      const e = MU(zW);
      return this.addObjectKeymap(e);
    }, this.build = () => {
      const e = {};
      return N(this, Yn).forEach((r) => {
        e[r.key] = [...e[r.key] || [], r];
      }), Object.fromEntries(
        Object.entries(e).map(([r, i]) => {
          const s = i.sort(
            (l, a) => (a.priority ?? 50) - (l.priority ?? 50)
          );
          return [r, (l, a, c) => {
            const u = N(this, _l);
            if (u == null) throw T1();
            const h = s.map((d) => d.onRun(u));
            return pu(...h)(l, a, c);
          }];
        })
      );
    };
  }
  get ctx() {
    return N(this, _l);
  }
}
_l = new WeakMap(), Yn = new WeakMap();
const Lm = Ge(new eA(), "keymap"), E2 = Ge([ei], "keymapTimer"), lf = ro("KeymapReady"), TU = (n) => {
  const e = new eA();
  return e.setCtx(n), n.inject(Lm, e).inject(E2, [ei]).record(lf), async () => (await n.waitTimers(E2), n.done(lf), () => {
    n.remove(Lm).remove(E2).clearTimer(lf);
  });
}, Rp = ro("ParserReady"), tA = () => {
  throw T1();
}, af = Ge(tA, "parser"), I2 = Ge([], "parserTimer"), nA = (n) => (n.inject(af, tA).inject(I2, [ei]).record(Rp), async () => {
  await n.waitTimers(I2);
  const e = n.get(ea), t = n.get(Qi);
  return n.set(af, bW.create(t, e)), n.done(Rp), () => {
    n.remove(af).remove(I2).clearTimer(Rp);
  };
});
sl(nA, {
  displayName: "Parser"
});
const cf = ro("SerializerReady"), D2 = Ge(
  [],
  "serializerTimer"
), rA = () => {
  throw T1();
}, ac = Ge(
  rA,
  "serializer"
), iA = (n) => (n.inject(ac, rA).inject(D2, [ei]).record(cf), async () => {
  await n.waitTimers(D2);
  const e = n.get(ea), t = n.get(Qi);
  return n.set(ac, wW.create(t, e)), n.done(cf), () => {
    n.remove(ac).remove(D2).clearTimer(cf);
  };
});
sl(iA, {
  displayName: "Serializer"
});
const Pp = Ge("", "defaultValue"), N2 = Ge(
  (n) => n,
  "stateOptions"
), R2 = Ge(
  [],
  "editorStateTimer"
), Lp = ro("EditorStateReady");
function AU(n, e, t) {
  if (typeof n == "string") return e(n);
  if (n.type === "html")
    return pa.fromSchema(t).parse(n.dom);
  if (n.type === "json")
    return Vs.fromJSON(t, n.value);
  throw aH(n);
}
const OU = new kt("MILKDOWN_STATE_TRACKER"), sA = (n) => (n.inject(Pp, "").inject(wh, {}).inject(N2, (e) => e).inject(R2, [
  Rp,
  cf,
  of,
  lf
]).record(Lp), async () => {
  await n.waitTimers(R2);
  const e = n.get(Qi), t = n.get(af), r = n.get(Ff), i = n.get(N2), s = n.get(Ko), o = n.get(Pp), l = AU(o, t, e), a = n.get(Lm), c = a.addBaseKeymap(), u = [
    ...s,
    new xt({
      key: OU,
      state: {
        init: () => {
        },
        apply: (d, p, m, g) => {
          n.set(wh, g);
        }
      }
    }),
    MH({ rules: r }),
    gT(a.build())
  ];
  n.set(Ko, u);
  const h = i({
    schema: e,
    doc: l,
    plugins: u
  }), f = Il.create(h);
  return n.set(wh, f), n.done(Lp), () => {
    c(), n.remove(Pp).remove(wh).remove(N2).remove(R2).clearTimer(Lp);
  };
});
sl(sA, {
  displayName: "EditorState"
});
const Bp = ro("EditorViewReady"), P2 = Ge(
  [],
  "editorViewTimer"
), uf = Ge(
  {},
  "editorViewOptions"
), zp = Ge(null, "root"), n5 = Ge(null, "rootDOM"), r5 = Ge(
  {},
  "rootAttrs"
);
function EU(n, e) {
  const t = document.createElement("div");
  t.className = "milkdown", n.appendChild(t), e.set(n5, t);
  const r = e.get(r5);
  return Object.entries(r).forEach(
    ([i, s]) => t.setAttribute(i, s)
  ), t;
}
function IU(n) {
  n.classList.add("editor"), n.setAttribute("role", "textbox");
}
const DU = new kt("MILKDOWN_VIEW_CLEAR"), oA = (n) => (n.inject(zp, document.body).inject(pt, {}).inject(uf, {}).inject(n5, null).inject(r5, {}).inject(P2, [Lp]).record(Bp), async () => {
  await n.wait(ta);
  const e = n.get(zp) || document.body, t = typeof e == "string" ? document.querySelector(e) : e;
  n.update(Ko, (a) => [
    new xt({
      key: DU,
      view: (c) => {
        const u = t ? EU(t, n) : void 0;
        return (() => {
          if (u && t) {
            const f = c.dom;
            t.replaceChild(u, f), u.appendChild(f);
          }
        })(), {
          destroy: () => {
            u != null && u.parentNode && (u == null || u.parentNode.replaceChild(c.dom, u)), u == null || u.remove();
          }
        };
      }
    }),
    ...a
  ]), await n.waitTimers(P2);
  const r = n.get(wh), i = n.get(uf), s = Object.fromEntries(n.get($f)), o = Object.fromEntries(n.get(Vf)), l = new Y3(t, {
    state: r,
    nodeViews: s,
    markViews: o,
    ...i
  });
  return IU(l.dom), n.set(pt, l), n.done(Bp), () => {
    l == null || l.destroy(), n.remove(zp).remove(pt).remove(uf).remove(n5).remove(r5).remove(P2).clearTimer(Bp);
  };
});
sl(oA, {
  displayName: "EditorView"
});
var Bm = /* @__PURE__ */ ((n) => (n.Idle = "Idle", n.OnCreate = "OnCreate", n.Created = "Created", n.OnDestroy = "OnDestroy", n.Destroyed = "Destroyed", n))(Bm || {}), Fl, xr, Ns, Sc, sd, od, Jn, Rs, Hl, ld, $l, Cc, ad, Io, Mc;
const cv = class cv {
  constructor() {
    ee(this, Fl);
    ee(this, xr);
    ee(this, Ns);
    ee(this, Sc);
    ee(this, sd);
    ee(this, od);
    ee(this, Jn);
    ee(this, Rs);
    ee(this, Hl);
    ee(this, ld);
    ee(this, $l);
    ee(this, Cc);
    ee(this, ad);
    ee(this, Io);
    ee(this, Mc);
    W(this, Fl, !1), W(this, xr, "Idle"), W(this, Ns, []), W(this, Sc, () => {
    }), W(this, sd, new AM()), W(this, od, new qH()), W(this, Jn, /* @__PURE__ */ new Map()), W(this, Rs, /* @__PURE__ */ new Map()), W(this, Hl, new Iy(N(this, sd), N(this, od))), W(this, ld, () => {
      const e = kU(async (r) => {
        await Promise.all(N(this, Ns).map((i) => i(r)));
      }), t = [
        XT,
        nA,
        iA,
        QT,
        TU,
        sA,
        oA,
        SU(this),
        e
      ];
      N(this, $l).call(this, t, N(this, Rs));
    }), W(this, $l, (e, t) => {
      e.forEach((r) => {
        const i = N(this, Hl).produce(
          N(this, Fl) ? r.meta : void 0
        ), s = r(i);
        t.set(r, { ctx: i, handler: s, cleanup: void 0 });
      });
    }), W(this, Cc, (e, t = !1) => Promise.all(
      [e].flat().map((r) => {
        const i = N(this, Jn).get(r), s = i == null ? void 0 : i.cleanup;
        return t ? N(this, Jn).delete(r) : N(this, Jn).set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        }), typeof s == "function" ? s() : s;
      })
    )), W(this, ad, async () => {
      await Promise.all(
        [...N(this, Rs).entries()].map(([e, { cleanup: t }]) => typeof t == "function" ? t() : t)
      ), N(this, Rs).clear();
    }), W(this, Io, (e) => {
      W(this, xr, e), N(this, Sc).call(this, e);
    }), W(this, Mc, (e) => [...e.entries()].map(async ([t, r]) => {
      const { ctx: i, handler: s } = r;
      if (!s) return;
      const o = await s();
      e.set(t, { ctx: i, handler: s, cleanup: o });
    })), this.enableInspector = (e = !0) => (W(this, Fl, e), this), this.onStatusChange = (e) => (W(this, Sc, e), this), this.config = (e) => (N(this, Ns).push(e), this), this.removeConfig = (e) => (W(this, Ns, N(this, Ns).filter((t) => t !== e)), this), this.use = (e) => {
      const t = [e].flat();
      return t.flat().forEach((r) => {
        N(this, Jn).set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), N(this, xr) === "Created" && N(this, $l).call(this, t, N(this, Jn)), this;
    }, this.remove = async (e) => N(this, xr) === "OnCreate" ? (console.warn(
      "[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."
    ), new Promise((t) => {
      setTimeout(() => {
        t(this.remove(e));
      }, 50);
    })) : (await N(this, Cc).call(this, [e].flat(), !0), this), this.create = async () => N(this, xr) === "OnCreate" ? this : (N(this, xr) === "Created" && await this.destroy(), N(this, Io).call(this, "OnCreate"), N(this, ld).call(this), N(this, $l).call(this, [...N(this, Jn).keys()], N(this, Jn)), await Promise.all(
      [
        N(this, Mc).call(this, N(this, Rs)),
        N(this, Mc).call(this, N(this, Jn))
      ].flat()
    ), N(this, Io).call(this, "Created"), this), this.destroy = async (e = !1) => N(this, xr) === "Destroyed" || N(this, xr) === "OnDestroy" ? this : N(this, xr) === "OnCreate" ? new Promise((t) => {
      setTimeout(() => {
        t(this.destroy(e));
      }, 50);
    }) : (e && W(this, Ns, []), N(this, Io).call(this, "OnDestroy"), await N(this, Cc).call(this, [...N(this, Jn).keys()], e), await N(this, ad).call(this), N(this, Io).call(this, "Destroyed"), this), this.action = (e) => e(N(this, Hl)), this.inspect = () => N(this, Fl) ? [...N(this, Rs).values(), ...N(this, Jn).values()].map(({ ctx: e }) => {
      var t;
      return (t = e == null ? void 0 : e.inspector) == null ? void 0 : t.read();
    }).filter((e) => !!e) : (console.warn(
      "[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."
    ), []);
  }
  /// Create a new editor instance.
  static make() {
    return new cv();
  }
  /// Get the ctx of the editor.
  get ctx() {
    return N(this, Hl);
  }
  /// Get the status of the editor.
  get status() {
    return N(this, xr);
  }
};
Fl = new WeakMap(), xr = new WeakMap(), Ns = new WeakMap(), Sc = new WeakMap(), sd = new WeakMap(), od = new WeakMap(), Jn = new WeakMap(), Rs = new WeakMap(), Hl = new WeakMap(), ld = new WeakMap(), $l = new WeakMap(), Cc = new WeakMap(), ad = new WeakMap(), Io = new WeakMap(), Mc = new WeakMap();
let i5 = cv, NU = (n) => crypto.getRandomValues(new Uint8Array(n)), RU = (n, e, t) => {
  let r = (2 << Math.log2(n.length - 1)) - 1, i = -~(1.6 * r * e / n.length);
  return (s = e) => {
    let o = "";
    for (; ; ) {
      let l = t(i), a = i | 0;
      for (; a--; )
        if (o += n[l[a] & r] || "", o.length >= s) return o;
    }
  };
}, J3 = (n, e = 21) => RU(n, e | 0, NU);
J3("abcedfghicklmn", 10);
function De(n, e) {
  const t = CU(n), r = (i) => async () => {
    r.key = t, await i.wait(of);
    const s = e(i);
    return i.get(pe).create(t, s), r.run = (o) => i.get(pe).call(n, o), () => {
      i.get(pe).remove(t);
    };
  };
  return r;
}
function On(n) {
  const e = (t) => async () => {
    await t.wait(ei);
    const r = n(t);
    return t.update(Ff, (i) => [...i, r]), e.inputRule = r, () => {
      t.update(Ff, (i) => i.filter((s) => s !== r));
    };
  };
  return e;
}
function PU(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(sf, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(sf, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(Qi).marks[n];
    if (!i) throw gH(n);
    return i;
  }, t;
}
function X3(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(rf, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(rf, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(Qi).nodes[n];
    if (!i) throw mH(n);
    return i;
  }, t;
}
function Ut(n) {
  let e;
  const t = (r) => async () => (await r.wait(ei), e = n(r), r.update(Ko, (i) => [...i, e]), () => {
    r.update(Ko, (i) => i.filter((s) => s !== e));
  });
  return t.plugin = () => e, t.key = () => e.spec.key, t;
}
function lA(n) {
  const e = (t) => async () => {
    await t.wait(lf);
    const r = t.get(Lm), i = n(t), s = r.addObjectKeymap(i);
    return e.keymap = i, () => {
      s();
    };
  };
  return e;
}
function Hd(n, e) {
  const t = (r) => async () => {
    await r.wait(ei);
    const i = e(r);
    return n.type(r) instanceof Am ? r.update($f, (s) => [
      ...s,
      [n.id, i]
    ]) : r.update(Vf, (s) => [
      ...s,
      [n.id, i]
    ]), t.view = i, t.type = n, () => {
      n.type(r) instanceof Am ? r.update($f, (s) => s.filter((o) => o[0] !== n.id)) : r.update(Vf, (s) => s.filter((o) => o[0] !== n.id));
    };
  };
  return t;
}
function it(n, e) {
  const t = Ge(n, e), r = (i) => (i.inject(t), () => () => {
    i.remove(t);
  });
  return r.key = t, r;
}
function _t(n, e) {
  const t = it(e, n), r = X3(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.node = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return _t(n, o);
  }, i;
}
function mu(n, e) {
  const t = it(e, n), r = PU(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.mark = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return mu(n, o);
  }, i;
}
function hr(n, e) {
  const t = Object.fromEntries(
    Object.entries(e).map(
      ([o, { shortcuts: l, priority: a }]) => [o, { shortcuts: l, priority: a }]
    )
  ), r = it(t, `${n}Keymap`), i = lA((o) => {
    const l = o.get(r.key), a = Object.entries(e).flatMap(
      ([c, { command: u }]) => {
        const h = l[c], f = [h.shortcuts].flat(), d = h.priority;
        return f.map(
          (p) => [
            p,
            {
              key: p,
              onRun: u,
              priority: d
            }
          ]
        );
      }
    );
    return Object.fromEntries(a);
  }), s = [r, i];
  return s.ctx = r, s.shortcuts = i, s.key = r.key, s.keymap = i.keymap, s;
}
const Oi = (n, e = () => ({})) => it(e, `${n}Attr`), $d = (n, e = () => ({})) => it(e, `${n}Attr`);
function as(n, e, t) {
  const r = it({}, n), i = (o) => async () => {
    await o.wait(ta);
    const a = {
      plugin: e(o),
      options: o.get(r.key)
    };
    return o.update(Hf, (c) => [...c, a]), () => {
      o.update(Hf, (c) => c.filter((u) => u !== a));
    };
  }, s = [r, i];
  return s.id = n, s.plugin = i, s.options = r, s;
}
function LU(n) {
  return (e) => {
    const t = e.get(pt);
    return e.get(Qi), e.get(ac)(t.state.doc);
  };
}
const s5 = Math.min, cc = Math.max, zm = Math.round, es = (n) => ({
  x: n,
  y: n
}), BU = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, zU = {
  start: "end",
  end: "start"
};
function B8(n, e, t) {
  return cc(n, s5(e, t));
}
function z1(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function va(n) {
  return n.split("-")[0];
}
function _1(n) {
  return n.split("-")[1];
}
function aA(n) {
  return n === "x" ? "y" : "x";
}
function cA(n) {
  return n === "y" ? "height" : "width";
}
const _U = /* @__PURE__ */ new Set(["top", "bottom"]);
function Bo(n) {
  return _U.has(va(n)) ? "y" : "x";
}
function uA(n) {
  return aA(Bo(n));
}
function FU(n, e, t) {
  t === void 0 && (t = !1);
  const r = _1(n), i = uA(n), s = cA(i);
  let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = _m(o)), [o, _m(o)];
}
function HU(n) {
  const e = _m(n);
  return [o5(n), e, o5(e)];
}
function o5(n) {
  return n.replace(/start|end/g, (e) => zU[e]);
}
const z8 = ["left", "right"], _8 = ["right", "left"], $U = ["top", "bottom"], VU = ["bottom", "top"];
function qU(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? _8 : z8 : e ? z8 : _8;
    case "left":
    case "right":
      return e ? $U : VU;
    default:
      return [];
  }
}
function WU(n, e, t, r) {
  const i = _1(n);
  let s = qU(va(n), t === "start", r);
  return i && (s = s.map((o) => o + "-" + i), e && (s = s.concat(s.map(o5)))), s;
}
function _m(n) {
  return n.replace(/left|right|bottom|top/g, (e) => BU[e]);
}
function jU(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function UU(n) {
  return typeof n != "number" ? jU(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function Fm(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function F8(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = Bo(e), o = uA(e), l = cA(o), a = va(e), c = s === "y", u = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, f = r[l] / 2 - i[l] / 2;
  let d;
  switch (a) {
    case "top":
      d = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      d = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      d = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      };
  }
  switch (_1(e)) {
    case "start":
      d[o] -= f * (t && c ? -1 : 1);
      break;
    case "end":
      d[o] += f * (t && c ? -1 : 1);
      break;
  }
  return d;
}
const GU = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = t, l = s.filter(Boolean), a = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: u,
    y: h
  } = F8(c, r, a), f = r, d = {}, p = 0;
  for (let m = 0; m < l.length; m++) {
    const {
      name: g,
      fn: b
    } = l[m], {
      x: w,
      y: k,
      data: T,
      reset: M
    } = await b({
      x: u,
      y: h,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: d,
      rects: c,
      platform: o,
      elements: {
        reference: n,
        floating: e
      }
    });
    u = w ?? u, h = k ?? h, d = {
      ...d,
      [g]: {
        ...d[g],
        ...T
      }
    }, M && p <= 50 && (p++, typeof M == "object" && (M.placement && (f = M.placement), M.rects && (c = M.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : M.rects), {
      x: u,
      y: h
    } = F8(c, f, a)), m = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: i,
    middlewareData: d
  };
};
async function hA(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: l,
    strategy: a
  } = n, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: d = 0
  } = z1(e, n), p = UU(d), g = l[f ? h === "floating" ? "reference" : "floating" : h], b = Fm(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(g))) == null || t ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(l.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: a
  })), w = h === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, k = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l.floating)), T = await (s.isElement == null ? void 0 : s.isElement(k)) ? await (s.getScale == null ? void 0 : s.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, M = Fm(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: l,
    rect: w,
    offsetParent: k,
    strategy: a
  }) : w);
  return {
    top: (b.top - M.top + p.top) / T.y,
    bottom: (M.bottom - b.bottom + p.bottom) / T.y,
    left: (b.left - M.left + p.left) / T.x,
    right: (M.right - b.right + p.right) / T.x
  };
}
const KU = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: l,
        platform: a,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: f,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: p = "none",
        flipAlignment: m = !0,
        ...g
      } = z1(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const b = va(i), w = Bo(l), k = va(l) === l, T = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), M = f || (k || !m ? [_m(l)] : HU(l)), C = p !== "none";
      !f && C && M.push(...WU(l, m, p, T));
      const I = [l, ...M], _ = await hA(e, g), F = [];
      let L = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (u && F.push(_[b]), h) {
        const te = FU(i, o, T);
        F.push(_[te[0]], _[te[1]]);
      }
      if (L = [...L, {
        placement: i,
        overflows: F
      }], !F.every((te) => te <= 0)) {
        var $, B;
        const te = ((($ = s.flip) == null ? void 0 : $.index) || 0) + 1, ie = I[te];
        if (ie && (!(h === "alignment" ? w !== Bo(ie) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        L.every((Re) => Bo(Re.placement) === w ? Re.overflows[0] > 0 : !0)))
          return {
            data: {
              index: te,
              overflows: L
            },
            reset: {
              placement: ie
            }
          };
        let Ce = (B = L.filter((Oe) => Oe.overflows[0] <= 0).sort((Oe, Re) => Oe.overflows[1] - Re.overflows[1])[0]) == null ? void 0 : B.placement;
        if (!Ce)
          switch (d) {
            case "bestFit": {
              var se;
              const Oe = (se = L.filter((Re) => {
                if (C) {
                  const Be = Bo(Re.placement);
                  return Be === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Be === "y";
                }
                return !0;
              }).map((Re) => [Re.placement, Re.overflows.filter((Be) => Be > 0).reduce((Be, D) => Be + D, 0)]).sort((Re, Be) => Re[1] - Be[1])[0]) == null ? void 0 : se[0];
              Oe && (Ce = Oe);
              break;
            }
            case "initialPlacement":
              Ce = l;
              break;
          }
        if (i !== Ce)
          return {
            reset: {
              placement: Ce
            }
          };
      }
      return {};
    }
  };
}, YU = /* @__PURE__ */ new Set(["left", "top"]);
async function JU(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = va(t), l = _1(t), a = Bo(t) === "y", c = YU.has(o) ? -1 : 1, u = s && a ? -1 : 1, h = z1(e, n);
  let {
    mainAxis: f,
    crossAxis: d,
    alignmentAxis: p
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return l && typeof p == "number" && (d = l === "end" ? p * -1 : p), a ? {
    x: d * u,
    y: f * c
  } : {
    x: f * c,
    y: d * u
  };
}
const XU = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: l
      } = e, a = await JU(e, n);
      return o === ((t = l.offset) == null ? void 0 : t.placement) && (r = l.arrow) != null && r.alignmentOffset ? {} : {
        x: i + a.x,
        y: s + a.y,
        data: {
          ...a,
          placement: o
        }
      };
    }
  };
}, ZU = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: l = {
          fn: (g) => {
            let {
              x: b,
              y: w
            } = g;
            return {
              x: b,
              y: w
            };
          }
        },
        ...a
      } = z1(n, e), c = {
        x: t,
        y: r
      }, u = await hA(e, a), h = Bo(va(i)), f = aA(h);
      let d = c[f], p = c[h];
      if (s) {
        const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", w = d + u[g], k = d - u[b];
        d = B8(w, d, k);
      }
      if (o) {
        const g = h === "y" ? "top" : "left", b = h === "y" ? "bottom" : "right", w = p + u[g], k = p - u[b];
        p = B8(w, p, k);
      }
      const m = l.fn({
        ...e,
        [f]: d,
        [h]: p
      });
      return {
        ...m,
        data: {
          x: m.x - t,
          y: m.y - r,
          enabled: {
            [f]: s,
            [h]: o
          }
        }
      };
    }
  };
};
function F1() {
  return typeof window < "u";
}
function gu(n) {
  return fA(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Er(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function io(n) {
  var e;
  return (e = (fA(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function fA(n) {
  return F1() ? n instanceof Node || n instanceof Er(n).Node : !1;
}
function Ci(n) {
  return F1() ? n instanceof Element || n instanceof Er(n).Element : !1;
}
function is(n) {
  return F1() ? n instanceof HTMLElement || n instanceof Er(n).HTMLElement : !1;
}
function H8(n) {
  return !F1() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Er(n).ShadowRoot;
}
const QU = /* @__PURE__ */ new Set(["inline", "contents"]);
function Vd(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = Mi(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !QU.has(i);
}
const eG = /* @__PURE__ */ new Set(["table", "td", "th"]);
function tG(n) {
  return eG.has(gu(n));
}
const nG = [":popover-open", ":modal"];
function H1(n) {
  return nG.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const rG = ["transform", "translate", "scale", "rotate", "perspective"], iG = ["transform", "translate", "scale", "rotate", "perspective", "filter"], sG = ["paint", "layout", "strict", "content"];
function Z3(n) {
  const e = Q3(), t = Ci(n) ? Mi(n) : n;
  return rG.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || iG.some((r) => (t.willChange || "").includes(r)) || sG.some((r) => (t.contain || "").includes(r));
}
function oG(n) {
  let e = Yo(n);
  for (; is(e) && !eu(e); ) {
    if (Z3(e))
      return e;
    if (H1(e))
      return null;
    e = Yo(e);
  }
  return null;
}
function Q3() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const lG = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function eu(n) {
  return lG.has(gu(n));
}
function Mi(n) {
  return Er(n).getComputedStyle(n);
}
function $1(n) {
  return Ci(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function Yo(n) {
  if (gu(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    H8(n) && n.host || // Fallback.
    io(n)
  );
  return H8(e) ? e.host : e;
}
function dA(n) {
  const e = Yo(n);
  return eu(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : is(e) && Vd(e) ? e : dA(e);
}
function pA(n, e, t) {
  var r;
  e === void 0 && (e = []);
  const i = dA(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = Er(i);
  return s ? (l5(o), e.concat(o, o.visualViewport || [], Vd(i) ? i : [], [])) : e.concat(i, pA(i, []));
}
function l5(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function mA(n) {
  const e = Mi(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = is(n), s = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, l = zm(t) !== s || zm(r) !== o;
  return l && (t = s, r = o), {
    width: t,
    height: r,
    $: l
  };
}
function gA(n) {
  return Ci(n) ? n : n.contextElement;
}
function uc(n) {
  const e = gA(n);
  if (!is(e))
    return es(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = mA(e);
  let o = (s ? zm(t.width) : t.width) / r, l = (s ? zm(t.height) : t.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: o,
    y: l
  };
}
const aG = /* @__PURE__ */ es(0);
function yA(n) {
  const e = Er(n);
  return !Q3() || !e.visualViewport ? aG : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function cG(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Er(n) ? !1 : e;
}
function qf(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), s = gA(n);
  let o = es(1);
  e && (r ? Ci(r) && (o = uc(r)) : o = uc(n));
  const l = cG(s, t, r) ? yA(s) : es(0);
  let a = (i.left + l.x) / o.x, c = (i.top + l.y) / o.y, u = i.width / o.x, h = i.height / o.y;
  if (s) {
    const f = Er(s), d = r && Ci(r) ? Er(r) : r;
    let p = f, m = l5(p);
    for (; m && r && d !== p; ) {
      const g = uc(m), b = m.getBoundingClientRect(), w = Mi(m), k = b.left + (m.clientLeft + parseFloat(w.paddingLeft)) * g.x, T = b.top + (m.clientTop + parseFloat(w.paddingTop)) * g.y;
      a *= g.x, c *= g.y, u *= g.x, h *= g.y, a += k, c += T, p = Er(m), m = l5(p);
    }
  }
  return Fm({
    width: u,
    height: h,
    x: a,
    y: c
  });
}
function V1(n, e) {
  const t = $1(n).scrollLeft;
  return e ? e.left + t : qf(io(n)).left + t;
}
function bA(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - V1(n, t), i = t.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function uG(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", o = io(r), l = e ? H1(e.floating) : !1;
  if (r === o || l && s)
    return t;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = es(1);
  const u = es(0), h = is(r);
  if ((h || !h && !s) && ((gu(r) !== "body" || Vd(o)) && (a = $1(r)), is(r))) {
    const d = qf(r);
    c = uc(r), u.x = d.x + r.clientLeft, u.y = d.y + r.clientTop;
  }
  const f = o && !h && !s ? bA(o, a) : es(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - a.scrollLeft * c.x + u.x + f.x,
    y: t.y * c.y - a.scrollTop * c.y + u.y + f.y
  };
}
function hG(n) {
  return Array.from(n.getClientRects());
}
function fG(n) {
  const e = io(n), t = $1(n), r = n.ownerDocument.body, i = cc(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = cc(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + V1(n);
  const l = -t.scrollTop;
  return Mi(r).direction === "rtl" && (o += cc(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: l
  };
}
const $8 = 25;
function dG(n, e) {
  const t = Er(n), r = io(n), i = t.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, l = 0, a = 0;
  if (i) {
    s = i.width, o = i.height;
    const u = Q3();
    (!u || u && e === "fixed") && (l = i.offsetLeft, a = i.offsetTop);
  }
  const c = V1(r);
  if (c <= 0) {
    const u = r.ownerDocument, h = u.body, f = getComputedStyle(h), d = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, p = Math.abs(r.clientWidth - h.clientWidth - d);
    p <= $8 && (s -= p);
  } else c <= $8 && (s += c);
  return {
    width: s,
    height: o,
    x: l,
    y: a
  };
}
const pG = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function mG(n, e) {
  const t = qf(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, s = is(n) ? uc(n) : es(1), o = n.clientWidth * s.x, l = n.clientHeight * s.y, a = i * s.x, c = r * s.y;
  return {
    width: o,
    height: l,
    x: a,
    y: c
  };
}
function V8(n, e, t) {
  let r;
  if (e === "viewport")
    r = dG(n, t);
  else if (e === "document")
    r = fG(io(n));
  else if (Ci(e))
    r = mG(e, t);
  else {
    const i = yA(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return Fm(r);
}
function vA(n, e) {
  const t = Yo(n);
  return t === e || !Ci(t) || eu(t) ? !1 : Mi(t).position === "fixed" || vA(t, e);
}
function gG(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = pA(n, []).filter((l) => Ci(l) && gu(l) !== "body"), i = null;
  const s = Mi(n).position === "fixed";
  let o = s ? Yo(n) : n;
  for (; Ci(o) && !eu(o); ) {
    const l = Mi(o), a = Z3(o);
    !a && l.position === "fixed" && (i = null), (s ? !a && !i : !a && l.position === "static" && !!i && pG.has(i.position) || Vd(o) && !a && vA(n, o)) ? r = r.filter((u) => u !== o) : i = l, o = Yo(o);
  }
  return e.set(n, r), r;
}
function yG(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...t === "clippingAncestors" ? H1(e) ? [] : gG(e, this._c) : [].concat(t), r], l = o[0], a = o.reduce((c, u) => {
    const h = V8(e, u, i);
    return c.top = cc(h.top, c.top), c.right = s5(h.right, c.right), c.bottom = s5(h.bottom, c.bottom), c.left = cc(h.left, c.left), c;
  }, V8(e, l, i));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function bG(n) {
  const {
    width: e,
    height: t
  } = mA(n);
  return {
    width: e,
    height: t
  };
}
function vG(n, e, t) {
  const r = is(e), i = io(e), s = t === "fixed", o = qf(n, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = es(0);
  function c() {
    a.x = V1(i);
  }
  if (r || !r && !s)
    if ((gu(e) !== "body" || Vd(i)) && (l = $1(e)), r) {
      const d = qf(e, !0, s, e);
      a.x = d.x + e.clientLeft, a.y = d.y + e.clientTop;
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? bA(i, l) : es(0), h = o.left + l.scrollLeft - a.x - u.x, f = o.top + l.scrollTop - a.y - u.y;
  return {
    x: h,
    y: f,
    width: o.width,
    height: o.height
  };
}
function L2(n) {
  return Mi(n).position === "static";
}
function q8(n, e) {
  if (!is(n) || Mi(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return io(n) === t && (t = t.ownerDocument.body), t;
}
function wA(n, e) {
  const t = Er(n);
  if (H1(n))
    return t;
  if (!is(n)) {
    let i = Yo(n);
    for (; i && !eu(i); ) {
      if (Ci(i) && !L2(i))
        return i;
      i = Yo(i);
    }
    return t;
  }
  let r = q8(n, e);
  for (; r && tG(r) && L2(r); )
    r = q8(r, e);
  return r && eu(r) && L2(r) && !Z3(r) ? t : r || oG(n) || t;
}
const wG = async function(n) {
  const e = this.getOffsetParent || wA, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: vG(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function xG(n) {
  return Mi(n).direction === "rtl";
}
const kG = {
  convertOffsetParentRelativeRectToViewportRelativeRect: uG,
  getDocumentElement: io,
  getClippingRect: yG,
  getOffsetParent: wA,
  getElementRects: wG,
  getClientRects: hG,
  getDimensions: bG,
  getScale: uc,
  isElement: Ci,
  isRTL: xG
}, Jo = XU, W8 = ZU, Hm = KU, Ti = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: kG,
    ...t
  }, s = {
    ...i.platform,
    _c: r
  };
  return GU(n, e, {
    ...i,
    platform: s
  });
};
function qd(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-block",
      ...e
    }
  }), n;
}
const SG = (n) => !Zi((t) => t.type.name === "table")(n), q1 = it(
  { filterNodes: SG },
  "blockConfig"
);
qd(q1, {
  displayName: "Ctx<blockConfig>"
});
function CG(n, e, t) {
  var i;
  if (!n.dom.parentElement) return null;
  try {
    const s = (i = n.posAtCoords({
      left: e.x,
      top: e.y
    })) == null ? void 0 : i.inside;
    if (s == null || s < 0) return null;
    let o = n.state.doc.resolve(s), l = n.state.doc.nodeAt(s), a = n.nodeDOM(s);
    const c = (h) => {
      const f = o.depth >= 1 && o.index(o.depth) === 0;
      if (!(h || f)) return;
      const p = o.before(o.depth);
      l = n.state.doc.nodeAt(p), a = n.nodeDOM(p), o = n.state.doc.resolve(p), t(o, l) || c(!0);
    }, u = t(o, l);
    return c(!u), !a || !l ? null : { node: l, $pos: o, el: a };
  } catch {
    return null;
  }
}
const j8 = P0.ie && P0.ie_version < 15 || P0.ios && P0.webkit_version < 604, U8 = 20;
var Tc, cd, Vl, gi, Ac, yi, Fs, xA, xh, ql, Wl, ud, Oc, Ec, Ic, hd, jl;
class MG {
  constructor() {
    ee(this, Fs);
    /// @internal
    ee(this, Tc);
    ee(this, cd);
    ee(this, Vl);
    ee(this, gi);
    ee(this, Ac);
    ee(this, yi);
    /// @internal
    ee(this, ql);
    ee(this, Wl);
    ee(this, ud);
    ee(this, Oc);
    ee(this, Ec);
    ee(this, Ic);
    ee(this, hd);
    ee(this, jl);
    W(this, cd, () => {
      if (!N(this, gi)) return null;
      const e = N(this, gi), t = N(this, Fs, xh);
      if (t && ve.isSelectable(e.node)) {
        const r = ve.create(
          t.state.doc,
          e.$pos.pos
        );
        return t.dispatch(t.state.tr.setSelection(r)), t.focus(), W(this, Vl, r), r;
      }
      return null;
    }), W(this, Vl, null), W(this, gi, null), W(this, Ac, void 0), W(this, yi, !1), W(this, Wl, () => {
      var e;
      (e = N(this, ql)) == null || e.call(this, { type: "hide" }), W(this, gi, null);
    }), W(this, ud, (e) => {
      var t;
      W(this, gi, e), (t = N(this, ql)) == null || t.call(this, { type: "show", active: e });
    }), this.bind = (e, t) => {
      W(this, Tc, e), W(this, ql, t);
    }, this.addEvent = (e) => {
      e.addEventListener("mousedown", N(this, Oc)), e.addEventListener("mouseup", N(this, Ec)), e.addEventListener("dragstart", N(this, Ic));
    }, this.removeEvent = (e) => {
      e.removeEventListener("mousedown", N(this, Oc)), e.removeEventListener("mouseup", N(this, Ec)), e.removeEventListener("dragstart", N(this, Ic));
    }, this.unBind = () => {
      W(this, ql, void 0);
    }, W(this, Oc, () => {
      var e;
      W(this, Ac, (e = N(this, gi)) == null ? void 0 : e.el.getBoundingClientRect()), N(this, cd).call(this);
    }), W(this, Ec, () => {
      if (!N(this, yi)) {
        requestAnimationFrame(() => {
          var e;
          N(this, Ac) && ((e = N(this, Fs, xh)) == null || e.focus());
        });
        return;
      }
      W(this, yi, !1), W(this, Vl, null);
    }), W(this, Ic, (e) => {
      var i;
      W(this, yi, !0);
      const t = N(this, Fs, xh);
      if (!t) return;
      t.dom.dataset.dragging = "true";
      const r = N(this, Vl);
      if (e.dataTransfer && r) {
        const s = r.content();
        e.dataTransfer.effectAllowed = "copyMove";
        const { dom: o, text: l } = t.serializeForClipboard(s);
        e.dataTransfer.clearData(), e.dataTransfer.setData(
          j8 ? "Text" : "text/html",
          o.innerHTML
        ), j8 || e.dataTransfer.setData("text/plain", l);
        const a = (i = N(this, gi)) == null ? void 0 : i.el;
        a && e.dataTransfer.setDragImage(a, 0, 0), t.dragging = {
          slice: s,
          move: !0
        };
      }
    }), this.keydownCallback = (e) => (N(this, Wl).call(this), W(this, yi, !1), e.dom.dataset.dragging = "false", !1), W(this, hd, f1((e, t) => {
      if (!e.editable) return;
      const r = e.dom.getBoundingClientRect(), i = r.left + r.width / 2;
      if (!(e.root.elementFromPoint(i, t.clientY) instanceof Element)) {
        N(this, Wl).call(this);
        return;
      }
      const o = N(this, Fs, xA);
      if (!o) return;
      const l = CG(
        e,
        { x: i, y: t.clientY },
        o
      );
      if (!l) {
        N(this, Wl).call(this);
        return;
      }
      N(this, ud).call(this, l);
    }, 200)), this.mousemoveCallback = (e, t) => (e.composing || !e.editable || N(this, hd).call(this, e, t), !1), this.dragoverCallback = (e, t) => {
      var r;
      if (N(this, yi)) {
        const i = (r = N(this, Fs, xh)) == null ? void 0 : r.dom.parentElement;
        if (!i) return !1;
        const s = i.scrollHeight > i.clientHeight, o = i.getBoundingClientRect();
        if (s) {
          if (i.scrollTop > 0 && Math.abs(t.y - o.y) < U8) {
            const c = i.scrollTop > 10 ? i.scrollTop - 10 : 0;
            return i.scrollTop = c, !1;
          }
          const l = Math.round(e.dom.getBoundingClientRect().height);
          if (Math.round(i.scrollTop + o.height) < l && Math.abs(t.y - (o.height + o.y)) < U8) {
            const c = i.scrollTop + 10;
            return i.scrollTop = c, !1;
          }
        }
      }
      return !1;
    }, this.dragenterCallback = (e) => {
      e.dragging && (W(this, yi, !0), e.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (e, t) => {
      const r = t.clientX, i = t.clientY;
      (r < 0 || i < 0 || r > window.innerWidth || i > window.innerHeight) && (W(this, gi, null), N(this, jl).call(this, e));
    }, this.dropCallback = (e) => (N(this, jl).call(this, e), !1), this.dragendCallback = (e) => {
      N(this, jl).call(this, e);
    }, W(this, jl, (e) => {
      W(this, yi, !1), e.dom.dataset.dragging = "false";
    });
  }
}
Tc = new WeakMap(), cd = new WeakMap(), Vl = new WeakMap(), gi = new WeakMap(), Ac = new WeakMap(), yi = new WeakMap(), Fs = new WeakSet(), xA = function() {
  var e;
  try {
    return (e = N(this, Tc)) == null ? void 0 : e.get(q1.key).filterNodes;
  } catch {
    return;
  }
}, xh = function() {
  var e;
  return (e = N(this, Tc)) == null ? void 0 : e.get(pt);
}, ql = new WeakMap(), Wl = new WeakMap(), ud = new WeakMap(), Oc = new WeakMap(), Ec = new WeakMap(), Ic = new WeakMap(), hd = new WeakMap(), jl = new WeakMap();
const eb = it(() => new MG(), "blockService"), W1 = it(
  {},
  "blockServiceInstance"
);
qd(eb, {
  displayName: "Ctx<blockService>"
});
qd(W1, {
  displayName: "Ctx<blockServiceInstance>"
});
const j1 = it({}, "blockSpec");
qd(j1, {
  displayName: "Ctx<blockSpec>"
});
const tb = Ut((n) => {
  const e = new kt("MILKDOWN_BLOCK"), r = n.get(eb.key)();
  n.set(W1.key, r);
  const i = n.get(j1.key);
  return new xt({
    key: e,
    ...i,
    props: {
      ...i.props,
      handleDOMEvents: {
        drop: (s) => r.dropCallback(s),
        pointermove: (s, o) => r.mousemoveCallback(s, o),
        keydown: (s) => r.keydownCallback(s),
        dragover: (s, o) => r.dragoverCallback(s, o),
        dragleave: (s, o) => r.dragleaveCallback(s, o),
        dragenter: (s) => r.dragenterCallback(s),
        dragend: (s) => r.dragendCallback(s)
      }
    }
  });
});
qd(tb, {
  displayName: "Prose<block>"
});
var Xn, Ps, Ul, Gl, fd, Dc, dd, pd, Nc, Rc, Pc, i1, kA;
class TG {
  constructor(e) {
    ee(this, i1);
    /// @internal
    ee(this, Xn);
    /// @internal
    ee(this, Ps);
    /// @internal
    ee(this, Ul);
    ee(this, Gl);
    /// @internal
    ee(this, fd);
    ee(this, Dc);
    /// @internal
    ee(this, dd);
    /// @internal
    ee(this, pd);
    /// @internal
    ee(this, Nc);
    /// @internal
    ee(this, Rc);
    /// @internal
    ee(this, Pc);
    W(this, Gl, null), W(this, Dc, !1), this.update = () => {
      requestAnimationFrame(() => {
        if (!N(this, Dc))
          try {
            u0(this, i1, kA).call(this), W(this, Dc, !0);
          } catch {
          }
      });
    }, this.destroy = () => {
      var t, r;
      (t = N(this, Ul)) == null || t.unBind(), (r = N(this, Ul)) == null || r.removeEvent(N(this, Xn)), N(this, Xn).remove();
    }, this.show = (t) => {
      const r = t.el, i = N(this, Ps).get(pt).dom, s = {
        ctx: N(this, Ps),
        active: t,
        editorDom: i,
        blockDom: N(this, Xn)
      }, o = {
        contextElement: r,
        getBoundingClientRect: () => N(this, Rc) ? N(this, Rc).call(this, s) : r.getBoundingClientRect()
      }, l = [Hm()];
      if (N(this, Nc)) {
        const a = N(this, Nc).call(this, s), c = Jo(a);
        l.push(c);
      }
      Ti(o, N(this, Xn), {
        placement: N(this, Pc) ? N(this, Pc).call(this, s) : "left",
        middleware: [...l, ...N(this, dd)],
        ...N(this, pd)
      }).then(({ x: a, y: c }) => {
        Object.assign(N(this, Xn).style, {
          left: `${a}px`,
          top: `${c}px`
        }), N(this, Xn).dataset.show = "true";
      }).catch(console.error);
    }, this.hide = () => {
      N(this, Xn).dataset.show = "false";
    }, W(this, Ps, e.ctx), W(this, Xn, e.content), W(this, Nc, e.getOffset), W(this, Rc, e.getPosition), W(this, Pc, e.getPlacement), W(this, dd, e.middleware ?? []), W(this, pd, e.floatingUIOptions ?? {}), W(this, fd, e.root), this.hide();
  }
  /// The context of current active node.
  get active() {
    return N(this, Gl);
  }
}
Xn = new WeakMap(), Ps = new WeakMap(), Ul = new WeakMap(), Gl = new WeakMap(), fd = new WeakMap(), Dc = new WeakMap(), dd = new WeakMap(), pd = new WeakMap(), Nc = new WeakMap(), Rc = new WeakMap(), Pc = new WeakMap(), i1 = new WeakSet(), /// @internal
kA = function() {
  const e = N(this, Ps).get(pt);
  (N(this, fd) ?? e.dom.parentElement ?? document.body).appendChild(N(this, Xn));
  const r = N(this, Ps).get(W1.key);
  r.bind(N(this, Ps), (i) => {
    i.type === "hide" ? (this.hide(), W(this, Gl, null)) : i.type === "show" && (this.show(i.active), W(this, Gl, i.active));
  }), W(this, Ul, r), N(this, Ul).addEvent(N(this, Xn)), N(this, Xn).draggable = !0;
};
const U1 = [
  j1,
  q1,
  eb,
  W1,
  tb
];
U1.key = j1.key;
U1.pluginKey = tb.key;
function AG(n, e) {
  return function(t, r) {
    let { $from: i, $to: s, node: o } = t.selection;
    if (o && o.isBlock || i.depth < 2 || !i.sameParent(s))
      return !1;
    let l = i.node(-1);
    if (l.type != n)
      return !1;
    if (i.parent.content.size == 0 && i.node(-1).childCount == i.indexAfter(-1)) {
      if (i.depth == 3 || i.node(-3).type != n || i.index(-2) != i.node(-2).childCount - 1)
        return !1;
      if (r) {
        let h = Y.empty, f = i.index(-1) ? 1 : i.index(-2) ? 2 : 3;
        for (let b = i.depth - f; b >= i.depth - 3; b--)
          h = Y.from(i.node(b).copy(h));
        let d = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3;
        h = h.append(Y.from(n.createAndFill()));
        let p = i.before(i.depth - (f - 1)), m = t.tr.replace(p, i.after(-d), new ue(h, 4 - f, 0)), g = -1;
        m.doc.nodesBetween(p, m.doc.content.size, (b, w) => {
          if (g > -1)
            return !1;
          b.isTextblock && b.content.size == 0 && (g = w + 1);
        }), g > -1 && m.setSelection(Pe.near(m.doc.resolve(g))), r(m.scrollIntoView());
      }
      return !0;
    }
    let a = s.pos == i.end() ? l.contentMatchAt(0).defaultType : null, c = t.tr.delete(i.pos, s.pos), u = a ? [null, { type: a }] : void 0;
    return Xh(c.doc, i.pos, 2, u) ? (r && r(c.split(i.pos, 2, u).scrollIntoView()), !0) : !1;
  };
}
function OG(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? r.node(s.depth - 1).type == n ? EG(e, t, n, s) : IG(e, t, s) : !0 : !1;
  };
}
function EG(n, e, t, r) {
  let i = n.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new Tn(s - 1, o, s, o, new ue(Y.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new jC(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const l = x1(r);
  if (l == null)
    return !1;
  i.lift(r, l);
  let a = i.doc.resolve(i.mapping.map(s, -1) - 1);
  return k1(i.doc, a.pos) && a.nodeBefore.type == a.nodeAfter.type && i.join(a.pos), e(i.scrollIntoView()), !0;
}
function IG(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let d = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--)
    d -= i.child(p).nodeSize, r.delete(d - 1, d + 1);
  let s = r.doc.resolve(t.start), o = s.nodeAfter;
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let l = t.startIndex == 0, a = t.endIndex == i.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (l ? 0 : 1), u + 1, o.content.append(a ? Y.empty : Y.from(i))))
    return !1;
  let h = s.pos, f = h + o.nodeSize;
  return r.step(new Tn(h - (l ? 1 : 0), f + (a ? 1 : 0), h + 1, f - 1, new ue((l ? Y.empty : Y.from(i.copy(Y.empty))).append(a ? Y.empty : Y.from(i.copy(Y.empty))), l ? 0 : 1, a ? 0 : 1), l ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function DG(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let l = s.parent, a = l.child(o - 1);
    if (a.type != n)
      return !1;
    if (t) {
      let c = a.lastChild && a.lastChild.type == l.type, u = Y.from(c ? n.create() : null), h = new ue(Y.from(n.create(null, Y.from(l.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, d = s.end;
      t(e.tr.step(new Tn(f - (c ? 3 : 1), d, f, d, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function NG(n) {
  const e = /* @__PURE__ */ new Map();
  if (!n || !n.type)
    throw new Error("mdast-util-definitions expected node");
  return rl(n, "definition", function(r) {
    const i = G8(r.identifier);
    i && !e.get(i) && e.set(i, r);
  }), t;
  function t(r) {
    const i = G8(r);
    return e.get(i);
  }
}
function G8(n) {
  return String(n || "").toUpperCase();
}
function RG() {
  return function(n) {
    const e = NG(n);
    rl(n, function(t, r, i) {
      if (t.type === "definition" && i !== void 0 && typeof r == "number")
        return i.children.splice(r, 1), [zy, r];
      if (t.type === "imageReference" || t.type === "linkReference") {
        const s = e(t.identifier);
        if (s && i && typeof r == "number")
          return i.children[r] = t.type === "imageReference" ? { type: "image", url: s.url, title: s.title, alt: t.alt } : {
            type: "link",
            url: s.url,
            title: s.title,
            children: t.children
          }, [zy, r];
      }
    });
  };
}
function SA(n, e) {
  var i;
  if (!(e.childCount >= 1 && ((i = e.lastChild) == null ? void 0 : i.type.name) === "hardbreak")) {
    n.next(e.content);
    return;
  }
  const r = [];
  e.content.forEach((s, o, l) => {
    l !== e.childCount - 1 && r.push(s);
  }), n.next(Y.fromArray(r));
}
function U(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), n;
}
const nb = $d("emphasis");
U(nb, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
const Ca = mu("emphasis", (n) => ({
  attrs: {
    marker: {
      default: n.get(nf).emphasis || "*",
      validate: "string"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", n.get(nb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, t) => {
      e.withMark(t, "emphasis", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
U(Ca.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
U(Ca.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
const G1 = De("ToggleEmphasis", (n) => () => R1(Ca.type(n)));
U(G1, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
const CA = On((n) => Pd(/(?:^|[^*])\*([^*]+)\*$/, Ca.type(n), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
U(CA, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
const MA = On((n) => Pd(/\b_(?![_\s])(.*?[^_\s])_\b/, Ca.type(n), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
U(MA, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
const rb = hr("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(G1.key);
    }
  }
});
U(rb.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
U(rb.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
const ib = $d("strong");
U(ib, {
  displayName: "Attr<strong>",
  group: "Strong"
});
const yu = mu("strong", (n) => ({
  attrs: {
    marker: {
      default: n.get(nf).strong || "*",
      validate: "string"
    }
  },
  parseDOM: [
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: (e) => e.style.fontWeight != "normal" && null
    },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" },
    { style: "font-weight=400", clearMark: (e) => e.type.name == "strong" },
    {
      style: "font-weight",
      getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
    }
  ],
  toDOM: (e) => ["strong", n.get(ib.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, t) => {
      e.withMark(t, "strong", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
U(yu.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
U(yu.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
const K1 = De("ToggleStrong", (n) => () => R1(yu.type(n)));
U(K1, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
const TA = On((n) => Pd(
  new RegExp("(?<![\\w:/])(?:\\*\\*|__)([^*_]+?)(?:\\*\\*|__)(?![\\w/])$"),
  yu.type(n),
  {
    getAttr: (e) => ({
      marker: e[0].startsWith("*") ? "*" : "_"
    })
  }
));
U(TA, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
const sb = hr("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(K1.key);
    }
  }
});
U(sb.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
U(sb.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
const ob = $d("inlineCode");
U(ob, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
const _s = mu("inlineCode", (n) => ({
  priority: 100,
  code: !0,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", n.get(ob.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, t, r) => {
      e.openMark(r), e.addText(t.value), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, t, r) => {
      e.withMark(t, "inlineCode", r.text || "");
    }
  }
}));
U(_s.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
U(_s.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
const Y1 = De(
  "ToggleInlineCode",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (r.empty) return !1;
    const { from: s, to: o } = r;
    return e.doc.rangeHasMark(s, o, _s.type(n)) ? (t == null || t(i.removeMark(s, o, _s.type(n))), !0) : (Object.keys(e.schema.marks).filter(
      (c) => c !== _s.type.name
    ).map((c) => e.schema.marks[c]).forEach((c) => {
      i.removeMark(s, o, c);
    }), t == null || t(i.addMark(s, o, _s.type(n).create())), !0);
  }
);
U(Y1, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
const AA = On((n) => Pd(/(?:`)([^`]+)(?:`)$/, _s.type(n)));
U(AA, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
const lb = hr("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Y1.key);
    }
  }
});
U(lb.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
U(lb.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
const ab = $d("link");
U(ab, {
  displayName: "Attr<link>",
  group: "Link"
});
const xi = mu("link", (n) => ({
  attrs: {
    href: { validate: "string" },
    title: { default: null, validate: "string|null" }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ai(e);
        return {
          href: e.getAttribute("href"),
          title: e.getAttribute("title")
        };
      }
    }
  ],
  toDOM: (e) => ["a", { ...n.get(ab.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, t, r) => {
      const i = t.url, s = t.title;
      e.openMark(r, { href: i, title: s }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, t) => {
      e.withMark(t, "link", void 0, {
        title: t.attrs.title,
        url: t.attrs.href
      });
    }
  }
}));
U(xi.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
const OA = De(
  "ToggleLink",
  (n) => (e = {}) => R1(xi.type(n), e)
);
U(OA, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
const EA = De(
  "UpdateLink",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !1;
    let i, s = -1;
    const { selection: o } = t, { from: l, to: a } = o;
    if (t.doc.nodesBetween(l, l === a ? a + 1 : a, (p, m) => {
      if (xi.type(n).isInSet(p.marks))
        return i = p, s = m, !1;
    }), !i) return !1;
    const c = i.marks.find(({ type: p }) => p === xi.type(n));
    if (!c) return !1;
    const u = s, h = s + i.nodeSize, { tr: f } = t, d = xi.type(n).create({ ...c.attrs, ...e });
    return d ? (r(
      f.removeMark(u, h, c).addMark(u, h, d).setSelection(new ge(f.selection.$anchor)).scrollIntoView()
    ), !0) : !1;
  }
);
U(EA, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
const IA = X3("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: n }) => n === "root",
    runner: (n, e, t) => {
      n.injectRoot(e, t);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "doc",
    runner: (n, e) => {
      n.openNode("root"), n.next(e.content);
    }
  }
}));
U(IA, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
function PG(n) {
  return I3(
    n,
    (e) => {
      var t;
      return e.type === "html" && ["<br />", "<br>", "<br >", "<br/>"].includes(
        (t = e.value) == null ? void 0 : t.trim()
      );
    },
    (e, t) => {
      if (!t.length) return;
      const r = t[t.length - 1];
      if (!r) return;
      const i = r.children.indexOf(e);
      i !== -1 && r.children.splice(i, 1);
    },
    !0
  );
}
const J1 = as(
  "remark-preserve-empty-line",
  () => () => PG
);
U(J1.plugin, {
  displayName: "Remark<remarkPreserveEmptyLine>",
  group: "Remark"
});
U(J1.options, {
  displayName: "RemarkConfig<remarkPreserveEmptyLine>",
  group: "Remark"
});
const cb = Oi("paragraph");
U(cb, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
const cs = _t("paragraph", (n) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", n.get(cb.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, t, r) => {
      e.openNode(r), t.children ? e.next(t.children) : e.addText(t.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, t) => {
      var s;
      const i = (s = n.get(pt).state) == null ? void 0 : s.doc.lastChild;
      e.openNode("paragraph"), (!t.content || t.content.size === 0) && t !== i && LG(n) ? e.addNode("html", void 0, "<br />") : SA(e, t), e.closeNode();
    }
  }
}));
function LG(n) {
  let e = !1;
  try {
    n.get(J1.id), e = !0;
  } catch {
    e = !1;
  }
  return e;
}
U(cs.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
U(cs.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
const ub = De(
  "TurnIntoText",
  (n) => () => Lf(cs.type(n))
);
U(ub, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
const hb = hr("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(ub.key);
    }
  }
});
U(hb.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
U(hb.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
const BG = Array(6).fill(0).map((n, e) => e + 1);
function zG(n) {
  return n.textContent.toLowerCase().trim().replace(/\s+/g, "-");
}
const X1 = it(
  zG,
  "headingIdGenerator"
);
U(X1, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
const fb = Oi("heading");
U(fb, {
  displayName: "Attr<heading>",
  group: "Heading"
});
const Sr = _t("heading", (n) => {
  const e = n.get(X1.key);
  return {
    content: "inline*",
    group: "block",
    defining: !0,
    attrs: {
      id: {
        default: "",
        validate: "string"
      },
      level: {
        default: 1,
        validate: "number"
      }
    },
    parseDOM: BG.map((t) => ({
      tag: `h${t}`,
      getAttrs: (r) => {
        if (!(r instanceof HTMLElement)) throw Ai(r);
        return { level: t, id: r.id };
      }
    })),
    toDOM: (t) => [
      `h${t.attrs.level}`,
      {
        ...n.get(fb.key)(t),
        id: t.attrs.id || e(t)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: t }) => t === "heading",
      runner: (t, r, i) => {
        const s = r.depth;
        t.openNode(i, { level: s }), t.next(r.children), t.closeNode();
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === "heading",
      runner: (t, r) => {
        t.openNode("heading", void 0, { depth: r.attrs.level }), SA(t, r), t.closeNode();
      }
    }
  };
});
U(Sr.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
U(Sr.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
const DA = On((n) => M3(
  /^(?<hashes>#+)\s$/,
  Sr.type(n),
  (e) => {
    var o, l;
    const t = ((l = (o = e.groups) == null ? void 0 : o.hashes) == null ? void 0 : l.length) || 0, r = n.get(pt), { $from: i } = r.state.selection, s = i.node();
    if (s.type.name === "heading") {
      let a = Number(s.attrs.level) + Number(t);
      return a > 6 && (a = 6), { level: a };
    }
    return { level: t };
  }
));
U(DA, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
const So = De("WrapInHeading", (n) => (e) => (e ?? (e = 1), e < 1 ? Lf(cs.type(n)) : Lf(Sr.type(n), { level: e })));
U(So, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
const db = De(
  "DowngradeHeading",
  (n) => () => (e, t, r) => {
    const { $from: i } = e.selection, s = i.node();
    if (s.type !== Sr.type(n) || !e.selection.empty || i.parentOffset !== 0)
      return !1;
    const o = s.attrs.level - 1;
    return o ? (t == null || t(
      e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
        ...s.attrs,
        level: o
      })
    ), !0) : Lf(cs.type(n))(e, t, r);
  }
);
U(db, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
const pb = hr("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(So.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(So.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(So.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(So.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(So.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(So.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(db.key);
    }
  }
});
U(pb.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
U(pb.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
const mb = Oi("blockquote");
U(mb, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
const bu = _t(
  "blockquote",
  (n) => ({
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (e) => ["blockquote", n.get(mb.key)(e), 0],
    parseMarkdown: {
      match: ({ type: e }) => e === "blockquote",
      runner: (e, t, r) => {
        e.openNode(r).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === "blockquote",
      runner: (e, t) => {
        e.openNode("blockquote").next(t.content).closeNode();
      }
    }
  })
);
U(bu.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
U(bu.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
const NA = On(
  (n) => C3(/^\s*>\s$/, bu.type(n))
);
U(NA, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
const gb = De(
  "WrapInBlockquote",
  (n) => () => _3(bu.type(n))
);
U(gb, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
const yb = hr("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(gb.key);
    }
  }
});
U(yb.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
U(yb.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
const bb = Oi("codeBlock", () => ({
  pre: {},
  code: {}
}));
U(bb, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
const ss = _t("code_block", (n) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: !0,
  code: !0,
  attrs: {
    language: {
      default: "",
      validate: "string"
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ai(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const t = n.get(bb.key)(e), r = e.attrs.language, i = r && r.length > 0 ? { "data-language": r } : void 0;
    return [
      "pre",
      {
        ...t.pre,
        ...i
      },
      ["code", t.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, t, r) => {
      const i = t.lang ?? "", s = t.value;
      e.openNode(r, { language: i }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, t) => {
      var r;
      e.addNode("code", void 0, ((r = t.content.firstChild) == null ? void 0 : r.text) || "", {
        lang: t.attrs.language
      });
    }
  }
}));
U(ss.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
U(ss.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
const RA = On(
  (n) => M3(
    /^```(?<language>[a-z]*)?[\s\n]$/,
    ss.type(n),
    (e) => {
      var t;
      return {
        language: ((t = e.groups) == null ? void 0 : t.language) ?? ""
      };
    }
  )
);
U(RA, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
const vb = De(
  "CreateCodeBlock",
  (n) => (e = "") => Lf(ss.type(n), { language: e })
);
U(vb, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
const _G = De(
  "UpdateCodeBlockLanguage",
  () => ({ pos: n, language: e } = {
    pos: -1,
    language: ""
  }) => (t, r) => n >= 0 ? (r == null || r(t.tr.setNodeAttribute(n, "language", e)), !0) : !1
);
U(_G, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
const wb = hr("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(vb.key);
    }
  }
});
U(wb.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
U(wb.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
const xb = Oi("image");
U(xb, {
  displayName: "Attr<image>",
  group: "Image"
});
const Ma = _t("image", (n) => ({
  inline: !0,
  group: "inline",
  selectable: !0,
  draggable: !0,
  marks: "",
  atom: !0,
  defining: !0,
  isolating: !0,
  attrs: {
    src: { default: "", validate: "string" },
    alt: { default: "", validate: "string" },
    title: { default: "", validate: "string" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ai(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...n.get(xb.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, t, r) => {
      const i = t.url, s = t.alt, o = t.title;
      e.addNode(r, {
        src: i,
        alt: s,
        title: o
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, t) => {
      e.addNode("image", void 0, void 0, {
        title: t.attrs.title,
        url: t.attrs.src,
        alt: t.attrs.alt
      });
    }
  }
}));
U(Ma.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
U(Ma.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
const PA = De(
  "InsertImage",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !0;
    const { src: i = "", alt: s = "", title: o = "" } = e, l = Ma.type(n).create({ src: i, alt: s, title: o });
    return l && r(t.tr.replaceSelectionWith(l).scrollIntoView()), !0;
  }
);
U(PA, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
const LA = De(
  "UpdateImage",
  (n) => (e = {}) => (t, r) => {
    const i = FH(
      t.selection,
      Ma.type(n)
    );
    if (!i) return !1;
    const { node: s, pos: o } = i, l = { ...s.attrs }, { src: a, alt: c, title: u } = e;
    return a !== void 0 && (l.src = a), c !== void 0 && (l.alt = c), u !== void 0 && (l.title = u), r == null || r(
      t.tr.setNodeMarkup(o, void 0, l).scrollIntoView()
    ), !0;
  }
);
U(LA, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
const FG = On(
  (n) => new ar(
    /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
    (e, t, r, i) => {
      const [s, o, l = "", a] = t;
      return s ? e.tr.replaceWith(
        r,
        i,
        Ma.type(n).create({ src: l, alt: o, title: a })
      ) : null;
    }
  )
);
U(FG, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
const $m = Oi("hardbreak", (n) => ({
  "data-type": "hardbreak",
  "data-is-inline": n.attrs.isInline
}));
U($m, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
const na = _t("hardbreak", (n) => ({
  inline: !0,
  group: "inline",
  attrs: {
    isInline: {
      default: !1,
      validate: "boolean"
    }
  },
  selectable: !1,
  parseDOM: [
    { tag: "br" },
    {
      tag: 'span[data-type="hardbreak"]',
      getAttrs: () => ({ isInline: !0 })
    }
  ],
  toDOM: (e) => e.attrs.isInline ? ["span", n.get($m.key)(e), " "] : ["br", n.get($m.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, t, r) => {
      var i;
      e.addNode(r, {
        isInline: !!((i = t.data) != null && i.isInline)
      });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, t) => {
      t.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
U(na.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
U(na.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
const kb = De(
  "InsertHardbreak",
  (n) => () => (e, t) => {
    var s;
    const { selection: r, tr: i } = e;
    if (!(r instanceof ge)) return !1;
    if (r.empty) {
      const o = r.$from.node();
      if (o.childCount > 0 && ((s = o.lastChild) == null ? void 0 : s.type.name) === "hardbreak")
        return t == null || t(
          i.replaceRangeWith(
            r.to - 1,
            r.to,
            e.schema.node("paragraph")
          ).setSelection(Pe.near(i.doc.resolve(r.to))).scrollIntoView()
        ), !0;
    }
    return t == null || t(
      i.setMeta("hardbreak", !0).replaceSelectionWith(na.type(n).create()).scrollIntoView()
    ), !0;
  }
);
U(kb, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
const Sb = hr("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(kb.key);
    }
  }
});
U(Sb.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
U(Sb.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
const Cb = Oi("hr");
U(Cb, {
  displayName: "Attr<hr>",
  group: "Hr"
});
const vu = _t("hr", (n) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", n.get(Cb.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, t, r) => {
      e.addNode(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
U(vu.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
U(vu.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
const BA = On(
  (n) => new ar(/^(?:---|___\s|\*\*\*\s)$/, (e, t, r, i) => {
    const { tr: s } = e;
    return t[0] && s.replaceWith(r - 1, i, vu.type(n).create()), s;
  })
);
U(BA, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
const zA = De(
  "InsertHr",
  (n) => () => (e, t) => {
    if (!t) return !0;
    const r = cs.node.type(n).create(), { tr: i, selection: s } = e, { from: o } = s, l = vu.type(n).create();
    if (!l) return !0;
    const a = i.replaceSelectionWith(l).insert(o, r), c = Pe.findFrom(a.doc.resolve(o), 1, !0);
    return c && t(a.setSelection(c).scrollIntoView()), !0;
  }
);
U(zA, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
const Mb = Oi("bulletList");
U(Mb, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
const Ta = _t("bullet_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ai(e);
        return {
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...n.get(Mb.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "false";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !1,
        spread: t.attrs.spread
      }).next(t.content).closeNode();
    }
  }
}));
U(Ta.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
U(Ta.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
const _A = On(
  (n) => C3(/^\s*([-+*])\s$/, Ta.type(n))
);
U(_A, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
const Tb = De(
  "WrapInBulletList",
  (n) => () => _3(Ta.type(n))
);
U(Tb, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
const Ab = hr("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Tb.key);
    }
  }
});
U(Ab.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
U(Ab.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
const Ob = Oi("orderedList");
U(Ob, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
const Aa = _t("ordered_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1,
      validate: "number"
    },
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ai(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...n.get(Ob.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !!t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !0,
        start: 1,
        spread: t.attrs.spread === "true"
      }), e.next(t.content), e.closeNode();
    }
  }
}));
U(Aa.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
U(Aa.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
const FA = On(
  (n) => C3(
    /^\s*(\d+)\.\s$/,
    Aa.type(n),
    (e) => ({ order: Number(e[1]) }),
    (e, t) => t.childCount + t.attrs.order === Number(e[1])
  )
);
U(FA, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
const Eb = De(
  "WrapInOrderedList",
  (n) => () => _3(Aa.type(n))
);
U(Eb, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
const Ib = hr("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Eb.key);
    }
  }
});
U(Ib.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
U(Ib.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
const Db = Oi("listItem");
U(Db, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
const Ei = _t("list_item", (n) => ({
  group: "listItem",
  content: "paragraph block*",
  attrs: {
    label: {
      default: "â€¢",
      validate: "string"
    },
    listType: {
      default: "bullet",
      validate: "string"
    },
    spread: {
      default: !0,
      validate: "boolean"
    }
  },
  defining: !0,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ai(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...n.get(Db.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, t, r) => {
      const i = t.label != null ? `${t.label}.` : "â€¢", s = t.label != null ? "ordered" : "bullet", o = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { label: i, listType: s, spread: o }), e.next(t.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, t) => {
      e.openNode("listItem", void 0, {
        spread: t.attrs.spread
      }), e.next(t.content), e.closeNode();
    }
  }
}));
U(Ei.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
U(Ei.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
const Nb = De(
  "SinkListItem",
  (n) => () => DG(Ei.type(n))
);
U(Nb, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
const Rb = De(
  "LiftListItem",
  (n) => () => OG(Ei.type(n))
);
U(Rb, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
const Pb = De(
  "SplitListItem",
  (n) => () => AG(Ei.type(n))
);
U(Pb, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function HG(n) {
  return (e, t, r) => {
    const { selection: i } = e;
    if (!(i instanceof ge)) return !1;
    const { empty: s, $from: o } = i;
    return !s || o.parentOffset !== 0 || o.node(-1).type !== Ei.type(n) ? !1 : cT(e, t, r);
  };
}
const Lb = De(
  "LiftFirstListItem",
  (n) => () => HG(n)
);
U(Lb, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
const Bb = hr("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Pb.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Nb.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Rb.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Lb.key);
    }
  }
});
U(Bb.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
U(Bb.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
const HA = X3("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: n }) => n === "text",
    runner: (n, e) => {
      n.addText(e.value);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "text",
    runner: (n, e) => {
      n.addNode("text", void 0, e.text);
    }
  }
}));
U(HA, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
const zb = Oi("html");
U(zb, {
  displayName: "Attr<html>",
  group: "Html"
});
const _b = _t("html", (n) => ({
  atom: !0,
  group: "inline",
  inline: !0,
  attrs: {
    value: {
      default: "",
      validate: "string"
    }
  },
  toDOM: (e) => {
    const t = document.createElement("span"), r = {
      ...n.get(zb.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return t.textContent = e.attrs.value, ["span", r, e.attrs.value];
  },
  parseDOM: [
    {
      tag: 'span[data-type="html"]',
      getAttrs: (e) => ({
        value: e.dataset.value ?? ""
      })
    }
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, t, r) => {
      e.addNode(r, { value: t.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, t) => {
      e.addNode("html", void 0, t.attrs.value);
    }
  }
}));
U(_b.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
U(_b.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
const $G = [
  IA,
  cb,
  cs,
  X1,
  fb,
  Sr,
  $m,
  na,
  mb,
  bu,
  bb,
  ss,
  Cb,
  vu,
  xb,
  Ma,
  Mb,
  Ta,
  Ob,
  Aa,
  Db,
  Ei,
  nb,
  Ca,
  ib,
  yu,
  ob,
  _s,
  ab,
  xi,
  zb,
  _b,
  HA
].flat(), VG = [
  NA,
  _A,
  FA,
  RA,
  BA,
  DA
].flat(), qG = [
  CA,
  MA,
  AA,
  TA
], ja = De(
  "IsMarkSelected",
  () => (n) => (e) => {
    if (!n) return !1;
    const { doc: t, selection: r } = e;
    return t.rangeHasMark(r.from, r.to, n);
  }
), $A = De(
  "IsNoteSelected",
  () => (n) => (e) => n ? TM(e, n).hasNode : !1
), un = De(
  "ClearTextInCurrentBlock",
  () => () => (n, e) => {
    let t = n.tr;
    const { $from: r, $to: i } = t.selection, { pos: s } = r, { pos: o } = i, l = s - r.node().content.size;
    return l < 0 ? !1 : (t = t.deleteRange(l, o), e == null || e(t), !0);
  }
), xs = De(
  "SetBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr, { from: o, to: l } = s.selection;
    try {
      s.setBlockType(o, l, r, i);
    } catch {
      return !1;
    }
    return t == null || t(s), !0;
  }
), kh = De(
  "WrapInBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    let s = e.tr;
    try {
      const { $from: o, $to: l } = s.selection, a = o.blockRange(l), c = a && k3(a, r, i);
      if (!c) return !1;
      s = s.wrap(a, c);
    } catch {
      return !1;
    }
    return t == null || t(s), !0;
  }
), Sh = De(
  "AddBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr;
    try {
      const o = r instanceof Vs ? r : r.createAndFill(i);
      if (!o) return !1;
      s.replaceSelectionWith(o);
    } catch {
      return !1;
    }
    return t == null || t(s), !0;
  }
), VA = De(
  "SelectTextNearPos",
  () => (n) => (e, t) => {
    const { pos: r } = n ?? {};
    if (r == null) return !1;
    const i = (o, l, a) => Math.min(Math.max(o, l), a), s = e.tr;
    try {
      const o = e.doc.resolve(i(r, 0, e.doc.content.size));
      s.setSelection(ge.near(o));
    } catch {
      return !1;
    }
    return t == null || t(s.scrollIntoView()), !0;
  }
), WG = [
  ub,
  gb,
  So,
  db,
  vb,
  kb,
  zA,
  PA,
  LA,
  Eb,
  Tb,
  Nb,
  Pb,
  Rb,
  Lb,
  G1,
  Y1,
  K1,
  OA,
  EA,
  ja,
  $A,
  un,
  xs,
  kh,
  Sh,
  VA
], jG = [
  yb,
  wb,
  Sb,
  pb,
  Bb,
  Ib,
  Ab,
  hb,
  rb,
  lb,
  sb
].flat(), Fb = as(
  "remarkAddOrderInList",
  () => () => (n) => {
    rl(n, "list", (e) => {
      if (e.ordered) {
        const t = e.start ?? 1;
        e.children.forEach((r, i) => {
          r.label = i + t;
        });
      }
    });
  }
);
U(Fb.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
U(Fb.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
const Hb = as(
  "remarkLineBreak",
  () => () => (n) => {
    const e = /[\t ]*(?:\r?\n|\r)/g;
    rl(
      n,
      "text",
      (t, r, i) => {
        if (!t.value || typeof t.value != "string") return;
        const s = [];
        let o = 0;
        e.lastIndex = 0;
        let l = e.exec(t.value);
        for (; l; ) {
          const c = l.index;
          o !== c && s.push({
            type: "text",
            value: t.value.slice(o, c)
          }), s.push({ type: "break", data: { isInline: !0 } }), o = c + l[0].length, l = e.exec(t.value);
        }
        if (s.length > 0 && i && typeof r == "number")
          return o < t.value.length && s.push({ type: "text", value: t.value.slice(o) }), i.children.splice(r, 1, ...s), r + s.length;
      }
    );
  }
);
U(Hb.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
U(Hb.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
const $b = as(
  "remarkInlineLink",
  () => RG
);
U($b.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
U($b.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
const UG = (n) => !!n.children, GG = (n) => n.type === "html";
function KG(n, e) {
  return t(n, 0, null)[0];
  function t(r, i, s) {
    if (UG(r)) {
      const o = [];
      for (let l = 0, a = r.children.length; l < a; l++) {
        const c = r.children[l];
        if (c) {
          const u = t(c, l, r);
          if (u)
            for (let h = 0, f = u.length; h < f; h++) {
              const d = u[h];
              d && o.push(d);
            }
        }
      }
      r.children = o;
    }
    return e(r, i, s);
  }
}
const YG = ["root", "blockquote", "listItem"], Vb = as(
  "remarkHTMLTransformer",
  () => () => (n) => {
    KG(n, (e, t, r) => GG(e) ? (r && YG.includes(r.type) && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
  }
);
U(Vb.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
U(Vb.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
const qb = as(
  "remarkMarker",
  () => () => (n, e) => {
    const t = (r) => e.value.charAt(r.position.start.offset);
    rl(
      n,
      (r) => ["strong", "emphasis"].includes(r.type),
      (r) => {
        r.marker = t(r);
      }
    );
  }
);
U(qb.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
U(qb.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
const qA = Ut(() => {
  let n = !1;
  const e = new kt(
    "MILKDOWN_INLINE_NODES_CURSOR"
  ), t = new xt({
    key: e,
    state: {
      init() {
        return !1;
      },
      apply(r) {
        if (!r.selection.empty) return !1;
        const i = r.selection.$from, s = i.nodeBefore, o = i.nodeAfter;
        return !!(s && o && s.isInline && !s.isText && o.isInline && !o.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (r, i) => n ? (n = !1, requestAnimationFrame(() => {
          if (t.getState(r.state)) {
            const o = r.state.selection.from;
            i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o));
          }
        }), !0) : !1,
        compositionstart: (r) => (t.getState(r.state) && (n = !0), !1),
        beforeinput: (r, i) => {
          if (t.getState(r.state) && i instanceof InputEvent && i.data && !n) {
            const o = r.state.selection.from;
            return i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o)), !0;
          }
          return !1;
        }
      },
      decorations(r) {
        if (t.getState(r)) {
          const o = r.selection.$from.pos, l = document.createElement("span"), a = Wt.widget(o, l, {
            side: -1
          }), c = document.createElement("span"), u = Wt.widget(o, c);
          return setTimeout(() => {
            l.contentEditable = "true", c.contentEditable = "true";
          }), ct.create(r.doc, [a, u]);
        }
        return ct.empty;
      }
    }
  });
  return t;
});
U(qA, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
const WA = Ut((n) => new xt({
  key: new kt("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, t, r) => {
    if (!e.length) return;
    const [i] = e;
    if (!i) return;
    const [s] = i.steps;
    if (i.getMeta("hardbreak")) {
      if (!(s instanceof tn)) return;
      const { from: a } = s;
      return r.tr.setNodeMarkup(
        a,
        na.type(n),
        void 0,
        []
      );
    }
    if (s instanceof Bs) {
      let a = r.tr;
      const { from: c, to: u } = s;
      return r.doc.nodesBetween(c, u, (h, f) => {
        h.type === na.type(n) && (a = a.setNodeMarkup(
          f,
          na.type(n),
          void 0,
          []
        ));
      }), a;
    }
  }
}));
U(WA, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
const Wb = it(
  ["table", "code_block"],
  "hardbreakFilterNodes"
);
U(Wb, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
const jA = Ut((n) => {
  const e = n.get(Wb.key);
  return new xt({
    key: new kt("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (t, r) => {
      const i = t.getMeta("hardbreak"), [s] = t.steps;
      if (i && s) {
        const { from: o } = s, l = r.doc.resolve(o);
        let a = l.depth, c = !0;
        for (; a > 0; )
          e.includes(l.node(a).type.name) && (c = !1), a--;
        return c;
      }
      return !0;
    }
  });
});
U(jA, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
const UA = Ut((n) => {
  const e = new kt("MILKDOWN_HEADING_ID"), t = (r) => {
    if (r.composing) return;
    const i = n.get(X1.key), s = r.state.tr.setMeta("addToHistory", !1);
    let o = !1;
    const l = {};
    r.state.doc.descendants((a, c) => {
      if (a.type === Sr.type(n)) {
        if (a.textContent.trim().length === 0) return;
        const u = a.attrs;
        let h = i(a);
        l[h] ? (l[h] += 1, h += `-#${l[h]}`) : l[h] = 1, u.id !== h && (o = !0, s.setMeta(e, !0).setNodeMarkup(c, void 0, {
          ...u,
          id: h
        }));
      }
    }), o && r.dispatch(s);
  };
  return new xt({
    key: e,
    view: (r) => (t(r), {
      update: (i, s) => {
        i.state.doc.eq(s.doc) || t(i);
      }
    })
  });
});
U(UA, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
const GA = Ut((n) => {
  const e = (t, r, i) => {
    if (!i.selection || t.some(
      (h) => h.getMeta("addToHistory") === !1 || !h.isGeneric
    ))
      return null;
    const s = Aa.type(n), o = Ta.type(n), l = Ei.type(n), a = (h, f) => {
      let d = !1;
      const p = `${f + 1}.`;
      return h.label !== p && (h.label = p, d = !0), d;
    };
    let c = i.tr, u = !1;
    return i.doc.descendants(
      (h, f, d, p) => {
        if (h.type === o) {
          const m = h.maybeChild(0);
          (m == null ? void 0 : m.type) === l && m.attrs.listType === "ordered" && (u = !0, c.setNodeMarkup(f, s, { spread: "true" }), h.descendants(
            (g, b, w, k) => {
              if (g.type === l) {
                const T = { ...g.attrs };
                a(T, k) && (c = c.setNodeMarkup(b, void 0, T));
              }
              return !1;
            }
          ));
        } else if (h.type === l && (d == null ? void 0 : d.type) === s) {
          const m = { ...h.attrs };
          let g = !1;
          m.listType !== "ordered" && (m.listType = "ordered", g = !0), (d == null ? void 0 : d.maybeChild(0)) && (g = a(m, p)), g && (c = c.setNodeMarkup(f, void 0, m), u = !0);
        }
      }
    ), u ? c.setMeta("addToHistory", !1) : null;
  };
  return new xt({
    key: new kt("MILKDOWN_KEEP_LIST_ORDER"),
    appendTransaction: e
  });
});
U(GA, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
const JG = [
  WA,
  Wb,
  jA,
  qA,
  Fb,
  $b,
  Hb,
  Vb,
  qb,
  J1,
  UA,
  GA
].flat(), XG = [
  $G,
  VG,
  qG,
  WG,
  jG,
  JG
].flat();
function ZG(n) {
  const e = it(
    {},
    `${n}_SLASH_SPEC`
  ), t = Ut((i) => {
    const s = i.get(e.key);
    return new xt({
      key: new kt(`${n}_SLASH`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${n}`
  }, r;
}
var Lc, md, gd, yd, bd, Kl, vd, Bc, wd, xd, s1, KA;
class QG {
  constructor(e) {
    ee(this, s1);
    ee(this, Lc);
    /// @internal
    ee(this, md);
    /// @internal
    ee(this, gd);
    /// @internal
    ee(this, yd);
    /// @internal
    ee(this, bd);
    /// @internal
    ee(this, Kl);
    /// @internal
    ee(this, vd);
    /// @internal
    ee(this, Bc);
    /// The offset to get the block. Default is 0.
    ee(this, wd);
    ee(this, xd);
    W(this, Lc, !1), this.onShow = () => {
    }, this.onHide = () => {
    }, W(this, xd, (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (N(this, Lc) || ((N(this, yd) ?? t.dom.parentElement ?? document.body).appendChild(this.element), W(this, Lc, !0)), s || h) return;
      if (!N(this, vd).call(this, t, r)) {
        this.hide();
        return;
      }
      Ti({
        getBoundingClientRect: () => O1(t, c, u)
      }, this.element, {
        placement: "bottom-start",
        middleware: [Hm(), Jo(N(this, wd)), ...N(this, md)],
        ...N(this, gd)
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }), this.update = (t, r) => {
      N(this, Bc).call(this, t, r);
    }, this.getContent = (t, r = (i) => i.type.name === "paragraph") => {
      const { selection: i } = t.state, { empty: s, $from: o } = i, l = t.state.selection instanceof ge;
      if (typeof document > "u") return;
      const a = this.element.contains(document.activeElement), c = !t.hasFocus() && !a, u = !t.editable, f = !_H(r)(t.state.selection);
      if (!(c || u || !s || !l || f))
        return o.parent.textBetween(
          Math.max(0, o.parentOffset - 500),
          o.parentOffset,
          void 0,
          "ï¿¼"
        );
    }, this.destroy = () => {
      N(this, Bc).cancel();
    }, this.show = () => {
      this.element.dataset.show = "true", this.onShow();
    }, this.hide = () => {
      this.element.dataset.show = "false", this.onHide();
    }, this.element = e.content, W(this, bd, e.debounce ?? 200), W(this, vd, e.shouldShow ?? u0(this, s1, KA)), W(this, Kl, e.trigger ?? "/"), W(this, wd, e.offset), W(this, md, e.middleware ?? []), W(this, gd, e.floatingUIOptions ?? {}), W(this, yd, e.root), W(this, Bc, h1(N(this, xd), N(this, bd)));
  }
}
Lc = new WeakMap(), md = new WeakMap(), gd = new WeakMap(), yd = new WeakMap(), bd = new WeakMap(), Kl = new WeakMap(), vd = new WeakMap(), Bc = new WeakMap(), wd = new WeakMap(), xd = new WeakMap(), s1 = new WeakSet(), /// @internal
KA = function(e) {
  const t = this.getContent(e);
  if (!t) return !1;
  const r = t.at(-1);
  return r ? Array.isArray(N(this, Kl)) ? N(this, Kl).includes(r) : N(this, Kl) === r : !1;
};
function YA(n) {
  var e, t, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var i = n.length;
    for (e = 0; e < i; e++) n[e] && (t = YA(n[e])) && (r && (r += " "), r += t);
  } else for (t in n) n[t] && (r && (r += " "), r += t);
  return r;
}
function bn() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++) (n = arguments[t]) && (e = YA(n)) && (r && (r += " "), r += e);
  return r;
}
/*! @license DOMPurify 3.2.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.7/LICENSE */
const {
  entries: JA,
  setPrototypeOf: K8,
  isFrozen: eK,
  getPrototypeOf: tK,
  getOwnPropertyDescriptor: nK
} = Object;
let {
  freeze: qn,
  seal: ni,
  create: XA
} = Object, {
  apply: a5,
  construct: c5
} = typeof Reflect < "u" && Reflect;
qn || (qn = function(e) {
  return e;
});
ni || (ni = function(e) {
  return e;
});
a5 || (a5 = function(e, t) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++)
    i[s - 2] = arguments[s];
  return e.apply(t, i);
});
c5 || (c5 = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    r[i - 1] = arguments[i];
  return new e(...r);
});
const B0 = Wn(Array.prototype.forEach), rK = Wn(Array.prototype.lastIndexOf), Y8 = Wn(Array.prototype.pop), Ju = Wn(Array.prototype.push), iK = Wn(Array.prototype.splice), _p = Wn(String.prototype.toLowerCase), B2 = Wn(String.prototype.toString), z2 = Wn(String.prototype.match), Xu = Wn(String.prototype.replace), sK = Wn(String.prototype.indexOf), oK = Wn(String.prototype.trim), pi = Wn(Object.prototype.hasOwnProperty), Rn = Wn(RegExp.prototype.test), Zu = lK(TypeError);
function Wn(n) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return a5(n, e, r);
  };
}
function lK(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return c5(n, t);
  };
}
function je(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _p;
  K8 && K8(n, null);
  let r = e.length;
  for (; r--; ) {
    let i = e[r];
    if (typeof i == "string") {
      const s = t(i);
      s !== i && (eK(e) || (e[r] = s), i = s);
    }
    n[i] = !0;
  }
  return n;
}
function aK(n) {
  for (let e = 0; e < n.length; e++)
    pi(n, e) || (n[e] = null);
  return n;
}
function ks(n) {
  const e = XA(null);
  for (const [t, r] of JA(n))
    pi(n, t) && (Array.isArray(r) ? e[t] = aK(r) : r && typeof r == "object" && r.constructor === Object ? e[t] = ks(r) : e[t] = r);
  return e;
}
function Qu(n, e) {
  for (; n !== null; ) {
    const r = nK(n, e);
    if (r) {
      if (r.get)
        return Wn(r.get);
      if (typeof r.value == "function")
        return Wn(r.value);
    }
    n = tK(n);
  }
  function t() {
    return null;
  }
  return t;
}
const J8 = qn(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), _2 = qn(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "slot", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), F2 = qn(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), cK = qn(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), H2 = qn(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), uK = qn(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), X8 = qn(["#text"]), Z8 = qn(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), $2 = qn(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Q8 = qn(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), z0 = qn(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), hK = ni(/\{\{[\w\W]*|[\w\W]*\}\}/gm), fK = ni(/<%[\w\W]*|[\w\W]*%>/gm), dK = ni(/\$\{[\w\W]*/gm), pK = ni(/^data-[\-\w.\u00B7-\uFFFF]+$/), mK = ni(/^aria-[\-\w]+$/), ZA = ni(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), gK = ni(/^(?:\w+script|data):/i), yK = ni(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), QA = ni(/^html$/i), bK = ni(/^[a-z][.\w]*(-[.\w]+)+$/i);
var ex = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: mK,
  ATTR_WHITESPACE: yK,
  CUSTOM_ELEMENT: bK,
  DATA_ATTR: pK,
  DOCTYPE_NAME: QA,
  ERB_EXPR: fK,
  IS_ALLOWED_URI: ZA,
  IS_SCRIPT_OR_DATA: gK,
  MUSTACHE_EXPR: hK,
  TMPLIT_EXPR: dK
});
const eh = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, vK = function() {
  return typeof window > "u" ? null : window;
}, wK = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let r = null;
  const i = "data-tt-policy-suffix";
  t && t.hasAttribute(i) && (r = t.getAttribute(i));
  const s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, tx = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function eO() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : vK();
  const e = (be) => eO(be);
  if (e.version = "3.2.7", e.removed = [], !n || !n.document || n.document.nodeType !== eh.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const r = t, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: l,
    Element: a,
    NodeFilter: c,
    NamedNodeMap: u = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: f,
    trustedTypes: d
  } = n, p = a.prototype, m = Qu(p, "cloneNode"), g = Qu(p, "remove"), b = Qu(p, "nextSibling"), w = Qu(p, "childNodes"), k = Qu(p, "parentNode");
  if (typeof o == "function") {
    const be = t.createElement("template");
    be.content && be.content.ownerDocument && (t = be.content.ownerDocument);
  }
  let T, M = "";
  const {
    implementation: C,
    createNodeIterator: I,
    createDocumentFragment: _,
    getElementsByTagName: F
  } = t, {
    importNode: L
  } = r;
  let $ = tx();
  e.isSupported = typeof JA == "function" && typeof k == "function" && C && C.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: B,
    ERB_EXPR: se,
    TMPLIT_EXPR: te,
    DATA_ATTR: ie,
    ARIA_ATTR: Ce,
    IS_SCRIPT_OR_DATA: Oe,
    ATTR_WHITESPACE: Re,
    CUSTOM_ELEMENT: Be
  } = ex;
  let {
    IS_ALLOWED_URI: D
  } = ex, Me = null;
  const _e = je({}, [...J8, ..._2, ...F2, ...H2, ...X8]);
  let O = null;
  const rt = je({}, [...Z8, ...$2, ...Q8, ...z0]);
  let Le = Object.seal(XA(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Ke = null, Dt = null, Pt = !0, Zt = !0, on = !1, Lr = !0, dr = !1, ci = !0, vn = !1, Br = !1, zr = !1, wn = !1, Un = !1, In = !1, lo = !0, cl = !1;
  const Da = "user-content-";
  let ao = !0, Ri = !1, ui = {}, q = null;
  const ne = je({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let Ee = null;
  const Fe = je({}, ["audio", "video", "img", "source", "image", "track"]);
  let Ye = null;
  const ln = je({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Dn = "http://www.w3.org/1998/Math/MathML", an = "http://www.w3.org/2000/svg", Qt = "http://www.w3.org/1999/xhtml";
  let Nn = Qt, Ft = !1, pr = null;
  const Gn = je({}, [Dn, an, Qt], B2);
  let ul = je({}, ["mi", "mo", "mn", "ms", "mtext"]), hl = je({}, ["annotation-xml"]);
  const i0 = je({}, ["title", "style", "font", "a", "script"]);
  let co = null;
  const s0 = ["application/xhtml+xml", "text/html"], o0 = "text/html";
  let Lt = null, ms = null;
  const l0 = t.createElement("form"), Ou = function(R) {
    return R instanceof RegExp || R instanceof Function;
  }, Na = function() {
    let R = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ms && ms === R)) {
      if ((!R || typeof R != "object") && (R = {}), R = ks(R), co = // eslint-disable-next-line unicorn/prefer-includes
      s0.indexOf(R.PARSER_MEDIA_TYPE) === -1 ? o0 : R.PARSER_MEDIA_TYPE, Lt = co === "application/xhtml+xml" ? B2 : _p, Me = pi(R, "ALLOWED_TAGS") ? je({}, R.ALLOWED_TAGS, Lt) : _e, O = pi(R, "ALLOWED_ATTR") ? je({}, R.ALLOWED_ATTR, Lt) : rt, pr = pi(R, "ALLOWED_NAMESPACES") ? je({}, R.ALLOWED_NAMESPACES, B2) : Gn, Ye = pi(R, "ADD_URI_SAFE_ATTR") ? je(ks(ln), R.ADD_URI_SAFE_ATTR, Lt) : ln, Ee = pi(R, "ADD_DATA_URI_TAGS") ? je(ks(Fe), R.ADD_DATA_URI_TAGS, Lt) : Fe, q = pi(R, "FORBID_CONTENTS") ? je({}, R.FORBID_CONTENTS, Lt) : ne, Ke = pi(R, "FORBID_TAGS") ? je({}, R.FORBID_TAGS, Lt) : ks({}), Dt = pi(R, "FORBID_ATTR") ? je({}, R.FORBID_ATTR, Lt) : ks({}), ui = pi(R, "USE_PROFILES") ? R.USE_PROFILES : !1, Pt = R.ALLOW_ARIA_ATTR !== !1, Zt = R.ALLOW_DATA_ATTR !== !1, on = R.ALLOW_UNKNOWN_PROTOCOLS || !1, Lr = R.ALLOW_SELF_CLOSE_IN_ATTR !== !1, dr = R.SAFE_FOR_TEMPLATES || !1, ci = R.SAFE_FOR_XML !== !1, vn = R.WHOLE_DOCUMENT || !1, wn = R.RETURN_DOM || !1, Un = R.RETURN_DOM_FRAGMENT || !1, In = R.RETURN_TRUSTED_TYPE || !1, zr = R.FORCE_BODY || !1, lo = R.SANITIZE_DOM !== !1, cl = R.SANITIZE_NAMED_PROPS || !1, ao = R.KEEP_CONTENT !== !1, Ri = R.IN_PLACE || !1, D = R.ALLOWED_URI_REGEXP || ZA, Nn = R.NAMESPACE || Qt, ul = R.MATHML_TEXT_INTEGRATION_POINTS || ul, hl = R.HTML_INTEGRATION_POINTS || hl, Le = R.CUSTOM_ELEMENT_HANDLING || {}, R.CUSTOM_ELEMENT_HANDLING && Ou(R.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Le.tagNameCheck = R.CUSTOM_ELEMENT_HANDLING.tagNameCheck), R.CUSTOM_ELEMENT_HANDLING && Ou(R.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Le.attributeNameCheck = R.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), R.CUSTOM_ELEMENT_HANDLING && typeof R.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Le.allowCustomizedBuiltInElements = R.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), dr && (Zt = !1), Un && (wn = !0), ui && (Me = je({}, X8), O = [], ui.html === !0 && (je(Me, J8), je(O, Z8)), ui.svg === !0 && (je(Me, _2), je(O, $2), je(O, z0)), ui.svgFilters === !0 && (je(Me, F2), je(O, $2), je(O, z0)), ui.mathMl === !0 && (je(Me, H2), je(O, Q8), je(O, z0))), R.ADD_TAGS && (Me === _e && (Me = ks(Me)), je(Me, R.ADD_TAGS, Lt)), R.ADD_ATTR && (O === rt && (O = ks(O)), je(O, R.ADD_ATTR, Lt)), R.ADD_URI_SAFE_ATTR && je(Ye, R.ADD_URI_SAFE_ATTR, Lt), R.FORBID_CONTENTS && (q === ne && (q = ks(q)), je(q, R.FORBID_CONTENTS, Lt)), ao && (Me["#text"] = !0), vn && je(Me, ["html", "head", "body"]), Me.table && (je(Me, ["tbody"]), delete Ke.tbody), R.TRUSTED_TYPES_POLICY) {
        if (typeof R.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Zu('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof R.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Zu('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        T = R.TRUSTED_TYPES_POLICY, M = T.createHTML("");
      } else
        T === void 0 && (T = wK(d, i)), T !== null && typeof M == "string" && (M = T.createHTML(""));
      qn && qn(R), ms = R;
    }
  }, Eu = je({}, [..._2, ...F2, ...cK]), Iu = je({}, [...H2, ...uK]), a0 = function(R) {
    let Q = k(R);
    (!Q || !Q.tagName) && (Q = {
      namespaceURI: Nn,
      tagName: "template"
    });
    const me = _p(R.tagName), ot = _p(Q.tagName);
    return pr[R.namespaceURI] ? R.namespaceURI === an ? Q.namespaceURI === Qt ? me === "svg" : Q.namespaceURI === Dn ? me === "svg" && (ot === "annotation-xml" || ul[ot]) : !!Eu[me] : R.namespaceURI === Dn ? Q.namespaceURI === Qt ? me === "math" : Q.namespaceURI === an ? me === "math" && hl[ot] : !!Iu[me] : R.namespaceURI === Qt ? Q.namespaceURI === an && !hl[ot] || Q.namespaceURI === Dn && !ul[ot] ? !1 : !Iu[me] && (i0[me] || !Eu[me]) : !!(co === "application/xhtml+xml" && pr[R.namespaceURI]) : !1;
  }, mr = function(R) {
    Ju(e.removed, {
      element: R
    });
    try {
      k(R).removeChild(R);
    } catch {
      g(R);
    }
  }, Pi = function(R, Q) {
    try {
      Ju(e.removed, {
        attribute: Q.getAttributeNode(R),
        from: Q
      });
    } catch {
      Ju(e.removed, {
        attribute: null,
        from: Q
      });
    }
    if (Q.removeAttribute(R), R === "is")
      if (wn || Un)
        try {
          mr(Q);
        } catch {
        }
      else
        try {
          Q.setAttribute(R, "");
        } catch {
        }
  }, Du = function(R) {
    let Q = null, me = null;
    if (zr)
      R = "<remove></remove>" + R;
    else {
      const Tt = z2(R, /^[\r\n\t ]+/);
      me = Tt && Tt[0];
    }
    co === "application/xhtml+xml" && Nn === Qt && (R = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + R + "</body></html>");
    const ot = T ? T.createHTML(R) : R;
    if (Nn === Qt)
      try {
        Q = new f().parseFromString(ot, co);
      } catch {
      }
    if (!Q || !Q.documentElement) {
      Q = C.createDocument(Nn, "template", null);
      try {
        Q.documentElement.innerHTML = Ft ? M : ot;
      } catch {
      }
    }
    const Kt = Q.body || Q.documentElement;
    return R && me && Kt.insertBefore(t.createTextNode(me), Kt.childNodes[0] || null), Nn === Qt ? F.call(Q, vn ? "html" : "body")[0] : vn ? Q.documentElement : Kt;
  }, Nu = function(R) {
    return I.call(
      R.ownerDocument || R,
      R,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, Ra = function(R) {
    return R instanceof h && (typeof R.nodeName != "string" || typeof R.textContent != "string" || typeof R.removeChild != "function" || !(R.attributes instanceof u) || typeof R.removeAttribute != "function" || typeof R.setAttribute != "function" || typeof R.namespaceURI != "string" || typeof R.insertBefore != "function" || typeof R.hasChildNodes != "function");
  }, Ru = function(R) {
    return typeof l == "function" && R instanceof l;
  };
  function _r(be, R, Q) {
    B0(be, (me) => {
      me.call(e, R, Q, ms);
    });
  }
  const Pu = function(R) {
    let Q = null;
    if (_r($.beforeSanitizeElements, R, null), Ra(R))
      return mr(R), !0;
    const me = Lt(R.nodeName);
    if (_r($.uponSanitizeElement, R, {
      tagName: me,
      allowedTags: Me
    }), ci && R.hasChildNodes() && !Ru(R.firstElementChild) && Rn(/<[/\w!]/g, R.innerHTML) && Rn(/<[/\w!]/g, R.textContent) || R.nodeType === eh.progressingInstruction || ci && R.nodeType === eh.comment && Rn(/<[/\w]/g, R.data))
      return mr(R), !0;
    if (!Me[me] || Ke[me]) {
      if (!Ke[me] && Bu(me) && (Le.tagNameCheck instanceof RegExp && Rn(Le.tagNameCheck, me) || Le.tagNameCheck instanceof Function && Le.tagNameCheck(me)))
        return !1;
      if (ao && !q[me]) {
        const ot = k(R) || R.parentNode, Kt = w(R) || R.childNodes;
        if (Kt && ot) {
          const Tt = Kt.length;
          for (let cn = Tt - 1; cn >= 0; --cn) {
            const Fr = m(Kt[cn], !0);
            Fr.__removalCount = (R.__removalCount || 0) + 1, ot.insertBefore(Fr, b(R));
          }
        }
      }
      return mr(R), !0;
    }
    return R instanceof a && !a0(R) || (me === "noscript" || me === "noembed" || me === "noframes") && Rn(/<\/no(script|embed|frames)/i, R.innerHTML) ? (mr(R), !0) : (dr && R.nodeType === eh.text && (Q = R.textContent, B0([B, se, te], (ot) => {
      Q = Xu(Q, ot, " ");
    }), R.textContent !== Q && (Ju(e.removed, {
      element: R.cloneNode()
    }), R.textContent = Q)), _r($.afterSanitizeElements, R, null), !1);
  }, Lu = function(R, Q, me) {
    if (lo && (Q === "id" || Q === "name") && (me in t || me in l0))
      return !1;
    if (!(Zt && !Dt[Q] && Rn(ie, Q))) {
      if (!(Pt && Rn(Ce, Q))) {
        if (!O[Q] || Dt[Q]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(Bu(R) && (Le.tagNameCheck instanceof RegExp && Rn(Le.tagNameCheck, R) || Le.tagNameCheck instanceof Function && Le.tagNameCheck(R)) && (Le.attributeNameCheck instanceof RegExp && Rn(Le.attributeNameCheck, Q) || Le.attributeNameCheck instanceof Function && Le.attributeNameCheck(Q, R)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            Q === "is" && Le.allowCustomizedBuiltInElements && (Le.tagNameCheck instanceof RegExp && Rn(Le.tagNameCheck, me) || Le.tagNameCheck instanceof Function && Le.tagNameCheck(me)))
          ) return !1;
        } else if (!Ye[Q]) {
          if (!Rn(D, Xu(me, Re, ""))) {
            if (!((Q === "src" || Q === "xlink:href" || Q === "href") && R !== "script" && sK(me, "data:") === 0 && Ee[R])) {
              if (!(on && !Rn(Oe, Xu(me, Re, "")))) {
                if (me)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Bu = function(R) {
    return R !== "annotation-xml" && z2(R, Be);
  }, zu = function(R) {
    _r($.beforeSanitizeAttributes, R, null);
    const {
      attributes: Q
    } = R;
    if (!Q || Ra(R))
      return;
    const me = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: O,
      forceKeepAttr: void 0
    };
    let ot = Q.length;
    for (; ot--; ) {
      const Kt = Q[ot], {
        name: Tt,
        namespaceURI: cn,
        value: Fr
      } = Kt, gs = Lt(Tt), Pa = Fr;
      let Ht = Tt === "value" ? Pa : oK(Pa);
      if (me.attrName = gs, me.attrValue = Ht, me.keepAttr = !0, me.forceKeepAttr = void 0, _r($.uponSanitizeAttribute, R, me), Ht = me.attrValue, cl && (gs === "id" || gs === "name") && (Pi(Tt, R), Ht = Da + Ht), ci && Rn(/((--!?|])>)|<\/(style|title|textarea)/i, Ht)) {
        Pi(Tt, R);
        continue;
      }
      if (gs === "attributename" && z2(Ht, "href")) {
        Pi(Tt, R);
        continue;
      }
      if (me.forceKeepAttr)
        continue;
      if (!me.keepAttr) {
        Pi(Tt, R);
        continue;
      }
      if (!Lr && Rn(/\/>/i, Ht)) {
        Pi(Tt, R);
        continue;
      }
      dr && B0([B, se, te], (Fu) => {
        Ht = Xu(Ht, Fu, " ");
      });
      const _u = Lt(R.nodeName);
      if (!Lu(_u, gs, Ht)) {
        Pi(Tt, R);
        continue;
      }
      if (T && typeof d == "object" && typeof d.getAttributeType == "function" && !cn)
        switch (d.getAttributeType(_u, gs)) {
          case "TrustedHTML": {
            Ht = T.createHTML(Ht);
            break;
          }
          case "TrustedScriptURL": {
            Ht = T.createScriptURL(Ht);
            break;
          }
        }
      if (Ht !== Pa)
        try {
          cn ? R.setAttributeNS(cn, Tt, Ht) : R.setAttribute(Tt, Ht), Ra(R) ? mr(R) : Y8(e.removed);
        } catch {
          Pi(Tt, R);
        }
    }
    _r($.afterSanitizeAttributes, R, null);
  }, c0 = function be(R) {
    let Q = null;
    const me = Nu(R);
    for (_r($.beforeSanitizeShadowDOM, R, null); Q = me.nextNode(); )
      _r($.uponSanitizeShadowNode, Q, null), Pu(Q), zu(Q), Q.content instanceof s && be(Q.content);
    _r($.afterSanitizeShadowDOM, R, null);
  };
  return e.sanitize = function(be) {
    let R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Q = null, me = null, ot = null, Kt = null;
    if (Ft = !be, Ft && (be = "<!-->"), typeof be != "string" && !Ru(be))
      if (typeof be.toString == "function") {
        if (be = be.toString(), typeof be != "string")
          throw Zu("dirty is not a string, aborting");
      } else
        throw Zu("toString is not a function");
    if (!e.isSupported)
      return be;
    if (Br || Na(R), e.removed = [], typeof be == "string" && (Ri = !1), Ri) {
      if (be.nodeName) {
        const Fr = Lt(be.nodeName);
        if (!Me[Fr] || Ke[Fr])
          throw Zu("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (be instanceof l)
      Q = Du("<!---->"), me = Q.ownerDocument.importNode(be, !0), me.nodeType === eh.element && me.nodeName === "BODY" || me.nodeName === "HTML" ? Q = me : Q.appendChild(me);
    else {
      if (!wn && !dr && !vn && // eslint-disable-next-line unicorn/prefer-includes
      be.indexOf("<") === -1)
        return T && In ? T.createHTML(be) : be;
      if (Q = Du(be), !Q)
        return wn ? null : In ? M : "";
    }
    Q && zr && mr(Q.firstChild);
    const Tt = Nu(Ri ? be : Q);
    for (; ot = Tt.nextNode(); )
      Pu(ot), zu(ot), ot.content instanceof s && c0(ot.content);
    if (Ri)
      return be;
    if (wn) {
      if (Un)
        for (Kt = _.call(Q.ownerDocument); Q.firstChild; )
          Kt.appendChild(Q.firstChild);
      else
        Kt = Q;
      return (O.shadowroot || O.shadowrootmode) && (Kt = L.call(r, Kt, !0)), Kt;
    }
    let cn = vn ? Q.outerHTML : Q.innerHTML;
    return vn && Me["!doctype"] && Q.ownerDocument && Q.ownerDocument.doctype && Q.ownerDocument.doctype.name && Rn(QA, Q.ownerDocument.doctype.name) && (cn = "<!DOCTYPE " + Q.ownerDocument.doctype.name + `>
` + cn), dr && B0([B, se, te], (Fr) => {
      cn = Xu(cn, Fr, " ");
    }), T && In ? T.createHTML(cn) : cn;
  }, e.setConfig = function() {
    let be = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Na(be), Br = !0;
  }, e.clearConfig = function() {
    ms = null, Br = !1;
  }, e.isValidAttribute = function(be, R, Q) {
    ms || Na({});
    const me = Lt(be), ot = Lt(R);
    return Lu(me, ot, Q);
  }, e.addHook = function(be, R) {
    typeof R == "function" && Ju($[be], R);
  }, e.removeHook = function(be, R) {
    if (R !== void 0) {
      const Q = rK($[be], R);
      return Q === -1 ? void 0 : iK($[be], Q, 1)[0];
    }
    return Y8($[be]);
  }, e.removeHooks = function(be) {
    $[be] = [];
  }, e.removeAllHooks = function() {
    $ = tx();
  }, e;
}
var Ii = eO();
function tu({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
tu.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var xK = Object.defineProperty, nx = Object.getOwnPropertySymbols, kK = Object.prototype.hasOwnProperty, SK = Object.prototype.propertyIsEnumerable, rx = (n, e, t) => e in n ? xK(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, CK = (n, e) => {
  for (var t in e || (e = {}))
    kK.call(e, t) && rx(n, t, e[t]);
  if (nx)
    for (var t of nx(e))
      SK.call(e, t) && rx(n, t, e[t]);
  return n;
};
function Wd(n, e) {
  return Object.assign(n, {
    meta: CK({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const MK = {
  imageIcon: "ðŸŒŒ",
  captionIcon: "ðŸ’¬",
  uploadButton: "Upload file",
  confirmButton: "Confirm âŽ",
  uploadPlaceholderText: "or paste the image link ...",
  captionPlaceholderText: "Image caption",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, Z1 = it(
  MK,
  "imageBlockConfigCtx"
);
Wd(Z1, {
  displayName: "Config<image-block>",
  group: "ImageBlock"
});
function TK(n) {
  return rl(
    n,
    "paragraph",
    (e, t, r) => {
      var i, s;
      if (((i = e.children) == null ? void 0 : i.length) !== 1) return;
      const o = (s = e.children) == null ? void 0 : s[0];
      if (!o || o.type !== "image") return;
      const { url: l, alt: a, title: c } = o, u = {
        type: "image-block",
        url: l,
        alt: a,
        title: c
      };
      r.children.splice(t, 1, u);
    }
  );
}
const jb = as(
  "remark-image-block",
  () => () => TK
);
Wd(jb.plugin, {
  displayName: "Remark<remarkImageBlock>",
  group: "ImageBlock"
});
Wd(jb.options, {
  displayName: "RemarkConfig<remarkImageBlock>",
  group: "ImageBlock"
});
var AK = Object.defineProperty, ix = Object.getOwnPropertySymbols, OK = Object.prototype.hasOwnProperty, EK = Object.prototype.propertyIsEnumerable, sx = (n, e, t) => e in n ? AK(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, IK = (n, e) => {
  for (var t in e || (e = {}))
    OK.call(e, t) && sx(n, t, e[t]);
  if (ix)
    for (var t of ix(e))
      EK.call(e, t) && sx(n, t, e[t]);
  return n;
};
const u5 = "image-block", Q1 = _t("image-block", () => ({
  inline: !1,
  group: "block",
  selectable: !0,
  draggable: !0,
  isolating: !0,
  marks: "",
  atom: !0,
  priority: 100,
  attrs: {
    src: { default: "", validate: "string" },
    caption: { default: "", validate: "string" },
    ratio: { default: 1, validate: "number" }
  },
  parseDOM: [
    {
      tag: `img[data-type="${u5}"]`,
      getAttrs: (n) => {
        var e;
        if (!(n instanceof HTMLElement)) throw Ai(n);
        return {
          src: n.getAttribute("src") || "",
          caption: n.getAttribute("caption") || "",
          ratio: Number((e = n.getAttribute("ratio")) != null ? e : 1)
        };
      }
    }
  ],
  toDOM: (n) => ["img", IK({ "data-type": u5 }, n.attrs)],
  parseMarkdown: {
    match: ({ type: n }) => n === "image-block",
    runner: (n, e, t) => {
      const r = e.url, i = e.title;
      let s = Number(e.alt || 1);
      (Number.isNaN(s) || s === 0) && (s = 1), n.addNode(t, {
        src: r,
        caption: i,
        ratio: s
      });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "image-block",
    runner: (n, e) => {
      n.openNode("paragraph"), n.addNode("image", void 0, void 0, {
        title: e.attrs.caption,
        url: e.attrs.src,
        alt: `${Number.parseFloat(e.attrs.ratio).toFixed(2)}`
      }), n.closeNode();
    }
  }
}));
Wd(Q1.node, {
  displayName: "NodeSchema<image-block>",
  group: "ImageBlock"
});
function hf({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
hf.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const DK = J3("abcdefg", 8), NK = Xt({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = ce(!1), f = ce(), d = ce((c = e.value) != null ? c : ""), p = ce(DK()), m = ce(((u = e.value) == null ? void 0 : u.length) !== 0), g = (T) => {
      const C = T.target.value;
      m.value = C.length !== 0, d.value = C;
    }, b = (T) => {
      var M, C;
      T.key === "Enter" && t((C = (M = f.value) == null ? void 0 : M.value) != null ? C : "");
    }, w = () => {
      var T, M;
      t((M = (T = f.value) == null ? void 0 : T.value) != null ? M : "");
    }, k = (T) => {
      var M;
      const C = (M = T.target.files) == null ? void 0 : M[0];
      C && r(C).then((I) => {
        I && (t(I), m.value = !0);
      }).catch((I) => {
        console.error("An error occurred while uploading image"), console.error(I);
      });
    };
    return () => /* @__PURE__ */ V("div", { class: bn("image-edit", a) }, /* @__PURE__ */ V(hf, { icon: i, class: "image-icon" }), /* @__PURE__ */ V("div", { class: bn("link-importer", h.value && "focus") }, /* @__PURE__ */ V(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (T) => {
          T.preventDefault(), T.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ V("div", { class: "placeholder" }, /* @__PURE__ */ V(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ V("label", { class: "uploader", for: p.value }, /* @__PURE__ */ V(hf, { icon: s })), /* @__PURE__ */ V("span", { class: "text", onClick: () => {
      var T;
      return (T = f.value) == null ? void 0 : T.focus();
    } }, l))), d.value && /* @__PURE__ */ V("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ V(hf, { icon: o })));
  }
}), RK = Xt({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup({ src: n, caption: e, ratio: t, readonly: r, setAttr: i, config: s }) {
    var o;
    const l = ce(), a = ce(), c = ce(!!((o = e.value) != null && o.length)), u = ce(0), h = () => {
      var w;
      const k = l.value;
      if (!k) return;
      const T = k.closest(".milkdown-image-block");
      if (!T) return;
      const M = T.getBoundingClientRect().width;
      if (!M) return;
      const C = k.height, I = k.width, _ = I < M ? C : M * (C / I), F = (_ * ((w = t.value) != null ? w : 1)).toFixed(2);
      k.dataset.origin = _.toFixed(2), k.dataset.height = F, k.style.height = `${F}px`;
    }, f = (w) => {
      w.preventDefault(), w.stopPropagation(), !r.value && (c.value = !c.value);
    }, d = (w) => {
      const T = w.target.value;
      u.value && window.clearTimeout(u.value), u.value = window.setTimeout(() => {
        i("caption", T);
      }, 1e3);
    }, p = (w) => {
      const T = w.target.value;
      u.value && (window.clearTimeout(u.value), u.value = 0), i("caption", T);
    }, m = (w) => {
      w.preventDefault();
      const k = l.value;
      if (!k) return;
      const T = k.getBoundingClientRect().top, M = w.clientY - T, C = Number(M < 100 ? 100 : M).toFixed(2);
      k.dataset.height = C, k.style.height = `${C}px`;
    }, g = () => {
      window.removeEventListener("pointermove", m), window.removeEventListener("pointerup", g);
      const w = l.value;
      if (!w) return;
      const k = Number(w.dataset.origin), T = Number(w.dataset.height), M = Number.parseFloat(
        Number(T / k).toFixed(2)
      );
      Number.isNaN(M) || i("ratio", M);
    }, b = (w) => {
      r.value || (w.preventDefault(), w.stopPropagation(), window.addEventListener("pointermove", m), window.addEventListener("pointerup", g));
    };
    return () => /* @__PURE__ */ V(xa, null, /* @__PURE__ */ V("div", { class: "image-wrapper" }, /* @__PURE__ */ V("div", { class: "operation" }, /* @__PURE__ */ V("div", { class: "operation-item", onPointerdown: f }, /* @__PURE__ */ V(hf, { icon: s.captionIcon }))), /* @__PURE__ */ V(
      "img",
      {
        ref: l,
        "data-type": u5,
        onLoad: h,
        src: n.value,
        alt: e.value
      }
    ), /* @__PURE__ */ V(
      "div",
      {
        ref: a,
        class: "image-resize-handle",
        onPointerdown: b
      }
    )), c.value && /* @__PURE__ */ V(
      "input",
      {
        draggable: "true",
        onDragstart: (w) => {
          w.preventDefault(), w.stopPropagation();
        },
        class: "caption-input",
        placeholder: s == null ? void 0 : s.captionPlaceholderText,
        onInput: d,
        onBlur: p,
        value: e.value
      }
    ));
  }
});
var PK = Object.defineProperty, ox = Object.getOwnPropertySymbols, LK = Object.prototype.hasOwnProperty, BK = Object.prototype.propertyIsEnumerable, lx = (n, e, t) => e in n ? PK(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, zK = (n, e) => {
  for (var t in e || (e = {}))
    LK.call(e, t) && lx(n, t, e[t]);
  if (ox)
    for (var t of ox(e))
      BK.call(e, t) && lx(n, t, e[t]);
  return n;
};
const _K = Xt({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e } = n;
    return () => {
      var t;
      return (t = e.value) != null && t.length ? /* @__PURE__ */ V(RK, zK({}, n)) : /* @__PURE__ */ V(
        NK,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (r) => n.setAttr("src", r),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload
        }
      );
    };
  }
}), tO = Hd(
  Q1.node,
  (n) => (e, t, r) => {
    const i = ce(e.attrs.src), s = ce(e.attrs.caption), o = ce(e.attrs.ratio), l = ce(!1), a = ce(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ii.sanitize(b) : b
        )
      );
    }, u = n.get(Z1.key), h = oi(_K, {
      src: i,
      caption: s,
      ratio: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("div");
    f.className = "milkdown-image-block";
    const d = au(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      o.value = g.attrs.ratio, s.value = g.attrs.caption, a.value = !t.editable;
    };
    return m(e), h.mount(f), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
Wd(tO, {
  displayName: "NodeView<image-block>",
  group: "ImageBlock"
});
const FK = [
  jb,
  Q1,
  tO,
  Z1
].flat();
var h5, f5;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  h5 = (e) => n.get(e), f5 = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  h5 = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r) return n[i + 1];
  }, f5 = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var nt = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let l = 1; s < this.width && this.map[e + l] == t; l++)
        s++;
      for (let l = 1; o < this.height && this.map[e + this.width * l] == t; l++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: l,
      top: a,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, a),
      right: Math.max(r, l),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[s - 1] == o || r == n.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const l = (n + 1) * this.width;
        for (; o < l && this.map[o] < i; ) o++;
        return o == l ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return h5(n) || f5(n, HK(n));
  }
};
function HK(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = $K(n), t = n.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * t; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < t; c++) {
    const h = n.child(c);
    u++;
    for (let p = 0; ; p++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (p == h.childCount) break;
      const m = h.child(p), { colspan: g, rowspan: b, colwidth: w } = m.attrs;
      for (let k = 0; k < b; k++) {
        if (k + c >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: b - k
          });
          break;
        }
        const T = i + k * e;
        for (let M = 0; M < g; M++) {
          r[T + M] == 0 ? r[T + M] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: g - M
          });
          const C = w && w[M];
          if (C) {
            const I = (T + M) % e * 2, _ = o[I];
            _ == null || _ != C && o[I + 1] == 1 ? (o[I] = C, o[I + 1] = 1) : _ == C && o[I + 1]++;
          }
        }
      }
      i += g, u += m.nodeSize;
    }
    const f = (c + 1) * e;
    let d = 0;
    for (; i < f; ) r[i++] == 0 && d++;
    d && (s || (s = [])).push({ type: "missing", row: c, n: d }), u++;
  }
  (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const l = new nt(e, t, r, s);
  let a = !1;
  for (let c = 0; !a && c < o.length; c += 2)
    o[c] != null && o[c + 1] < t && (a = !0);
  return a && VK(l, o, n), l;
}
function $K(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let s = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const l = n.child(o);
        for (let a = 0; a < l.childCount; a++) {
          const c = l.child(a);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const l = i.child(o);
      s += l.attrs.colspan, l.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function VK(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const s = n.map[i];
    if (r[s]) continue;
    r[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let l = null;
    const a = o.attrs;
    for (let c = 0; c < a.colspan; c++) {
      const u = (i + c) % n.width, h = e[u * 2];
      h != null && (!a.colwidth || a.colwidth[c] != h) && ((l || (l = qK(a)))[c] = h);
    }
    l && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: l
    });
  }
}
function qK(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function ax(n, e) {
  if (typeof n == "string")
    return {};
  const t = n.getAttribute("data-colwidth"), r = t && /^\d+(,\d+)*$/.test(t) ? t.split(",").map((o) => Number(o)) : null, i = Number(n.getAttribute("colspan") || 1), s = {
    colspan: i,
    rowspan: Number(n.getAttribute("rowspan") || 1),
    colwidth: r && r.length == i ? r : null
  };
  for (const o in e) {
    const l = e[o].getFromDOM, a = l && l(n);
    a != null && (s[o] = a);
  }
  return s;
}
function cx(n, e) {
  const t = {};
  n.attrs.colspan != 1 && (t.colspan = n.attrs.colspan), n.attrs.rowspan != 1 && (t.rowspan = n.attrs.rowspan), n.attrs.colwidth && (t["data-colwidth"] = n.attrs.colwidth.join(","));
  for (const r in e) {
    const i = e[r].setDOMAttr;
    i && i(n.attrs[r], t);
  }
  return t;
}
function WK(n) {
  if (n !== null) {
    if (!Array.isArray(n))
      throw new TypeError("colwidth must be null or an array");
    for (const e of n)
      if (typeof e != "number")
        throw new TypeError("colwidth must be null or an array of numbers");
  }
}
function jK(n) {
  const e = n.cellAttributes || {}, t = {
    colspan: { default: 1, validate: "number" },
    rowspan: { default: 1, validate: "number" },
    colwidth: { default: null, validate: WK }
  };
  for (const r in e)
    t[r] = {
      default: e[r].default,
      validate: e[r].validate
    };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: n.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: n.cellContent,
      attrs: t,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [
        { tag: "td", getAttrs: (r) => ax(r, e) }
      ],
      toDOM(r) {
        return ["td", cx(r, e), 0];
      }
    },
    table_header: {
      content: n.cellContent,
      attrs: t,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [
        { tag: "th", getAttrs: (r) => ax(r, e) }
      ],
      toDOM(r) {
        return ["th", cx(r, e), 0];
      }
    }
  };
}
function ri(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var Ao = new kt("selectingCells");
function jd(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function li(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function eg(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = jd(e.$head) || UK(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function UK(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function d5(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function GK(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function Ub(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function nO(n, e, t) {
  const r = n.node(-1), i = nt.get(r), s = n.start(-1), o = i.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function wa(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function KK(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function YK(n, e, t) {
  const r = ri(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var ft = class Ss extends Pe {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), i = nt.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      t.pos - s
    ), l = e.node(0), a = i.cellsInRect(o).filter((u) => u != t.pos - s);
    a.unshift(t.pos - s);
    const c = a.map((u) => {
      const h = r.nodeAt(u);
      if (!h)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new mM(
        l.resolve(f),
        l.resolve(f + h.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos));
    if (d5(r) && d5(i) && Ub(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? Ss.rowSelection(r, i) : s && this.isColSelection() ? Ss.colSelection(r, i) : new Ss(r, i);
    }
    return ge.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = nt.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let a = i.top; a < i.bottom; a++) {
      const c = [];
      for (let u = a * t.width + i.left, h = i.left; h < i.right; h++, u++) {
        const f = t.map[u];
        if (s[f]) continue;
        s[f] = !0;
        const d = t.findCell(f);
        let p = e.nodeAt(f);
        if (!p)
          throw RangeError(`No cell with offset ${f} found`);
        const m = i.left - d.left, g = d.right - i.right;
        if (m > 0 || g > 0) {
          let b = p.attrs;
          if (m > 0 && (b = wa(b, 0, m)), g > 0 && (b = wa(
            b,
            b.colspan - g,
            g
          )), d.left < i.left) {
            if (p = p.type.createAndFill(b), !p)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(b)}`
              );
          } else
            p = p.type.create(b, p.content);
        }
        if (d.top < i.top || d.bottom > i.bottom) {
          const b = {
            ...p.attrs,
            rowspan: Math.min(d.bottom, i.bottom) - Math.max(d.top, i.top)
          };
          d.top < i.top ? p = p.type.createAndFill(b) : p = p.type.create(b, p.content);
        }
        c.push(p);
      }
      o.push(e.child(a).copy(Y.from(c)));
    }
    const l = this.isColSelection() && this.isRowSelection() ? e : o;
    return new ue(Y.from(l), 1, 1);
  }
  replace(e, t = ue.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: l, $to: a } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(l.pos),
        c.map(a.pos),
        o ? ue.empty : t
      );
    }
    const s = Pe.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, t) {
    this.replace(e, new ue(Y.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = nt.get(t), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(t.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), i = nt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.top <= l.top ? (o.top > 0 && (e = a.resolve(s + i.map[o.left])), l.bottom < i.height && (t = a.resolve(
      s + i.map[i.width * (i.height - 1) + l.right - 1]
    ))) : (l.top > 0 && (t = a.resolve(s + i.map[l.left])), o.bottom < i.height && (e = a.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Ss(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = nt.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), s = t.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0) return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, l = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, l) == t.width;
  }
  eq(e) {
    return e instanceof Ss && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), i = nt.get(r), s = e.start(-1), o = i.findCell(e.pos - s), l = i.findCell(t.pos - s), a = e.node(0);
    return o.left <= l.left ? (o.left > 0 && (e = a.resolve(
      s + i.map[o.top * i.width]
    )), l.right < i.width && (t = a.resolve(
      s + i.map[i.width * (l.top + 1) - 1]
    ))) : (l.left > 0 && (t = a.resolve(s + i.map[l.top * i.width])), o.right < i.width && (e = a.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new Ss(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Ss(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new Ss(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new JK(this.$anchorCell.pos, this.$headCell.pos);
  }
};
ft.prototype.visible = !1;
Pe.jsonID("cell", ft);
var JK = class rO {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new rO(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && Ub(t, r) ? new ft(t, r) : Pe.near(r, 1);
  }
};
function XK(n) {
  if (!(n.selection instanceof ft)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      Wt.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), ct.create(n.doc, e);
}
function ZK({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function QK({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const s = n.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function eY(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let s, o;
  if (r instanceof ve && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = ft.create(i, r.from);
    else if (o == "row") {
      const l = i.resolve(r.from + 1);
      s = ft.rowSelection(l, l);
    } else if (!t) {
      const l = nt.get(r.node), a = r.from + 1, c = a + l.map[l.width * l.height - 1];
      s = ft.create(i, a + 1, c);
    }
  } else r instanceof ge && ZK(r) ? s = ge.create(i, r.from) : r instanceof ge && QK(r) && (s = ge.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var tY = new kt("fix-tables");
function iO(n, e, t, r) {
  const i = n.childCount, s = e.childCount;
  e: for (let o = 0, l = 0; o < s; o++) {
    const a = e.child(o);
    for (let c = l, u = Math.min(i, o + 3); c < u; c++)
      if (n.child(c) == a) {
        l = c + 1, t += a.nodeSize;
        continue e;
      }
    r(a, t), l < i && n.child(l).sameMarkup(a) ? iO(n.child(l), a, t + 1, r) : a.nodesBetween(0, a.content.size, r, t + 1), t += a.nodeSize;
  }
}
function nY(n, e) {
  let t;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (t = rY(n, i, s, t));
  };
  return e ? e.doc != n.doc && iO(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function rY(n, e, t, r) {
  const i = nt.get(e);
  if (!i.problems) return r;
  r || (r = n.tr);
  const s = [];
  for (let a = 0; a < i.height; a++) s.push(0);
  for (let a = 0; a < i.problems.length; a++) {
    const c = i.problems[a];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const h = u.attrs;
      for (let f = 0; f < h.rowspan; f++) s[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + c.pos),
        null,
        wa(h, h.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(t);
      r.delete(u, u + e.nodeSize);
    }
  }
  let o, l;
  for (let a = 0; a < s.length; a++)
    s[a] && (o == null && (o = a), l = a);
  for (let a = 0, c = t + 1; a < i.height; a++) {
    const u = e.child(a), h = c + u.nodeSize, f = s[a];
    if (f > 0) {
      let d = "cell";
      u.firstChild && (d = u.firstChild.type.spec.tableRole);
      const p = [];
      for (let g = 0; g < f; g++) {
        const b = ri(n.schema)[d].createAndFill();
        b && p.push(b);
      }
      const m = (a == 0 || o == a - 1) && l == a ? c + 1 : h - 1;
      r.insert(r.mapping.map(m), p);
    }
    c = h;
  }
  return r.setMeta(tY, { fixTables: !0 });
}
function sO(n) {
  const e = nt.get(n), t = [], r = e.height, i = e.width;
  for (let s = 0; s < r; s++) {
    const o = [];
    for (let l = 0; l < i; l++) {
      const a = s * i + l, c = e.map[a];
      if (s > 0) {
        const u = a - i, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      if (l > 0) {
        const u = a - 1, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      o.push(n.nodeAt(c));
    }
    t.push(o);
  }
  return t;
}
function oO(n, e) {
  const t = [], r = nt.get(n), i = r.height, s = r.width;
  for (let l = 0; l < i; l++) {
    const a = n.child(l), c = [];
    for (let h = 0; h < s; h++) {
      const f = e[l][h];
      if (!f)
        continue;
      const d = r.map[l * r.width + h], p = n.nodeAt(d);
      if (!p)
        continue;
      const m = p.type.createChecked(
        f.attrs,
        f.content,
        f.marks
      );
      c.push(m);
    }
    const u = a.type.createChecked(
      a.attrs,
      c,
      a.marks
    );
    t.push(u);
  }
  return n.type.createChecked(
    n.attrs,
    t,
    n.marks
  );
}
function wu(n) {
  return iY((e) => e.type.spec.tableRole === "table", n);
}
function iY(n, e) {
  for (let t = e.depth; t >= 0; t -= 1) {
    const r = e.node(t);
    if (n(r)) {
      const i = t === 0 ? 0 : e.before(t), s = e.start(t);
      return { node: r, pos: i, start: s, depth: t };
    }
  }
  return null;
}
function Ua(n, e) {
  const t = wu(e.$from);
  if (!t)
    return;
  const r = nt.get(t.node);
  return n < 0 || n > r.width - 1 ? void 0 : r.cellsInRect({
    left: n,
    right: n + 1,
    top: 0,
    bottom: r.height
  }).map((s) => {
    const o = t.node.nodeAt(s), l = s + t.start;
    return { pos: l, start: l + 1, node: o, depth: t.depth + 2 };
  });
}
function Ga(n, e) {
  const t = wu(e.$from);
  if (!t)
    return;
  const r = nt.get(t.node);
  return n < 0 || n > r.height - 1 ? void 0 : r.cellsInRect({
    left: 0,
    right: r.width,
    top: n,
    bottom: n + 1
  }).map((s) => {
    const o = t.node.nodeAt(s), l = s + t.start;
    return { pos: l, start: l + 1, node: o, depth: t.depth + 2 };
  });
}
function ux(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = Ua(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = Ua(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.colspan + h - 1;
      d.node.attrs.colspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = Ua(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = Ua(r, n.selection), l = Ga(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = Ua(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function hx(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = Ga(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      p >= r && (r = h), p > i && (i = p);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = Ga(h, n.selection);
    f && f.forEach((d) => {
      const p = d.node.attrs.rowspan + h - 1;
      d.node.attrs.rowspan > 1 && p > i && (i = p);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = Ga(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = Ga(r, n.selection), l = Ua(0, n.selection);
  if (!o || !l)
    return;
  const a = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = Ga(h, n.selection);
    if (f && f.length > 0) {
      for (let d = l.length - 1; d >= 0; d--)
        if (l[d].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: a, $head: u, indexes: s };
}
function lO(n, e, t, r) {
  const i = e[0] > t[0] ? -1 : 1, s = n.splice(e[0], e.length), o = s.length % 2 === 0 ? 1 : 0;
  let l;
  return l = i === -1 ? t[0] : t[t.length - 1] - o, n.splice(l, 0, ...s), n;
}
function fx(n) {
  return n[0].map((e, t) => n.map((r) => r[t]));
}
function sY(n) {
  var e, t;
  const { tr: r, originIndex: i, targetIndex: s, select: o, pos: l } = n, a = r.doc.resolve(l), c = wu(a);
  if (!c) return !1;
  const u = (e = ux(
    r,
    i
  )) == null ? void 0 : e.indexes, h = (t = ux(
    r,
    s
  )) == null ? void 0 : t.indexes;
  if (!u || !h || u.includes(s)) return !1;
  const f = oY(
    c.node,
    u,
    h
  );
  if (r.replaceWith(c.pos, c.pos + c.node.nodeSize, f), !o) return !0;
  const d = nt.get(f), p = c.start, m = s, g = d.positionAt(d.height - 1, m, f), b = r.doc.resolve(p + g), w = d.positionAt(0, m, f), k = r.doc.resolve(p + w);
  return r.setSelection(ft.colSelection(b, k)), !0;
}
function oY(n, e, t, r) {
  let i = fx(sO(n));
  return i = lO(i, e, t), i = fx(i), oO(n, i);
}
function lY(n) {
  var e, t;
  const { tr: r, originIndex: i, targetIndex: s, select: o, pos: l } = n, a = r.doc.resolve(l), c = wu(a);
  if (!c) return !1;
  const u = (e = hx(r, i)) == null ? void 0 : e.indexes, h = (t = hx(r, s)) == null ? void 0 : t.indexes;
  if (!u || !h || u.includes(s)) return !1;
  const f = aY(
    c.node,
    u,
    h
  );
  if (r.replaceWith(c.pos, c.pos + c.node.nodeSize, f), !o) return !0;
  const d = nt.get(f), p = c.start, m = s, g = d.positionAt(m, d.width - 1, f), b = r.doc.resolve(p + g), w = d.positionAt(m, 0, f), k = r.doc.resolve(p + w);
  return r.setSelection(ft.rowSelection(b, k)), !0;
}
function aY(n, e, t, r) {
  let i = sO(n);
  return i = lO(i, e, t), oO(n, i);
}
function ol(n) {
  const e = n.selection, t = eg(n), r = t.node(-1), i = t.start(-1), s = nt.get(r);
  return { ...e instanceof ft ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(t.pos - i), tableStart: i, map: s, table: r };
}
function aO(n, { map: e, tableStart: t, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  YK(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const l = o * e.width + i;
    if (i > 0 && i < e.width && e.map[l - 1] == e.map[l]) {
      const a = e.map[l], c = r.nodeAt(a);
      n.setNodeMarkup(
        n.mapping.map(t + a),
        null,
        KK(c.attrs, i - e.colCount(a))
      ), o += c.attrs.rowspan - 1;
    } else {
      const a = s == null ? ri(r.type.schema).cell : r.nodeAt(e.map[l + s]).type, c = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + c), a.createAndFill());
    }
  }
  return n;
}
function cY(n, e) {
  if (!li(n)) return !1;
  if (e) {
    const t = ol(n);
    e(aO(n.tr, t, t.left));
  }
  return !0;
}
function uY(n, e) {
  if (!li(n)) return !1;
  if (e) {
    const t = ol(n);
    e(aO(n.tr, t, t.right));
  }
  return !0;
}
function hY(n, { map: e, table: t, tableStart: r }, i) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const l = o * e.width + i, a = e.map[l], c = t.nodeAt(a), u = c.attrs;
    if (i > 0 && e.map[l - 1] == a || i < e.width - 1 && e.map[l + 1] == a)
      n.setNodeMarkup(
        n.mapping.slice(s).map(r + a),
        null,
        wa(u, i - e.colCount(a))
      );
    else {
      const h = n.mapping.slice(s).map(r + a);
      n.delete(h, h + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function fY(n, e) {
  if (!li(n)) return !1;
  if (e) {
    const t = ol(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let i = t.right - 1; hY(r, t, i), i != t.left; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = nt.get(s);
    }
    e(r);
  }
  return !0;
}
function dY(n, { map: e, table: t, tableStart: r }, i) {
  let s = 0;
  for (let c = 0; c < i; c++) s += t.child(c).nodeSize;
  const o = s + t.child(i).nodeSize, l = n.mapping.maps.length;
  n.delete(s + r, o + r);
  const a = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const h = e.map[u];
    if (!a.has(h)) {
      if (a.add(h), i > 0 && h == e.map[u - e.width]) {
        const f = t.nodeAt(h).attrs;
        n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && h == e.map[u + e.width]) {
        const f = t.nodeAt(h), d = f.attrs, p = f.type.create(
          { ...d, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), m = e.positionAt(i + 1, c, t);
        n.insert(n.mapping.slice(l).map(r + m), p), c += d.colspan - 1;
      }
    }
  }
}
function pY(n, e) {
  if (!li(n)) return !1;
  if (e) {
    const t = ol(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let i = t.bottom - 1; dY(r, t, i), i != t.top; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = nt.get(t.table);
    }
    e(r);
  }
  return !0;
}
function mY(n, e) {
  return function(t, r) {
    if (!li(t)) return !1;
    const i = eg(t);
    if (i.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const s = t.tr;
      t.selection instanceof ft ? t.selection.forEachCell((o, l) => {
        o.attrs[n] !== e && s.setNodeMarkup(l, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(s);
    }
    return !0;
  };
}
function gY(n) {
  return function(e, t) {
    if (!li(e)) return !1;
    if (t) {
      const r = ri(e.schema), i = ol(e), s = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), l = o.map((a) => i.table.nodeAt(a));
      for (let a = 0; a < o.length; a++)
        l[a].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[a],
          r.cell,
          l[a].attrs
        );
      if (s.steps.length == 0)
        for (let a = 0; a < o.length; a++)
          s.setNodeMarkup(
            i.tableStart + o[a],
            r.header_cell,
            l[a].attrs
          );
      t(s);
    }
    return !0;
  };
}
function dx(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function Gb(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? gY(n) : function(t, r) {
    if (!li(t)) return !1;
    if (r) {
      const i = ri(t.schema), s = ol(t), o = t.tr, l = dx("row", s, i), a = dx(
        "column",
        s,
        i
      ), u = (n === "column" ? l : n === "row" ? a : !1) ? 1 : 0, h = n == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = n == "column" ? a ? i.cell : i.header_cell : n == "row" ? l ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(h).forEach((d) => {
        const p = d + s.tableStart, m = o.doc.nodeAt(p);
        m && o.setNodeMarkup(p, f, m.attrs);
      }), r(o);
    }
    return !0;
  };
}
Gb("row", {
  useDeprecatedLogic: !0
});
Gb("column", {
  useDeprecatedLogic: !0
});
Gb("cell", {
  useDeprecatedLogic: !0
});
function yY(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const s = n.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const s = t.child(r);
      if (s.childCount) return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function cO(n) {
  return function(e, t) {
    if (!li(e)) return !1;
    const r = yY(eg(e), n);
    if (r == null) return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(ge.between(i, GK(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function bY(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function _0(n, e) {
  const t = n.selection;
  if (!(t instanceof ft)) return !1;
  if (e) {
    const r = n.tr, i = ri(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new ue(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function vY(n) {
  return (e, t) => {
    const {
      from: r,
      to: i,
      select: s = !0,
      pos: o = e.selection.from
    } = n, l = e.tr;
    return lY({ tr: l, originIndex: r, targetIndex: i, select: s, pos: o }) ? (t == null || t(l), !0) : !1;
  };
}
function wY(n) {
  return (e, t) => {
    const {
      from: r,
      to: i,
      select: s = !0,
      pos: o = e.selection.from
    } = n, l = e.tr;
    return sY({ tr: l, originIndex: r, targetIndex: i, select: s, pos: o }) ? (t == null || t(l), !0) : !1;
  };
}
function xY(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, l = [];
  if (s == "row")
    for (let a = 0; a < e.childCount; a++) {
      let c = e.child(a).content;
      const u = a ? 0 : Math.max(0, t - 1), h = a < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || h) && (c = p5(
        ri(o).row,
        new ue(c, u, h)
      ).content), l.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    l.push(
      t || r ? p5(
        ri(o).row,
        new ue(e, t, r)
      ).content : e
    );
  else
    return null;
  return kY(o, l);
}
function kY(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: l, colspan: a } = s.child(o).attrs;
      for (let c = i; c < i + l; c++)
        t[c] = (t[c] || 0) + a;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++) r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push(Y.empty), t[i] < r) {
      const s = ri(n).cell.createAndFill(), o = [];
      for (let l = t[i]; l < r; l++)
        o.push(s);
      e[i] = e[i].append(Y.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function p5(n, e) {
  const t = n.createAndFill();
  return new pM(t).replace(0, t.content.size, e).doc;
}
function SY({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const s = [], o = [];
    for (let l = 0; l < t.length; l++) {
      const a = t[l], c = [];
      for (let u = s[l] || 0, h = 0; u < r; h++) {
        let f = a.child(h % a.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          wa(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let d = 1; d < f.attrs.rowspan; d++)
          s[l + d] = (s[l + d] || 0) + f.attrs.colspan;
      }
      o.push(Y.from(c));
    }
    t = o, n = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, l = 0; o < i; o++, l++) {
      const a = [], c = t[l % e];
      for (let u = 0; u < c.childCount; u++) {
        let h = c.child(u);
        o + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), a.push(h);
      }
      s.push(Y.from(a));
    }
    t = s, e = i;
  }
  return { width: n, height: e, rows: t };
}
function CY(n, e, t, r, i, s, o) {
  const l = n.doc.type.schema, a = ri(l);
  let c, u;
  if (i > e.width)
    for (let h = 0, f = 0; h < e.height; h++) {
      const d = t.child(h);
      f += d.nodeSize;
      const p = [];
      let m;
      d.lastChild == null || d.lastChild.type == a.cell ? m = c || (c = a.cell.createAndFill()) : m = u || (u = a.header_cell.createAndFill());
      for (let g = e.width; g < i; g++) p.push(m);
      n.insert(n.mapping.slice(o).map(f - 1 + r), p);
    }
  if (s > e.height) {
    const h = [];
    for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, i); p++) {
      const g = p >= e.width ? !1 : t.nodeAt(e.map[m + p]).type == a.header_cell;
      h.push(
        g ? u || (u = a.header_cell.createAndFill()) : c || (c = a.cell.createAndFill())
      );
    }
    const f = a.row.create(null, Y.from(h)), d = [];
    for (let p = e.height; p < s; p++) d.push(f);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), d);
  }
  return !!(c || u);
}
function px(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.height) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = o * e.width + c, h = e.map[u];
    if (e.map[u - e.width] == h) {
      a = !0;
      const f = t.nodeAt(h), { top: d, left: p } = e.findCell(h);
      n.setNodeMarkup(n.mapping.slice(l).map(h + r), null, {
        ...f.attrs,
        rowspan: o - d
      }), n.insert(
        n.mapping.slice(l).map(e.positionAt(o, p, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: d + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return a;
}
function mx(n, e, t, r, i, s, o, l) {
  if (o == 0 || o == e.width) return !1;
  let a = !1;
  for (let c = i; c < s; c++) {
    const u = c * e.width + o, h = e.map[u];
    if (e.map[u - 1] == h) {
      a = !0;
      const f = t.nodeAt(h), d = e.colCount(h), p = n.mapping.slice(l).map(h + r);
      n.setNodeMarkup(
        p,
        null,
        wa(
          f.attrs,
          o - d,
          f.attrs.colspan - (o - d)
        )
      ), n.insert(
        p + f.nodeSize,
        f.type.createAndFill(
          wa(f.attrs, 0, o - d)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return a;
}
function gx(n, e, t, r, i) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = nt.get(s);
  const { top: l, left: a } = r, c = a + i.width, u = l + i.height, h = n.tr;
  let f = 0;
  function d() {
    if (s = t ? h.doc.nodeAt(t - 1) : h.doc, !s)
      throw new Error("No table found");
    o = nt.get(s), f = h.mapping.maps.length;
  }
  CY(h, o, s, t, c, u, f) && d(), px(h, o, s, t, a, c, l, f) && d(), px(h, o, s, t, a, c, u, f) && d(), mx(h, o, s, t, l, u, a, f) && d(), mx(h, o, s, t, l, u, c, f) && d();
  for (let p = l; p < u; p++) {
    const m = o.positionAt(p, a, s), g = o.positionAt(p, c, s);
    h.replace(
      h.mapping.slice(f).map(m + t),
      h.mapping.slice(f).map(g + t),
      new ue(i.rows[p - l], 0, 0)
    );
  }
  d(), h.setSelection(
    new ft(
      h.doc.resolve(t + o.positionAt(l, a, s)),
      h.doc.resolve(t + o.positionAt(u - 1, c - 1, s))
    )
  ), e(h);
}
var MY = F3({
  ArrowLeft: F0("horiz", -1),
  ArrowRight: F0("horiz", 1),
  ArrowUp: F0("vert", -1),
  ArrowDown: F0("vert", 1),
  "Shift-ArrowLeft": H0("horiz", -1),
  "Shift-ArrowRight": H0("horiz", 1),
  "Shift-ArrowUp": H0("vert", -1),
  "Shift-ArrowDown": H0("vert", 1),
  Backspace: _0,
  "Mod-Backspace": _0,
  Delete: _0,
  "Mod-Delete": _0
});
function Fp(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function F0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    if (s instanceof ft)
      return Fp(
        t,
        r,
        Pe.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty) return !1;
    const o = uO(i, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return Fp(
        t,
        r,
        Pe.near(t.doc.resolve(s.head + e), e)
      );
    {
      const l = t.doc.resolve(o), a = nO(l, n, e);
      let c;
      return a ? c = Pe.near(a, 1) : e < 0 ? c = Pe.near(t.doc.resolve(l.before(-1)), -1) : c = Pe.near(t.doc.resolve(l.after(-1)), 1), Fp(t, r, c);
    }
  };
}
function H0(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    let o;
    if (s instanceof ft)
      o = s;
    else {
      const a = uO(i, n, e);
      if (a == null) return !1;
      o = new ft(t.doc.resolve(a));
    }
    const l = nO(o.$headCell, n, e);
    return l ? Fp(
      t,
      r,
      new ft(o.$anchorCell, l)
    ) : !1;
  };
}
function TY(n, e) {
  const t = n.state.doc, r = jd(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new ft(r))), !0) : !1;
}
function AY(n, e, t) {
  if (!li(n.state)) return !1;
  let r = xY(t);
  const i = n.state.selection;
  if (i instanceof ft) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        Y.from(
          p5(ri(n.state.schema).cell, t)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), l = nt.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = SY(r, l.right - l.left, l.bottom - l.top), gx(n.state, n.dispatch, o, l, r), !0;
  } else if (r) {
    const s = eg(n.state), o = s.start(-1);
    return gx(
      n.state,
      n.dispatch,
      o,
      nt.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function OY(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = yx(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof ft)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = jd(n.state.selection.$anchor)) != null && ((t = V2(n, e)) == null ? void 0 : t.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(a, c) {
    let u = V2(n, c);
    const h = Ao.getState(n.state) == null;
    if (!u || !Ub(a, u))
      if (h) u = a;
      else return;
    const f = new ft(a, u);
    if (h || !n.state.selection.eq(f)) {
      const d = n.state.tr.setSelection(f);
      h && d.setMeta(Ao, a.pos), n.dispatch(d);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", l), Ao.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Ao, -1));
  }
  function l(a) {
    const c = a, u = Ao.getState(n.state);
    let h;
    if (u != null)
      h = n.state.doc.resolve(u);
    else if (yx(n, c.target) != r && (h = V2(n, e), !h))
      return o();
    h && s(h, c);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", l);
}
function uO(n, e, t) {
  if (!(n.state.selection instanceof ge)) return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const l = r.before(i), a = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(a) ? l : null;
    }
  }
  return null;
}
function yx(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function V2(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? jd(n.state.doc.resolve(t.pos)) : null;
}
var EY = class {
  constructor(n, e) {
    this.node = n, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${e}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), m5(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type != this.node.type ? !1 : (this.node = n, m5(
      n,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(n) {
    return n.type == "attributes" && (n.target == this.table || this.colgroup.contains(n.target));
  }
};
function m5(n, e, t, r, i, s) {
  var o;
  let l = 0, a = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u) {
    for (let h = 0, f = 0; h < u.childCount; h++) {
      const { colspan: d, colwidth: p } = u.child(h).attrs;
      for (let m = 0; m < d; m++, f++) {
        const g = i == f ? s : p && p[m], b = g ? g + "px" : "";
        if (l += g || r, g || (a = !1), c)
          c.style.width != b && (c.style.width = b), c = c.nextSibling;
        else {
          const w = document.createElement("col");
          w.style.width = b, e.appendChild(w);
        }
      }
    }
    for (; c; ) {
      const h = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = h;
    }
    a ? (t.style.width = l + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = l + "px");
  }
}
var Mr = new kt(
  "tableColumnResizing"
);
function IY({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: r = EY,
  lastColumnResizable: i = !0
} = {}) {
  const s = new xt({
    key: Mr,
    state: {
      init(o, l) {
        var a, c;
        const u = (c = (a = s.spec) == null ? void 0 : a.props) == null ? void 0 : c.nodeViews, h = ri(l.schema).table.name;
        return r && u && (u[h] = (f, d) => new r(f, t, d)), new DY(-1, !1);
      },
      apply(o, l) {
        return l.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const l = Mr.getState(o);
        return l && l.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, l) => {
          NY(o, l, n, i);
        },
        mouseleave: (o) => {
          RY(o);
        },
        mousedown: (o, l) => {
          PY(o, l, e, t);
        }
      },
      decorations: (o) => {
        const l = Mr.getState(o);
        if (l && l.activeHandle > -1)
          return FY(o, l.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var DY = class Hp {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, r = e.getMeta(Mr);
    if (r && r.setHandle != null)
      return new Hp(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new Hp(t.activeHandle, r.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(t.activeHandle, -1);
      return d5(e.doc.resolve(i)) || (i = -1), new Hp(i, t.dragging);
    }
    return t;
  }
};
function NY(n, e, t, r) {
  if (!n.editable) return;
  const i = Mr.getState(n.state);
  if (i && !i.dragging) {
    const s = BY(e.target);
    let o = -1;
    if (s) {
      const { left: l, right: a } = s.getBoundingClientRect();
      e.clientX - l <= t ? o = bx(n, e, "left", t) : a - e.clientX <= t && (o = bx(n, e, "right", t));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const l = n.state.doc.resolve(o), a = l.node(-1), c = nt.get(a), u = l.start(-1);
        if (c.colCount(l.pos - u) + l.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      hO(n, o);
    }
  }
}
function RY(n) {
  if (!n.editable) return;
  const e = Mr.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && hO(n, -1);
}
function PY(n, e, t, r) {
  var i;
  if (!n.editable) return !1;
  const s = (i = n.dom.ownerDocument.defaultView) != null ? i : window, o = Mr.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const l = n.state.doc.nodeAt(o.activeHandle), a = LY(n, o.activeHandle, l.attrs);
  n.dispatch(
    n.state.tr.setMeta(Mr, {
      setDragging: { startX: e.clientX, startWidth: a }
    })
  );
  function c(h) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = Mr.getState(n.state);
    f != null && f.dragging && (zY(
      n,
      f.activeHandle,
      vx(f.dragging, h, t)
    ), n.dispatch(
      n.state.tr.setMeta(Mr, { setDragging: null })
    ));
  }
  function u(h) {
    if (!h.which) return c(h);
    const f = Mr.getState(n.state);
    if (f && f.dragging) {
      const d = vx(f.dragging, h, t);
      wx(
        n,
        f.activeHandle,
        d,
        r
      );
    }
  }
  return wx(
    n,
    o.activeHandle,
    a,
    r
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function LY(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const s = n.domAtPos(e);
  let l = s.node.childNodes[s.offset].offsetWidth, a = t;
  if (r)
    for (let c = 0; c < t; c++)
      r[c] && (l -= r[c], a--);
  return l / a;
}
function BY(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function bx(n, e, t, r) {
  const i = t == "right" ? -r : r, s = n.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: o } = s, l = jd(n.state.doc.resolve(o));
  if (!l) return -1;
  if (t == "right") return l.pos;
  const a = nt.get(l.node(-1)), c = l.start(-1), u = a.map.indexOf(l.pos - c);
  return u % a.width == 0 ? -1 : c + a.map[u - 1];
}
function vx(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function hO(n, e) {
  n.dispatch(
    n.state.tr.setMeta(Mr, { setHandle: e })
  );
}
function zY(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), s = nt.get(i), o = r.start(-1), l = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, a = n.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + l;
    if (c && s.map[u] == s.map[u - s.width]) continue;
    const h = s.map[u], f = i.nodeAt(h).attrs, d = f.colspan == 1 ? 0 : l - s.colCount(h);
    if (f.colwidth && f.colwidth[d] == t) continue;
    const p = f.colwidth ? f.colwidth.slice() : _Y(f.colspan);
    p[d] = t, a.setNodeMarkup(o + h, null, { ...f, colwidth: p });
  }
  a.docChanged && n.dispatch(a);
}
function wx(n, e, t, r) {
  const i = n.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), l = nt.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let a = n.domAtPos(i.start(-1)).node;
  for (; a && a.nodeName != "TABLE"; )
    a = a.parentNode;
  a && m5(
    s,
    a.firstChild,
    a,
    r,
    l,
    t
  );
}
function _Y(n) {
  return Array(n).fill(0);
}
function FY(n, e) {
  var t;
  const r = [], i = n.doc.resolve(e), s = i.node(-1);
  if (!s)
    return ct.empty;
  const o = nt.get(s), l = i.start(-1), a = o.colCount(i.pos - l) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = a + c * o.width;
    if ((a == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const h = o.map[u], f = l + h + s.nodeAt(h).nodeSize - 1, d = document.createElement("div");
      d.className = "column-resize-handle", (t = Mr.getState(n)) != null && t.dragging && r.push(
        Wt.node(
          l + h,
          l + h + s.nodeAt(h).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(Wt.widget(f, d));
    }
  }
  return ct.create(n.doc, r);
}
function HY({
  allowTableNodeSelection: n = !1
} = {}) {
  return new xt({
    key: Ao,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(Ao);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: i, pos: s } = e.mapping.mapResult(t);
        return i ? null : s;
      }
    },
    props: {
      decorations: XK,
      handleDOMEvents: {
        mousedown: OY
      },
      createSelectionBetween(e) {
        return Ao.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: TY,
      handleKeyDown: MY,
      handlePaste: AY
    },
    appendTransaction(e, t, r) {
      return eY(
        r,
        nY(r, t),
        n
      );
    }
  });
}
var Vm = typeof navigator < "u" ? navigator : null, Kb = Vm && Vm.userAgent || "", $Y = /Edge\/(\d+)/.exec(Kb), VY = /MSIE \d/.exec(Kb), qY = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Kb), WY = !!(VY || qY || $Y), jY = !WY && !!Vm && /Apple Computer/.test(Vm.vendor), fO = new kt("safari-ime-span"), g5 = !1, UY = {
  key: fO,
  props: {
    decorations: GY,
    handleDOMEvents: {
      compositionstart: () => {
        g5 = !0;
      },
      compositionend: () => {
        g5 = !1;
      }
    }
  }
};
function GY(n) {
  const { $from: e, $to: t, to: r } = n.selection;
  if (g5 && e.sameParent(t)) {
    const i = Wt.widget(r, KY, {
      ignoreSelection: !0,
      key: "safari-ime-span"
    });
    return ct.create(n.doc, [i]);
  }
}
function KY(n) {
  const e = n.dom.ownerDocument.createElement("span");
  return e.className = "ProseMirror-safari-ime-span", e;
}
var YY = new xt(jY ? UY : { key: fO });
function xx(n, e) {
  const t = String(n);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = t.indexOf(e);
  for (; i !== -1; )
    r++, i = t.indexOf(e, i + e.length);
  return r;
}
function JY(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function XY(n, e, t) {
  const i = D1((t || {}).ignore || []), s = ZY(e);
  let o = -1;
  for (; ++o < s.length; )
    I3(n, "text", l);
  function l(c, u) {
    let h = -1, f;
    for (; ++h < u.length; ) {
      const d = u[h], p = f ? f.children : void 0;
      if (i(
        d,
        p ? p.indexOf(d) : void 0,
        f
      ))
        return;
      f = d;
    }
    if (f)
      return a(c, u);
  }
  function a(c, u) {
    const h = u[u.length - 1], f = s[o][0], d = s[o][1];
    let p = 0;
    const g = h.children.indexOf(c);
    let b = !1, w = [];
    f.lastIndex = 0;
    let k = f.exec(c.value);
    for (; k; ) {
      const T = k.index, M = {
        index: k.index,
        input: k.input,
        stack: [...u, c]
      };
      let C = d(...k, M);
      if (typeof C == "string" && (C = C.length > 0 ? { type: "text", value: C } : void 0), C === !1 ? f.lastIndex = T + 1 : (p !== T && w.push({
        type: "text",
        value: c.value.slice(p, T)
      }), Array.isArray(C) ? w.push(...C) : C && w.push(C), p = T + k[0].length, b = !0), !f.global)
        break;
      k = f.exec(c.value);
    }
    return b ? (p < c.value.length && w.push({ type: "text", value: c.value.slice(p) }), h.children.splice(g, 1, ...w)) : w = [c], g + w.length;
  }
}
function ZY(n) {
  const e = [];
  if (!Array.isArray(n))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const t = !n[0] || Array.isArray(n[0]) ? n : [n];
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    e.push([QY(i[0]), eJ(i[1])]);
  }
  return e;
}
function QY(n) {
  return typeof n == "string" ? new RegExp(JY(n), "g") : n;
}
function eJ(n) {
  return typeof n == "function" ? n : function() {
    return n;
  };
}
const q2 = "phrasing", W2 = ["autolink", "link", "image", "label"];
function tJ() {
  return {
    transforms: [aJ],
    enter: {
      literalAutolink: rJ,
      literalAutolinkEmail: j2,
      literalAutolinkHttp: j2,
      literalAutolinkWww: j2
    },
    exit: {
      literalAutolink: lJ,
      literalAutolinkEmail: oJ,
      literalAutolinkHttp: iJ,
      literalAutolinkWww: sJ
    }
  };
}
function nJ() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: q2,
        notInConstruct: W2
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: q2,
        notInConstruct: W2
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: q2,
        notInConstruct: W2
      }
    ]
  };
}
function rJ(n) {
  this.enter({ type: "link", title: null, url: "", children: [] }, n);
}
function j2(n) {
  this.config.enter.autolinkProtocol.call(this, n);
}
function iJ(n) {
  this.config.exit.autolinkProtocol.call(this, n);
}
function sJ(n) {
  this.config.exit.data.call(this, n);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(n);
}
function oJ(n) {
  this.config.exit.autolinkEmail.call(this, n);
}
function lJ(n) {
  this.exit(n);
}
function aJ(n) {
  XY(
    n,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, cJ],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), uJ]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function cJ(n, e, t, r, i) {
  let s = "";
  if (!dO(i) || (/^w/i.test(e) && (t = e + t, e = "", s = "http://"), !hJ(t)))
    return !1;
  const o = fJ(t + r);
  if (!o[0]) return !1;
  const l = {
    type: "link",
    title: null,
    url: s + e + o[0],
    children: [{ type: "text", value: e + o[0] }]
  };
  return o[1] ? [l, { type: "text", value: o[1] }] : l;
}
function uJ(n, e, t, r) {
  return (
    // Not an expected previous character.
    !dO(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(t) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + t,
      children: [{ type: "text", value: e + "@" + t }]
    }
  );
}
function hJ(n) {
  const e = n.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function fJ(n) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(n);
  if (!e)
    return [n, void 0];
  n = n.slice(0, e.index);
  let t = e[0], r = t.indexOf(")");
  const i = xx(n, "(");
  let s = xx(n, ")");
  for (; r !== -1 && i > s; )
    n += t.slice(0, r + 1), t = t.slice(r + 1), r = t.indexOf(")"), s++;
  return [n, t];
}
function dO(n, e) {
  const t = n.input.charCodeAt(n.index - 1);
  return (n.index === 0 || ga(t) || E1(t)) && // If itâ€™s an email, the previous character should not be a slash.
  (!e || t !== 47);
}
pO.peek = xJ;
function dJ() {
  this.buffer();
}
function pJ(n) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, n);
}
function mJ() {
  this.buffer();
}
function gJ(n) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    n
  );
}
function yJ(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = wi(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function bJ(n) {
  this.exit(n);
}
function vJ(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = wi(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function wJ(n) {
  this.exit(n);
}
function xJ() {
  return "[";
}
function pO(n, e, t, r) {
  const i = t.createTracker(r);
  let s = i.move("[^");
  const o = t.enter("footnoteReference"), l = t.enter("reference");
  return s += i.move(
    t.safe(t.associationId(n), { after: "]", before: s })
  ), l(), o(), s += i.move("]"), s;
}
function kJ() {
  return {
    enter: {
      gfmFootnoteCallString: dJ,
      gfmFootnoteCall: pJ,
      gfmFootnoteDefinitionLabelString: mJ,
      gfmFootnoteDefinition: gJ
    },
    exit: {
      gfmFootnoteCallString: yJ,
      gfmFootnoteCall: bJ,
      gfmFootnoteDefinitionLabelString: vJ,
      gfmFootnoteDefinition: wJ
    }
  };
}
function SJ(n) {
  let e = !1;
  return n && n.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: t, footnoteReference: pO },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function t(r, i, s, o) {
    const l = s.createTracker(o);
    let a = l.move("[^");
    const c = s.enter("footnoteDefinition"), u = s.enter("label");
    return a += l.move(
      s.safe(s.associationId(r), { before: a, after: "]" })
    ), u(), a += l.move("]:"), r.children && r.children.length > 0 && (l.shift(4), a += l.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, l.current()),
        e ? mO : CJ
      )
    )), c(), a;
  }
}
function CJ(n, e, t) {
  return e === 0 ? n : mO(n, e, t);
}
function mO(n, e, t) {
  return (t ? "" : "    ") + n;
}
const MJ = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
gO.peek = IJ;
function TJ() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: OJ },
    exit: { strikethrough: EJ }
  };
}
function AJ() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: MJ
      }
    ],
    handlers: { delete: gO }
  };
}
function OJ(n) {
  this.enter({ type: "delete", children: [] }, n);
}
function EJ(n) {
  this.exit(n);
}
function gO(n, e, t, r) {
  const i = t.createTracker(r), s = t.enter("strikethrough");
  let o = i.move("~~");
  return o += t.containerPhrasing(n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function IJ() {
  return "~";
}
function DJ(n) {
  return n.length;
}
function NJ(n, e) {
  const t = e || {}, r = (t.align || []).concat(), i = t.stringLength || DJ, s = [], o = [], l = [], a = [];
  let c = 0, u = -1;
  for (; ++u < n.length; ) {
    const m = [], g = [];
    let b = -1;
    for (n[u].length > c && (c = n[u].length); ++b < n[u].length; ) {
      const w = RJ(n[u][b]);
      if (t.alignDelimiters !== !1) {
        const k = i(w);
        g[b] = k, (a[b] === void 0 || k > a[b]) && (a[b] = k);
      }
      m.push(w);
    }
    o[u] = m, l[u] = g;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < c; )
      s[h] = kx(r[h]);
  else {
    const m = kx(r);
    for (; ++h < c; )
      s[h] = m;
  }
  h = -1;
  const f = [], d = [];
  for (; ++h < c; ) {
    const m = s[h];
    let g = "", b = "";
    m === 99 ? (g = ":", b = ":") : m === 108 ? g = ":" : m === 114 && (b = ":");
    let w = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      a[h] - g.length - b.length
    );
    const k = g + "-".repeat(w) + b;
    t.alignDelimiters !== !1 && (w = g.length + w + b.length, w > a[h] && (a[h] = w), d[h] = w), f[h] = k;
  }
  o.splice(1, 0, f), l.splice(1, 0, d), u = -1;
  const p = [];
  for (; ++u < o.length; ) {
    const m = o[u], g = l[u];
    h = -1;
    const b = [];
    for (; ++h < c; ) {
      const w = m[h] || "";
      let k = "", T = "";
      if (t.alignDelimiters !== !1) {
        const M = a[h] - (g[h] || 0), C = s[h];
        C === 114 ? k = " ".repeat(M) : C === 99 ? M % 2 ? (k = " ".repeat(M / 2 + 0.5), T = " ".repeat(M / 2 - 0.5)) : (k = " ".repeat(M / 2), T = k) : T = " ".repeat(M);
      }
      t.delimiterStart !== !1 && !h && b.push("|"), t.padding !== !1 && // Donâ€™t add the opening space if weâ€™re not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && w === "") && (t.delimiterStart !== !1 || h) && b.push(" "), t.alignDelimiters !== !1 && b.push(k), b.push(w), t.alignDelimiters !== !1 && b.push(T), t.padding !== !1 && b.push(" "), (t.delimiterEnd !== !1 || h !== c - 1) && b.push("|");
    }
    p.push(
      t.delimiterEnd === !1 ? b.join("").replace(/ +$/, "") : b.join("")
    );
  }
  return p.join(`
`);
}
function RJ(n) {
  return n == null ? "" : String(n);
}
function kx(n) {
  const e = typeof n == "string" ? n.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function PJ() {
  return {
    enter: {
      table: LJ,
      tableData: Sx,
      tableHeader: Sx,
      tableRow: zJ
    },
    exit: {
      codeText: _J,
      table: BJ,
      tableData: U2,
      tableHeader: U2,
      tableRow: U2
    }
  };
}
function LJ(n) {
  const e = n._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(t) {
        return t === "none" ? null : t;
      }),
      children: []
    },
    n
  ), this.data.inTable = !0;
}
function BJ(n) {
  this.exit(n), this.data.inTable = void 0;
}
function zJ(n) {
  this.enter({ type: "tableRow", children: [] }, n);
}
function U2(n) {
  this.exit(n);
}
function Sx(n) {
  this.enter({ type: "tableCell", children: [] }, n);
}
function _J(n) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, FJ));
  const t = this.stack[this.stack.length - 1];
  t.type, t.value = e, this.exit(n);
}
function FJ(n, e) {
  return e === "|" ? e : n;
}
function HJ(n) {
  const e = n || {}, t = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = t ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: o,
      tableCell: a,
      tableRow: l
    }
  };
  function o(d, p, m, g) {
    return c(u(d, m, g), d.align);
  }
  function l(d, p, m, g) {
    const b = h(d, m, g), w = c([b]);
    return w.slice(0, w.indexOf(`
`));
  }
  function a(d, p, m, g) {
    const b = m.enter("tableCell"), w = m.enter("phrasing"), k = m.containerPhrasing(d, {
      ...g,
      before: s,
      after: s
    });
    return w(), b(), k;
  }
  function c(d, p) {
    return NJ(d, {
      align: p,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: t,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("table");
    for (; ++b < g.length; )
      w[b] = h(g[b], p, m);
    return k(), w;
  }
  function h(d, p, m) {
    const g = d.children;
    let b = -1;
    const w = [], k = p.enter("tableRow");
    for (; ++b < g.length; )
      w[b] = a(g[b], d, p, m);
    return k(), w;
  }
  function f(d, p, m) {
    let g = N3.inlineCode(d, p, m);
    return m.stack.includes("tableCell") && (g = g.replace(/\|/g, "\\$&")), g;
  }
}
function $J() {
  return {
    exit: {
      taskListCheckValueChecked: Cx,
      taskListCheckValueUnchecked: Cx,
      paragraph: qJ
    }
  };
}
function VJ() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: WJ }
  };
}
function Cx(n) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = n.type === "taskListCheckValueChecked";
}
function qJ(n) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const t = this.stack[this.stack.length - 1];
    t.type;
    const r = t.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, o;
      for (; ++s < i.length; ) {
        const l = i[s];
        if (l.type === "paragraph") {
          o = l;
          break;
        }
      }
      o === t && (r.value = r.value.slice(1), r.value.length === 0 ? t.children.shift() : t.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, t.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(n);
}
function WJ(n, e, t, r) {
  const i = n.children[0], s = typeof n.checked == "boolean" && i && i.type === "paragraph", o = "[" + (n.checked ? "x" : " ") + "] ", l = t.createTracker(r);
  s && l.move(o);
  let a = N3.listItem(n, e, t, {
    ...r,
    ...l.current()
  });
  return s && (a = a.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), a;
  function c(u) {
    return u + o;
  }
}
function jJ() {
  return [
    tJ(),
    kJ(),
    TJ(),
    PJ(),
    $J()
  ];
}
function UJ(n) {
  return {
    extensions: [
      nJ(),
      SJ(n),
      AJ(),
      HJ(n),
      VJ()
    ]
  };
}
const GJ = {
  tokenize: QJ,
  partial: !0
}, yO = {
  tokenize: eX,
  partial: !0
}, bO = {
  tokenize: tX,
  partial: !0
}, vO = {
  tokenize: nX,
  partial: !0
}, KJ = {
  tokenize: rX,
  partial: !0
}, wO = {
  name: "wwwAutolink",
  tokenize: XJ,
  previous: kO
}, xO = {
  name: "protocolAutolink",
  tokenize: ZJ,
  previous: SO
}, so = {
  name: "emailAutolink",
  tokenize: JJ,
  previous: CO
}, us = {};
function YJ() {
  return {
    text: us
  };
}
let pl = 48;
for (; pl < 123; )
  us[pl] = so, pl++, pl === 58 ? pl = 65 : pl === 91 && (pl = 97);
us[43] = so;
us[45] = so;
us[46] = so;
us[95] = so;
us[72] = [so, xO];
us[104] = [so, xO];
us[87] = [so, wO];
us[119] = [so, wO];
function JJ(n, e, t) {
  const r = this;
  let i, s;
  return o;
  function o(h) {
    return !y5(h) || !CO.call(r, r.previous) || Yb(r.events) ? t(h) : (n.enter("literalAutolink"), n.enter("literalAutolinkEmail"), l(h));
  }
  function l(h) {
    return y5(h) ? (n.consume(h), l) : h === 64 ? (n.consume(h), a) : t(h);
  }
  function a(h) {
    return h === 46 ? n.check(KJ, u, c)(h) : h === 45 || h === 95 || ir(h) ? (s = !0, n.consume(h), a) : u(h);
  }
  function c(h) {
    return n.consume(h), i = !0, a;
  }
  function u(h) {
    return s && i && Ln(r.previous) ? (n.exit("literalAutolinkEmail"), n.exit("literalAutolink"), e(h)) : t(h);
  }
}
function XJ(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !kO.call(r, r.previous) || Yb(r.events) ? t(o) : (n.enter("literalAutolink"), n.enter("literalAutolinkWww"), n.check(GJ, n.attempt(yO, n.attempt(bO, s), t), t)(o));
  }
  function s(o) {
    return n.exit("literalAutolinkWww"), n.exit("literalAutolink"), e(o);
  }
}
function ZJ(n, e, t) {
  const r = this;
  let i = "", s = !1;
  return o;
  function o(h) {
    return (h === 72 || h === 104) && SO.call(r, r.previous) && !Yb(r.events) ? (n.enter("literalAutolink"), n.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), n.consume(h), l) : t(h);
  }
  function l(h) {
    if (Ln(h) && i.length < 5)
      return i += String.fromCodePoint(h), n.consume(h), l;
    if (h === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return n.consume(h), a;
    }
    return t(h);
  }
  function a(h) {
    return h === 47 ? (n.consume(h), s ? c : (s = !0, a)) : t(h);
  }
  function c(h) {
    return h === null || Om(h) || ht(h) || ga(h) || E1(h) ? t(h) : n.attempt(yO, n.attempt(bO, u), t)(h);
  }
  function u(h) {
    return n.exit("literalAutolinkHttp"), n.exit("literalAutolink"), e(h);
  }
}
function QJ(n, e, t) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, n.consume(o), i) : o === 46 && r === 3 ? (n.consume(o), s) : t(o);
  }
  function s(o) {
    return o === null ? t(o) : e(o);
  }
}
function eX(n, e, t) {
  let r, i, s;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? n.check(vO, a, l)(c) : c === null || ht(c) || ga(c) || c !== 45 && E1(c) ? a(c) : (s = !0, n.consume(c), o);
  }
  function l(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), n.consume(c), o;
  }
  function a(c) {
    return i || r || !s ? t(c) : e(c);
  }
}
function tX(n, e) {
  let t = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (t++, n.consume(o), i) : o === 41 && r < t ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? n.check(vO, e, s)(o) : o === null || ht(o) || ga(o) ? e(o) : (n.consume(o), i);
  }
  function s(o) {
    return o === 41 && r++, n.consume(o), i;
  }
}
function nX(n, e, t) {
  return r;
  function r(l) {
    return l === 33 || l === 34 || l === 39 || l === 41 || l === 42 || l === 44 || l === 46 || l === 58 || l === 59 || l === 63 || l === 95 || l === 126 ? (n.consume(l), r) : l === 38 ? (n.consume(l), s) : l === 93 ? (n.consume(l), i) : (
      // `<` is an end.
      l === 60 || // So is whitespace.
      l === null || ht(l) || ga(l) ? e(l) : t(l)
    );
  }
  function i(l) {
    return l === null || l === 40 || l === 91 || ht(l) || ga(l) ? e(l) : r(l);
  }
  function s(l) {
    return Ln(l) ? o(l) : t(l);
  }
  function o(l) {
    return l === 59 ? (n.consume(l), r) : Ln(l) ? (n.consume(l), o) : t(l);
  }
}
function rX(n, e, t) {
  return r;
  function r(s) {
    return n.consume(s), i;
  }
  function i(s) {
    return ir(s) ? t(s) : e(s);
  }
}
function kO(n) {
  return n === null || n === 40 || n === 42 || n === 95 || n === 91 || n === 93 || n === 126 || ht(n);
}
function SO(n) {
  return !Ln(n);
}
function CO(n) {
  return !(n === 47 || y5(n));
}
function y5(n) {
  return n === 43 || n === 45 || n === 46 || n === 95 || ir(n);
}
function Yb(n) {
  let e = n.length, t = !1;
  for (; e--; ) {
    const r = n[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      t = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      t = !1;
      break;
    }
  }
  return n.length > 0 && !t && (n[n.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t;
}
const iX = {
  tokenize: fX,
  partial: !0
};
function sX() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: cX,
        continuation: {
          tokenize: uX
        },
        exit: hX
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: aX
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: oX,
        resolveTo: lX
      }
    }
  };
}
function oX(n, e, t) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const a = r.events[i][1];
    if (a.type === "labelImage") {
      o = a;
      break;
    }
    if (a.type === "gfmFootnoteCall" || a.type === "labelLink" || a.type === "label" || a.type === "image" || a.type === "link")
      break;
  }
  return l;
  function l(a) {
    if (!o || !o._balanced)
      return t(a);
    const c = wi(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !s.includes(c.slice(1)) ? t(a) : (n.enter("gfmFootnoteCallLabelMarker"), n.consume(a), n.exit("gfmFootnoteCallLabelMarker"), e(a));
  }
}
function lX(n, e) {
  let t = n.length;
  for (; t--; )
    if (n[t][1].type === "labelImage" && n[t][0] === "enter") {
      n[t][1];
      break;
    }
  n[t + 1][1].type = "data", n[t + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, n[t + 3][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, n[t + 3][1].end),
    end: Object.assign({}, n[t + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, n[n.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, l = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    n[t + 1],
    n[t + 2],
    ["enter", r, e],
    // The `[`
    n[t + 3],
    n[t + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", o, e],
    ["exit", o, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    n[n.length - 2],
    n[n.length - 1],
    ["exit", r, e]
  ];
  return n.splice(t, n.length - t + 1, ...l), n;
}
function aX(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, o;
  return l;
  function l(h) {
    return n.enter("gfmFootnoteCall"), n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), a;
  }
  function a(h) {
    return h !== 94 ? t(h) : (n.enter("gfmFootnoteCallMarker"), n.consume(h), n.exit("gfmFootnoteCallMarker"), n.enter("gfmFootnoteCallString"), n.enter("chunkString").contentType = "string", c);
  }
  function c(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || ht(h)
    )
      return t(h);
    if (h === 93) {
      n.exit("chunkString");
      const f = n.exit("gfmFootnoteCallString");
      return i.includes(wi(r.sliceSerialize(f))) ? (n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), n.exit("gfmFootnoteCall"), e) : t(h);
    }
    return ht(h) || (o = !0), s++, n.consume(h), h === 92 ? u : c;
  }
  function u(h) {
    return h === 91 || h === 92 || h === 93 ? (n.consume(h), s++, c) : c(h);
  }
}
function cX(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, o = 0, l;
  return a;
  function a(p) {
    return n.enter("gfmFootnoteDefinition")._container = !0, n.enter("gfmFootnoteDefinitionLabel"), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(p) {
    return p === 94 ? (n.enter("gfmFootnoteDefinitionMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionMarker"), n.enter("gfmFootnoteDefinitionLabelString"), n.enter("chunkString").contentType = "string", u) : t(p);
  }
  function u(p) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      p === 93 && !l || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || ht(p)
    )
      return t(p);
    if (p === 93) {
      n.exit("chunkString");
      const m = n.exit("gfmFootnoteDefinitionLabelString");
      return s = wi(r.sliceSerialize(m)), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(p), n.exit("gfmFootnoteDefinitionLabelMarker"), n.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return ht(p) || (l = !0), o++, n.consume(p), p === 92 ? h : u;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (n.consume(p), o++, u) : u(p);
  }
  function f(p) {
    return p === 58 ? (n.enter("definitionMarker"), n.consume(p), n.exit("definitionMarker"), i.includes(s) || i.push(s), qe(n, d, "gfmFootnoteDefinitionWhitespace")) : t(p);
  }
  function d(p) {
    return e(p);
  }
}
function uX(n, e, t) {
  return n.check(Ld, e, n.attempt(iX, e, t));
}
function hX(n) {
  n.exit("gfmFootnoteDefinition");
}
function fX(n, e, t) {
  const r = this;
  return qe(n, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(s) : t(s);
  }
}
function dX(n) {
  let t = (n || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return t == null && (t = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, l) {
    let a = -1;
    for (; ++a < o.length; )
      if (o[a][0] === "enter" && o[a][1].type === "strikethroughSequenceTemporary" && o[a][1]._close) {
        let c = a;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[a][1].end.offset - o[a][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[a][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[a][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[a][1].start)
            }, f = [["enter", u, l], ["enter", o[c][1], l], ["exit", o[c][1], l], ["enter", h, l]], d = l.parser.constructs.insideSpan.null;
            d && Or(f, f.length, 0, I1(d, o.slice(c + 1, a), l)), Or(f, f.length, 0, [["exit", h, l], ["enter", o[a][1], l], ["exit", o[a][1], l], ["exit", u, l]]), Or(o, c - 1, a - c + 3, f), a = c + f.length - 2;
            break;
          }
      }
    for (a = -1; ++a < o.length; )
      o[a][1].type === "strikethroughSequenceTemporary" && (o[a][1].type = "data");
    return o;
  }
  function s(o, l, a) {
    const c = this.previous, u = this.events;
    let h = 0;
    return f;
    function f(p) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? a(p) : (o.enter("strikethroughSequenceTemporary"), d(p));
    }
    function d(p) {
      const m = Jc(c);
      if (p === 126)
        return h > 1 ? a(p) : (o.consume(p), h++, d);
      if (h < 2 && !t) return a(p);
      const g = o.exit("strikethroughSequenceTemporary"), b = Jc(p);
      return g._open = !b || b === 2 && !!m, g._close = !m || m === 2 && !!b, l(p);
    }
  }
}
class pX {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, t, r) {
    mX(this, e, t, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, o) {
      return s[0] - o[0];
    }), this.map.length === 0)
      return;
    let t = this.map.length;
    const r = [];
    for (; t > 0; )
      t -= 1, r.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function mX(n, e, t, r) {
  let i = 0;
  if (!(t === 0 && r.length === 0)) {
    for (; i < n.map.length; ) {
      if (n.map[i][0] === e) {
        n.map[i][1] += t, n.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    n.map.push([e, t, r]);
  }
}
function gX(n, e) {
  let t = !1;
  const r = [];
  for (; e < n.length; ) {
    const i = n[e];
    if (t) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(n[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (n[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0);
    e += 1;
  }
  return r;
}
function yX() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: bX,
        resolveAll: vX
      }
    }
  };
}
function bX(n, e, t) {
  const r = this;
  let i = 0, s = 0, o;
  return l;
  function l(L) {
    let $ = r.events.length - 1;
    for (; $ > -1; ) {
      const te = r.events[$][1].type;
      if (te === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      te === "linePrefix") $--;
      else break;
    }
    const B = $ > -1 ? r.events[$][1].type : null, se = B === "tableHead" || B === "tableRow" ? C : a;
    return se === C && r.parser.lazy[r.now().line] ? t(L) : se(L);
  }
  function a(L) {
    return n.enter("tableHead"), n.enter("tableRow"), c(L);
  }
  function c(L) {
    return L === 124 || (o = !0, s += 1), u(L);
  }
  function u(L) {
    return L === null ? t(L) : ye(L) ? s > 1 ? (s = 0, r.interrupt = !0, n.exit("tableRow"), n.enter("lineEnding"), n.consume(L), n.exit("lineEnding"), d) : t(L) : Ue(L) ? qe(n, u, "whitespace")(L) : (s += 1, o && (o = !1, i += 1), L === 124 ? (n.enter("tableCellDivider"), n.consume(L), n.exit("tableCellDivider"), o = !0, u) : (n.enter("data"), h(L)));
  }
  function h(L) {
    return L === null || L === 124 || ht(L) ? (n.exit("data"), u(L)) : (n.consume(L), L === 92 ? f : h);
  }
  function f(L) {
    return L === 92 || L === 124 ? (n.consume(L), h) : h(L);
  }
  function d(L) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? t(L) : (n.enter("tableDelimiterRow"), o = !1, Ue(L) ? qe(n, p, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(L) : p(L));
  }
  function p(L) {
    return L === 45 || L === 58 ? g(L) : L === 124 ? (o = !0, n.enter("tableCellDivider"), n.consume(L), n.exit("tableCellDivider"), m) : M(L);
  }
  function m(L) {
    return Ue(L) ? qe(n, g, "whitespace")(L) : g(L);
  }
  function g(L) {
    return L === 58 ? (s += 1, o = !0, n.enter("tableDelimiterMarker"), n.consume(L), n.exit("tableDelimiterMarker"), b) : L === 45 ? (s += 1, b(L)) : L === null || ye(L) ? T(L) : M(L);
  }
  function b(L) {
    return L === 45 ? (n.enter("tableDelimiterFiller"), w(L)) : M(L);
  }
  function w(L) {
    return L === 45 ? (n.consume(L), w) : L === 58 ? (o = !0, n.exit("tableDelimiterFiller"), n.enter("tableDelimiterMarker"), n.consume(L), n.exit("tableDelimiterMarker"), k) : (n.exit("tableDelimiterFiller"), k(L));
  }
  function k(L) {
    return Ue(L) ? qe(n, T, "whitespace")(L) : T(L);
  }
  function T(L) {
    return L === 124 ? p(L) : L === null || ye(L) ? !o || i !== s ? M(L) : (n.exit("tableDelimiterRow"), n.exit("tableHead"), e(L)) : M(L);
  }
  function M(L) {
    return t(L);
  }
  function C(L) {
    return n.enter("tableRow"), I(L);
  }
  function I(L) {
    return L === 124 ? (n.enter("tableCellDivider"), n.consume(L), n.exit("tableCellDivider"), I) : L === null || ye(L) ? (n.exit("tableRow"), e(L)) : Ue(L) ? qe(n, I, "whitespace")(L) : (n.enter("data"), _(L));
  }
  function _(L) {
    return L === null || L === 124 || ht(L) ? (n.exit("data"), I(L)) : (n.consume(L), L === 92 ? F : _);
  }
  function F(L) {
    return L === 92 || L === 124 ? (n.consume(L), _) : _(L);
  }
}
function vX(n, e) {
  let t = -1, r = !0, i = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], l = !1, a = 0, c, u, h;
  const f = new pX();
  for (; ++t < n.length; ) {
    const d = n[t], p = d[1];
    d[0] === "enter" ? p.type === "tableHead" ? (l = !1, a !== 0 && (Mx(f, e, a, c, u), u = void 0, a = 0), c = {
      type: "table",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", c, e]])) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], o = [0, t + 1, 0, 0], l && (l = !1, u = {
      type: "tableBody",
      start: Object.assign({}, p.start),
      // Note: correct end is set later.
      end: Object.assign({}, p.end)
    }, f.add(t, 0, [["enter", u, e]])), i = p.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (s[1] !== 0 && (o[0] = o[1], h = $0(f, e, s, i, void 0, h), s = [0, 0, 0, 0]), o[2] = t)) : p.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1], h = $0(f, e, s, i, void 0, h)), s = o, o = [s[1], t, 0, 0])) : p.type === "tableHead" ? (l = !0, a = t) : p.type === "tableRow" || p.type === "tableDelimiterRow" ? (a = t, s[1] !== 0 ? (o[0] = o[1], h = $0(f, e, s, i, t, h)) : o[1] !== 0 && (h = $0(f, e, o, i, t, h)), i = 0) : i && (p.type === "data" || p.type === "tableDelimiterMarker" || p.type === "tableDelimiterFiller") && (o[3] = t);
  }
  for (a !== 0 && Mx(f, e, a, c, u), f.consume(e.events), t = -1; ++t < e.events.length; ) {
    const d = e.events[t];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = gX(e.events, t));
  }
  return n;
}
function $0(n, e, t, r, i, s) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", l = "tableContent";
  t[0] !== 0 && (s.end = Object.assign({}, Ka(e.events, t[0])), n.add(t[0], 0, [["exit", s, e]]));
  const a = Ka(e.events, t[1]);
  if (s = {
    type: o,
    start: Object.assign({}, a),
    // Note: correct end is set later.
    end: Object.assign({}, a)
  }, n.add(t[1], 0, [["enter", s, e]]), t[2] !== 0) {
    const c = Ka(e.events, t[2]), u = Ka(e.events, t[3]), h = {
      type: l,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (n.add(t[2], 0, [["enter", h, e]]), r !== 2) {
      const f = e.events[t[2]], d = e.events[t[3]];
      if (f[1].end = Object.assign({}, d[1].end), f[1].type = "chunkText", f[1].contentType = "text", t[3] > t[2] + 1) {
        const p = t[2] + 1, m = t[3] - t[2] - 1;
        n.add(p, m, []);
      }
    }
    n.add(t[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, Ka(e.events, i)), n.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function Mx(n, e, t, r, i) {
  const s = [], o = Ka(e.events, t);
  i && (i.end = Object.assign({}, o), s.push(["exit", i, e])), r.end = Object.assign({}, o), s.push(["exit", r, e]), n.add(t + 1, 0, s);
}
function Ka(n, e) {
  const t = n[e], r = t[0] === "enter" ? "start" : "end";
  return t[1][r];
}
const wX = {
  name: "tasklistCheck",
  tokenize: kX
};
function xX() {
  return {
    text: {
      91: wX
    }
  };
}
function kX(n, e, t) {
  const r = this;
  return i;
  function i(a) {
    return (
      // Exit if thereâ€™s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? t(a) : (n.enter("taskListCheck"), n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), s)
    );
  }
  function s(a) {
    return ht(a) ? (n.enter("taskListCheckValueUnchecked"), n.consume(a), n.exit("taskListCheckValueUnchecked"), o) : a === 88 || a === 120 ? (n.enter("taskListCheckValueChecked"), n.consume(a), n.exit("taskListCheckValueChecked"), o) : t(a);
  }
  function o(a) {
    return a === 93 ? (n.enter("taskListCheckMarker"), n.consume(a), n.exit("taskListCheckMarker"), n.exit("taskListCheck"), l) : t(a);
  }
  function l(a) {
    return ye(a) ? e(a) : Ue(a) ? n.check({
      tokenize: SX
    }, e, t)(a) : t(a);
  }
}
function SX(n, e, t) {
  return qe(n, r, "whitespace");
  function r(i) {
    return i === null ? t(i) : e(i);
  }
}
function CX(n) {
  return EM([
    YJ(),
    sX(),
    dX(n),
    yX(),
    xX()
  ]);
}
const MX = {};
function TX(n) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), t = n || MX, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(CX(t)), s.push(jJ()), o.push(UJ(t));
}
function Ne(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-gfm",
      ...e
    }
  }), n;
}
const Jb = $d("strike_through");
Ne(Jb, {
  displayName: "Attr<strikethrough>",
  group: "Strikethrough"
});
const xu = mu("strike_through", (n) => ({
  parseDOM: [
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: (e) => e === "line-through"
    }
  ],
  toDOM: (e) => ["del", n.get(Jb.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "delete",
    runner: (e, t, r) => {
      e.openMark(r), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strike_through",
    runner: (e, t) => {
      e.withMark(t, "delete");
    }
  }
}));
Ne(xu.mark, {
  displayName: "MarkSchema<strikethrough>",
  group: "Strikethrough"
});
Ne(xu.ctx, {
  displayName: "MarkSchemaCtx<strikethrough>",
  group: "Strikethrough"
});
const tg = De(
  "ToggleStrikeThrough",
  (n) => () => R1(xu.type(n))
);
Ne(tg, {
  displayName: "Command<ToggleStrikethrough>",
  group: "Strikethrough"
});
const MO = On((n) => Pd(
  new RegExp("(?<![\\w:/])(~{1,2})(.+?)\\1(?!\\w|\\/)"),
  xu.type(n)
));
Ne(MO, {
  displayName: "InputRule<strikethrough>",
  group: "Strikethrough"
});
const Xb = hr("strikeThroughKeymap", {
  ToggleStrikethrough: {
    shortcuts: "Mod-Alt-x",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(tg.key);
    }
  }
});
Ne(Xb.ctx, {
  displayName: "KeymapCtx<strikethrough>",
  group: "Strikethrough"
});
Ne(Xb.shortcuts, {
  displayName: "Keymap<strikethrough>",
  group: "Strikethrough"
});
const Ud = jK({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (n) => n.style.textAlign || "left",
      setDOMAttr: (n, e) => {
        e.style = `text-align: ${n || "left"}`;
      }
    }
  }
}), Oa = _t("table", () => ({
  ...Ud.table,
  content: "table_header_row table_row+",
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "table",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r,
        isHeader: o === 0
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table",
    runner: (n, e) => {
      var i;
      const t = (i = e.content.firstChild) == null ? void 0 : i.content;
      if (!t) return;
      const r = [];
      t.forEach((s) => {
        r.push(s.attrs.alignment);
      }), n.openNode("table", void 0, { align: r }), n.next(e.content), n.closeNode();
    }
  }
}));
Ne(Oa.node, {
  displayName: "NodeSchema<table>",
  group: "Table"
});
Ne(Oa.ctx, {
  displayName: "NodeSchemaCtx<table>",
  group: "Table"
});
const ng = _t("table_header_row", () => ({
  ...Ud.table_row,
  disableDropCursor: !0,
  content: "(table_header)*",
  parseDOM: [{ tag: "tr[data-is-header]" }],
  toDOM() {
    return ["tr", { "data-is-header": !0 }, 0];
  },
  parseMarkdown: {
    match: (n) => !!(n.type === "tableRow" && n.isHeader),
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o],
        isHeader: e.isHeader
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header_row",
    runner: (n, e) => {
      n.openNode("tableRow", void 0, { isHeader: !0 }), n.next(e.content), n.closeNode();
    }
  }
}));
Ne(ng.node, {
  displayName: "NodeSchema<tableHeaderRow>",
  group: "Table"
});
Ne(ng.ctx, {
  displayName: "NodeSchemaCtx<tableHeaderRow>",
  group: "Table"
});
const Gd = _t("table_row", () => ({
  ...Ud.table_row,
  disableDropCursor: !0,
  content: "(table_cell)*",
  parseMarkdown: {
    match: (n) => n.type === "tableRow",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o]
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_row",
    runner: (n, e) => {
      e.content.size !== 0 && (n.openNode("tableRow"), n.next(e.content), n.closeNode());
    }
  }
}));
Ne(Gd.node, {
  displayName: "NodeSchema<tableRow>",
  group: "Table"
});
Ne(Gd.ctx, {
  displayName: "NodeSchemaCtx<tableRow>",
  group: "Table"
});
const Kd = _t("table_cell", () => ({
  ...Ud.table_cell,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }).openNode(n.schema.nodes.paragraph).next(e.children).closeNode().closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_cell",
    runner: (n, e) => {
      n.openNode("tableCell").next(e.content).closeNode();
    }
  }
}));
Ne(Kd.node, {
  displayName: "NodeSchema<tableCell>",
  group: "Table"
});
Ne(Kd.ctx, {
  displayName: "NodeSchemaCtx<tableCell>",
  group: "Table"
});
const rg = _t("table_header", () => ({
  ...Ud.table_header,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !!n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }), n.openNode(n.schema.nodes.paragraph), n.next(e.children), n.closeNode(), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header",
    runner: (n, e) => {
      n.openNode("tableCell"), n.next(e.content), n.closeNode();
    }
  }
}));
Ne(rg.node, {
  displayName: "NodeSchema<tableHeader>",
  group: "Table"
});
Ne(rg.ctx, {
  displayName: "NodeSchemaCtx<tableHeader>",
  group: "Table"
});
function Zb(n, e = 3, t = 3) {
  const r = Array(t).fill(0).map(() => Kd.type(n).createAndFill()), i = Array(t).fill(0).map(() => rg.type(n).createAndFill()), s = Array(e).fill(0).map(
    (o, l) => l === 0 ? ng.type(n).create(null, i) : Gd.type(n).create(null, r)
  );
  return Oa.type(n).create(null, s);
}
function TO(n) {
  return (e, t) => (r) => {
    t = t ?? r.selection.from;
    const i = r.doc.resolve(t), s = MM(
      (a) => a.type.name === "table"
    )(i), o = s ? {
      node: s.node,
      from: s.start
    } : void 0, l = n === "row";
    if (o) {
      const a = nt.get(o.node);
      if (e >= 0 && e < (l ? a.height : a.width)) {
        const c = a.positionAt(
          l ? e : a.height - 1,
          l ? a.width - 1 : e,
          o.node
        ), u = r.doc.resolve(o.from + c), h = l ? ft.rowSelection : ft.colSelection, f = a.positionAt(
          l ? e : 0,
          l ? 0 : e,
          o.node
        ), d = r.doc.resolve(o.from + f);
        return CM(
          r.setSelection(
            h(u, d)
          )
        );
      }
    }
    return r;
  };
}
const AX = TO("row"), OX = TO("col");
function AO(n, e, { map: t, tableStart: r, table: i }, s) {
  const o = Array(s).fill(0).reduce((a, c, u) => a + i.child(u).nodeSize, r), l = Array(t.width).fill(0).map((a, c) => {
    const u = i.nodeAt(t.map[c]);
    return Kd.type(n).createAndFill({ alignment: u == null ? void 0 : u.attrs.alignment });
  });
  return e.insert(o, Gd.type(n).create(null, l)), e;
}
function EX(n) {
  const e = wu(n.$from);
  if (!e) return;
  const t = nt.get(e.node);
  return t.cellsInRect({
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  }).map((i) => {
    const s = e.node.nodeAt(i), o = i + e.start;
    return { pos: o, start: o + 1, node: s };
  });
}
function IX(n) {
  const e = EX(n.selection);
  if (e && e[0]) {
    const t = n.doc.resolve(e[0].pos), r = e[e.length - 1];
    if (r) {
      const i = n.doc.resolve(r.pos);
      return CM(n.setSelection(new ft(i, t)));
    }
  }
  return n;
}
const Qb = De(
  "GoToPrevTableCell",
  () => () => cO(-1)
);
Ne(Qb, {
  displayName: "Command<goToPrevTableCellCommand>",
  group: "Table"
});
const e7 = De(
  "GoToNextTableCell",
  () => () => cO(1)
);
Ne(e7, {
  displayName: "Command<goToNextTableCellCommand>",
  group: "Table"
});
const t7 = De(
  "ExitTable",
  (n) => () => (e, t) => {
    if (!li(e)) return !1;
    const { $head: r } = e.selection, i = BH(r, Oa.type(n));
    if (!i) return !1;
    const { to: s } = i, o = e.tr.replaceWith(
      s,
      s,
      cs.type(n).createAndFill()
    );
    return o.setSelection(Pe.near(o.doc.resolve(s), 1)).scrollIntoView(), t == null || t(o), !0;
  }
);
Ne(t7, {
  displayName: "Command<breakTableCommand>",
  group: "Table"
});
const OO = De(
  "InsertTable",
  (n) => ({ row: e, col: t } = {}) => (r, i) => {
    const { selection: s, tr: o } = r, { from: l } = s, a = Zb(n, e, t), c = o.replaceSelectionWith(a), u = Pe.findFrom(c.doc.resolve(l), 1, !0);
    return u && c.setSelection(u), i == null || i(c), !0;
  }
);
Ne(OO, {
  displayName: "Command<insertTableCommand>",
  group: "Table"
});
const n7 = De(
  "MoveRow",
  () => ({ from: n, to: e, pos: t } = {}) => vY({
    from: n ?? 0,
    to: e ?? 0,
    pos: t
  })
);
Ne(n7, {
  displayName: "Command<moveRowCommand>",
  group: "Table"
});
const r7 = De(
  "MoveCol",
  () => ({ from: n, to: e, pos: t } = {}) => wY({
    from: n ?? 0,
    to: e ?? 0,
    pos: t
  })
);
Ne(r7, {
  displayName: "Command<moveColCommand>",
  group: "Table"
});
const Rl = De(
  "SelectRow",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!(t == null ? void 0 : t(AX(n.index, n.pos)(r)));
  }
);
Ne(Rl, {
  displayName: "Command<selectRowCommand>",
  group: "Table"
});
const Pl = De(
  "SelectCol",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!(t == null ? void 0 : t(OX(n.index, n.pos)(r)));
  }
);
Ne(Pl, {
  displayName: "Command<selectColCommand>",
  group: "Table"
});
const EO = De(
  "SelectTable",
  () => () => (n, e) => {
    const { tr: t } = n;
    return !!(e == null ? void 0 : e(IX(t)));
  }
);
Ne(EO, {
  displayName: "Command<selectTableCommand>",
  group: "Table"
});
const i7 = De(
  "DeleteSelectedCells",
  () => () => (n, e) => {
    const { selection: t } = n;
    if (!(t instanceof ft)) return !1;
    const r = t.isRowSelection(), i = t.isColSelection();
    return r && i ? bY(n, e) : i ? fY(n, e) : pY(n, e);
  }
);
Ne(i7, {
  displayName: "Command<deleteSelectedCellsCommand>",
  group: "Table"
});
const s7 = De(
  "AddColBefore",
  () => () => cY
);
Ne(s7, {
  displayName: "Command<addColBeforeCommand>",
  group: "Table"
});
const o7 = De(
  "AddColAfter",
  () => () => uY
);
Ne(o7, {
  displayName: "Command<addColAfterCommand>",
  group: "Table"
});
const l7 = De(
  "AddRowBefore",
  (n) => () => (e, t) => {
    if (!li(e)) return !1;
    if (t) {
      const r = ol(e);
      t(AO(n, e.tr, r, r.top));
    }
    return !0;
  }
);
Ne(l7, {
  displayName: "Command<addRowBeforeCommand>",
  group: "Table"
});
const a7 = De(
  "AddRowAfter",
  (n) => () => (e, t) => {
    if (!li(e)) return !1;
    if (t) {
      const r = ol(e);
      t(AO(n, e.tr, r, r.bottom));
    }
    return !0;
  }
);
Ne(a7, {
  displayName: "Command<addRowAfterCommand>",
  group: "Table"
});
const c7 = De(
  "SetAlign",
  () => (n = "left") => mY("alignment", n)
);
Ne(c7, {
  displayName: "Command<setAlignCommand>",
  group: "Table"
});
const IO = On(
  (n) => new ar(
    /^\|(?<col>\d+)[xX](?<row>\d+)\|\s$/,
    (e, t, r, i) => {
      var c, u;
      const s = e.doc.resolve(r);
      if (!s.node(-1).canReplaceWith(
        s.index(-1),
        s.indexAfter(-1),
        Oa.type(n)
      ))
        return null;
      const o = Math.max(Number(((c = t.groups) == null ? void 0 : c.row) ?? 0), 2), l = Zb(n, o, Number((u = t.groups) == null ? void 0 : u.col)), a = e.tr.replaceRangeWith(r, i, l);
      return a.setSelection(ge.create(a.doc, r + 3)).scrollIntoView();
    }
  )
);
Ne(IO, {
  displayName: "InputRule<insertTableInputRule>",
  group: "Table"
});
const u7 = hr("tableKeymap", {
  NextCell: {
    priority: 100,
    shortcuts: ["Mod-]", "Tab"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(e7.key);
    }
  },
  PrevCell: {
    shortcuts: ["Mod-[", "Shift-Tab"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(Qb.key);
    }
  },
  ExitTable: {
    shortcuts: ["Mod-Enter", "Enter"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(t7.key);
    }
  }
});
Ne(u7.ctx, {
  displayName: "KeymapCtx<table>",
  group: "Table"
});
Ne(u7.shortcuts, {
  displayName: "Keymap<table>",
  group: "Table"
});
const G2 = "footnote_definition", Tx = "footnoteDefinition", h7 = _t(
  "footnote_definition",
  () => ({
    group: "block",
    content: "block+",
    defining: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `dl[data-type="${G2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Ai(n);
          return {
            label: n.dataset.label
          };
        },
        contentElement: "dd"
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "dl",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": G2
        },
        ["dt", e],
        ["dd", 0]
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === Tx,
      runner: (n, e, t) => {
        n.openNode(t, {
          label: e.label
        }).next(e.children).closeNode();
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === G2,
      runner: (n, e) => {
        n.openNode(Tx, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        }).next(e.content).closeNode();
      }
    }
  })
);
Ne(h7.ctx, {
  displayName: "NodeSchemaCtx<footnodeDef>",
  group: "footnote"
});
Ne(h7.node, {
  displayName: "NodeSchema<footnodeDef>",
  group: "footnote"
});
const K2 = "footnote_reference", f7 = _t(
  "footnote_reference",
  () => ({
    group: "inline",
    inline: !0,
    atom: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `sup[data-type="${K2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Ai(n);
          return {
            label: n.dataset.label
          };
        }
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "sup",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": K2
        },
        e
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === "footnoteReference",
      runner: (n, e, t) => {
        n.addNode(t, {
          label: e.label
        });
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === K2,
      runner: (n, e) => {
        n.addNode("footnoteReference", void 0, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        });
      }
    }
  })
);
Ne(f7.ctx, {
  displayName: "NodeSchemaCtx<footnodeRef>",
  group: "footnote"
});
Ne(f7.node, {
  displayName: "NodeSchema<footnodeRef>",
  group: "footnote"
});
const d7 = Ei.extendSchema(
  (n) => (e) => {
    const t = n(e);
    return {
      ...t,
      attrs: {
        ...t.attrs,
        checked: {
          default: null,
          validate: "boolean|null"
        }
      },
      parseDOM: [
        {
          tag: 'li[data-item-type="task"]',
          getAttrs: (r) => {
            if (!(r instanceof HTMLElement)) throw Ai(r);
            return {
              label: r.dataset.label,
              listType: r.dataset.listType,
              spread: r.dataset.spread,
              checked: r.dataset.checked ? r.dataset.checked === "true" : null
            };
          }
        },
        ...(t == null ? void 0 : t.parseDOM) || []
      ],
      toDOM: (r) => t.toDOM && r.attrs.checked == null ? t.toDOM(r) : [
        "li",
        {
          "data-item-type": "task",
          "data-label": r.attrs.label,
          "data-list-type": r.attrs.listType,
          "data-spread": r.attrs.spread,
          "data-checked": r.attrs.checked
        },
        0
      ],
      parseMarkdown: {
        match: ({ type: r }) => r === "listItem",
        runner: (r, i, s) => {
          if (i.checked == null) {
            t.parseMarkdown.runner(r, i, s);
            return;
          }
          const o = i.label != null ? `${i.label}.` : "â€¢", l = i.checked != null ? !!i.checked : null, a = i.label != null ? "ordered" : "bullet", c = i.spread != null ? `${i.spread}` : "true";
          r.openNode(s, { label: o, listType: a, spread: c, checked: l }), r.next(i.children), r.closeNode();
        }
      },
      toMarkdown: {
        match: (r) => r.type.name === "list_item",
        runner: (r, i) => {
          if (i.attrs.checked == null) {
            t.toMarkdown.runner(r, i);
            return;
          }
          const s = i.attrs.label, o = i.attrs.listType, l = i.attrs.spread === "true", a = i.attrs.checked;
          r.openNode("listItem", void 0, {
            label: s,
            listType: o,
            spread: l,
            checked: a
          }), r.next(i.content), r.closeNode();
        }
      }
    };
  }
);
Ne(d7.node, {
  displayName: "NodeSchema<taskListItem>",
  group: "ListItem"
});
Ne(d7.ctx, {
  displayName: "NodeSchemaCtx<taskListItem>",
  group: "ListItem"
});
const DO = On(() => new ar(
  /^\[(?<checked>\s|x)\]\s$/,
  (n, e, t, r) => {
    var u;
    const i = n.doc.resolve(t);
    let s = 0, o = i.node(s);
    for (; o && o.type.name !== "list_item"; )
      s--, o = i.node(s);
    if (!o || o.attrs.checked != null) return null;
    const l = ((u = e.groups) == null ? void 0 : u.checked) === "x", a = i.before(s), c = n.tr;
    return c.deleteRange(t, r).setNodeMarkup(a, void 0, {
      ...o.attrs,
      checked: l
    }), c;
  }
));
Ne(DO, {
  displayName: "InputRule<wrapInTaskListInputRule>",
  group: "ListItem"
});
const DX = [
  Xb,
  u7
].flat(), NX = [
  IO,
  DO
], RX = [MO], NO = Ut(() => YY);
Ne(NO, {
  displayName: "Prose<autoInsertSpanPlugin>",
  group: "Prose"
});
const PX = Ut(() => IY({}));
Ne(PX, {
  displayName: "Prose<columnResizingPlugin>",
  group: "Prose"
});
const RO = Ut(
  () => HY({ allowTableNodeSelection: !0 })
);
Ne(RO, {
  displayName: "Prose<tableEditingPlugin>",
  group: "Prose"
});
const p7 = as("remarkGFM", () => TX);
Ne(p7.plugin, {
  displayName: "Remark<remarkGFMPlugin>",
  group: "Remark"
});
Ne(p7.options, {
  displayName: "RemarkConfig<remarkGFMPlugin>",
  group: "Remark"
});
const LX = new kt("MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN");
function BX(n, e) {
  let t = 0;
  return e.forEach((r, i, s) => {
    r === n && (t = s);
  }), t;
}
const PO = Ut(() => new xt({
  key: LX,
  appendTransaction: (n, e, t) => {
    let r;
    const i = (s, o) => {
      if (r || (r = t.tr), s.type.name !== "table_cell") return;
      const l = t.doc.resolve(o), a = l.node(l.depth), u = l.node(l.depth - 1).firstChild;
      if (!u) return;
      const h = BX(s, a), f = u.maybeChild(h);
      if (!f) return;
      const d = f.attrs.alignment, p = s.attrs.alignment;
      d !== p && r.setNodeMarkup(o, void 0, { ...s.attrs, alignment: d });
    };
    return e.doc !== t.doc && t.doc.descendants(i), r;
  }
}));
Ne(PO, {
  displayName: "Prose<keepTableAlignPlugin>",
  group: "Prose"
});
const zX = [
  PO,
  NO,
  p7,
  RO
].flat(), _X = [
  d7,
  Oa,
  ng,
  Gd,
  rg,
  Kd,
  h7,
  f7,
  Jb,
  xu
].flat(), FX = [
  e7,
  Qb,
  t7,
  OO,
  n7,
  r7,
  Rl,
  Pl,
  EO,
  i7,
  l7,
  a7,
  s7,
  o7,
  c7,
  tg
], HX = [
  _X,
  NX,
  RX,
  DX,
  FX,
  zX
].flat(), $X = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), r = g7(n.state, t.from);
  return r.line ? VX(n) : r.block ? WX(n) : !1;
};
function m7(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let i = n(e, t);
    return i ? (r(t.update(i)), !0) : !1;
  };
}
const VX = /* @__PURE__ */ m7(
  GX,
  0
  /* CommentOption.Toggle */
), qX = /* @__PURE__ */ m7(
  LO,
  0
  /* CommentOption.Toggle */
), WX = /* @__PURE__ */ m7(
  (n, e) => LO(n, e, UX(e)),
  0
  /* CommentOption.Toggle */
);
function g7(n, e) {
  let t = n.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const th = 50;
function jX(n, { open: e, close: t }, r, i) {
  let s = n.sliceDoc(r - th, r), o = n.sliceDoc(i, i + th), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, c = s.length - l;
  if (s.slice(c - e.length, c) == e && o.slice(a, a + t.length) == t)
    return {
      open: { pos: r - l, margin: l && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let u, h;
  i - r <= 2 * th ? u = h = n.sliceDoc(r, i) : (u = n.sliceDoc(r, r + th), h = n.sliceDoc(i - th, i));
  let f = /^\s*/.exec(u)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - t.length;
  return u.slice(f, f + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function UX(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from), i = t.to <= r.to ? r : n.doc.lineAt(t.to);
    i.from > r.from && i.from == t.to && (i = t.to == r.to + 1 ? r : n.doc.lineAt(t.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function LO(n, e, t = e.selection.ranges) {
  let r = t.map((s) => g7(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = t.map((s, o) => jX(e, r[o], s.from, s.to));
  if (n != 2 && !i.every((s) => s))
    return { changes: e.changes(t.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (n != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let a = r[o], { open: c, close: u } = l;
        s.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function GX(n, e, t = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of t) {
    let l = r.length, a = 1e9, c = g7(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < a && (a = f), r.push({ line: h, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        u = h.to + 1;
      }
      if (a < 1e9)
        for (let u = l; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (n != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: c, empty: u, single: h } of r)
      (h || !u) && s.push({ from: l.from + c, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of r)
      if (l >= 0) {
        let c = o.from + l, u = c + a.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const b5 = /* @__PURE__ */ to.define(), KX = /* @__PURE__ */ to.define(), YX = /* @__PURE__ */ he.define(), BO = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
    });
  }
}), zO = /* @__PURE__ */ sn.define({
  create() {
    return ff.empty;
  },
  update(n, e) {
    let t = e.state.facet(BO), r = e.annotation(b5);
    if (r) {
      let a = sr.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? n.undone : n.done;
      return a ? u = qm(u, u.length, t.minDepth, a) : u = HO(u, e.startState.selection), new ff(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let i = e.annotation(KX);
    if ((i == "full" || i == "before") && (n = n.isolate()), e.annotation(zn.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = sr.fromTransaction(e), o = e.annotation(zn.time), l = e.annotation(zn.userEvent);
    return s ? n = n.addChanges(s, o, l, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (i == "full" || i == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new ff(n.done.map(sr.fromJSON), n.undone.map(sr.fromJSON));
  }
});
function JX(n = {}) {
  return [
    zO,
    BO.of(n),
    de.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? _O : e.inputType == "historyRedo" ? v5 : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function ig(n, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(zO, !1);
    if (!i)
      return !1;
    let s = i.pop(n, t, e);
    return s ? (r(s), !0) : !1;
  };
}
const _O = /* @__PURE__ */ ig(0, !1), v5 = /* @__PURE__ */ ig(1, !1), XX = /* @__PURE__ */ ig(0, !0), ZX = /* @__PURE__ */ ig(1, !0);
class sr {
  constructor(e, t, r, i, s) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new sr(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new sr(e.changes && Yt.fromJSON(e.changes), [], e.mapped && Xi.fromJSON(e.mapped), e.startSelection && G.fromJSON(e.startSelection), e.selectionsAfter.map(G.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = Kr;
    for (let i of e.startState.facet(YX)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new sr(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, Kr);
  }
  static selection(e) {
    return new sr(void 0, Kr, void 0, void 0, e);
  }
}
function qm(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(i, e);
  return s.push(r), s;
}
function QX(n, e) {
  let t = [], r = !1;
  return n.iterChangedRanges((i, s) => t.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let a = 0; a < t.length; ) {
      let c = t[a++], u = t[a++];
      l >= c && o <= u && (r = !0);
    }
  }), r;
}
function eZ(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function FO(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const Kr = [], tZ = 200;
function HO(n, e) {
  if (n.length) {
    let t = n[n.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - tZ));
    return r.length && r[r.length - 1].eq(e) ? n : (r.push(e), qm(n, n.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [sr.selection([e])];
}
function nZ(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function Y2(n, e) {
  if (!n.length)
    return n;
  let t = n.length, r = Kr;
  for (; t; ) {
    let i = rZ(n[t - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = i, s;
    } else
      e = i.mapped, t--, r = i.selectionsAfter;
  }
  return r.length ? [sr.selection(r)] : Kr;
}
function rZ(n, e, t) {
  let r = FO(n.selectionsAfter.length ? n.selectionsAfter.map((l) => l.map(e)) : Kr, t);
  if (!n.changes)
    return sr.selection(r);
  let i = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new sr(i, ze.mapEffects(n.effects, e), o, n.startSelection.map(s), r);
}
const iZ = /^(input\.type|delete)($|\.)/;
let ff = class Ch {
  constructor(e, t, r = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Ch(this.done, this.undone) : this;
  }
  addChanges(e, t, r, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!r || iZ.test(r)) && (!l.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(s, QX(l.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = qm(o, o.length - 1, i.minDepth, new sr(e.changes.compose(l.changes), FO(ze.mapEffects(e.effects, l.changes), l.effects), l.mapped, l.startSelection, Kr)) : o = qm(o, o.length, i.minDepth, e), new Ch(o, Kr, t, r);
  }
  addSelection(e, t, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Kr;
    return s.length > 0 && t - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && eZ(s[s.length - 1], e) ? this : new Ch(HO(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new Ch(Y2(this.done, e), Y2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: b5.of({ side: e, rest: nZ(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? Kr : i.slice(0, i.length - 1);
      return s.mapped && (l = Y2(l, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: b5.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
};
ff.empty = /* @__PURE__ */ new ff(Kr, Kr);
const sZ = [
  { key: "Mod-z", run: _O, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: v5, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: v5, preventDefault: !0 },
  { key: "Mod-u", run: XX, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ZX, preventDefault: !0 }
];
function ku(n, e) {
  return G.create(n.ranges.map(e), n.mainIndex);
}
function Di(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Ni({ state: n, dispatch: e }, t) {
  let r = ku(n.selection, t);
  return r.eq(n.selection, !0) ? !1 : (e(Di(n, r)), !0);
}
function sg(n, e) {
  return G.cursor(e ? n.to : n.from);
}
function $O(n, e) {
  return Ni(n, (t) => t.empty ? n.moveByChar(t, e) : sg(t, e));
}
function En(n) {
  return n.textDirectionAt(n.state.selection.main.head) == wt.LTR;
}
const VO = (n) => $O(n, !En(n)), qO = (n) => $O(n, En(n));
function WO(n, e) {
  return Ni(n, (t) => t.empty ? n.moveByGroup(t, e) : sg(t, e));
}
const oZ = (n) => WO(n, !En(n)), lZ = (n) => WO(n, En(n));
function aZ(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function og(n, e, t) {
  let r = yn(n).resolveInner(e.head), i = t ? We.closedBy : We.openedBy;
  for (let a = e.head; ; ) {
    let c = t ? r.childAfter(a) : r.childBefore(a);
    if (!c)
      break;
    aZ(n, c, i) ? r = c : a = t ? c.to : c.from;
  }
  let s = r.type.prop(i), o, l;
  return s && (o = t ? Gi(n, r.from, 1) : Gi(n, r.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? r.to : r.from, G.cursor(l, t ? -1 : 1);
}
const cZ = (n) => Ni(n, (e) => og(n.state, e, !En(n))), uZ = (n) => Ni(n, (e) => og(n.state, e, En(n)));
function jO(n, e) {
  return Ni(n, (t) => {
    if (!t.empty)
      return sg(t, e);
    let r = n.moveVertically(t, e);
    return r.head != t.head ? r : n.moveToLineBoundary(t, e);
  });
}
const UO = (n) => jO(n, !1), GO = (n) => jO(n, !0);
function KO(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, r = 0, i;
  if (e) {
    for (let s of n.state.facet(de.scrollMargins)) {
      let o = s(n);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (r = Math.max(o == null ? void 0 : o.bottom, r));
    }
    i = n.scrollDOM.clientHeight - t - r;
  } else
    i = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  };
}
function YO(n, e) {
  let t = KO(n), { state: r } = n, i = ku(r.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : sg(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(r.selection.main.head), l = n.scrollDOM.getBoundingClientRect(), a = l.top + t.marginTop, c = l.bottom - t.marginBottom;
    o && o.top > a && o.bottom < c && (s = de.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - a }));
  }
  return n.dispatch(Di(r, i), { effects: s }), !0;
}
const Ax = (n) => YO(n, !1), w5 = (n) => YO(n, !0);
function ll(n, e, t) {
  let r = n.lineBlockAt(e.head), i = n.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? r.to : r.from) && (i = n.moveToLineBoundary(e, t, !1)), !t && i.head == r.from && r.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = G.cursor(r.from + s));
  }
  return i;
}
const hZ = (n) => Ni(n, (e) => ll(n, e, !0)), fZ = (n) => Ni(n, (e) => ll(n, e, !1)), dZ = (n) => Ni(n, (e) => ll(n, e, !En(n))), pZ = (n) => Ni(n, (e) => ll(n, e, En(n))), mZ = (n) => Ni(n, (e) => G.cursor(n.lineBlockAt(e.head).from, 1)), gZ = (n) => Ni(n, (e) => G.cursor(n.lineBlockAt(e.head).to, -1));
function yZ(n, e, t) {
  let r = !1, i = ku(n.selection, (s) => {
    let o = Gi(n, s.head, -1) || Gi(n, s.head, 1) || s.head > 0 && Gi(n, s.head - 1, 1) || s.head < n.doc.length && Gi(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return G.cursor(l);
  });
  return r ? (e(Di(n, i)), !0) : !1;
}
const bZ = ({ state: n, dispatch: e }) => yZ(n, e);
function ai(n, e) {
  let t = ku(n.state.selection, (r) => {
    let i = e(r);
    return G.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Di(n.state, t)), !0);
}
function JO(n, e) {
  return ai(n, (t) => n.moveByChar(t, e));
}
const XO = (n) => JO(n, !En(n)), ZO = (n) => JO(n, En(n));
function QO(n, e) {
  return ai(n, (t) => n.moveByGroup(t, e));
}
const vZ = (n) => QO(n, !En(n)), wZ = (n) => QO(n, En(n)), xZ = (n) => ai(n, (e) => og(n.state, e, !En(n))), kZ = (n) => ai(n, (e) => og(n.state, e, En(n)));
function eE(n, e) {
  return ai(n, (t) => n.moveVertically(t, e));
}
const tE = (n) => eE(n, !1), nE = (n) => eE(n, !0);
function rE(n, e) {
  return ai(n, (t) => n.moveVertically(t, e, KO(n).height));
}
const Ox = (n) => rE(n, !1), Ex = (n) => rE(n, !0), SZ = (n) => ai(n, (e) => ll(n, e, !0)), CZ = (n) => ai(n, (e) => ll(n, e, !1)), MZ = (n) => ai(n, (e) => ll(n, e, !En(n))), TZ = (n) => ai(n, (e) => ll(n, e, En(n))), AZ = (n) => ai(n, (e) => G.cursor(n.lineBlockAt(e.head).from)), OZ = (n) => ai(n, (e) => G.cursor(n.lineBlockAt(e.head).to)), Ix = ({ state: n, dispatch: e }) => (e(Di(n, { anchor: 0 })), !0), Dx = ({ state: n, dispatch: e }) => (e(Di(n, { anchor: n.doc.length })), !0), Nx = ({ state: n, dispatch: e }) => (e(Di(n, { anchor: n.selection.main.anchor, head: 0 })), !0), Rx = ({ state: n, dispatch: e }) => (e(Di(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), EZ = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), IZ = ({ state: n, dispatch: e }) => {
  let t = lg(n).map(({ from: r, to: i }) => G.range(r, Math.min(i + 1, n.doc.length)));
  return e(n.update({ selection: G.create(t), userEvent: "select" })), !0;
}, DZ = ({ state: n, dispatch: e }) => {
  let t = ku(n.selection, (r) => {
    let i = yn(n), s = i.resolveStack(r.from, 1);
    if (r.empty) {
      let o = i.resolveStack(r.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < r.from && l.to >= r.to || l.to > r.to && l.from <= r.from) && o.next)
        return G.range(l.to, l.from);
    }
    return r;
  });
  return t.eq(n.selection) ? !1 : (e(Di(n, t)), !0);
};
function iE(n, e) {
  let { state: t } = n, r = t.selection, i = t.selection.ranges.slice();
  for (let s of t.selection.ranges) {
    let o = t.doc.lineAt(s.head);
    if (e ? o.to < n.state.doc.length : o.from > 0)
      for (let l = s; ; ) {
        let a = n.moveVertically(l, e);
        if (a.head < o.from || a.head > o.to) {
          i.some((c) => c.head == a.head) || i.push(a);
          break;
        } else {
          if (a.head == l.head)
            break;
          l = a;
        }
      }
  }
  return i.length == r.ranges.length ? !1 : (n.dispatch(Di(t, G.create(i, i.length - 1))), !0);
}
const NZ = (n) => iE(n, !1), RZ = (n) => iE(n, !0), PZ = ({ state: n, dispatch: e }) => {
  let t = n.selection, r = null;
  return t.ranges.length > 1 ? r = G.create([t.main]) : t.main.empty || (r = G.create([G.cursor(t.main.head)])), r ? (e(Di(n, r)), !0) : !1;
};
function Yd(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = n, i = r.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (t = "delete.backward", a = V0(n, a, !1)) : a > o && (t = "delete.forward", a = V0(n, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = V0(n, o, !1), l = V0(n, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: G.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (n.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? de.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function V0(n, e, t) {
  if (n instanceof de)
    for (let r of n.state.facet(de.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = t ? s : i);
      });
  return e;
}
const sE = (n, e, t) => Yd(n, (r) => {
  let i = r.from, { state: s } = n, o = s.doc.lineAt(i), l, a;
  if (t && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(l = o.text.slice(0, i - o.from))) {
    if (l[l.length - 1] == "	")
      return i - 1;
    let c = fu(l, s.tabSize), u = c % ha(s) || ha(s);
    for (let h = 0; h < u && l[l.length - 1 - h] == " "; h++)
      i--;
    a = i;
  } else
    a = gn(o.text, i - o.from, e, e) + o.from, a == i && o.number != (e ? s.doc.lines : 1) ? a += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(a - o.from, i - o.from)) && (a = gn(o.text, a - o.from, !1, !1) + o.from);
  return a;
}), x5 = (n) => sE(n, !1, !0), oE = (n) => sE(n, !0, !1), lE = (n, e) => Yd(n, (t) => {
  let r = t.head, { state: i } = n, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let l = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == t.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let a = gn(s.text, r - s.from, e) + s.from, c = s.text.slice(Math.min(r, a) - s.from, Math.max(r, a) - s.from), u = o(c);
    if (l != null && u != l)
      break;
    (c != " " || r != t.head) && (l = u), r = a;
  }
  return r;
}), aE = (n) => lE(n, !1), LZ = (n) => lE(n, !0), BZ = (n) => Yd(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), zZ = (n) => Yd(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), _Z = (n) => Yd(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), FZ = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: Xe.of(["", ""]) },
    range: G.cursor(r.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, HZ = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == n.doc.length)
      return { range: r };
    let i = r.from, s = n.doc.lineAt(i), o = i == s.from ? i - 1 : gn(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : gn(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: n.doc.slice(i, l).append(n.doc.slice(o, i)) },
      range: G.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function lg(n) {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from), s = n.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = n.doc.lineAt(r.to - 1)), t >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    t = s.number + 1;
  }
  return e;
}
function cE(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of lg(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (t) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let a of s.ranges)
        i.push(G.range(Math.min(n.doc.length, a.anchor + l), Math.min(n.doc.length, a.head + l)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let a of s.ranges)
        i.push(G.range(a.anchor - l, a.head - l));
    }
  }
  return r.length ? (e(n.update({
    changes: r,
    scrollIntoView: !0,
    selection: G.create(i, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const $Z = ({ state: n, dispatch: e }) => cE(n, e, !1), VZ = ({ state: n, dispatch: e }) => cE(n, e, !0);
function uE(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [];
  for (let i of lg(n))
    t ? r.push({ from: i.from, insert: n.doc.slice(i.from, i.to) + n.lineBreak }) : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) });
  return e(n.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const qZ = ({ state: n, dispatch: e }) => uE(n, e, !1), WZ = ({ state: n, dispatch: e }) => uE(n, e, !0), jZ = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(lg(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = ku(e.selection, (i) => {
    let s;
    if (n.lineWrapping) {
      let o = n.lineBlockAt(i.head), l = n.coordsAtPos(i.head, i.assoc || 1);
      l && (s = o.bottom + n.documentTop - l.bottom + n.defaultLineHeight / 2);
    }
    return n.moveVertically(i, !0, s);
  }).map(t);
  return n.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function UZ(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = yn(n).resolveInner(e), r = t.childBefore(e), i = t.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(We.closedBy)) && s.indexOf(i.name) > -1 && n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from && !/\S/.test(n.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const Px = /* @__PURE__ */ hE(!1), GZ = /* @__PURE__ */ hE(!0);
function hE(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), a = !n && s == o && UZ(e, s);
      n && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let c = new b1(e, { simulateBreak: s, simulateDoubleBreak: !!a }), u = m3(c, s);
      for (u == null && (u = fu(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let h = ["", Ef(e, u)];
      return a && h.push(Ef(e, c.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: Xe.of(h) },
        range: G.cursor(s + 1 + h[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function y7(n, e) {
  let t = -1;
  return n.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let l = n.doc.lineAt(o);
      l.number > t && (r.empty || r.to > l.from) && (e(l, i, r), t = l.number), o = l.to + 1;
    }
    let s = n.changes(i);
    return {
      changes: i,
      range: G.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const KZ = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new b1(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), i = y7(n, (s, o, l) => {
    let a = m3(r, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let c = /^\s*/.exec(s.text)[0], u = Ef(n, a);
    (c != u || l.from < s.from + c.length) && (t[s.from] = a, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return i.changes.empty || e(n.update(i, { userEvent: "indent" })), !0;
}, fE = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(y7(n, (t, r) => {
  r.push({ from: t.from, insert: n.facet(y1) });
}), { userEvent: "input.indent" })), !0), dE = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(y7(n, (t, r) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let s = fu(i, n.tabSize), o = 0, l = Ef(n, Math.max(0, s - ha(n)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), YZ = (n) => (n.setTabFocusMode(), !0), JZ = [
  { key: "Ctrl-b", run: VO, shift: XO, preventDefault: !0 },
  { key: "Ctrl-f", run: qO, shift: ZO },
  { key: "Ctrl-p", run: UO, shift: tE },
  { key: "Ctrl-n", run: GO, shift: nE },
  { key: "Ctrl-a", run: mZ, shift: AZ },
  { key: "Ctrl-e", run: gZ, shift: OZ },
  { key: "Ctrl-d", run: oE },
  { key: "Ctrl-h", run: x5 },
  { key: "Ctrl-k", run: BZ },
  { key: "Ctrl-Alt-h", run: aE },
  { key: "Ctrl-o", run: FZ },
  { key: "Ctrl-t", run: HZ },
  { key: "Ctrl-v", run: w5 }
], XZ = /* @__PURE__ */ [
  { key: "ArrowLeft", run: VO, shift: XO, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: oZ, shift: vZ, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: dZ, shift: MZ, preventDefault: !0 },
  { key: "ArrowRight", run: qO, shift: ZO, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: lZ, shift: wZ, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: pZ, shift: TZ, preventDefault: !0 },
  { key: "ArrowUp", run: UO, shift: tE, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Ix, shift: Nx },
  { mac: "Ctrl-ArrowUp", run: Ax, shift: Ox },
  { key: "ArrowDown", run: GO, shift: nE, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Dx, shift: Rx },
  { mac: "Ctrl-ArrowDown", run: w5, shift: Ex },
  { key: "PageUp", run: Ax, shift: Ox },
  { key: "PageDown", run: w5, shift: Ex },
  { key: "Home", run: fZ, shift: CZ, preventDefault: !0 },
  { key: "Mod-Home", run: Ix, shift: Nx },
  { key: "End", run: hZ, shift: SZ, preventDefault: !0 },
  { key: "Mod-End", run: Dx, shift: Rx },
  { key: "Enter", run: Px, shift: Px },
  { key: "Mod-a", run: EZ },
  { key: "Backspace", run: x5, shift: x5, preventDefault: !0 },
  { key: "Delete", run: oE, preventDefault: !0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: aE, preventDefault: !0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: LZ, preventDefault: !0 },
  { mac: "Mod-Backspace", run: zZ, preventDefault: !0 },
  { mac: "Mod-Delete", run: _Z, preventDefault: !0 }
].concat(/* @__PURE__ */ JZ.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), pE = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cZ, shift: xZ },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: uZ, shift: kZ },
  { key: "Alt-ArrowUp", run: $Z },
  { key: "Shift-Alt-ArrowUp", run: qZ },
  { key: "Alt-ArrowDown", run: VZ },
  { key: "Shift-Alt-ArrowDown", run: WZ },
  { key: "Mod-Alt-ArrowUp", run: NZ },
  { key: "Mod-Alt-ArrowDown", run: RZ },
  { key: "Escape", run: PZ },
  { key: "Mod-Enter", run: GZ },
  { key: "Alt-l", mac: "Ctrl-l", run: IZ },
  { key: "Mod-i", run: DZ, preventDefault: !0 },
  { key: "Mod-[", run: dE },
  { key: "Mod-]", run: fE },
  { key: "Mod-Alt-\\", run: KZ },
  { key: "Shift-Mod-k", run: jZ },
  { key: "Shift-Mod-\\", run: bZ },
  { key: "Mod-/", run: $X },
  { key: "Alt-A", run: qX },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: YZ }
].concat(XZ), ZZ = { key: "Tab", run: fE, shift: dE };
var Wm = 200, rn = function() {
};
rn.prototype.append = function(e) {
  return e.length ? (e = rn.from(e), !this.length && e || e.length < Wm && this.leafAppend(e) || this.length < Wm && e.leafPrepend(this) || this.appendInner(e)) : this;
};
rn.prototype.prepend = function(e) {
  return e.length ? rn.from(e).append(this) : this;
};
rn.prototype.appendInner = function(e) {
  return new QZ(this, e);
};
rn.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? rn.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
rn.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
rn.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
rn.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, t, r), i;
};
rn.from = function(e) {
  return e instanceof rn ? e : e && e.length ? new mE(e) : rn.empty;
};
var mE = /* @__PURE__ */ function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, l) {
    for (var a = s; a < o; a++)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, l) {
    for (var a = s - 1; a >= o; a--)
      if (i(this.values[a], l + a) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= Wm)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= Wm)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(rn);
rn.empty = new mE([]);
var QZ = /* @__PURE__ */ function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i < l && this.left.forEachInner(r, i, Math.min(s, l), o) === !1 || s > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, s) - l, o + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var l = this.left.length;
    if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(s, l) - l, o + l) === !1 || s < l && this.left.forEachInvertedInner(r, Math.min(i, l), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(rn);
const eQ = 500;
class vi {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    t && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, l, a, c = [], u = [];
    return this.items.forEach((h, f) => {
      if (!h.step) {
        i || (i = this.remapping(r, f + 1), s = i.maps.length), s--, u.push(h);
        return;
      }
      if (i) {
        u.push(new Vi(h.map));
        let d = h.step.map(i.slice(s)), p;
        d && o.maybeStep(d).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new Vi(p, void 0, void 0, c.length + u.length))), s--, p && i.appendMap(p, s);
      } else
        o.maybeStep(h.step);
      if (h.selection)
        return l = i ? h.selection.map(i.slice(s)) : h.selection, a = new vi(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: a, transform: o, selection: l };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let s = [], o = this.eventCount, l = this.items, a = !i && l.length ? l.get(l.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let h = e.steps[u].invert(e.docs[u]), f = new Vi(e.mapping.maps[u], h, t), d;
      (d = a && a.merge(f)) && (f = d, u ? s.pop() : l = l.slice(0, l.length - 1)), s.push(f), t && (o++, t = void 0), i || (a = f);
    }
    let c = o - r.depth;
    return c > nQ && (l = tQ(l, c), o -= c), new vi(l.append(s), o);
  }
  remapping(e, t) {
    let r = new Rf();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new vi(this.items.append(e.map((t) => new Vi(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, l = this.eventCount;
    this.items.forEach((f) => {
      f.selection && l--;
    }, i);
    let a = t;
    this.items.forEach((f) => {
      let d = s.getMirror(--a);
      if (d == null)
        return;
      o = Math.min(o, d);
      let p = s.maps[d];
      if (f.step) {
        let m = e.steps[d].invert(e.docs[d]), g = f.selection && f.selection.map(s.slice(a + 1, d));
        g && l++, r.push(new Vi(p, m, g));
      } else
        r.push(new Vi(p));
    }, i);
    let c = [];
    for (let f = t; f < o; f++)
      c.push(new Vi(s.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), h = new vi(u, l);
    return h.emptyItemCount() > eQ && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
    return this.items.forEach((o, l) => {
      if (l >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let a = o.step.map(t.slice(r)), c = a && a.getMap();
        if (r--, c && t.appendMap(c, r), a) {
          let u = o.selection && o.selection.map(t.slice(r));
          u && s++;
          let h = new Vi(c.invert(), a, u), f, d = i.length - 1;
          (f = i.length && i[d].merge(h)) ? i[d] = f : i.push(h);
        }
      } else o.map && r--;
    }, this.items.length, 0), new vi(rn.from(i.reverse()), s);
  }
}
vi.empty = new vi(rn.empty, 0);
function tQ(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class Vi {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new Vi(t.getMap().invert(), t, this.selection);
    }
  }
}
class Co {
  constructor(e, t, r, i, s) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
  }
}
const nQ = 20;
function rQ(n, e, t, r) {
  let i = t.getMeta(ra), s;
  if (i)
    return i.historyState;
  t.getMeta(oQ) && (n = new Co(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(ra))
    return o.getMeta(ra).redo ? new Co(n.done.addTransform(t, void 0, r, $p(e)), n.undone, Lx(t.mapping.maps), n.prevTime, n.prevComposition) : new Co(n.done, n.undone.addTransform(t, void 0, r, $p(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let l = t.getMeta("composition"), a = n.prevTime == 0 || !o && n.prevComposition != l && (n.prevTime < (t.time || 0) - r.newGroupDelay || !iQ(t, n.prevRanges)), c = o ? J2(n.prevRanges, t.mapping) : Lx(t.mapping.maps);
    return new Co(n.done.addTransform(t, a ? e.selection.getBookmark() : void 0, r, $p(e)), vi.empty, c, t.time, l ?? n.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new Co(n.done.rebased(t, s), n.undone.rebased(t, s), J2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new Co(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), J2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function iQ(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function Lx(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, i, s, o) => e.push(s, o));
  return e;
}
function J2(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function sQ(n, e, t) {
  let r = $p(e), i = ra.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), l = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), a = new Co(t ? l : s.remaining, t ? s.remaining : l, null, 0, -1);
  return s.transform.setSelection(o).setMeta(ra, { redo: t, historyState: a });
}
let X2 = !1, Bx = null;
function $p(n) {
  let e = n.plugins;
  if (Bx != e) {
    X2 = !1, Bx = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        X2 = !0;
        break;
      }
  }
  return X2;
}
const ra = new kt("history"), oQ = new kt("closeHistory");
function lQ(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new xt({
    key: ra,
    state: {
      init() {
        return new Co(vi.empty, vi.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return rQ(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? ag : r == "historyRedo" ? nu : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function gE(n, e) {
  return (t, r) => {
    let i = ra.getState(t);
    if (!i || (n ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let s = sQ(i, t, n);
      s && r(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const ag = gE(!1, !0), nu = gE(!0, !0);
var aQ = Object.defineProperty, zx = Object.getOwnPropertySymbols, cQ = Object.prototype.hasOwnProperty, uQ = Object.prototype.propertyIsEnumerable, _x = (n, e, t) => e in n ? aQ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, hQ = (n, e) => {
  for (var t in e || (e = {}))
    cQ.call(e, t) && _x(n, t, e[t]);
  if (zx)
    for (var t of zx(e))
      uQ.call(e, t) && _x(n, t, e[t]);
  return n;
};
function yE(n, e) {
  return Object.assign(n, {
    meta: hQ({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const fQ = {
  extensions: [],
  languages: [],
  expandIcon: "â¬‡",
  searchIcon: "ðŸ”",
  clearSearchIcon: "âŒ«",
  searchPlaceholder: "Search language",
  noResultText: "No result",
  copyText: "Copy",
  copyIcon: "ðŸ“‹",
  onCopy: () => {
  },
  renderLanguage: (n) => n,
  renderPreview: () => null,
  previewToggleButton: (n) => n ? "Edit" : "Hide",
  previewLabel: "Preview"
}, Jd = it(fQ, "codeBlockConfigCtx");
yE(Jd, {
  displayName: "Config<code-block>",
  group: "CodeBlock"
});
class dQ {
  constructor(e) {
    this.languages = e, this.map = {}, e.forEach((t) => {
      t.alias.forEach((r) => {
        this.map[r] = t;
      });
    });
  }
  getAll() {
    return this.languages.map((e) => ({
      name: e.name,
      alias: e.alias
    }));
  }
  load(e) {
    const r = this.map[e.toLowerCase()];
    return r ? r.support ? Promise.resolve(r.support) : r.load() : Promise.resolve(void 0);
  }
}
function hc({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
hc.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var pQ = (n, e, t) => new Promise((r, i) => {
  var s = (a) => {
    try {
      l(t.next(a));
    } catch (c) {
      i(c);
    }
  }, o = (a) => {
    try {
      l(t.throw(a));
    } catch (c) {
      i(c);
    }
  }, l = (a) => a.done ? r(a.value) : Promise.resolve(a.value).then(s, o);
  l((t = t.apply(n, e)).next());
});
function mQ(n) {
  return pQ(this, null, function* () {
    try {
      return navigator.clipboard.writeText(n);
    } catch {
      const t = document.createElement("textarea"), r = document.activeElement;
      t.value = n, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
      const i = document.getSelection(), s = i ? i.rangeCount > 0 && i.getRangeAt(0) : null;
      document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = n.length, document.execCommand("copy"), document.body.removeChild(t), s && (i.removeAllRanges(), i.addRange(s)), r && r.focus();
    }
  });
}
const gQ = Xt({
  props: {
    copyText: {
      type: String,
      required: !0
    },
    copyIcon: {
      type: String,
      required: !0
    },
    onCopy: {
      type: Function,
      required: !0
    },
    text: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = () => {
      mQ(n.text).then(() => n.onCopy(n.text)).catch(console.error);
    };
    return () => /* @__PURE__ */ V(xa, null, /* @__PURE__ */ V("button", { type: "button", class: "copy-button", onClick: e }, /* @__PURE__ */ V(hc, { icon: n.copyIcon }), n.copyText));
  }
}), yQ = Xt({
  props: {
    language: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    }
  },
  setup({ language: n, config: e, setLanguage: t, getAllLanguages: r, getReadOnly: i }) {
    const s = ce(), o = ce(!1), l = ce(), a = ce(), c = ce("");
    W5([o, s, a], () => {
      c.value = "";
      const m = s.value, g = a.value;
      !m || !g || Ti(m, g, {
        placement: "bottom-start"
      }).then(({ x: b, y: w }) => {
        Object.assign(g.style, {
          left: `${b}px`,
          top: `${w}px`
        });
      }).catch(console.error);
    });
    const u = (m) => {
      if (m.preventDefault(), m.stopPropagation(), i()) return;
      const g = !o.value;
      o.value = g, g && setTimeout(() => {
        var b;
        return (b = l.value) == null ? void 0 : b.focus();
      }, 0);
    }, h = (m) => {
      const g = m.target;
      c.value = g.value;
    }, f = (m) => {
      m.key === "Escape" && (c.value = "");
    }, d = sa(() => {
      var m;
      if (!o.value) return [];
      const g = (m = r()) != null ? m : [], b = g.find(
        (k) => k.name.toLowerCase() === n.value.toLowerCase()
      ), w = g.filter((k) => {
        const T = c.value.toLowerCase();
        return (k.name.toLowerCase().includes(T) || k.alias.some(
          (M) => M.toLowerCase().includes(T)
        )) && k !== b;
      });
      return w.length === 0 ? [] : b ? [b, ...w] : w;
    }), p = (m) => {
      const g = m.target;
      if (s.value && s.value.contains(g)) return;
      const b = a.value, w = s.value;
      !w || !b || w.dataset.expanded === "true" && (b.contains(g) || (o.value = !1));
    };
    return Td(() => {
      window.addEventListener("click", p);
    }), l1(() => {
      window.removeEventListener("click", p);
    }), () => /* @__PURE__ */ V(xa, null, /* @__PURE__ */ V(
      "button",
      {
        type: "button",
        ref: s,
        class: "language-button",
        onClick: u,
        "data-expanded": String(o.value)
      },
      n.value || "Text",
      /* @__PURE__ */ V("div", { class: "expand-icon" }, /* @__PURE__ */ V(hc, { icon: e.expandIcon }))
    ), /* @__PURE__ */ V("div", { ref: a, class: "language-picker" }, o.value ? /* @__PURE__ */ V("div", { class: "list-wrapper" }, /* @__PURE__ */ V("div", { class: "search-box" }, /* @__PURE__ */ V("div", { class: "search-icon" }, /* @__PURE__ */ V(hc, { icon: e.searchIcon })), /* @__PURE__ */ V(
      "input",
      {
        ref: l,
        class: "search-input",
        placeholder: e.searchPlaceholder,
        value: c.value,
        onInput: h,
        onKeydown: f
      }
    ), /* @__PURE__ */ V(
      "div",
      {
        class: bn(
          "clear-icon",
          c.value.length === 0 && "hidden"
        ),
        onMousedown: (m) => {
          m.preventDefault(), c.value = "";
        }
      },
      /* @__PURE__ */ V(hc, { icon: e.clearSearchIcon })
    )), /* @__PURE__ */ V(
      "ul",
      {
        class: "language-list",
        role: "listbox",
        onKeydown: (m) => {
          if (m.key === "Enter") {
            const g = document.activeElement;
            g instanceof HTMLElement && g.dataset.language && t(g.dataset.language);
          }
        }
      },
      d.value.length ? d.value.map((m) => /* @__PURE__ */ V(
        "li",
        {
          role: "listitem",
          tabindex: "0",
          class: "language-list-item",
          "aria-selected": m.name.toLowerCase() === n.value.toLowerCase(),
          "data-language": m.name,
          onClick: () => {
            t(m.name), o.value = !1;
          }
        },
        e.renderLanguage(
          m.name,
          m.name.toLowerCase() === n.value.toLowerCase()
        )
      )) : /* @__PURE__ */ V("li", { class: "language-list-item no-result" }, e.noResultText)
    )) : null));
  }
}), bQ = Xt({
  props: {
    text: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    previewOnlyMode: {
      type: Object,
      required: !0
    },
    preview: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { previewOnlyMode: e, config: t, preview: r } = n, i = ce();
    return au(() => {
      const s = i.value;
      if (!s) return;
      for (; s.firstChild; )
        s.removeChild(s.firstChild);
      const o = r.value;
      (typeof o == "string" || o instanceof Element) && (s.innerHTML = Ii.sanitize(o));
    }), () => r.value ? /* @__PURE__ */ V("div", { class: "preview-panel" }, !e.value && /* @__PURE__ */ V(xa, null, /* @__PURE__ */ V("div", { class: "preview-divider" }), /* @__PURE__ */ V("div", { class: bn("preview-label", e && "hidden") }, t.previewLabel)), /* @__PURE__ */ V("div", { ref: i, class: "preview" })) : null;
  }
}), vQ = Xt({
  props: {
    text: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    codemirror: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = ce(!1), t = ce();
    Td(() => {
      for (var s; (s = t.value) != null && s.firstChild; )
        t.value.removeChild(t.value.firstChild);
      t.value && t.value.appendChild(n.codemirror.dom);
    });
    const r = sa(() => {
      const s = n.text.value, o = n.language.value;
      return n.config.renderPreview(o, s);
    }), i = () => {
    };
    return () => {
      var s;
      return /* @__PURE__ */ V(xa, null, /* @__PURE__ */ V("div", { class: "tools" }, /* @__PURE__ */ V(
        yQ,
        {
          language: n.language,
          config: n.config,
          setLanguage: n.setLanguage,
          getAllLanguages: n.getAllLanguages,
          getReadOnly: n.getReadOnly
        }
      ), /* @__PURE__ */ V("div", { class: "tools-button-group" }, /* @__PURE__ */ V(
        gQ,
        {
          copyIcon: n.config.copyIcon,
          copyText: n.config.copyText,
          onCopy: (s = n.config.onCopy) != null ? s : i,
          text: n.text.value
        }
      ), r.value ? /* @__PURE__ */ V(
        "button",
        {
          class: "preview-toggle-button",
          onClick: () => e.value = !e.value
        },
        /* @__PURE__ */ V(
          hc,
          {
            icon: n.config.previewToggleButton(
              e.value
            )
          }
        )
      ) : null)), /* @__PURE__ */ V(
        "div",
        {
          ref: t,
          class: bn(
            "codemirror-host",
            r.value && e.value && "hidden"
          )
        }
      ), /* @__PURE__ */ V(
        bQ,
        {
          text: n.text,
          language: n.language,
          config: n.config,
          previewOnlyMode: e,
          preview: r
        }
      ));
    };
  }
});
class wQ {
  constructor(e, t, r, i, s) {
    this.node = e, this.view = t, this.getPos = r, this.loader = i, this.config = s, this.selected = ce(!1), this.language = ce(""), this.text = ce(""), this.updating = !1, this.languageName = "", this.forwardUpdate = (o) => {
      var l;
      if (this.updating || !this.cm.hasFocus) return;
      let a = ((l = this.getPos()) != null ? l : 0) + 1;
      const { main: c } = o.state.selection, u = a + c.from, h = a + c.to, f = this.view.state.selection;
      if (o.docChanged || f.from !== u || f.to !== h) {
        const d = this.view.state.tr;
        o.changes.iterChanges((p, m, g, b, w) => {
          w.length ? d.replaceWith(
            a + p,
            a + m,
            this.view.state.schema.text(w.toString())
          ) : d.delete(a + p, a + m), a += b - g - (m - p);
        }), d.setSelection(ge.create(d.doc, u, h)), this.view.dispatch(d);
      }
    }, this.createApp = () => oi(vQ, {
      text: this.text,
      selected: this.selected,
      codemirror: this.cm,
      language: this.language,
      getAllLanguages: this.getAllLanguages,
      getReadOnly: () => !this.view.editable,
      setLanguage: this.setLanguage,
      config: this.config
    }), this.codeMirrorKeymap = () => {
      const o = this.view;
      return [
        { key: "ArrowUp", run: () => this.maybeEscape("line", -1) },
        { key: "ArrowLeft", run: () => this.maybeEscape("char", -1) },
        { key: "ArrowDown", run: () => this.maybeEscape("line", 1) },
        { key: "ArrowRight", run: () => this.maybeEscape("char", 1) },
        {
          key: "Mod-Enter",
          run: () => fT(o.state, o.dispatch) ? (o.focus(), !0) : !1
        },
        { key: "Mod-z", run: () => ag(o.state, o.dispatch) },
        { key: "Shift-Mod-z", run: () => nu(o.state, o.dispatch) },
        { key: "Mod-y", run: () => nu(o.state, o.dispatch) },
        {
          key: "Backspace",
          run: () => {
            var l;
            const a = this.cm.state.selection.ranges;
            if (a.length > 1) return !1;
            const c = a[0];
            if (c && (!c.empty || c.anchor > 0) || this.cm.state.doc.lines >= 2) return !1;
            const u = this.view.state, h = (l = this.getPos()) != null ? l : 0, f = u.tr.replaceWith(
              h,
              h + this.node.nodeSize,
              u.schema.nodes.paragraph.createChecked({}, this.node.content)
            );
            return f.setSelection(ge.near(f.doc.resolve(h))), this.view.dispatch(f), this.view.focus(), !0;
          }
        }
      ];
    }, this.maybeEscape = (o, l) => {
      var a;
      const { state: c } = this.cm;
      let u = c.selection.main;
      if (!u.empty || (o === "line" && (u = c.doc.lineAt(u.head)), l < 0 ? u.from > 0 : u.to < c.doc.length)) return !1;
      const h = ((a = this.getPos()) != null ? a : 0) + (l < 0 ? 0 : this.node.nodeSize), f = ge.near(
        this.view.state.doc.resolve(h),
        l
      ), d = this.view.state.tr.setSelection(f).scrollIntoView();
      return this.view.dispatch(d), this.view.focus(), !0;
    }, this.setLanguage = (o) => {
      var l;
      this.view.dispatch(
        this.view.state.tr.setNodeAttribute(
          (l = this.getPos()) != null ? l : 0,
          "language",
          o
        )
      );
    }, this.getAllLanguages = () => this.loader.getAll(), this.languageConf = new Wc(), this.readOnlyConf = new Wc(), this.cm = new de({
      doc: this.node.textContent,
      root: this.view.root,
      extensions: [
        this.readOnlyConf.of(Ct.readOnly.of(!this.view.editable)),
        sC(),
        du.of(this.codeMirrorKeymap()),
        this.languageConf.of([]),
        Ct.changeFilter.of(() => this.view.editable),
        ...s.extensions,
        de.updateListener.of(this.forwardUpdate)
      ]
    }), this.app = this.createApp(), this.dom = this.createDom(this.app), this.disposeSelectedWatcher = au(() => {
      this.selected.value ? this.dom.classList.add("selected") : this.dom.classList.remove("selected");
    }), this.updateLanguage();
  }
  createDom(e) {
    const t = document.createElement("div");
    return t.className = "milkdown-code-block", this.text.value = this.node.textContent, e.mount(t), t;
  }
  updateLanguage() {
    const e = this.node.attrs.language;
    if (e === this.languageName) return;
    this.language.value = e, this.loader.load(e ?? "").then((r) => {
      r && (this.cm.dispatch({
        effects: this.languageConf.reconfigure(r)
      }), this.languageName = e);
    }).catch(console.error);
  }
  setSelection(e, t) {
    this.cm.dom.isConnected && (this.cm.focus(), this.updating = !0, this.cm.dispatch({ selection: { anchor: e, head: t } }), this.updating = !1);
  }
  update(e) {
    if (e.type !== this.node.type) return !1;
    if (this.updating) return !0;
    this.node = e, this.text.value = e.textContent, this.updateLanguage(), this.view.editable === this.cm.state.readOnly && this.cm.dispatch({
      effects: this.readOnlyConf.reconfigure(
        Ct.readOnly.of(!this.view.editable)
      )
    });
    const t = xQ(this.cm.state.doc.toString(), e.textContent);
    return t && (this.updating = !0, this.cm.dispatch({
      changes: { from: t.from, to: t.to, insert: t.text },
      scrollIntoView: !0
    }), this.updating = !1), !0;
  }
  selectNode() {
    this.selected.value = !0, this.cm.focus();
  }
  deselectNode() {
    this.selected.value = !1;
  }
  stopEvent() {
    return !0;
  }
  destroy() {
    this.app.unmount(), this.cm.destroy(), this.disposeSelectedWatcher();
  }
}
function xQ(n, e) {
  if (n === e) return null;
  let t = 0, r = n.length, i = e.length;
  for (; t < r && n.charCodeAt(t) === e.charCodeAt(t); )
    ++t;
  for (; r > t && i > t && n.charCodeAt(r - 1) === e.charCodeAt(i - 1); )
    r--, i--;
  return { from: t, to: r, text: e.slice(t, i) };
}
const bE = Hd(
  ss.node,
  (n) => {
    const e = n.get(Jd.key), t = new dQ(e.languages);
    return (r, i, s) => new wQ(r, i, s, t, e);
  }
);
yE(bE, {
  displayName: "NodeView<code-block>",
  group: "CodeBlock"
});
const kQ = [
  bE,
  Jd
], Fx = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class ru {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (l) => s(Fx(l)) : Fx, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return er(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = e3(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Wi(e);
      let i = this.normalize(t);
      if (i.length)
        for (let s = 0, o = r; ; s++) {
          let l = i.charCodeAt(s), a = this.match(l, o, this.bufferPos + this.bufferStart);
          if (s == i.length - 1) {
            if (a)
              return this.value = a, this;
            break;
          }
          o == r && s < t.length && t.charCodeAt(s) == l && o++;
        }
    }
  }
  match(e, t, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], l = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: r } : (this.matches[s]++, l = !0)), l || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: r } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (ru.prototype[Symbol.iterator] = function() {
  return this;
});
const vE = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, b7 = "gm" + (/x/.unicode == null ? "" : "u");
class wE {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = vE, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new xE(e, t, r, i, s);
    this.re = new RegExp(t, b7 + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = jm(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, i = r + t[0].length;
        if (this.matchPos = jm(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Z2 = /* @__PURE__ */ new WeakMap();
class fc {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let i = Z2.get(e);
    if (!i || i.from >= r || i.to <= t) {
      let l = new fc(t, e.sliceString(t, r));
      return Z2.set(e, l), l;
    }
    if (i.from == t && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > t && (s = e.sliceString(t, o) + s, o = t), i.to < r && (s += e.sliceString(i.to, r)), Z2.set(e, new fc(o, s)), new fc(t, s.slice(t - o, r - o));
  }
}
class xE {
  constructor(e, t, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = vE, this.matchPos = jm(e, i), this.re = new RegExp(t, b7 + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = fc.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, i = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this.matchPos = jm(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = fc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (wE.prototype[Symbol.iterator] = xE.prototype[Symbol.iterator] = function() {
  return this;
});
function SQ(n) {
  try {
    return new RegExp(n, b7), !0;
  } catch {
    return !1;
  }
}
function jm(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function k5(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = lt("input", { class: "cm-textfield", name: "line", value: e }), r = lt("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), n.dispatch({ effects: df.of(!1) }), n.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, lt("label", n.state.phrase("Go to line"), ": ", t), " ", lt("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")), lt("button", {
    name: "close",
    onclick: () => {
      n.dispatch({ effects: df.of(!1) }), n.focus();
    },
    "aria-label": n.state.phrase("close"),
    type: "button"
  }, ["Ã—"]));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = n, l = o.doc.lineAt(o.selection.main.head), [, a, c, u, h] = s, f = u ? +u.slice(1) : 0, d = c ? +c : l.number;
    if (c && h) {
      let g = d / 100;
      a && (g = g * (a == "-" ? -1 : 1) + l.number / o.doc.lines), d = Math.round(o.doc.lines * g);
    } else c && a && (d = d * (a == "-" ? -1 : 1) + l.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), m = G.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    n.dispatch({
      effects: [df.of(!1), de.scrollIntoView(m.from, { y: "center" })],
      selection: m
    }), n.focus();
  }
  return { dom: r };
}
const df = /* @__PURE__ */ ze.define(), Hx = /* @__PURE__ */ sn.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(df) && (n = t.value);
    return n;
  },
  provide: (n) => Of.from(n, (e) => e ? k5 : null)
}), CQ = (n) => {
  let e = Af(n, k5);
  if (!e) {
    let t = [df.of(!0)];
    n.state.field(Hx, !1) == null && t.push(ze.appendConfig.of([Hx, MQ])), n.dispatch({ effects: t }), e = Af(n, k5);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, MQ = /* @__PURE__ */ de.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), TQ = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, AQ = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, TQ, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function OQ(n) {
  return [RQ, NQ];
}
const EQ = /* @__PURE__ */ Se.mark({ class: "cm-selectionMatch" }), IQ = /* @__PURE__ */ Se.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function $x(n, e, t, r) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != St.Word) && (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != St.Word);
}
function DQ(n, e, t, r) {
  return n(e.sliceDoc(t, t + 1)) == St.Word && n(e.sliceDoc(r - 1, r)) == St.Word;
}
const NQ = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(AQ), { state: t } = n, r = t.selection;
    if (r.ranges.length > 1)
      return Se.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return Se.none;
      let a = t.wordAt(i.head);
      if (!a)
        return Se.none;
      o = t.charCategorizer(i.head), s = t.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return Se.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(i.from, i.to), o = t.charCategorizer(i.head), !($x(o, t, i.from, i.to) && DQ(o, t, i.from, i.to)))
          return Se.none;
      } else if (s = t.sliceDoc(i.from, i.to), !s)
        return Se.none;
    }
    let l = [];
    for (let a of n.visibleRanges) {
      let c = new ru(t.doc, s, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || $x(o, t, u, h)) && (i.empty && u <= i.from && h >= i.to ? l.push(IQ.range(u, h)) : (u >= i.to || h <= i.from) && l.push(EQ.range(u, h)), l.length > e.maxMatches))
          return Se.none;
      }
    }
    return Se.set(l);
  }
}, {
  decorations: (n) => n.decorations
}), RQ = /* @__PURE__ */ de.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), PQ = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, r = G.create(t.ranges.map((i) => n.wordAt(i.head) || G.cursor(i.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0);
};
function LQ(n, e) {
  let { main: t, ranges: r } = n.selection, i = n.wordAt(t.head), s = i && i.from == t.from && i.to == t.to;
  for (let o = !1, l = new ru(n.doc, e, r[r.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new ru(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = n.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const BQ = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return PQ({ state: n, dispatch: e });
  let r = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = LQ(n, r);
  return i ? (e(n.update({
    selection: n.selection.addRange(G.range(i.from, i.to), !1),
    effects: de.scrollIntoView(i.to)
  })), !0) : !1;
}, Su = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new KQ(e),
      scrollToMatch: (e) => de.scrollIntoView(e)
    });
  }
});
class kE {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || SQ(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new HQ(this) : new _Q(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : Ct.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? Ja(this, i, t, r) : Ya(this, i, t, r);
  }
}
class SE {
  constructor(e) {
    this.spec = e;
  }
}
function Ya(n, e, t, r) {
  return new ru(e.doc, n.unquoted, t, r, n.caseSensitive ? void 0 : (i) => i.toLowerCase(), n.wholeWord ? zQ(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function zQ(n, e) {
  return (t, r, i, s) => ((s > t || s + i.length < r) && (s = Math.max(0, t - 2), i = n.sliceString(s, Math.min(n.length, r + 2))), (e(Um(i, t - s)) != St.Word || e(Gm(i, t - s)) != St.Word) && (e(Gm(i, r - s)) != St.Word || e(Um(i, r - s)) != St.Word));
}
class _Q extends SE {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let i = Ya(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
      i = Ya(this.spec, e, 0, s).nextOverlapping();
    }
    return i.done || i.value.from == t && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let s = Math.max(t, i - 1e4 - this.spec.unquoted.length), o = Ya(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let i = this.prevMatchInRange(e, 0, t);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != t || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = Ya(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = Ya(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function Ja(n, e, t, r) {
  return new wE(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? FQ(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function Um(n, e) {
  return n.slice(gn(n, e, !1), e);
}
function Gm(n, e) {
  return n.slice(e, gn(n, e));
}
function FQ(n) {
  return (e, t, r) => !r[0].length || (n(Um(r.input, r.index)) != St.Word || n(Gm(r.input, r.index)) != St.Word) && (n(Gm(r.input, r.index + r[0].length)) != St.Word || n(Um(r.input, r.index + r[0].length)) != St.Word);
}
class HQ extends SE {
  nextMatch(e, t, r) {
    let i = Ja(this.spec, e, r, e.doc.length).next();
    return i.done && (i = Ja(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        t,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = Ja(this.spec, e, s, r), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == t || l.from > s + 10))
        return l;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let s = +r.slice(0, i);
        if (s > 0 && s < e.match.length)
          return e.match[s] + r.slice(i);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = Ja(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = Ja(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const Wf = /* @__PURE__ */ ze.define(), v7 = /* @__PURE__ */ ze.define(), $o = /* @__PURE__ */ sn.define({
  create(n) {
    return new Q2(S5(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Wf) ? n = new Q2(t.value.create(), n.panel) : t.is(v7) && (n = new Q2(n.query, t.value ? w7 : null));
    return n;
  },
  provide: (n) => Of.from(n, (e) => e.panel)
});
class Q2 {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const $Q = /* @__PURE__ */ Se.mark({ class: "cm-searchMatch" }), VQ = /* @__PURE__ */ Se.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), qQ = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field($o));
  }
  update(n) {
    let e = n.state.field($o);
    (e != n.startState.field($o) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return Se.none;
    let { view: t } = this, r = new Us();
    for (let i = 0, s = t.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: a } = s[i];
      for (; i < o - 1 && a > s[i + 1].from - 2 * 250; )
        a = s[++i].to;
      n.highlight(t.state, l, a, (c, u) => {
        let h = t.state.selection.ranges.some((f) => f.from == c && f.to == u);
        r.add(c, u, h ? VQ : $Q);
      });
    }
    return r.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Xd(n) {
  return (e) => {
    let t = e.state.field($o, !1);
    return t && t.query.spec.valid ? n(e, t) : TE(e);
  };
}
const Km = /* @__PURE__ */ Xd((n, { query: e }) => {
  let { to: t } = n.state.selection.main, r = e.nextMatch(n.state, t, t);
  if (!r)
    return !1;
  let i = G.single(r.from, r.to), s = n.state.facet(Su);
  return n.dispatch({
    selection: i,
    effects: [x7(n, r), s.scrollToMatch(i.main, n)],
    userEvent: "select.search"
  }), ME(n), !0;
}), Ym = /* @__PURE__ */ Xd((n, { query: e }) => {
  let { state: t } = n, { from: r } = t.selection.main, i = e.prevMatch(t, r, r);
  if (!i)
    return !1;
  let s = G.single(i.from, i.to), o = n.state.facet(Su);
  return n.dispatch({
    selection: s,
    effects: [x7(n, i), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), ME(n), !0;
}), WQ = /* @__PURE__ */ Xd((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: G.create(t.map((r) => G.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), jQ = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: i } = t.main, s = [], o = 0;
  for (let l = new ru(n.doc, n.sliceDoc(r, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == r && (o = s.length), s.push(G.range(l.value.from, l.value.to));
  }
  return e(n.update({
    selection: G.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, Vx = /* @__PURE__ */ Xd((n, { query: e }) => {
  let { state: t } = n, { from: r, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, r, r);
  if (!s)
    return !1;
  let o = s, l = [], a, c, u = [];
  o.from == r && o.to == i && (c = t.toText(e.getReplacement(o)), l.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), u.push(de.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let h = n.state.changes(l);
  return o && (a = G.single(o.from, o.to).map(h), u.push(x7(n, o)), u.push(t.facet(Su).scrollToMatch(a.main, n))), n.dispatch({
    changes: h,
    selection: a,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), UQ = /* @__PURE__ */ Xd((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let r = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: de.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function w7(n) {
  return n.state.facet(Su).createPanel(n);
}
function S5(n, e) {
  var t, r, i, s, o;
  let l = n.selection.main, a = l.empty || l.to > l.from + 100 ? "" : n.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let c = n.facet(Su);
  return new kE({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function CE(n) {
  let e = Af(n, w7);
  return e && e.dom.querySelector("[main-field]");
}
function ME(n) {
  let e = CE(n);
  e && e == n.root.activeElement && e.select();
}
const TE = (n) => {
  let e = n.state.field($o, !1);
  if (e && e.panel) {
    let t = CE(n);
    if (t && t != n.root.activeElement) {
      let r = S5(n.state, e.query.spec);
      r.valid && n.dispatch({ effects: Wf.of(r) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      v7.of(!0),
      e ? Wf.of(S5(n.state, e.query.spec)) : ze.appendConfig.of(JQ)
    ] });
  return !0;
}, AE = (n) => {
  let e = n.state.field($o, !1);
  if (!e || !e.panel)
    return !1;
  let t = Af(n, w7);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: v7.of(!1) }), !0;
}, GQ = [
  { key: "Mod-f", run: TE, scope: "editor search-panel" },
  { key: "F3", run: Km, shift: Ym, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Km, shift: Ym, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: AE, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: jQ },
  { key: "Mod-Alt-g", run: CQ },
  { key: "Mod-d", run: BQ, preventDefault: !0 }
];
class KQ {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field($o).query.spec;
    this.commit = this.commit.bind(this), this.searchField = lt("input", {
      value: t.search,
      placeholder: gr(e, "Find"),
      "aria-label": gr(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = lt("input", {
      value: t.replace,
      placeholder: gr(e, "Replace"),
      "aria-label": gr(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = lt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = lt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = lt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return lt("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = lt("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Km(e), [gr(e, "next")]),
      r("prev", () => Ym(e), [gr(e, "previous")]),
      r("select", () => WQ(e), [gr(e, "all")]),
      lt("label", null, [this.caseField, gr(e, "match case")]),
      lt("label", null, [this.reField, gr(e, "regexp")]),
      lt("label", null, [this.wordField, gr(e, "by word")]),
      ...e.state.readOnly ? [] : [
        lt("br"),
        this.replaceField,
        r("replace", () => Vx(e), [gr(e, "replace")]),
        r("replaceAll", () => UQ(e), [gr(e, "replace all")])
      ],
      lt("button", {
        name: "close",
        onclick: () => AE(e),
        "aria-label": gr(e, "close"),
        type: "button"
      }, ["Ã—"])
    ]);
  }
  commit() {
    let e = new kE({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Wf.of(e) }));
  }
  keydown(e) {
    GB(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Ym : Km)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Vx(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Wf) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Su).top;
  }
}
function gr(n, e) {
  return n.state.phrase(e);
}
const q0 = 30, W0 = /[\s\.,:;?!]/;
function x7(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e), i = n.state.doc.lineAt(t).to, s = Math.max(r.from, e - q0), o = Math.min(i, t + q0), l = n.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let a = 0; a < q0; a++)
      if (!W0.test(l[a + 1]) && W0.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != i) {
    for (let a = l.length - 1; a > l.length - q0; a--)
      if (!W0.test(l[a - 1]) && W0.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return de.announce.of(`${n.state.phrase("current match")}. ${l} ${n.state.phrase("on line")} ${r.number}.`);
}
const YQ = /* @__PURE__ */ de.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), JQ = [
  $o,
  /* @__PURE__ */ el.low(qQ),
  YQ
];
class OE {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, i) {
    this.state = e, this.pos = t, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = yn(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), i = t.text.slice(r - t.from, this.pos - t.from), s = i.search(EE(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function qx(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function XQ(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of n) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      t[i[s]] = !0;
  }
  let r = qx(e) + qx(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function ZQ(n) {
  let e = n.map((i) => typeof i == "string" ? { label: i } : i), [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : XQ(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: t } : null;
  };
}
function ile(n, e) {
  return (t) => {
    for (let r = yn(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class Wx {
  constructor(e, t, r, i) {
    this.completion = e, this.source = t, this.match = r, this.score = i;
  }
}
function ia(n) {
  return n.selection.main.from;
}
function EE(n, e) {
  var t;
  let { source: r } = n, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? n : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const k7 = /* @__PURE__ */ to.define();
function QQ(n, e, t, r) {
  let { main: i } = n.selection, s = t - i.from, o = r - i.from;
  return {
    ...n.changeByRange((l) => {
      if (l != i && t != r && n.sliceDoc(l.from + s, l.from + o) != n.sliceDoc(t, r))
        return { range: l };
      let a = n.toText(e);
      return {
        changes: { from: l.from + s, to: r == i.from ? l.to : l.from + o, insert: a },
        range: G.cursor(l.from + s + a.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const jx = /* @__PURE__ */ new WeakMap();
function eee(n) {
  if (!Array.isArray(n))
    return n;
  let e = jx.get(n);
  return e || jx.set(n, e = ZQ(n)), e;
}
const Jm = /* @__PURE__ */ ze.define(), jf = /* @__PURE__ */ ze.define();
class tee {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = er(e, t), i = Wi(r);
      this.chars.push(r);
      let s = e.slice(t, t + i), o = s.toUpperCase();
      this.folded.push(er(o == s ? s.toLowerCase() : o, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: i, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let w = er(e, 0), k = Wi(w), T = k == e.length ? 0 : -100;
      if (w != t[0]) if (w == r[0])
        T += -200;
      else
        return null;
      return this.ret(T, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = t.length, c = 0;
    if (l < 0) {
      for (let w = 0, k = Math.min(e.length, 200); w < k && c < a; ) {
        let T = er(e, w);
        (T == t[c] || T == r[c]) && (i[c++] = w), w += Wi(T);
      }
      if (c < a)
        return null;
    }
    let u = 0, h = 0, f = !1, d = 0, p = -1, m = -1, g = /[a-z]/.test(e), b = !0;
    for (let w = 0, k = Math.min(e.length, 200), T = 0; w < k && h < a; ) {
      let M = er(e, w);
      l < 0 && (u < a && M == t[u] && (s[u++] = w), d < a && (M == t[d] || M == r[d] ? (d == 0 && (p = w), m = w + 1, d++) : d = 0));
      let C, I = M < 255 ? M >= 48 && M <= 57 || M >= 97 && M <= 122 ? 2 : M >= 65 && M <= 90 ? 1 : 0 : (C = e3(M)) != C.toLowerCase() ? 1 : C != C.toUpperCase() ? 2 : 0;
      (!w || I == 1 && g || T == 0 && I != 0) && (t[h] == M || r[h] == M && (f = !0) ? o[h++] = w : o.length && (b = !1)), T = I, w += Wi(M);
    }
    return h == a && o[0] == 0 && b ? this.result(-100 + (f ? -200 : 0), o, e) : d == a && p == 0 ? this.ret(-200 - e.length + (m == e.length ? 0 : -100), [0, m]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-900 - e.length, [p, m]) : h == a ? this.result(-100 + (f ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, r) {
    let i = [], s = 0;
    for (let o of t) {
      let l = o + (this.astral ? Wi(er(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - r.length, i);
  }
}
class nee {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const nn = /* @__PURE__ */ he.define({
  combine(n) {
    return ls(n, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: ree,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => Ux(e(r), t(r)),
      optionClass: (e, t) => (r) => Ux(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function Ux(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function ree(n, e, t, r, i, s) {
  let o = n.textDirection == wt.RTL, l = o, a = !1, c = "top", u, h, f = e.left - i.left, d = i.right - e.right, p = r.right - r.left, m = r.bottom - r.top;
  if (l && f < Math.min(p, d) ? l = !1 : !l && d < Math.min(p, f) && (l = !0), p <= (l ? f : d))
    u = Math.max(i.top, Math.min(t.top, i.bottom - m)) - e.top, h = Math.min(400, l ? f : d);
  else {
    a = !0, h = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let w = i.bottom - e.bottom;
    w >= m || w > e.top ? u = t.bottom - e.top : (c = "bottom", u = e.bottom - t.top);
  }
  let g = (e.bottom - e.top) / s.offsetHeight, b = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / g}px; max-width: ${h / b}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function iee(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = t.displayLabel || t.label, a = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > a && o.appendChild(document.createTextNode(l.slice(a, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(l.slice(u, h))), f.className = "cm-completionMatchedText", a = h;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function e4(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let r = Math.floor((n - e) / t);
  return { from: n - (r + 1) * t, to: n - r * t };
}
class see {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: s, selected: o } = i.open, l = e.state.facet(nn);
    this.optionContent = iee(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = e4(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: c } = e.state.field(t).open;
      for (let u = a.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(nn).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: jf.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: l } = r.open;
      (!i.open || i.open.options != s) && (this.range = e4(s.length, o, e.state.facet(nn).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), l != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = e4(t.options.length, t.selected, this.view.state.facet(nn).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => rr(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && lee(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return i.top > Math.min(s.bottom, t.bottom) - 10 || i.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(nn).positionInfo(this.view, t, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (o) => {
      o.target == i && o.preventDefault();
    });
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: l, match: a } = e[o], { section: c } = l;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = t + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(l);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let d = f(l, this.view.state, this.view, a);
        d && u.appendChild(d);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function oee(n, e) {
  return (t) => new see(t, n, e);
}
function lee(n, e) {
  let t = n.getBoundingClientRect(), r = e.getBoundingClientRect(), i = t.height / n.offsetHeight;
  r.top < t.top ? n.scrollTop -= (t.top - r.top) / i : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i);
}
function Gx(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function aee(n, e) {
  let t = [], r = null, i = null, s = (u) => {
    t.push(u);
    let { section: h } = u.completion;
    if (h) {
      r || (r = []);
      let f = typeof h == "string" ? h : h.name;
      r.some((d) => d.name == f) || r.push(typeof h == "string" ? { name: f } : h);
    }
  }, o = e.facet(nn);
  for (let u of n)
    if (u.hasResult()) {
      let h = u.result.getMatch;
      if (u.result.filter === !1)
        for (let f of u.result.options)
          s(new Wx(f, u.source, h ? h(f) : [], 1e9 - t.length));
      else {
        let f = e.sliceDoc(u.from, u.to), d, p = o.filterStrict ? new nee(f) : new tee(f);
        for (let m of u.result.options)
          if (d = p.match(m.label)) {
            let g = m.displayLabel ? h ? h(m, d.matched) : [] : d.matched, b = d.score + (m.boost || 0);
            if (s(new Wx(m, u.source, g, b)), typeof m.section == "object" && m.section.rank === "dynamic") {
              let { name: w } = m.section;
              i || (i = /* @__PURE__ */ Object.create(null)), i[w] = Math.max(b, i[w] || -1e9);
            }
          }
      }
    }
  if (r) {
    let u = /* @__PURE__ */ Object.create(null), h = 0, f = (d, p) => (d.rank === "dynamic" && p.rank === "dynamic" ? i[p.name] - i[d.name] : 0) || (typeof d.rank == "number" ? d.rank : 1e9) - (typeof p.rank == "number" ? p.rank : 1e9) || (d.name < p.name ? -1 : 1);
    for (let d of r.sort(f))
      h -= 1e5, u[d.name] = h;
    for (let d of t) {
      let { section: p } = d.completion;
      p && (d.score += u[typeof p == "string" ? p : p.name]);
    }
  }
  let l = [], a = null, c = o.compareCompletions;
  for (let u of t.sort((h, f) => f.score - h.score || c(h.completion, f.completion))) {
    let h = u.completion;
    !a || a.label != h.label || a.detail != h.detail || a.type != null && h.type != null && a.type != h.type || a.apply != h.apply || a.boost != h.boost ? l.push(u) : Gx(u.completion) > Gx(a) && (l[l.length - 1] = u), a = u.completion;
  }
  return l;
}
class nc {
  constructor(e, t, r, i, s, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new nc(this.options, Kx(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, i, s, o) {
    if (i && !o && e.some((c) => c.isPending))
      return i.setDisabled();
    let l = aee(e, t);
    if (!l.length)
      return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
    let a = t.facet(nn).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let c = i.options[i.selected].completion;
      for (let u = 0; u < l.length; u++)
        if (l[u].completion == c) {
          a = u;
          break;
        }
    }
    return new nc(l, Kx(r, a), {
      pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
      create: pee,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new nc(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new nc(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class Xm {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new Xm(fee, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(nn), s = (r.override || t.languageDataAt("autocomplete", ia(t)).map(eee)).map((a) => (this.active.find((u) => u.source == a) || new Yr(
      a,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((a, c) => a == this.active[c]) && (s = this.active);
    let o = this.open, l = e.effects.some((a) => a.is(S7));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !cee(s, this.active) || l ? o = nc.build(s, t, this.id, o, r, l) : o && o.disabled && !s.some((a) => a.isPending) && (o = null), !o && s.every((a) => !a.isPending) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new Yr(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(DE) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new Xm(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? uee : hee;
  }
}
function cee(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = t == n.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (n[t++].result != e[r++].result)
      return !1;
  }
}
const uee = {
  "aria-autocomplete": "list"
}, hee = {};
function Kx(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const fee = [];
function IE(n, e) {
  if (n.isUserEvent("input.complete")) {
    let r = n.annotation(k7);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = n.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
class Yr {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = IE(e, t), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new Yr(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new Yr(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let s of e.effects)
      if (s.is(Jm))
        i = new Yr(i.source, 1, s.value);
      else if (s.is(jf))
        i = new Yr(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(S7))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(ia(e.state));
  }
}
class dc extends Yr {
  constructor(e, t, r, i, s, o) {
    super(e, 3, t), this.limit = r, this.result = i, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = ia(e.state);
    if (l > o || !i || t & 2 && (ia(e.startState) == this.from || l < this.limit))
      return new Yr(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let a = e.changes.mapPos(this.limit);
    return dee(i.validFor, e.state, s, o) ? new dc(this.source, this.explicit, a, i, s, o) : i.update && (i = i.update(i, s, o, new OE(e.state, l, !1))) ? new dc(this.source, this.explicit, a, i, i.from, (r = i.to) !== null && r !== void 0 ? r : ia(e.state)) : new Yr(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new dc(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Yr(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function dee(n, e, t, r) {
  if (!n)
    return !1;
  let i = e.sliceDoc(t, r);
  return typeof n == "function" ? n(i, t, r, e) : EE(n, !0).test(i);
}
const S7 = /* @__PURE__ */ ze.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), DE = /* @__PURE__ */ ze.define(), nr = /* @__PURE__ */ sn.define({
  create() {
    return Xm.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    p3.from(n, (e) => e.tooltip),
    de.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function C7(n, e) {
  const t = e.completion.apply || e.completion.label;
  let r = n.state.field(nr).active.find((i) => i.source == e.source);
  return r instanceof dc ? (typeof t == "string" ? n.dispatch({
    ...QQ(n.state, t, r.from, r.to),
    annotations: k7.of(e.completion)
  }) : t(n, e.completion, r.from, r.to), !0) : !1;
}
const pee = /* @__PURE__ */ oee(nr, C7);
function j0(n, e = "option") {
  return (t) => {
    let r = t.state.field(nr, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(nn).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = cC(t, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, l = r.open.selected > -1 ? r.open.selected + i * (n ? 1 : -1) : n ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), t.dispatch({ effects: DE.of(l) }), !0;
  };
}
const mee = (n) => {
  let e = n.state.field(nr, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(nn).interactionDelay ? !1 : C7(n, e.open.options[e.open.selected]);
}, t4 = (n) => n.state.field(nr, !1) ? (n.dispatch({ effects: Jm.of(!0) }), !0) : !1, gee = (n) => {
  let e = n.state.field(nr, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: jf.of(null) }), !0);
};
class yee {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const bee = 50, vee = 1e3, wee = /* @__PURE__ */ jt.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(nr).active)
      e.isPending && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(nr), t = n.state.facet(nn);
    if (!n.selectionSet && !n.docChanged && n.startState.field(nr) == e)
      return;
    let r = n.transactions.some((s) => {
      let o = IE(s, t);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (r || o.context.abortOnDocChange && n.docChanged || o.updates.length + n.transactions.length > bee && Date.now() - o.time > vee) {
        for (let l of o.context.abortListeners)
          try {
            l();
          } catch (a) {
            rr(this.view.state, a);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((s) => s.effects.some((o) => o.is(Jm))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let s of n.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(nr);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(nn).updateSyncTime));
  }
  startQuery(n) {
    let { state: e } = this.view, t = ia(e), r = new OE(e, t, n.explicit, this.view), i = new yee(n, r);
    this.running.push(i), Promise.resolve(n.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: jf.of(null) }), rr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(nn).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(nn), r = this.view.state.field(nr);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let l = ia(s.updates.length ? s.updates[0].startState : this.view.state), a = Math.min(l, s.done.from + (s.active.explicit ? 0 : 1)), c = new dc(s.active.source, s.active.explicit, a, s.done, s.done.from, (n = s.done.to) !== null && n !== void 0 ? n : l);
        for (let u of s.updates)
          c = c.update(u, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((l) => l.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let l = new Yr(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let a of s.updates)
            l = l.update(a, t);
          l.isPending || e.push(l);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: S7.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(nr, !1);
      if (e && e.tooltip && this.view.state.facet(nn).closeOnBlur) {
        let t = e.open && cC(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: jf.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Jm.of(!1) }), 20), this.composing = 0;
    }
  }
}), xee = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), kee = /* @__PURE__ */ el.highest(/* @__PURE__ */ de.domEventHandlers({
  keydown(n, e) {
    let t = e.state.field(nr, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(xee && n.altKey) || n.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], i = t.active.find((o) => o.source == r.source), s = r.completion.commitCharacters || i.result.commitCharacters;
    return s && s.indexOf(n.key) > -1 && C7(e, r), !1;
  }
})), NE = /* @__PURE__ */ de.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class See {
  constructor(e, t, r, i) {
    this.field = e, this.line = t, this.from = r, this.to = i;
  }
}
class M7 {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, mn.TrackDel), r = e.mapPos(this.to, 1, mn.TrackDel);
    return t == null || r == null ? null : new M7(this.field, t, r);
  }
}
class T7 {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], i = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let c = o, u = /^\t*/.exec(a)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(y1);
        i.push(t + c.length - u), a = c + a.slice(u);
      }
      r.push(a), t += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new M7(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let t = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", c = -1, u = a.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < t.length; h++)
          (l != null ? t[h].seq == l : u && t[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < t.length && (l == null || t[h].seq != null && t[h].seq < l); )
            h++;
          t.splice(h, 0, { seq: l, name: u }), c = h;
          for (let f of i)
            f.field >= c && f.field++;
        }
        for (let h of i)
          if (h.line == r.length && h.from > s.index) {
            let f = s[2] ? 3 + (s[1] || "").length : 2;
            h.from -= f, h.to -= f;
          }
        i.push(new See(c, r.length, s.index, s.index + u.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (l, a, c) => {
        for (let u of i)
          u.line == r.length && u.from > c && (u.from--, u.to--);
        return a;
      }), r.push(o);
    }
    return new T7(r, i);
  }
}
let Cee = /* @__PURE__ */ Se.widget({ widget: /* @__PURE__ */ new class extends no {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Mee = /* @__PURE__ */ Se.mark({ class: "cm-snippetField" });
class Cu {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = Se.set(e.map((r) => (r.from == r.to ? Cee : Mee).range(r.from, r.to)), !0);
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new Cu(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const Zd = /* @__PURE__ */ ze.define({
  map(n, e) {
    return n && n.map(e);
  }
}), Tee = /* @__PURE__ */ ze.define(), Uf = /* @__PURE__ */ sn.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(Zd))
        return t.value;
      if (t.is(Tee) && n)
        return new Cu(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => de.decorations.from(n, (e) => e ? e.deco : Se.none)
});
function A7(n, e) {
  return G.create(n.filter((t) => t.field == e).map((t) => G.range(t.from, t.to)));
}
function Aee(n) {
  let e = T7.parse(n);
  return (t, r, i, s) => {
    let { text: o, ranges: l } = e.instantiate(t.state, i), { main: a } = t.state.selection, c = {
      changes: { from: i, to: s == a.from ? a.to : s, insert: Xe.of(o) },
      scrollIntoView: !0,
      annotations: r ? [k7.of(r), zn.userEvent.of("input.complete")] : void 0
    };
    if (l.length && (c.selection = A7(l, 0)), l.some((u) => u.field > 0)) {
      let u = new Cu(l, 0), h = c.effects = [Zd.of(u)];
      t.state.field(Uf, !1) === void 0 && h.push(ze.appendConfig.of([Uf, Nee, Ree, NE]));
    }
    t.dispatch(t.state.update(c));
  };
}
function RE(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(Uf, !1);
    if (!r || n < 0 && r.active == 0)
      return !1;
    let i = r.active + n, s = n > 0 && !r.ranges.some((o) => o.field == i + n);
    return t(e.update({
      selection: A7(r.ranges, i),
      effects: Zd.of(s ? null : new Cu(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const Oee = ({ state: n, dispatch: e }) => n.field(Uf, !1) ? (e(n.update({ effects: Zd.of(null) })), !0) : !1, Eee = /* @__PURE__ */ RE(1), Iee = /* @__PURE__ */ RE(-1), Dee = [
  { key: "Tab", run: Eee, shift: Iee },
  { key: "Escape", run: Oee }
], Yx = /* @__PURE__ */ he.define({
  combine(n) {
    return n.length ? n[0] : Dee;
  }
}), Nee = /* @__PURE__ */ el.highest(/* @__PURE__ */ du.compute([Yx], (n) => n.facet(Yx)));
function sle(n, e) {
  return { ...e, apply: Aee(n) };
}
const Ree = /* @__PURE__ */ de.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(Uf, !1), r;
    if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let i = t.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: A7(t.ranges, i.field),
      effects: Zd.of(t.ranges.some((s) => s.field > i.field) ? new Cu(t.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), Gf = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Ll = /* @__PURE__ */ ze.define({
  map(n, e) {
    let t = e.mapPos(n, -1, mn.TrackAfter);
    return t ?? void 0;
  }
}), O7 = /* @__PURE__ */ new class extends la {
}();
O7.startSide = 1;
O7.endSide = -1;
const PE = /* @__PURE__ */ sn.define({
  create() {
    return Ze.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(Ll) && (n = n.update({ add: [O7.range(t.value, t.value + 1)] }));
    return n;
  }
});
function Pee() {
  return [Bee, PE];
}
const n4 = "()[]{}<>Â«Â»Â»Â«ï¼»ï¼½ï½›ï½";
function LE(n) {
  for (let e = 0; e < n4.length; e += 2)
    if (n4.charCodeAt(e) == n)
      return n4.charAt(e + 1);
  return e3(n < 128 ? n : n + 1);
}
function BE(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || Gf;
}
const Lee = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Bee = /* @__PURE__ */ de.inputHandler.of((n, e, t, r) => {
  if ((Lee ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let i = n.state.selection.main;
  if (r.length > 2 || r.length == 2 && Wi(er(r, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let s = Fee(n.state, r);
  return s ? (n.dispatch(s), !0) : !1;
}), zee = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let r = BE(n, n.selection.main.head).brackets || Gf.brackets, i = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let l = Hee(n.doc, o.head);
      for (let a of r)
        if (a == l && cg(n.doc, o.head) == LE(er(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: G.cursor(o.head - a.length)
          };
    }
    return { range: i = o };
  });
  return i || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, _ee = [
  { key: "Backspace", run: zee }
];
function Fee(n, e) {
  let t = BE(n, n.selection.main.head), r = t.brackets || Gf.brackets;
  for (let i of r) {
    let s = LE(er(i, 0));
    if (e == i)
      return s == i ? qee(n, i, r.indexOf(i + i + i) > -1, t) : $ee(n, i, s, t.before || Gf.before);
    if (e == s && zE(n, n.selection.main.from))
      return Vee(n, i, s);
  }
  return null;
}
function zE(n, e) {
  let t = !1;
  return n.field(PE).between(0, n.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function cg(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, Wi(er(t, 0)));
}
function Hee(n, e) {
  let t = n.sliceString(e - 2, e);
  return Wi(er(t, 0)) == t.length ? t : t.slice(1);
}
function $ee(n, e, t, r) {
  let i = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: Ll.of(o.to + e.length),
        range: G.range(o.anchor + e.length, o.head + e.length)
      };
    let l = cg(n.doc, o.head);
    return !l || /\s/.test(l) || r.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: Ll.of(o.head + e.length),
      range: G.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Vee(n, e, t) {
  let r = null, i = n.changeByRange((s) => s.empty && cg(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: G.cursor(s.head + t.length)
  } : r = { range: s });
  return r ? null : n.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function qee(n, e, t, r) {
  let i = r.stringPrefixes || Gf.stringPrefixes, s = null, o = n.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: Ll.of(l.to + e.length),
        range: G.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, c = cg(n.doc, a), u;
    if (c == e) {
      if (Jx(n, a))
        return {
          changes: { insert: e + e, from: a },
          effects: Ll.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (zE(n, a)) {
        let f = t && n.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + f.length, insert: f },
          range: G.cursor(a + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(a - 2 * e.length, a) == e + e && (u = Xx(n, a - 2 * e.length, i)) > -1 && Jx(n, u))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: Ll.of(a + e.length),
          range: G.cursor(a + e.length)
        };
      if (n.charCategorizer(a)(c) != St.Word && Xx(n, a, i) > -1 && !Wee(n, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: Ll.of(a + e.length),
          range: G.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Jx(n, e) {
  let t = yn(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function Wee(n, e, t, r) {
  let i = yn(n).resolveInner(e, -1), s = r.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + s)), a = l.indexOf(t);
    if (!a || a > -1 && r.indexOf(l.slice(0, a)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > t.length + a; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function Xx(n, e, t) {
  let r = n.charCategorizer(e);
  if (r(n.sliceDoc(e - 1, e)) != St.Word)
    return e;
  for (let i of t) {
    let s = e - i.length;
    if (n.sliceDoc(s, e) == i && r(n.sliceDoc(s - 1, s)) != St.Word)
      return s;
  }
  return -1;
}
function jee(n = {}) {
  return [
    kee,
    nr,
    nn.of(n),
    wee,
    Uee,
    NE
  ];
}
const _E = [
  { key: "Ctrl-Space", run: t4 },
  { mac: "Alt-`", run: t4 },
  { mac: "Alt-i", run: t4 },
  { key: "Escape", run: gee },
  { key: "ArrowDown", run: /* @__PURE__ */ j0(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ j0(!1) },
  { key: "PageDown", run: /* @__PURE__ */ j0(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ j0(!1, "page") },
  { key: "Enter", run: mee }
], Uee = /* @__PURE__ */ el.highest(/* @__PURE__ */ du.computeN([nn], (n) => n.facet(nn).defaultKeymap ? [_E] : []));
class Zx {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class Ol {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let i = r.facet(Kf).markerFilter;
    i && (e = i(e, r));
    let s = e.slice().sort((u, h) => u.from - h.from || u.to - h.to), o = new Us(), l = [], a = 0;
    for (let u = 0; ; ) {
      let h = u == s.length ? null : s[u];
      if (!h && !l.length)
        break;
      let f, d;
      for (l.length ? (f = a, d = l.reduce((m, g) => Math.min(m, g.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, d = h.to, l.push(h), u++); u < s.length; ) {
        let m = s[u];
        if (m.from == f && (m.to > m.from || m.to == f))
          l.push(m), u++, d = Math.min(m.to, d);
        else {
          d = Math.min(m.from, d);
          break;
        }
      }
      let p = ste(l);
      if (l.some((m) => m.from == m.to || m.from == m.to - 1 && r.doc.lineAt(m.from).to == m.from))
        o.add(f, f, Se.widget({
          widget: new tte(p),
          diagnostics: l.slice()
        }));
      else {
        let m = l.reduce((g, b) => b.markClass ? g + " " + b.markClass : g, "");
        o.add(f, d, Se.mark({
          class: "cm-lintRange cm-lintRange-" + p + m,
          diagnostics: l.slice(),
          inclusiveEnd: l.some((g) => g.to > d)
        }));
      }
      a = d;
      for (let m = 0; m < l.length; m++)
        l[m].to <= a && l.splice(m--, 1);
    }
    let c = o.finish();
    return new Ol(c, t, iu(c));
  }
}
function iu(n, e = null, t = 0) {
  let r = null;
  return n.between(t, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new Zx(i, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new Zx(r.from, s, r.diagnostic);
      }
  }), r;
}
function Gee(n, e) {
  let t = e.pos, r = e.end || t, i = n.state.facet(Kf).hideOn(n, t, r);
  if (i != null)
    return i;
  let s = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((o) => o.is(FE)) || n.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function Kee(n, e) {
  return n.field(Ar, !1) ? e : e.concat(ze.appendConfig.of(ote));
}
const FE = /* @__PURE__ */ ze.define(), E7 = /* @__PURE__ */ ze.define(), HE = /* @__PURE__ */ ze.define(), Ar = /* @__PURE__ */ sn.define({
  create() {
    return new Ol(Se.none, null, null);
  },
  update(n, e) {
    if (e.docChanged && n.diagnostics.size) {
      let t = n.diagnostics.map(e.changes), r = null, i = n.panel;
      if (n.selected) {
        let s = e.changes.mapPos(n.selected.from, 1);
        r = iu(t, n.selected.diagnostic, s) || iu(t, null, s);
      }
      !t.size && i && e.state.facet(Kf).autoPanel && (i = null), n = new Ol(t, i, r);
    }
    for (let t of e.effects)
      if (t.is(FE)) {
        let r = e.state.facet(Kf).autoPanel ? t.value.length ? Yf.open : null : n.panel;
        n = Ol.init(t.value, r, e.state);
      } else t.is(E7) ? n = new Ol(n.diagnostics, t.value ? Yf.open : null, n.selected) : t.is(HE) && (n = new Ol(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    Of.from(n, (e) => e.panel),
    de.decorations.from(n, (e) => e.diagnostics)
  ]
}), Yee = /* @__PURE__ */ Se.mark({ class: "cm-lintRange cm-lintRange-active" });
function Jee(n, e, t) {
  let { diagnostics: r } = n.state.field(Ar), i, s = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, c, { spec: u }) => {
    if (e >= a && e <= c && (a == c || (e > a || t > 0) && (e < c || t < 0)))
      return i = u.diagnostics, s = a, o = c, !1;
  });
  let l = n.state.facet(Kf).tooltipFilter;
  return i && l && (i = l(i, n.state)), i ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: Xee(n, i) };
    }
  } : null;
}
function Xee(n, e) {
  return lt("ul", { class: "cm-tooltip-lint" }, e.map((t) => VE(n, t, !1)));
}
const Zee = (n) => {
  let e = n.state.field(Ar, !1);
  (!e || !e.panel) && n.dispatch({ effects: Kee(n.state, [E7.of(!0)]) });
  let t = Af(n, Yf.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Qx = (n) => {
  let e = n.state.field(Ar, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: E7.of(!1) }), !0);
}, Qee = (n) => {
  let e = n.state.field(Ar, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, ete = [
  { key: "Mod-Shift-m", run: Zee, preventDefault: !0 },
  { key: "F8", run: Qee }
], Kf = /* @__PURE__ */ he.define({
  combine(n) {
    return {
      sources: n.map((e) => e.source).filter((e) => e != null),
      ...ls(n.map((e) => e.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: ek,
        tooltipFilter: ek,
        needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t,
        hideOn: (e, t) => e ? t ? (r, i, s) => e(r, i, s) || t(r, i, s) : e : t,
        autoPanel: (e, t) => e || t
      })
    };
  }
});
function ek(n, e) {
  return n ? e ? (t, r) => e(n(t, r), r) : n : e;
}
function $E(n) {
  let e = [];
  if (n)
    e: for (let { name: t } of n) {
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function VE(n, e, t) {
  var r;
  let i = t ? $E(e.actions) : [];
  return lt("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, lt("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(n) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let l = !1, a = (d) => {
      if (d.preventDefault(), l)
        return;
      l = !0;
      let p = iu(n.state.field(Ar).diagnostics, e);
      p && s.apply(n, p.from, p.to);
    }, { name: c } = s, u = i[o] ? c.indexOf(i[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      lt("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ], f = s.markClass ? " " + s.markClass : "";
    return lt("button", {
      type: "button",
      class: "cm-diagnosticAction" + f,
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, h);
  }), e.source && lt("div", { class: "cm-diagnosticSource" }, e.source));
}
class tte extends no {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return lt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class tk {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = VE(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Yf {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        Qx(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = $E(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = iu(this.view.state.field(Ar).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = lt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = lt("div", { class: "cm-panel-lint" }, this.list, lt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Qx(this.view)
    }, "Ã—")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Ar).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Ar), r = 0, i = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (l, a, { spec: c }) => {
      for (let u of c.diagnostics) {
        if (o.has(u))
          continue;
        o.add(u);
        let h = -1, f;
        for (let d = r; d < this.items.length; d++)
          if (this.items[d].diagnostic == u) {
            h = d;
            break;
          }
        h < 0 ? (f = new tk(this.view, u), this.items.splice(r, 0, f), i = !0) : (f = this.items[h], h > r && (this.items.splice(r, h - r), i = !0)), t && f.diagnostic == t.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), s = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new tk(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: l, panel: a }) => {
        let c = a.height / this.list.offsetHeight;
        l.top < a.top ? this.list.scrollTop -= (a.top - l.top) / c : l.bottom > a.bottom && (this.list.scrollTop += (l.bottom - a.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Ar), r = iu(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: HE.of(r)
    });
  }
  static open(e) {
    return new Yf(e);
  }
}
function nte(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function U0(n) {
  return nte(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const rte = /* @__PURE__ */ de.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ U0("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ U0("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ U0("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ U0("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function ite(n) {
  return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
}
function ste(n) {
  let e = "hint", t = 1;
  for (let r of n) {
    let i = ite(r.severity);
    i > t && (t = i, e = r.severity);
  }
  return e;
}
const ote = [
  Ar,
  /* @__PURE__ */ de.decorations.compute([Ar], (n) => {
    let { selected: e, panel: t } = n.field(Ar);
    return !e || !t || e.from == e.to ? Se.none : Se.set([
      Yee.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ Nz(Jee, { hideOn: Gee }),
  rte
], lte = [
  qz(),
  Uz(),
  cz(),
  JX(),
  O_(),
  sC(),
  rz(),
  Ct.allowMultipleSelections.of(!0),
  p_(),
  OC(N_, { fallback: !0 }),
  F_(),
  Pee(),
  jee(),
  xz(),
  Cz(),
  mz(),
  OQ(),
  du.of([
    ..._ee,
    ...pE,
    ...GQ,
    ...sZ,
    ...C_,
    ..._E,
    ...ete
  ])
];
function ate(n) {
  return n.nodeType === 1;
}
function cte(n) {
  return ate(n) && n.namespaceURI === "http://www.w3.org/1999/xhtml";
}
function ute(n) {
  let e = [[-1, n.state.doc]], t = [];
  for (; e.length > 0; ) {
    const [r, i] = e.pop();
    if (r >= 0) {
      let s = n.nodeDOM(r);
      if (s && cte(s)) {
        let { top: o, bottom: l, left: a, right: c } = s.getBoundingClientRect();
        t.push([r, [
          a,
          o,
          c,
          o
        ]], [r + i.nodeSize, [
          a,
          l,
          c,
          l
        ]]);
      }
    }
    if (i.isBlock && !i.isTextblock) {
      let s = r + 1;
      for (let o of i.children)
        e.push([s, o]), s += o.nodeSize;
    }
  }
  return t;
}
function hte(n, e) {
  let t = [], r, i;
  const s = () => {
    const u = n.dom.getBoundingClientRect(), h = n.state.doc;
    return t && r && i && u.width === i.width && u.height === i.height && u.x === i.x && u.y === i.y && r.eq(h) || (i = u, r = h, t = ute(n)), t;
  }, o = (u, h) => {
    if (!n.editable || n.isDestroyed) return;
    const f = (m, g) => {
      const [b, w] = m, [k, T] = g, M = rk(u, w), C = rk(u, T);
      return M - C || b - k;
    };
    let d = s();
    d.sort(f), d = d.slice(0, 8);
    const p = d.find((m) => (e == null ? void 0 : e({
      view: n,
      pos: m[0],
      event: h
    })) !== !1);
    if (!(p && dte(n, p[0])))
      return p;
  };
  let l, a;
  return (u, h) => (l && fte(l, u) || (l = u, a = o(u, h)), a);
}
function fte(n, e) {
  return n[0] === e[0] && n[1] === e[1];
}
function nk(n, e) {
  return Math.abs(n[0] - e[0]) + Math.abs(n[1] - e[1]);
}
function rk(n, e) {
  return Math.min(nk(n, [e[0], e[1]]), nk(n, [e[2], e[3]]));
}
function dte(n, e) {
  const t = n.dragging;
  if (!t) return;
  const { move: r } = t;
  if (!r) return;
  const i = n.state.selection;
  if (!(i instanceof ve)) return;
  const { from: s, to: o } = i;
  return s <= e && e <= o;
}
function pte(n) {
  let e;
  return new xt({
    key: new kt("prosekit-drop-indicator"),
    view: (t) => (e = hte(t, n.onDrag), gte(t, e, n)),
    props: { handleDrop(t, r, i, s) {
      if (!e) return !1;
      const o = e([r.clientX, r.clientY], r);
      if (!o) return !1;
      r.preventDefault();
      let l = o[0], a = t.state.tr;
      if (s) {
        let { node: d } = t.dragging || {};
        d ? d.replace(a) : a.deleteSelection();
      }
      let c = a.mapping.map(l), u = i.openStart == 0 && i.openEnd == 0 && i.content.childCount == 1, h = a.doc;
      if (u ? a.replaceRangeWith(c, c, i.content.firstChild) : a.replaceRange(c, c, i), a.doc.eq(h)) return !0;
      let f = a.doc.resolve(c);
      if (u && ve.isSelectable(i.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(i.content.firstChild)) a.setSelection(new ve(f));
      else {
        let d = a.mapping.map(l);
        a.mapping.maps[a.mapping.maps.length - 1].forEach((p, m, g, b) => d = b), a.setSelection(mte(t, f, a.doc.resolve(d)));
      }
      return t.focus(), t.dispatch(a.setMeta("uiEvent", "drop")), !0;
    } }
  });
}
function mte(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || ge.between(e, t, r);
}
function gte(n, e, t) {
  let r = n.dom, i, s, o, l = !1;
  const a = () => {
    i && clearTimeout(i), l = !1, i = setTimeout(() => {
      var h;
      l || (h = t.onHide) == null || h.call(t);
    }, 30);
  }, c = (h) => {
    var m;
    l = !0;
    const { clientX: f, clientY: d } = h;
    if (s === f && o === d) return;
    s = f, o = d;
    let p = e([f, d], h);
    if (p) {
      const [g, [b, w, k, T]] = p, M = {
        p1: {
          x: b,
          y: w
        },
        p2: {
          x: k,
          y: T
        }
      };
      (m = t.onShow) == null || m.call(t, {
        view: n,
        pos: g,
        line: M
      });
    } else {
      a();
      return;
    }
  };
  return r.addEventListener("dragover", c), r.addEventListener("dragend", a), r.addEventListener("drop", a), r.addEventListener("dragleave", a), { destroy: () => {
    r.removeEventListener("dragover", c), r.removeEventListener("dragend", a), r.removeEventListener("drop", a), r.removeEventListener("dragleave", a);
  } };
}
class Rt extends Pe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return Rt.valid(r) ? new Rt(r) : Pe.near(r);
  }
  content() {
    return ue.empty;
  }
  eq(e) {
    return e instanceof Rt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Rt(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new I7(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !yte(e) || !bte(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && Rt.valid(e))
        return e;
      let i = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let l = e.node(o);
        if (t > 0 ? e.indexAfter(o) < l.childCount : e.index(o) > 0) {
          s = l.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        i += t;
        let a = e.doc.resolve(i);
        if (Rt.valid(a))
          return a;
      }
      for (; ; ) {
        let o = t > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !ve.isSelectable(s)) {
            e = e.doc.resolve(i + s.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        s = o, i += t;
        let l = e.doc.resolve(i);
        if (Rt.valid(l))
          return l;
      }
      return null;
    }
  }
}
Rt.prototype.visible = !1;
Rt.findFrom = Rt.findGapCursorFrom;
Pe.jsonID("gapcursor", Rt);
class I7 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new I7(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return Rt.valid(t) ? new Rt(t) : Pe.near(t);
  }
}
function yte(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function bte(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function vte() {
  return new xt({
    props: {
      decorations: Ste,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && Rt.valid(t) ? new Rt(t) : null;
      },
      handleClick: xte,
      handleKeyDown: wte,
      handleDOMEvents: { beforeinput: kte }
    }
  });
}
const wte = F3({
  ArrowLeft: G0("horiz", -1),
  ArrowRight: G0("horiz", 1),
  ArrowUp: G0("vert", -1),
  ArrowDown: G0("vert", 1)
});
function G0(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, l = e > 0 ? o.$to : o.$from, a = o.empty;
    if (o instanceof ge) {
      if (!s.endOfTextblock(t) || l.depth == 0)
        return !1;
      a = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let c = Rt.findGapCursorFrom(l, e, a);
    return c ? (i && i(r.tr.setSelection(new Rt(c))), !0) : !1;
  };
}
function xte(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!Rt.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && ve.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new Rt(r))), !0);
}
function kte(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof Rt))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = Y.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = Y.from(r[o].createAndFill(null, i));
  let s = n.state.tr.replace(t.pos, t.pos, new ue(i, 0, 0));
  return s.setSelection(ge.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function Ste(n) {
  if (!(n.selection instanceof Rt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", ct.create(n.doc, [Wt.widget(n.selection.head, e, { key: "gapcursor" })]);
}
function Qd(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-cursor",
      ...e
    }
  }), n;
}
const Jf = it(
  null,
  "dropIndicatorState"
);
Qd(Jf, {
  displayName: "Ctx<dropIndicatorState>"
});
const ug = it(
  {
    width: 2,
    color: !1,
    class: "milkdown-drop-indicator"
  },
  "dropIndicatorConfig"
);
Qd(ug, {
  displayName: "Ctx<dropIndicatorConfig>"
});
const Cte = new kt("MILKDOWN_DROP_INDICATOR_DOM"), qE = Ut(
  (n) => new xt({
    key: Cte,
    view: (e) => {
      var o;
      const t = n.get(ug.key), r = document.createElement("div");
      Object.assign(r.style, {
        position: "fixed",
        pointerEvents: "none",
        display: "none",
        backgroundColor: t.color,
        top: "0",
        left: "0"
      }), r.classList.add(t.class), r.classList.add("milkdown-drop-indicator"), (o = e.dom.parentNode) == null || o.appendChild(r);
      const i = n.use(Jf.key), s = (l) => {
        Mte(r, l, t);
      };
      return i.on(s), {
        destroy: () => {
          i.off(s), r.remove();
        }
      };
    }
  })
);
Qd(qE, {
  displayName: "Prose<dropIndicatorDOM>"
});
function Mte(n, e, t) {
  if (!e) {
    Object.assign(n.style, { display: "none" });
    return;
  }
  const { line: r } = e, { width: i } = t, {
    p1: { x: s, y: o },
    p2: { x: l, y: a }
  } = r, c = o === a;
  let u, h, f = o, d = s;
  c ? (u = l - s, h = i, f -= i / 2) : (u = i, h = a - o, d -= i / 2), f = Math.round(f), d = Math.round(d), Object.assign(n.style, {
    display: "block",
    width: `${u}px`,
    height: `${h}px`,
    transform: `translate(${d}px, ${f}px)`
  });
}
const WE = Ut((n) => pte({
  onShow: (i) => {
    n.set(Jf.key, i);
  },
  onHide: () => {
    n.set(Jf.key, null);
  },
  onDrag: () => !0
}));
Qd(WE, {
  displayName: "Prose<dropIndicator>"
});
const jE = Ut(() => vte());
Qd(jE, {
  displayName: "Prose<gapCursor>"
});
const Tte = [
  jE,
  ug,
  Jf,
  qE,
  WE
].flat();
function Ate(n) {
  var e;
  const t = (e = void 0) != null ? e : !1;
  let r = typeof document > "u" ? null : document.createElement("div");
  return new xt({
    key: Ote,
    view: (i) => {
      t !== !0 && Nte(i.state.schema, t || []);
      const s = i.dom.ownerDocument;
      r = r || document.createElement("div");
      const o = r, l = () => {
        Ite(i, o);
      };
      let a;
      return window.ResizeObserver && (a = new window.ResizeObserver(() => l()), a.observe(i.dom)), s.addEventListener("selectionchange", l), {
        update: () => {
          l();
        },
        destroy: () => {
          s.removeEventListener("selectionchange", l), a && a.unobserve(i.dom);
        }
      };
    },
    props: {
      handleKeyDown: (i, s) => {
        var o;
        const { selection: l } = i.state;
        if (s.altKey || s.ctrlKey || s.metaKey || s.shiftKey || s.isComposing || !["ArrowLeft", "ArrowRight"].includes(s.key) || !C5(l) || !l.empty)
          return !1;
        const a = l.$head, [c, u] = UE(a), h = i.state.storedMarks || a.marks();
        if (c && u && !$e.sameSet(c, u)) {
          if (s.key === "ArrowLeft" && !$e.sameSet(c, h))
            return i.dispatch(i.state.tr.setStoredMarks(c)), !0;
          if (s.key === "ArrowRight" && !$e.sameSet(u, h))
            return i.dispatch(i.state.tr.setStoredMarks(u)), !0;
        }
        return s.key === "ArrowLeft" && a.textOffset === 1 ? (i.dispatch(
          i.state.tr.setSelection(ge.create(i.state.doc, a.pos - 1)).setStoredMarks(a.marks())
        ), !0) : s.key === "ArrowRight" && a.textOffset + 1 === ((o = a.parent.maybeChild(a.index())) == null ? void 0 : o.nodeSize) ? (i.dispatch(
          i.state.tr.setSelection(ge.create(i.state.doc, a.pos + 1)).setStoredMarks(a.marks())
        ), !0) : !1;
      },
      decorations: (i) => {
        if (!(!r || !C5(i.selection) || !i.selection.empty))
          return ct.create(i.doc, [
            Wt.widget(0, r, {
              key: "prosemirror-virtual-cursor"
            })
          ]);
      },
      attributes: {
        class: "virtual-cursor-enabled"
      }
    }
  });
}
var Ote = new kt("prosemirror-virtual-cursor");
function Ete(n, e) {
  var t;
  const r = window.getSelection();
  if (!r || !r.rangeCount)
    return null;
  const i = (t = r == null ? void 0 : r.getRangeAt(0)) == null ? void 0 : t.cloneRange();
  if (!i)
    return null;
  i.collapse(e);
  const s = i.getClientRects(), o = s != null && s.length ? s[s.length - 1] : null;
  return o != null && o.height ? o : n.coordsAtPos(n.state.selection.head);
}
function UE(n) {
  const e = n.index(), t = n.parent.maybeChild(e);
  let r = n.textOffset ? t : null;
  return !r && e > 0 && (r = n.parent.maybeChild(e - 1)), [r == null ? void 0 : r.marks, t == null ? void 0 : t.marks];
}
function C5(n) {
  return n && typeof n == "object" && "$cursor" in n;
}
function Ite(n, e) {
  if (!n || !n.dom || n.isDestroyed || !e)
    return;
  const { state: t, dom: r } = n, { selection: i } = t;
  if (!C5(i))
    return;
  const s = Ete(n, i.$head === i.$from);
  if (!s)
    return e;
  const o = r.getBoundingClientRect();
  let l = "prosemirror-virtual-cursor";
  const a = t.selection.$head, [c, u] = UE(a), h = t.storedMarks || a.marks();
  i.$cursor && c && u && h && !$e.sameSet(c, u) && ($e.sameSet(c, h) ? l += " prosemirror-virtual-cursor-left" : $e.sameSet(u, h) && (l += " prosemirror-virtual-cursor-right")), e.className = l, Dte(e, "prosemirror-virtual-cursor-animation"), e.style.height = `${s.bottom - s.top}px`, e.style.left = `${s.left - o.left}px`, e.style.top = `${s.top - o.top}px`;
}
function Dte(n, e) {
  n.classList.remove(e), n.offsetWidth, n.classList.add(e);
}
function Nte(n, e) {
  for (const [t, r] of Object.entries(n.marks))
    r.spec.inclusive === !1 && !e.includes(t) && console.warn(
      `[prosemirror-virtual-cursor] Virtual cursor does not work well with marks that have inclusive set to false. Please consider removing the inclusive option from the "${t}" mark or adding it to the "skipWarning" option.`
    );
}
var Rte = Object.defineProperty, ik = Object.getOwnPropertySymbols, Pte = Object.prototype.hasOwnProperty, Lte = Object.prototype.propertyIsEnumerable, sk = (n, e, t) => e in n ? Rte(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Bte = (n, e) => {
  for (var t in e || (e = {}))
    Pte.call(e, t) && sk(n, t, e[t]);
  if (ik)
    for (var t of ik(e))
      Lte.call(e, t) && sk(n, t, e[t]);
  return n;
};
function GE(n, e) {
  return Object.assign(n, {
    meta: Bte({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const zte = {
  imageIcon: "ðŸŒŒ",
  uploadButton: "Upload",
  confirmButton: "âŽ",
  uploadPlaceholderText: "/Paste",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, hg = it(
  zte,
  "inlineImageConfigCtx"
);
GE(hg, {
  displayName: "Config<image-inline>",
  group: "ImageInline"
});
function Vp({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
Vp.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const _te = J3("abcdefg", 8), Fte = Xt({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: l,
    className: a
  }) {
    var c, u;
    const h = ce(!1), f = ce(), d = ce((c = e.value) != null ? c : ""), p = ce(_te()), m = ce(((u = e.value) == null ? void 0 : u.length) !== 0), g = (T) => {
      const C = T.target.value;
      m.value = C.length !== 0, d.value = C;
    }, b = (T) => {
      var M, C;
      T.key === "Enter" && t((C = (M = f.value) == null ? void 0 : M.value) != null ? C : "");
    }, w = () => {
      var T, M;
      t((M = (T = f.value) == null ? void 0 : T.value) != null ? M : "");
    }, k = (T) => {
      var M;
      const C = (M = T.target.files) == null ? void 0 : M[0];
      C && r(C).then((I) => {
        I && (t(I), m.value = !0);
      }).catch((I) => {
        console.error("An error occurred while uploading image"), console.error(I);
      });
    };
    return () => /* @__PURE__ */ V("div", { class: bn("image-edit", a) }, /* @__PURE__ */ V(Vp, { icon: i, class: "image-icon" }), /* @__PURE__ */ V("div", { class: bn("link-importer", h.value && "focus") }, /* @__PURE__ */ V(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (T) => {
          T.preventDefault(), T.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: d.value,
        onInput: g,
        onKeydown: b,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !m.value && /* @__PURE__ */ V("div", { class: "placeholder" }, /* @__PURE__ */ V(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: p.value,
        type: "file",
        accept: "image/*",
        onChange: k
      }
    ), /* @__PURE__ */ V("label", { class: "uploader", for: p.value }, /* @__PURE__ */ V(Vp, { icon: s })), /* @__PURE__ */ V("span", { class: "text", onClick: () => {
      var T;
      return (T = f.value) == null ? void 0 : T.focus();
    } }, l))), d.value && /* @__PURE__ */ V("div", { class: "confirm", onClick: () => w() }, /* @__PURE__ */ V(Vp, { icon: o })));
  }
}), Hte = Xt({
  props: {
    src: {
      type: Object,
      required: !0
    },
    alt: {
      type: Object,
      required: !0
    },
    title: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e, alt: t, title: r } = n;
    return () => {
      var i;
      return (i = e.value) != null && i.length ? /* @__PURE__ */ V(
        "img",
        {
          class: "image-inline",
          src: e.value,
          alt: t.value,
          title: r.value
        }
      ) : /* @__PURE__ */ V(
        Fte,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (s) => n.setAttr("src", s),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload,
          className: "empty-image-inline"
        }
      );
    };
  }
}), KE = Hd(
  Ma.node,
  (n) => (e, t, r) => {
    const i = ce(e.attrs.src), s = ce(e.attrs.alt), o = ce(e.attrs.title), l = ce(!1), a = ce(!t.editable), c = (g, b) => {
      if (!t.editable) return;
      const w = r();
      w != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          w,
          g,
          g === "src" ? Ii.sanitize(b) : b
        )
      );
    }, u = n.get(hg.key), h = oi(Hte, {
      src: i,
      alt: s,
      title: o,
      selected: l,
      readonly: a,
      setAttr: c,
      config: u
    }), f = document.createElement("span");
    f.className = "milkdown-image-inline";
    const d = au(() => {
      l.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), p = u.proxyDomURL, m = (g) => {
      if (!p)
        i.value = g.attrs.src;
      else {
        const b = p(g.attrs.src);
        typeof b == "string" ? i.value = b : b.then((w) => {
          i.value = w;
        }).catch(console.error);
      }
      s.value = g.attrs.alt, o.value = g.attrs.title;
    };
    return m(e), h.mount(f), {
      dom: f,
      update: (g) => g.type !== e.type ? !1 : (m(g), !0),
      stopEvent: (g) => g.target instanceof HTMLInputElement,
      selectNode: () => {
        l.value = !0;
      },
      deselectNode: () => {
        l.value = !1;
      },
      destroy: () => {
        d(), h.unmount(), f.remove();
      }
    };
  }
);
GE(KE, {
  displayName: "NodeView<image-inline>",
  group: "ImageInline"
});
const $te = [
  hg,
  KE
];
class Qn {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, t, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, t) {
    return t ? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer ? null : new Qn(e.loc.lexer, e.loc.start, t.loc.end) : e && e.loc;
  }
}
class Ir {
  // don't expand the token
  // used in \noexpand
  constructor(e, t) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, t) {
    return new Ir(t, Qn.range(this, e));
  }
}
class Z {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, t) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + e, i, s, o = t && t.loc;
    if (o && o.start <= o.end) {
      var l = o.lexer.input;
      i = o.start, s = o.end, i === l.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var a = l.slice(i, s).replace(/[^]/g, "$&Ì²"), c;
      i > 15 ? c = "â€¦" + l.slice(i - 15, i) : c = l.slice(0, i);
      var u;
      s + 15 < l.length ? u = l.slice(s, s + 15) + "â€¦" : u = l.slice(s), r += c + a + u;
    }
    var h = new Error(r);
    return h.name = "ParseError", h.__proto__ = Z.prototype, h.position = i, i != null && s != null && (h.length = s - i), h.rawMessage = e, h;
  }
}
Z.prototype.__proto__ = Error.prototype;
var Vte = function(e, t) {
  return e.indexOf(t) !== -1;
}, qte = function(e, t) {
  return e === void 0 ? t : e;
}, Wte = /([A-Z])/g, jte = function(e) {
  return e.replace(Wte, "-$1").toLowerCase();
}, Ute = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Gte = /[&><"']/g;
function Kte(n) {
  return String(n).replace(Gte, (e) => Ute[e]);
}
var YE = function n(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? n(e.body[0]) : e : e.type === "font" ? n(e.body) : e;
}, Yte = function(e) {
  var t = YE(e);
  return t.type === "mathord" || t.type === "textord" || t.type === "atom";
}, Jte = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, Xte = function(e) {
  var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative";
}, xe = {
  contains: Vte,
  deflt: qte,
  escape: Kte,
  hyphenate: jte,
  getBaseElem: YE,
  isCharacterBox: Yte,
  protocolFromUrl: Xte
}, qp = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (n) => "#" + n
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (n, e) => (e.push(n), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (n) => Math.max(0, n),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (n) => Math.max(0, n),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? 1 / 0 : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function Zte(n) {
  if (n.default)
    return n.default;
  var e = n.type, t = Array.isArray(e) ? e[0] : e;
  if (typeof t != "string")
    return t.enum[0];
  switch (t) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class D7 {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var t in qp)
      if (qp.hasOwnProperty(t)) {
        var r = qp[t];
        this[t] = e[t] !== void 0 ? r.processor ? r.processor(e[t]) : e[t] : Zte(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, t, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, t, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new Z("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, t, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, t, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var t = xe.protocolFromUrl(e.url);
      if (t == null)
        return !1;
      e.protocol = t;
    }
    var r = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!r;
  }
}
class fo {
  constructor(e, t, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return qi[Qte[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return qi[ene[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return qi[tne[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return qi[nne[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return qi[rne[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return qi[ine[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var N7 = 0, Zm = 1, pc = 2, Ws = 3, Xf = 4, Jr = 5, su = 6, Bn = 7, qi = [new fo(N7, 0, !1), new fo(Zm, 0, !0), new fo(pc, 1, !1), new fo(Ws, 1, !0), new fo(Xf, 2, !1), new fo(Jr, 2, !0), new fo(su, 3, !1), new fo(Bn, 3, !0)], Qte = [Xf, Jr, Xf, Jr, su, Bn, su, Bn], ene = [Jr, Jr, Jr, Jr, Bn, Bn, Bn, Bn], tne = [pc, Ws, Xf, Jr, su, Bn, su, Bn], nne = [Ws, Ws, Jr, Jr, Bn, Bn, Bn, Bn], rne = [Zm, Zm, Ws, Ws, Jr, Jr, Bn, Bn], ine = [N7, Zm, pc, Ws, pc, Ws, pc, Ws], Ae = {
  DISPLAY: qi[N7],
  TEXT: qi[pc],
  SCRIPT: qi[Xf],
  SCRIPTSCRIPT: qi[su]
}, M5 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900â€“097F)
  // Bengali (0980â€“09FF)
  // Gurmukhi (0A00â€“0A7F)
  // Gujarati (0A80â€“0AFF)
  // Oriya (0B00â€“0B7F)
  // Tamil (0B80â€“0BFF)
  // Telugu (0C00â€“0C7F)
  // Kannada (0C80â€“0CFF)
  // Malayalam (0D00â€“0D7F)
  // Sinhala (0D80â€“0DFF)
  // Thai (0E00â€“0E7F)
  // Lao (0E80â€“0EFF)
  // Tibetan (0F00â€“0FFF)
  // Myanmar (1000â€“109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function sne(n) {
  for (var e = 0; e < M5.length; e++)
    for (var t = M5[e], r = 0; r < t.blocks.length; r++) {
      var i = t.blocks[r];
      if (n >= i[0] && n <= i[1])
        return t.name;
    }
  return null;
}
var Wp = [];
M5.forEach((n) => n.blocks.forEach((e) => Wp.push(...e)));
function JE(n) {
  for (var e = 0; e < Wp.length; e += 2)
    if (n >= Wp[e] && n <= Wp[e + 1])
      return !0;
  return !1;
}
var Fa = 80, one = function(e, t) {
  return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, lne = function(e, t) {
  return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, ane = function(e, t) {
  return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, cne = function(e, t) {
  return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, une = function(e, t) {
  return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, hne = function(e) {
  var t = e / 2;
  return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, fne = function(e, t, r) {
  var i = r - 54 - t - e;
  return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, dne = function(e, t, r) {
  t = 1e3 * t;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = one(t, Fa);
      break;
    case "sqrtSize1":
      i = lne(t, Fa);
      break;
    case "sqrtSize2":
      i = ane(t, Fa);
      break;
    case "sqrtSize3":
      i = cne(t, Fa);
      break;
    case "sqrtSize4":
      i = une(t, Fa);
      break;
    case "sqrtTall":
      i = fne(t, Fa, r);
  }
  return i;
}, pne = function(e, t) {
  switch (e) {
    case "âŽœ":
      return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
    case "âˆ£":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
    case "âˆ¥":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
    case "âŽŸ":
      return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
    case "âŽ¢":
      return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
    case "âŽ¥":
      return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
    case "âŽª":
      return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
    case "â":
      return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
    case "â€–":
      return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
    default:
      return "";
  }
}, ok = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, mne = function(e, t) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class e0 {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return xe.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
      e.appendChild(this.children[t].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", t = 0; t < this.children.length; t++)
      e += this.children[t].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (t) => t.toText();
    return this.children.map(e).join("");
  }
}
var Yi = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, K0 = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, lk = {
  // Latin-1
  Ã…: "A",
  Ã: "D",
  Ãž: "o",
  Ã¥: "a",
  Ã°: "d",
  Ã¾: "o",
  // Cyrillic
  Ð: "A",
  Ð‘: "B",
  Ð’: "B",
  Ð“: "F",
  Ð”: "A",
  Ð•: "E",
  Ð–: "K",
  Ð—: "3",
  Ð˜: "N",
  Ð™: "N",
  Ðš: "K",
  Ð›: "N",
  Ðœ: "M",
  Ð: "H",
  Ðž: "O",
  ÐŸ: "N",
  Ð : "P",
  Ð¡: "C",
  Ð¢: "T",
  Ð£: "y",
  Ð¤: "O",
  Ð¥: "X",
  Ð¦: "U",
  Ð§: "h",
  Ð¨: "W",
  Ð©: "W",
  Ðª: "B",
  Ð«: "X",
  Ð¬: "B",
  Ð­: "3",
  Ð®: "X",
  Ð¯: "R",
  Ð°: "a",
  Ð±: "b",
  Ð²: "a",
  Ð³: "r",
  Ð´: "y",
  Ðµ: "e",
  Ð¶: "m",
  Ð·: "e",
  Ð¸: "n",
  Ð¹: "n",
  Ðº: "n",
  Ð»: "n",
  Ð¼: "m",
  Ð½: "n",
  Ð¾: "o",
  Ð¿: "n",
  Ñ€: "p",
  Ñ: "c",
  Ñ‚: "o",
  Ñƒ: "y",
  Ñ„: "b",
  Ñ…: "x",
  Ñ†: "n",
  Ñ‡: "n",
  Ñˆ: "w",
  Ñ‰: "w",
  ÑŠ: "a",
  Ñ‹: "m",
  ÑŒ: "a",
  Ñ: "e",
  ÑŽ: "m",
  Ñ: "r"
};
function gne(n, e) {
  Yi[n] = e;
}
function R7(n, e, t) {
  if (!Yi[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var r = n.charCodeAt(0), i = Yi[e][r];
  if (!i && n[0] in lk && (r = lk[n[0]].charCodeAt(0), i = Yi[e][r]), !i && t === "text" && JE(r) && (i = Yi[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var r4 = {};
function yne(n) {
  var e;
  if (n >= 5 ? e = 0 : n >= 3 ? e = 1 : e = 2, !r4[e]) {
    var t = r4[e] = {
      cssEmPerMu: K0.quad[e] / 18
    };
    for (var r in K0)
      K0.hasOwnProperty(r) && (t[r] = K0[r][e]);
  }
  return r4[e];
}
var bne = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], ak = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], ck = function(e, t) {
  return t.size < 2 ? e : bne[e - 1][t.size - 1];
};
class As {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || As.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = ak[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var t = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in e)
      e.hasOwnProperty(r) && (t[r] = e[r]);
    return new As(t);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: ck(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: ak[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var t = ck(As.BASESIZE, e);
    return this.size === t && this.textSize === As.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: t
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== As.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + As.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = yne(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
As.BASESIZE = 6;
var T5 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, vne = {
  ex: !0,
  em: !0,
  mu: !0
}, XE = function(e) {
  return typeof e != "string" && (e = e.unit), e in T5 || e in vne || e === "ex";
}, It = function(e, t) {
  var r;
  if (e.unit in T5)
    r = T5[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
  else if (e.unit === "mu")
    r = t.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (t.style.isTight() ? i = t.havingStyle(t.style.text()) : i = t, e.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new Z("Invalid unit: '" + e.unit + "'");
    i !== t && (r *= i.sizeMultiplier / t.sizeMultiplier);
  }
  return Math.min(e.number * r, t.maxSize);
}, re = function(e) {
  return +e.toFixed(4) + "em";
}, Xo = function(e) {
  return e.filter((t) => t).join(" ");
}, ZE = function(e, t, r) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, t) {
    t.style.isTight() && this.classes.push("mtight");
    var i = t.getColor();
    i && (this.style.color = i);
  }
}, QE = function(e) {
  var t = document.createElement(e);
  t.className = Xo(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
  for (var s = 0; s < this.children.length; s++)
    t.appendChild(this.children[s].toNode());
  return t;
}, wne = /[\s"'>/=\x00-\x1f]/, eI = function(e) {
  var t = "<" + e;
  this.classes.length && (t += ' class="' + xe.escape(Xo(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += xe.hyphenate(i) + ":" + this.style[i] + ";");
  r && (t += ' style="' + xe.escape(r) + '"');
  for (var s in this.attributes)
    if (this.attributes.hasOwnProperty(s)) {
      if (wne.test(s))
        throw new Z("Invalid attribute name '" + s + "'");
      t += " " + s + '="' + xe.escape(this.attributes[s]) + '"';
    }
  t += ">";
  for (var o = 0; o < this.children.length; o++)
    t += this.children[o].toMarkup();
  return t += "</" + e + ">", t;
};
class t0 {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, ZE.call(this, e, r, i), this.children = t || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return xe.contains(this.classes, e);
  }
  toNode() {
    return QE.call(this, "span");
  }
  toMarkup() {
    return eI.call(this, "span");
  }
}
class P7 {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, ZE.call(this, t, i), this.children = r || [], this.setAttribute("href", e);
  }
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return xe.contains(this.classes, e);
  }
  toNode() {
    return QE.call(this, "a");
  }
  toMarkup() {
    return eI.call(this, "a");
  }
}
class xne {
  constructor(e, t, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = r;
  }
  hasClass(e) {
    return xe.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var t in this.style)
      this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + xe.escape(this.src) + '"' + (' alt="' + xe.escape(this.alt) + '"'), t = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t += xe.hyphenate(r) + ":" + this.style[r] + ";");
    return t && (e += ' style="' + xe.escape(t) + '"'), e += "'/>", e;
  }
}
var kne = {
  Ã®: "Ä±Ì‚",
  Ã¯: "Ä±Ìˆ",
  Ã­: "Ä±Ì",
  // 'Ä«': '\u0131\u0304', // enable when we add Extended Latin
  Ã¬: "Ä±Ì€"
};
class ii {
  constructor(e, t, r, i, s, o, l, a) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = r || 0, this.italic = i || 0, this.skew = s || 0, this.width = o || 0, this.classes = l || [], this.style = a || {}, this.maxFontSize = 0;
    var c = sne(this.text.charCodeAt(0));
    c && this.classes.push(c + "_fallback"), /[Ã®Ã¯Ã­Ã¬]/.test(this.text) && (this.text = kne[this.text]);
  }
  hasClass(e) {
    return xe.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), t = null;
    this.italic > 0 && (t = document.createElement("span"), t.style.marginRight = re(this.italic)), this.classes.length > 0 && (t = t || document.createElement("span"), t.className = Xo(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t = t || document.createElement("span"), t.style[r] = this.style[r]);
    return t ? (t.appendChild(e), t) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, t = "<span";
    this.classes.length && (e = !0, t += ' class="', t += xe.escape(Xo(this.classes)), t += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += xe.hyphenate(i) + ":" + this.style[i] + ";");
    r && (e = !0, t += ' style="' + xe.escape(r) + '"');
    var s = xe.escape(this.text);
    return e ? (t += ">", t += s, t += "</span>", t) : s;
  }
}
class Js {
  constructor(e, t) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      t.appendChild(this.children[i].toNode());
    return t;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + xe.escape(this.attributes[t]) + '"');
    e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</svg>", e;
  }
}
class Zo {
  constructor(e, t) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "path");
    return this.alternate ? t.setAttribute("d", this.alternate) : t.setAttribute("d", ok[this.pathName]), t;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + xe.escape(this.alternate) + '"/>' : '<path d="' + xe.escape(ok[this.pathName]) + '"/>';
  }
}
class A5 {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    return t;
  }
  toMarkup() {
    var e = "<line";
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + xe.escape(this.attributes[t]) + '"');
    return e += "/>", e;
  }
}
function uk(n) {
  if (n instanceof ii)
    return n;
  throw new Error("Expected symbolNode but got " + String(n) + ".");
}
function Sne(n) {
  if (n instanceof t0)
    return n;
  throw new Error("Expected span<HtmlDomNode> but got " + String(n) + ".");
}
var Cne = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, Mne = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, gt = {
  math: {},
  text: {}
};
function y(n, e, t, r, i, s) {
  gt[n][i] = {
    font: e,
    group: t,
    replace: r
  }, s && r && (gt[n][r] = gt[n][i]);
}
var v = "math", J = "text", x = "main", A = "ams", Mt = "accent-token", fe = "bin", jn = "close", Mu = "inner", Te = "mathord", Gt = "op-token", Pr = "open", fg = "punct", E = "rel", oo = "spacing", P = "textord";
y(v, x, E, "â‰¡", "\\equiv", !0);
y(v, x, E, "â‰º", "\\prec", !0);
y(v, x, E, "â‰»", "\\succ", !0);
y(v, x, E, "âˆ¼", "\\sim", !0);
y(v, x, E, "âŠ¥", "\\perp");
y(v, x, E, "âª¯", "\\preceq", !0);
y(v, x, E, "âª°", "\\succeq", !0);
y(v, x, E, "â‰ƒ", "\\simeq", !0);
y(v, x, E, "âˆ£", "\\mid", !0);
y(v, x, E, "â‰ª", "\\ll", !0);
y(v, x, E, "â‰«", "\\gg", !0);
y(v, x, E, "â‰", "\\asymp", !0);
y(v, x, E, "âˆ¥", "\\parallel");
y(v, x, E, "â‹ˆ", "\\bowtie", !0);
y(v, x, E, "âŒ£", "\\smile", !0);
y(v, x, E, "âŠ‘", "\\sqsubseteq", !0);
y(v, x, E, "âŠ’", "\\sqsupseteq", !0);
y(v, x, E, "â‰", "\\doteq", !0);
y(v, x, E, "âŒ¢", "\\frown", !0);
y(v, x, E, "âˆ‹", "\\ni", !0);
y(v, x, E, "âˆ", "\\propto", !0);
y(v, x, E, "âŠ¢", "\\vdash", !0);
y(v, x, E, "âŠ£", "\\dashv", !0);
y(v, x, E, "âˆ‹", "\\owns");
y(v, x, fg, ".", "\\ldotp");
y(v, x, fg, "â‹…", "\\cdotp");
y(v, x, P, "#", "\\#");
y(J, x, P, "#", "\\#");
y(v, x, P, "&", "\\&");
y(J, x, P, "&", "\\&");
y(v, x, P, "â„µ", "\\aleph", !0);
y(v, x, P, "âˆ€", "\\forall", !0);
y(v, x, P, "â„", "\\hbar", !0);
y(v, x, P, "âˆƒ", "\\exists", !0);
y(v, x, P, "âˆ‡", "\\nabla", !0);
y(v, x, P, "â™­", "\\flat", !0);
y(v, x, P, "â„“", "\\ell", !0);
y(v, x, P, "â™®", "\\natural", !0);
y(v, x, P, "â™£", "\\clubsuit", !0);
y(v, x, P, "â„˜", "\\wp", !0);
y(v, x, P, "â™¯", "\\sharp", !0);
y(v, x, P, "â™¢", "\\diamondsuit", !0);
y(v, x, P, "â„œ", "\\Re", !0);
y(v, x, P, "â™¡", "\\heartsuit", !0);
y(v, x, P, "â„‘", "\\Im", !0);
y(v, x, P, "â™ ", "\\spadesuit", !0);
y(v, x, P, "Â§", "\\S", !0);
y(J, x, P, "Â§", "\\S");
y(v, x, P, "Â¶", "\\P", !0);
y(J, x, P, "Â¶", "\\P");
y(v, x, P, "â€ ", "\\dag");
y(J, x, P, "â€ ", "\\dag");
y(J, x, P, "â€ ", "\\textdagger");
y(v, x, P, "â€¡", "\\ddag");
y(J, x, P, "â€¡", "\\ddag");
y(J, x, P, "â€¡", "\\textdaggerdbl");
y(v, x, jn, "âŽ±", "\\rmoustache", !0);
y(v, x, Pr, "âŽ°", "\\lmoustache", !0);
y(v, x, jn, "âŸ¯", "\\rgroup", !0);
y(v, x, Pr, "âŸ®", "\\lgroup", !0);
y(v, x, fe, "âˆ“", "\\mp", !0);
y(v, x, fe, "âŠ–", "\\ominus", !0);
y(v, x, fe, "âŠŽ", "\\uplus", !0);
y(v, x, fe, "âŠ“", "\\sqcap", !0);
y(v, x, fe, "âˆ—", "\\ast");
y(v, x, fe, "âŠ”", "\\sqcup", !0);
y(v, x, fe, "â—¯", "\\bigcirc", !0);
y(v, x, fe, "âˆ™", "\\bullet", !0);
y(v, x, fe, "â€¡", "\\ddagger");
y(v, x, fe, "â‰€", "\\wr", !0);
y(v, x, fe, "â¨¿", "\\amalg");
y(v, x, fe, "&", "\\And");
y(v, x, E, "âŸµ", "\\longleftarrow", !0);
y(v, x, E, "â‡", "\\Leftarrow", !0);
y(v, x, E, "âŸ¸", "\\Longleftarrow", !0);
y(v, x, E, "âŸ¶", "\\longrightarrow", !0);
y(v, x, E, "â‡’", "\\Rightarrow", !0);
y(v, x, E, "âŸ¹", "\\Longrightarrow", !0);
y(v, x, E, "â†”", "\\leftrightarrow", !0);
y(v, x, E, "âŸ·", "\\longleftrightarrow", !0);
y(v, x, E, "â‡”", "\\Leftrightarrow", !0);
y(v, x, E, "âŸº", "\\Longleftrightarrow", !0);
y(v, x, E, "â†¦", "\\mapsto", !0);
y(v, x, E, "âŸ¼", "\\longmapsto", !0);
y(v, x, E, "â†—", "\\nearrow", !0);
y(v, x, E, "â†©", "\\hookleftarrow", !0);
y(v, x, E, "â†ª", "\\hookrightarrow", !0);
y(v, x, E, "â†˜", "\\searrow", !0);
y(v, x, E, "â†¼", "\\leftharpoonup", !0);
y(v, x, E, "â‡€", "\\rightharpoonup", !0);
y(v, x, E, "â†™", "\\swarrow", !0);
y(v, x, E, "â†½", "\\leftharpoondown", !0);
y(v, x, E, "â‡", "\\rightharpoondown", !0);
y(v, x, E, "â†–", "\\nwarrow", !0);
y(v, x, E, "â‡Œ", "\\rightleftharpoons", !0);
y(v, A, E, "â‰®", "\\nless", !0);
y(v, A, E, "î€", "\\@nleqslant");
y(v, A, E, "î€‘", "\\@nleqq");
y(v, A, E, "âª‡", "\\lneq", !0);
y(v, A, E, "â‰¨", "\\lneqq", !0);
y(v, A, E, "î€Œ", "\\@lvertneqq");
y(v, A, E, "â‹¦", "\\lnsim", !0);
y(v, A, E, "âª‰", "\\lnapprox", !0);
y(v, A, E, "âŠ€", "\\nprec", !0);
y(v, A, E, "â‹ ", "\\npreceq", !0);
y(v, A, E, "â‹¨", "\\precnsim", !0);
y(v, A, E, "âª¹", "\\precnapprox", !0);
y(v, A, E, "â‰", "\\nsim", !0);
y(v, A, E, "î€†", "\\@nshortmid");
y(v, A, E, "âˆ¤", "\\nmid", !0);
y(v, A, E, "âŠ¬", "\\nvdash", !0);
y(v, A, E, "âŠ­", "\\nvDash", !0);
y(v, A, E, "â‹ª", "\\ntriangleleft");
y(v, A, E, "â‹¬", "\\ntrianglelefteq", !0);
y(v, A, E, "âŠŠ", "\\subsetneq", !0);
y(v, A, E, "î€š", "\\@varsubsetneq");
y(v, A, E, "â«‹", "\\subsetneqq", !0);
y(v, A, E, "î€—", "\\@varsubsetneqq");
y(v, A, E, "â‰¯", "\\ngtr", !0);
y(v, A, E, "î€", "\\@ngeqslant");
y(v, A, E, "î€Ž", "\\@ngeqq");
y(v, A, E, "âªˆ", "\\gneq", !0);
y(v, A, E, "â‰©", "\\gneqq", !0);
y(v, A, E, "î€", "\\@gvertneqq");
y(v, A, E, "â‹§", "\\gnsim", !0);
y(v, A, E, "âªŠ", "\\gnapprox", !0);
y(v, A, E, "âŠ", "\\nsucc", !0);
y(v, A, E, "â‹¡", "\\nsucceq", !0);
y(v, A, E, "â‹©", "\\succnsim", !0);
y(v, A, E, "âªº", "\\succnapprox", !0);
y(v, A, E, "â‰†", "\\ncong", !0);
y(v, A, E, "î€‡", "\\@nshortparallel");
y(v, A, E, "âˆ¦", "\\nparallel", !0);
y(v, A, E, "âŠ¯", "\\nVDash", !0);
y(v, A, E, "â‹«", "\\ntriangleright");
y(v, A, E, "â‹­", "\\ntrianglerighteq", !0);
y(v, A, E, "î€˜", "\\@nsupseteqq");
y(v, A, E, "âŠ‹", "\\supsetneq", !0);
y(v, A, E, "î€›", "\\@varsupsetneq");
y(v, A, E, "â«Œ", "\\supsetneqq", !0);
y(v, A, E, "î€™", "\\@varsupsetneqq");
y(v, A, E, "âŠ®", "\\nVdash", !0);
y(v, A, E, "âªµ", "\\precneqq", !0);
y(v, A, E, "âª¶", "\\succneqq", !0);
y(v, A, E, "î€–", "\\@nsubseteqq");
y(v, A, fe, "âŠ´", "\\unlhd");
y(v, A, fe, "âŠµ", "\\unrhd");
y(v, A, E, "â†š", "\\nleftarrow", !0);
y(v, A, E, "â†›", "\\nrightarrow", !0);
y(v, A, E, "â‡", "\\nLeftarrow", !0);
y(v, A, E, "â‡", "\\nRightarrow", !0);
y(v, A, E, "â†®", "\\nleftrightarrow", !0);
y(v, A, E, "â‡Ž", "\\nLeftrightarrow", !0);
y(v, A, E, "â–³", "\\vartriangle");
y(v, A, P, "â„", "\\hslash");
y(v, A, P, "â–½", "\\triangledown");
y(v, A, P, "â—Š", "\\lozenge");
y(v, A, P, "â“ˆ", "\\circledS");
y(v, A, P, "Â®", "\\circledR");
y(J, A, P, "Â®", "\\circledR");
y(v, A, P, "âˆ¡", "\\measuredangle", !0);
y(v, A, P, "âˆ„", "\\nexists");
y(v, A, P, "â„§", "\\mho");
y(v, A, P, "â„²", "\\Finv", !0);
y(v, A, P, "â…", "\\Game", !0);
y(v, A, P, "â€µ", "\\backprime");
y(v, A, P, "â–²", "\\blacktriangle");
y(v, A, P, "â–¼", "\\blacktriangledown");
y(v, A, P, "â– ", "\\blacksquare");
y(v, A, P, "â§«", "\\blacklozenge");
y(v, A, P, "â˜…", "\\bigstar");
y(v, A, P, "âˆ¢", "\\sphericalangle", !0);
y(v, A, P, "âˆ", "\\complement", !0);
y(v, A, P, "Ã°", "\\eth", !0);
y(J, x, P, "Ã°", "Ã°");
y(v, A, P, "â•±", "\\diagup");
y(v, A, P, "â•²", "\\diagdown");
y(v, A, P, "â–¡", "\\square");
y(v, A, P, "â–¡", "\\Box");
y(v, A, P, "â—Š", "\\Diamond");
y(v, A, P, "Â¥", "\\yen", !0);
y(J, A, P, "Â¥", "\\yen", !0);
y(v, A, P, "âœ“", "\\checkmark", !0);
y(J, A, P, "âœ“", "\\checkmark");
y(v, A, P, "â„¶", "\\beth", !0);
y(v, A, P, "â„¸", "\\daleth", !0);
y(v, A, P, "â„·", "\\gimel", !0);
y(v, A, P, "Ï", "\\digamma", !0);
y(v, A, P, "Ï°", "\\varkappa");
y(v, A, Pr, "â”Œ", "\\@ulcorner", !0);
y(v, A, jn, "â”", "\\@urcorner", !0);
y(v, A, Pr, "â””", "\\@llcorner", !0);
y(v, A, jn, "â”˜", "\\@lrcorner", !0);
y(v, A, E, "â‰¦", "\\leqq", !0);
y(v, A, E, "â©½", "\\leqslant", !0);
y(v, A, E, "âª•", "\\eqslantless", !0);
y(v, A, E, "â‰²", "\\lesssim", !0);
y(v, A, E, "âª…", "\\lessapprox", !0);
y(v, A, E, "â‰Š", "\\approxeq", !0);
y(v, A, fe, "â‹–", "\\lessdot");
y(v, A, E, "â‹˜", "\\lll", !0);
y(v, A, E, "â‰¶", "\\lessgtr", !0);
y(v, A, E, "â‹š", "\\lesseqgtr", !0);
y(v, A, E, "âª‹", "\\lesseqqgtr", !0);
y(v, A, E, "â‰‘", "\\doteqdot");
y(v, A, E, "â‰“", "\\risingdotseq", !0);
y(v, A, E, "â‰’", "\\fallingdotseq", !0);
y(v, A, E, "âˆ½", "\\backsim", !0);
y(v, A, E, "â‹", "\\backsimeq", !0);
y(v, A, E, "â«…", "\\subseteqq", !0);
y(v, A, E, "â‹", "\\Subset", !0);
y(v, A, E, "âŠ", "\\sqsubset", !0);
y(v, A, E, "â‰¼", "\\preccurlyeq", !0);
y(v, A, E, "â‹ž", "\\curlyeqprec", !0);
y(v, A, E, "â‰¾", "\\precsim", !0);
y(v, A, E, "âª·", "\\precapprox", !0);
y(v, A, E, "âŠ²", "\\vartriangleleft");
y(v, A, E, "âŠ´", "\\trianglelefteq");
y(v, A, E, "âŠ¨", "\\vDash", !0);
y(v, A, E, "âŠª", "\\Vvdash", !0);
y(v, A, E, "âŒ£", "\\smallsmile");
y(v, A, E, "âŒ¢", "\\smallfrown");
y(v, A, E, "â‰", "\\bumpeq", !0);
y(v, A, E, "â‰Ž", "\\Bumpeq", !0);
y(v, A, E, "â‰§", "\\geqq", !0);
y(v, A, E, "â©¾", "\\geqslant", !0);
y(v, A, E, "âª–", "\\eqslantgtr", !0);
y(v, A, E, "â‰³", "\\gtrsim", !0);
y(v, A, E, "âª†", "\\gtrapprox", !0);
y(v, A, fe, "â‹—", "\\gtrdot");
y(v, A, E, "â‹™", "\\ggg", !0);
y(v, A, E, "â‰·", "\\gtrless", !0);
y(v, A, E, "â‹›", "\\gtreqless", !0);
y(v, A, E, "âªŒ", "\\gtreqqless", !0);
y(v, A, E, "â‰–", "\\eqcirc", !0);
y(v, A, E, "â‰—", "\\circeq", !0);
y(v, A, E, "â‰œ", "\\triangleq", !0);
y(v, A, E, "âˆ¼", "\\thicksim");
y(v, A, E, "â‰ˆ", "\\thickapprox");
y(v, A, E, "â«†", "\\supseteqq", !0);
y(v, A, E, "â‹‘", "\\Supset", !0);
y(v, A, E, "âŠ", "\\sqsupset", !0);
y(v, A, E, "â‰½", "\\succcurlyeq", !0);
y(v, A, E, "â‹Ÿ", "\\curlyeqsucc", !0);
y(v, A, E, "â‰¿", "\\succsim", !0);
y(v, A, E, "âª¸", "\\succapprox", !0);
y(v, A, E, "âŠ³", "\\vartriangleright");
y(v, A, E, "âŠµ", "\\trianglerighteq");
y(v, A, E, "âŠ©", "\\Vdash", !0);
y(v, A, E, "âˆ£", "\\shortmid");
y(v, A, E, "âˆ¥", "\\shortparallel");
y(v, A, E, "â‰¬", "\\between", !0);
y(v, A, E, "â‹”", "\\pitchfork", !0);
y(v, A, E, "âˆ", "\\varpropto");
y(v, A, E, "â—€", "\\blacktriangleleft");
y(v, A, E, "âˆ´", "\\therefore", !0);
y(v, A, E, "âˆ", "\\backepsilon");
y(v, A, E, "â–¶", "\\blacktriangleright");
y(v, A, E, "âˆµ", "\\because", !0);
y(v, A, E, "â‹˜", "\\llless");
y(v, A, E, "â‹™", "\\gggtr");
y(v, A, fe, "âŠ²", "\\lhd");
y(v, A, fe, "âŠ³", "\\rhd");
y(v, A, E, "â‰‚", "\\eqsim", !0);
y(v, x, E, "â‹ˆ", "\\Join");
y(v, A, E, "â‰‘", "\\Doteq", !0);
y(v, A, fe, "âˆ”", "\\dotplus", !0);
y(v, A, fe, "âˆ–", "\\smallsetminus");
y(v, A, fe, "â‹’", "\\Cap", !0);
y(v, A, fe, "â‹“", "\\Cup", !0);
y(v, A, fe, "â©ž", "\\doublebarwedge", !0);
y(v, A, fe, "âŠŸ", "\\boxminus", !0);
y(v, A, fe, "âŠž", "\\boxplus", !0);
y(v, A, fe, "â‹‡", "\\divideontimes", !0);
y(v, A, fe, "â‹‰", "\\ltimes", !0);
y(v, A, fe, "â‹Š", "\\rtimes", !0);
y(v, A, fe, "â‹‹", "\\leftthreetimes", !0);
y(v, A, fe, "â‹Œ", "\\rightthreetimes", !0);
y(v, A, fe, "â‹", "\\curlywedge", !0);
y(v, A, fe, "â‹Ž", "\\curlyvee", !0);
y(v, A, fe, "âŠ", "\\circleddash", !0);
y(v, A, fe, "âŠ›", "\\circledast", !0);
y(v, A, fe, "â‹…", "\\centerdot");
y(v, A, fe, "âŠº", "\\intercal", !0);
y(v, A, fe, "â‹’", "\\doublecap");
y(v, A, fe, "â‹“", "\\doublecup");
y(v, A, fe, "âŠ ", "\\boxtimes", !0);
y(v, A, E, "â‡¢", "\\dashrightarrow", !0);
y(v, A, E, "â‡ ", "\\dashleftarrow", !0);
y(v, A, E, "â‡‡", "\\leftleftarrows", !0);
y(v, A, E, "â‡†", "\\leftrightarrows", !0);
y(v, A, E, "â‡š", "\\Lleftarrow", !0);
y(v, A, E, "â†ž", "\\twoheadleftarrow", !0);
y(v, A, E, "â†¢", "\\leftarrowtail", !0);
y(v, A, E, "â†«", "\\looparrowleft", !0);
y(v, A, E, "â‡‹", "\\leftrightharpoons", !0);
y(v, A, E, "â†¶", "\\curvearrowleft", !0);
y(v, A, E, "â†º", "\\circlearrowleft", !0);
y(v, A, E, "â†°", "\\Lsh", !0);
y(v, A, E, "â‡ˆ", "\\upuparrows", !0);
y(v, A, E, "â†¿", "\\upharpoonleft", !0);
y(v, A, E, "â‡ƒ", "\\downharpoonleft", !0);
y(v, x, E, "âŠ¶", "\\origof", !0);
y(v, x, E, "âŠ·", "\\imageof", !0);
y(v, A, E, "âŠ¸", "\\multimap", !0);
y(v, A, E, "â†­", "\\leftrightsquigarrow", !0);
y(v, A, E, "â‡‰", "\\rightrightarrows", !0);
y(v, A, E, "â‡„", "\\rightleftarrows", !0);
y(v, A, E, "â† ", "\\twoheadrightarrow", !0);
y(v, A, E, "â†£", "\\rightarrowtail", !0);
y(v, A, E, "â†¬", "\\looparrowright", !0);
y(v, A, E, "â†·", "\\curvearrowright", !0);
y(v, A, E, "â†»", "\\circlearrowright", !0);
y(v, A, E, "â†±", "\\Rsh", !0);
y(v, A, E, "â‡Š", "\\downdownarrows", !0);
y(v, A, E, "â†¾", "\\upharpoonright", !0);
y(v, A, E, "â‡‚", "\\downharpoonright", !0);
y(v, A, E, "â‡", "\\rightsquigarrow", !0);
y(v, A, E, "â‡", "\\leadsto");
y(v, A, E, "â‡›", "\\Rrightarrow", !0);
y(v, A, E, "â†¾", "\\restriction");
y(v, x, P, "â€˜", "`");
y(v, x, P, "$", "\\$");
y(J, x, P, "$", "\\$");
y(J, x, P, "$", "\\textdollar");
y(v, x, P, "%", "\\%");
y(J, x, P, "%", "\\%");
y(v, x, P, "_", "\\_");
y(J, x, P, "_", "\\_");
y(J, x, P, "_", "\\textunderscore");
y(v, x, P, "âˆ ", "\\angle", !0);
y(v, x, P, "âˆž", "\\infty", !0);
y(v, x, P, "â€²", "\\prime");
y(v, x, P, "â–³", "\\triangle");
y(v, x, P, "Î“", "\\Gamma", !0);
y(v, x, P, "Î”", "\\Delta", !0);
y(v, x, P, "Î˜", "\\Theta", !0);
y(v, x, P, "Î›", "\\Lambda", !0);
y(v, x, P, "Îž", "\\Xi", !0);
y(v, x, P, "Î ", "\\Pi", !0);
y(v, x, P, "Î£", "\\Sigma", !0);
y(v, x, P, "Î¥", "\\Upsilon", !0);
y(v, x, P, "Î¦", "\\Phi", !0);
y(v, x, P, "Î¨", "\\Psi", !0);
y(v, x, P, "Î©", "\\Omega", !0);
y(v, x, P, "A", "Î‘");
y(v, x, P, "B", "Î’");
y(v, x, P, "E", "Î•");
y(v, x, P, "Z", "Î–");
y(v, x, P, "H", "Î—");
y(v, x, P, "I", "Î™");
y(v, x, P, "K", "Îš");
y(v, x, P, "M", "Îœ");
y(v, x, P, "N", "Î");
y(v, x, P, "O", "ÎŸ");
y(v, x, P, "P", "Î¡");
y(v, x, P, "T", "Î¤");
y(v, x, P, "X", "Î§");
y(v, x, P, "Â¬", "\\neg", !0);
y(v, x, P, "Â¬", "\\lnot");
y(v, x, P, "âŠ¤", "\\top");
y(v, x, P, "âŠ¥", "\\bot");
y(v, x, P, "âˆ…", "\\emptyset");
y(v, A, P, "âˆ…", "\\varnothing");
y(v, x, Te, "Î±", "\\alpha", !0);
y(v, x, Te, "Î²", "\\beta", !0);
y(v, x, Te, "Î³", "\\gamma", !0);
y(v, x, Te, "Î´", "\\delta", !0);
y(v, x, Te, "Ïµ", "\\epsilon", !0);
y(v, x, Te, "Î¶", "\\zeta", !0);
y(v, x, Te, "Î·", "\\eta", !0);
y(v, x, Te, "Î¸", "\\theta", !0);
y(v, x, Te, "Î¹", "\\iota", !0);
y(v, x, Te, "Îº", "\\kappa", !0);
y(v, x, Te, "Î»", "\\lambda", !0);
y(v, x, Te, "Î¼", "\\mu", !0);
y(v, x, Te, "Î½", "\\nu", !0);
y(v, x, Te, "Î¾", "\\xi", !0);
y(v, x, Te, "Î¿", "\\omicron", !0);
y(v, x, Te, "Ï€", "\\pi", !0);
y(v, x, Te, "Ï", "\\rho", !0);
y(v, x, Te, "Ïƒ", "\\sigma", !0);
y(v, x, Te, "Ï„", "\\tau", !0);
y(v, x, Te, "Ï…", "\\upsilon", !0);
y(v, x, Te, "Ï•", "\\phi", !0);
y(v, x, Te, "Ï‡", "\\chi", !0);
y(v, x, Te, "Ïˆ", "\\psi", !0);
y(v, x, Te, "Ï‰", "\\omega", !0);
y(v, x, Te, "Îµ", "\\varepsilon", !0);
y(v, x, Te, "Ï‘", "\\vartheta", !0);
y(v, x, Te, "Ï–", "\\varpi", !0);
y(v, x, Te, "Ï±", "\\varrho", !0);
y(v, x, Te, "Ï‚", "\\varsigma", !0);
y(v, x, Te, "Ï†", "\\varphi", !0);
y(v, x, fe, "âˆ—", "*", !0);
y(v, x, fe, "+", "+");
y(v, x, fe, "âˆ’", "-", !0);
y(v, x, fe, "â‹…", "\\cdot", !0);
y(v, x, fe, "âˆ˜", "\\circ", !0);
y(v, x, fe, "Ã·", "\\div", !0);
y(v, x, fe, "Â±", "\\pm", !0);
y(v, x, fe, "Ã—", "\\times", !0);
y(v, x, fe, "âˆ©", "\\cap", !0);
y(v, x, fe, "âˆª", "\\cup", !0);
y(v, x, fe, "âˆ–", "\\setminus", !0);
y(v, x, fe, "âˆ§", "\\land");
y(v, x, fe, "âˆ¨", "\\lor");
y(v, x, fe, "âˆ§", "\\wedge", !0);
y(v, x, fe, "âˆ¨", "\\vee", !0);
y(v, x, P, "âˆš", "\\surd");
y(v, x, Pr, "âŸ¨", "\\langle", !0);
y(v, x, Pr, "âˆ£", "\\lvert");
y(v, x, Pr, "âˆ¥", "\\lVert");
y(v, x, jn, "?", "?");
y(v, x, jn, "!", "!");
y(v, x, jn, "âŸ©", "\\rangle", !0);
y(v, x, jn, "âˆ£", "\\rvert");
y(v, x, jn, "âˆ¥", "\\rVert");
y(v, x, E, "=", "=");
y(v, x, E, ":", ":");
y(v, x, E, "â‰ˆ", "\\approx", !0);
y(v, x, E, "â‰…", "\\cong", !0);
y(v, x, E, "â‰¥", "\\ge");
y(v, x, E, "â‰¥", "\\geq", !0);
y(v, x, E, "â†", "\\gets");
y(v, x, E, ">", "\\gt", !0);
y(v, x, E, "âˆˆ", "\\in", !0);
y(v, x, E, "î€ ", "\\@not");
y(v, x, E, "âŠ‚", "\\subset", !0);
y(v, x, E, "âŠƒ", "\\supset", !0);
y(v, x, E, "âŠ†", "\\subseteq", !0);
y(v, x, E, "âŠ‡", "\\supseteq", !0);
y(v, A, E, "âŠˆ", "\\nsubseteq", !0);
y(v, A, E, "âŠ‰", "\\nsupseteq", !0);
y(v, x, E, "âŠ¨", "\\models");
y(v, x, E, "â†", "\\leftarrow", !0);
y(v, x, E, "â‰¤", "\\le");
y(v, x, E, "â‰¤", "\\leq", !0);
y(v, x, E, "<", "\\lt", !0);
y(v, x, E, "â†’", "\\rightarrow", !0);
y(v, x, E, "â†’", "\\to");
y(v, A, E, "â‰±", "\\ngeq", !0);
y(v, A, E, "â‰°", "\\nleq", !0);
y(v, x, oo, "Â ", "\\ ");
y(v, x, oo, "Â ", "\\space");
y(v, x, oo, "Â ", "\\nobreakspace");
y(J, x, oo, "Â ", "\\ ");
y(J, x, oo, "Â ", " ");
y(J, x, oo, "Â ", "\\space");
y(J, x, oo, "Â ", "\\nobreakspace");
y(v, x, oo, null, "\\nobreak");
y(v, x, oo, null, "\\allowbreak");
y(v, x, fg, ",", ",");
y(v, x, fg, ";", ";");
y(v, A, fe, "âŠ¼", "\\barwedge", !0);
y(v, A, fe, "âŠ»", "\\veebar", !0);
y(v, x, fe, "âŠ™", "\\odot", !0);
y(v, x, fe, "âŠ•", "\\oplus", !0);
y(v, x, fe, "âŠ—", "\\otimes", !0);
y(v, x, P, "âˆ‚", "\\partial", !0);
y(v, x, fe, "âŠ˜", "\\oslash", !0);
y(v, A, fe, "âŠš", "\\circledcirc", !0);
y(v, A, fe, "âŠ¡", "\\boxdot", !0);
y(v, x, fe, "â–³", "\\bigtriangleup");
y(v, x, fe, "â–½", "\\bigtriangledown");
y(v, x, fe, "â€ ", "\\dagger");
y(v, x, fe, "â‹„", "\\diamond");
y(v, x, fe, "â‹†", "\\star");
y(v, x, fe, "â—ƒ", "\\triangleleft");
y(v, x, fe, "â–¹", "\\triangleright");
y(v, x, Pr, "{", "\\{");
y(J, x, P, "{", "\\{");
y(J, x, P, "{", "\\textbraceleft");
y(v, x, jn, "}", "\\}");
y(J, x, P, "}", "\\}");
y(J, x, P, "}", "\\textbraceright");
y(v, x, Pr, "{", "\\lbrace");
y(v, x, jn, "}", "\\rbrace");
y(v, x, Pr, "[", "\\lbrack", !0);
y(J, x, P, "[", "\\lbrack", !0);
y(v, x, jn, "]", "\\rbrack", !0);
y(J, x, P, "]", "\\rbrack", !0);
y(v, x, Pr, "(", "\\lparen", !0);
y(v, x, jn, ")", "\\rparen", !0);
y(J, x, P, "<", "\\textless", !0);
y(J, x, P, ">", "\\textgreater", !0);
y(v, x, Pr, "âŒŠ", "\\lfloor", !0);
y(v, x, jn, "âŒ‹", "\\rfloor", !0);
y(v, x, Pr, "âŒˆ", "\\lceil", !0);
y(v, x, jn, "âŒ‰", "\\rceil", !0);
y(v, x, P, "\\", "\\backslash");
y(v, x, P, "âˆ£", "|");
y(v, x, P, "âˆ£", "\\vert");
y(J, x, P, "|", "\\textbar", !0);
y(v, x, P, "âˆ¥", "\\|");
y(v, x, P, "âˆ¥", "\\Vert");
y(J, x, P, "âˆ¥", "\\textbardbl");
y(J, x, P, "~", "\\textasciitilde");
y(J, x, P, "\\", "\\textbackslash");
y(J, x, P, "^", "\\textasciicircum");
y(v, x, E, "â†‘", "\\uparrow", !0);
y(v, x, E, "â‡‘", "\\Uparrow", !0);
y(v, x, E, "â†“", "\\downarrow", !0);
y(v, x, E, "â‡“", "\\Downarrow", !0);
y(v, x, E, "â†•", "\\updownarrow", !0);
y(v, x, E, "â‡•", "\\Updownarrow", !0);
y(v, x, Gt, "âˆ", "\\coprod");
y(v, x, Gt, "â‹", "\\bigvee");
y(v, x, Gt, "â‹€", "\\bigwedge");
y(v, x, Gt, "â¨„", "\\biguplus");
y(v, x, Gt, "â‹‚", "\\bigcap");
y(v, x, Gt, "â‹ƒ", "\\bigcup");
y(v, x, Gt, "âˆ«", "\\int");
y(v, x, Gt, "âˆ«", "\\intop");
y(v, x, Gt, "âˆ¬", "\\iint");
y(v, x, Gt, "âˆ­", "\\iiint");
y(v, x, Gt, "âˆ", "\\prod");
y(v, x, Gt, "âˆ‘", "\\sum");
y(v, x, Gt, "â¨‚", "\\bigotimes");
y(v, x, Gt, "â¨", "\\bigoplus");
y(v, x, Gt, "â¨€", "\\bigodot");
y(v, x, Gt, "âˆ®", "\\oint");
y(v, x, Gt, "âˆ¯", "\\oiint");
y(v, x, Gt, "âˆ°", "\\oiiint");
y(v, x, Gt, "â¨†", "\\bigsqcup");
y(v, x, Gt, "âˆ«", "\\smallint");
y(J, x, Mu, "â€¦", "\\textellipsis");
y(v, x, Mu, "â€¦", "\\mathellipsis");
y(J, x, Mu, "â€¦", "\\ldots", !0);
y(v, x, Mu, "â€¦", "\\ldots", !0);
y(v, x, Mu, "â‹¯", "\\@cdots", !0);
y(v, x, Mu, "â‹±", "\\ddots", !0);
y(v, x, P, "â‹®", "\\varvdots");
y(J, x, P, "â‹®", "\\varvdots");
y(v, x, Mt, "ËŠ", "\\acute");
y(v, x, Mt, "Ë‹", "\\grave");
y(v, x, Mt, "Â¨", "\\ddot");
y(v, x, Mt, "~", "\\tilde");
y(v, x, Mt, "Ë‰", "\\bar");
y(v, x, Mt, "Ë˜", "\\breve");
y(v, x, Mt, "Ë‡", "\\check");
y(v, x, Mt, "^", "\\hat");
y(v, x, Mt, "âƒ—", "\\vec");
y(v, x, Mt, "Ë™", "\\dot");
y(v, x, Mt, "Ëš", "\\mathring");
y(v, x, Te, "î„±", "\\@imath");
y(v, x, Te, "îˆ·", "\\@jmath");
y(v, x, P, "Ä±", "Ä±");
y(v, x, P, "È·", "È·");
y(J, x, P, "Ä±", "\\i", !0);
y(J, x, P, "È·", "\\j", !0);
y(J, x, P, "ÃŸ", "\\ss", !0);
y(J, x, P, "Ã¦", "\\ae", !0);
y(J, x, P, "Å“", "\\oe", !0);
y(J, x, P, "Ã¸", "\\o", !0);
y(J, x, P, "Ã†", "\\AE", !0);
y(J, x, P, "Å’", "\\OE", !0);
y(J, x, P, "Ã˜", "\\O", !0);
y(J, x, Mt, "ËŠ", "\\'");
y(J, x, Mt, "Ë‹", "\\`");
y(J, x, Mt, "Ë†", "\\^");
y(J, x, Mt, "Ëœ", "\\~");
y(J, x, Mt, "Ë‰", "\\=");
y(J, x, Mt, "Ë˜", "\\u");
y(J, x, Mt, "Ë™", "\\.");
y(J, x, Mt, "Â¸", "\\c");
y(J, x, Mt, "Ëš", "\\r");
y(J, x, Mt, "Ë‡", "\\v");
y(J, x, Mt, "Â¨", '\\"');
y(J, x, Mt, "Ë", "\\H");
y(J, x, Mt, "â—¯", "\\textcircled");
var tI = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
y(J, x, P, "â€“", "--", !0);
y(J, x, P, "â€“", "\\textendash");
y(J, x, P, "â€”", "---", !0);
y(J, x, P, "â€”", "\\textemdash");
y(J, x, P, "â€˜", "`", !0);
y(J, x, P, "â€˜", "\\textquoteleft");
y(J, x, P, "â€™", "'", !0);
y(J, x, P, "â€™", "\\textquoteright");
y(J, x, P, "â€œ", "``", !0);
y(J, x, P, "â€œ", "\\textquotedblleft");
y(J, x, P, "â€", "''", !0);
y(J, x, P, "â€", "\\textquotedblright");
y(v, x, P, "Â°", "\\degree", !0);
y(J, x, P, "Â°", "\\degree");
y(J, x, P, "Â°", "\\textdegree", !0);
y(v, x, P, "Â£", "\\pounds");
y(v, x, P, "Â£", "\\mathsterling", !0);
y(J, x, P, "Â£", "\\pounds");
y(J, x, P, "Â£", "\\textsterling", !0);
y(v, A, P, "âœ ", "\\maltese");
y(J, A, P, "âœ ", "\\maltese");
var hk = '0123456789/@."';
for (var i4 = 0; i4 < hk.length; i4++) {
  var fk = hk.charAt(i4);
  y(v, x, P, fk, fk);
}
var dk = '0123456789!@*()-=+";:?/.,';
for (var s4 = 0; s4 < dk.length; s4++) {
  var pk = dk.charAt(s4);
  y(J, x, P, pk, pk);
}
var Qm = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var o4 = 0; o4 < Qm.length; o4++) {
  var Y0 = Qm.charAt(o4);
  y(v, x, Te, Y0, Y0), y(J, x, P, Y0, Y0);
}
y(v, A, P, "C", "â„‚");
y(J, A, P, "C", "â„‚");
y(v, A, P, "H", "â„");
y(J, A, P, "H", "â„");
y(v, A, P, "N", "â„•");
y(J, A, P, "N", "â„•");
y(v, A, P, "P", "â„™");
y(J, A, P, "P", "â„™");
y(v, A, P, "Q", "â„š");
y(J, A, P, "Q", "â„š");
y(v, A, P, "R", "â„");
y(J, A, P, "R", "â„");
y(v, A, P, "Z", "â„¤");
y(J, A, P, "Z", "â„¤");
y(v, x, Te, "h", "â„Ž");
y(J, x, Te, "h", "â„Ž");
var Ie = "";
for (var Pn = 0; Pn < Qm.length; Pn++) {
  var Nt = Qm.charAt(Pn);
  Ie = String.fromCharCode(55349, 56320 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56372 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56424 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56580 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56684 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56736 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56788 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56840 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56944 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Pn < 26 && (Ie = String.fromCharCode(55349, 56632 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie), Ie = String.fromCharCode(55349, 56476 + Pn), y(v, x, Te, Nt, Ie), y(J, x, P, Nt, Ie));
}
Ie = "ð•œ";
y(v, x, Te, "k", Ie);
y(J, x, P, "k", Ie);
for (var ml = 0; ml < 10; ml++) {
  var po = ml.toString();
  Ie = String.fromCharCode(55349, 57294 + ml), y(v, x, Te, po, Ie), y(J, x, P, po, Ie), Ie = String.fromCharCode(55349, 57314 + ml), y(v, x, Te, po, Ie), y(J, x, P, po, Ie), Ie = String.fromCharCode(55349, 57324 + ml), y(v, x, Te, po, Ie), y(J, x, P, po, Ie), Ie = String.fromCharCode(55349, 57334 + ml), y(v, x, Te, po, Ie), y(J, x, P, po, Ie);
}
var O5 = "ÃÃžÃ¾";
for (var l4 = 0; l4 < O5.length; l4++) {
  var J0 = O5.charAt(l4);
  y(v, x, Te, J0, J0), y(J, x, P, J0, J0);
}
var X0 = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], mk = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Tne = function(e, t) {
  var r = e.charCodeAt(0), i = e.charCodeAt(1), s = (r - 55296) * 1024 + (i - 56320) + 65536, o = t === "math" ? 0 : 1;
  if (119808 <= s && s < 120484) {
    var l = Math.floor((s - 119808) / 26);
    return [X0[l][2], X0[l][o]];
  } else if (120782 <= s && s <= 120831) {
    var a = Math.floor((s - 120782) / 10);
    return [mk[a][2], mk[a][o]];
  } else {
    if (s === 120485 || s === 120486)
      return [X0[0][2], X0[0][o]];
    if (120486 < s && s < 120782)
      return ["", ""];
    throw new Z("Unsupported character: " + e);
  }
}, dg = function(e, t, r) {
  return gt[r][e] && gt[r][e].replace && (e = gt[r][e].replace), {
    value: e,
    metrics: R7(e, t, r)
  };
}, bi = function(e, t, r, i, s) {
  var o = dg(e, t, r), l = o.metrics;
  e = o.value;
  var a;
  if (l) {
    var c = l.italic;
    (r === "text" || i && i.font === "mathit") && (c = 0), a = new ii(e, l.height, l.depth, c, l.skew, l.width, s);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + r + "'")), a = new ii(e, 0, 0, 0, 0, 0, s);
  if (i) {
    a.maxFontSize = i.sizeMultiplier, i.style.isTight() && a.classes.push("mtight");
    var u = i.getColor();
    u && (a.style.color = u);
  }
  return a;
}, Ane = function(e, t, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && dg(e, "Main-Bold", t).metrics ? bi(e, "Main-Bold", t, r, i.concat(["mathbf"])) : e === "\\" || gt[t][e].font === "main" ? bi(e, "Main-Regular", t, r, i) : bi(e, "AMS-Regular", t, r, i.concat(["amsrm"]));
}, One = function(e, t, r, i, s) {
  return s !== "textord" && dg(e, "Math-BoldItalic", t).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Ene = function(e, t, r) {
  var i = e.mode, s = e.text, o = ["mord"], l = i === "math" || i === "text" && t.font, a = l ? t.font : t.fontFamily, c = "", u = "";
  if (s.charCodeAt(0) === 55349 && ([c, u] = Tne(s, i)), c.length > 0)
    return bi(s, c, i, t, o.concat(u));
  if (a) {
    var h, f;
    if (a === "boldsymbol") {
      var d = One(s, i, t, o, r);
      h = d.fontName, f = [d.fontClass];
    } else l ? (h = iI[a].fontName, f = [a]) : (h = Z0(a, t.fontWeight, t.fontShape), f = [a, t.fontWeight, t.fontShape]);
    if (dg(s, h, i).metrics)
      return bi(s, h, i, t, o.concat(f));
    if (tI.hasOwnProperty(s) && h.slice(0, 10) === "Typewriter") {
      for (var p = [], m = 0; m < s.length; m++)
        p.push(bi(s[m], h, i, t, o.concat(f)));
      return rI(p);
    }
  }
  if (r === "mathord")
    return bi(s, "Math-Italic", i, t, o.concat(["mathnormal"]));
  if (r === "textord") {
    var g = gt[i][s] && gt[i][s].font;
    if (g === "ams") {
      var b = Z0("amsrm", t.fontWeight, t.fontShape);
      return bi(s, b, i, t, o.concat("amsrm", t.fontWeight, t.fontShape));
    } else if (g === "main" || !g) {
      var w = Z0("textrm", t.fontWeight, t.fontShape);
      return bi(s, w, i, t, o.concat(t.fontWeight, t.fontShape));
    } else {
      var k = Z0(g, t.fontWeight, t.fontShape);
      return bi(s, k, i, t, o.concat(k, t.fontWeight, t.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Ine = (n, e) => {
  if (Xo(n.classes) !== Xo(e.classes) || n.skew !== e.skew || n.maxFontSize !== e.maxFontSize)
    return !1;
  if (n.classes.length === 1) {
    var t = n.classes[0];
    if (t === "mbin" || t === "mord")
      return !1;
  }
  for (var r in n.style)
    if (n.style.hasOwnProperty(r) && n.style[r] !== e.style[r])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && n.style[i] !== e.style[i])
      return !1;
  return !0;
}, Dne = (n) => {
  for (var e = 0; e < n.length - 1; e++) {
    var t = n[e], r = n[e + 1];
    t instanceof ii && r instanceof ii && Ine(t, r) && (t.text += r.text, t.height = Math.max(t.height, r.height), t.depth = Math.max(t.depth, r.depth), t.italic = r.italic, n.splice(e + 1, 1), e--);
  }
  return n;
}, L7 = function(e) {
  for (var t = 0, r = 0, i = 0, s = 0; s < e.children.length; s++) {
    var o = e.children[s];
    o.height > t && (t = o.height), o.depth > r && (r = o.depth), o.maxFontSize > i && (i = o.maxFontSize);
  }
  e.height = t, e.depth = r, e.maxFontSize = i;
}, Zn = function(e, t, r, i) {
  var s = new t0(e, t, r, i);
  return L7(s), s;
}, nI = (n, e, t, r) => new t0(n, e, t, r), Nne = function(e, t, r) {
  var i = Zn([e], [], t);
  return i.height = Math.max(r || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = re(i.height), i.maxFontSize = 1, i;
}, Rne = function(e, t, r, i) {
  var s = new P7(e, t, r, i);
  return L7(s), s;
}, rI = function(e) {
  var t = new e0(e);
  return L7(t), t;
}, Pne = function(e, t) {
  return e instanceof e0 ? Zn([], [e], t) : e;
}, Lne = function(e) {
  if (e.positionType === "individualShift") {
    for (var t = e.children, r = [t[0]], i = -t[0].shift - t[0].elem.depth, s = i, o = 1; o < t.length; o++) {
      var l = -t[o].shift - s - t[o].elem.depth, a = l - (t[o - 1].elem.height + t[o - 1].elem.depth);
      s = s + l, r.push({
        type: "kern",
        size: a
      }), r.push(t[o]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var c;
  if (e.positionType === "top") {
    for (var u = e.positionData, h = 0; h < e.children.length; h++) {
      var f = e.children[h];
      u -= f.type === "kern" ? f.size : f.elem.height + f.elem.depth;
    }
    c = u;
  } else if (e.positionType === "bottom")
    c = -e.positionData;
  else {
    var d = e.children[0];
    if (d.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      c = -d.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      c = -d.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: c
  };
}, Bne = function(e, t) {
  for (var {
    children: r,
    depth: i
  } = Lne(e), s = 0, o = 0; o < r.length; o++) {
    var l = r[o];
    if (l.type === "elem") {
      var a = l.elem;
      s = Math.max(s, a.maxFontSize, a.height);
    }
  }
  s += 2;
  var c = Zn(["pstrut"], []);
  c.style.height = re(s);
  for (var u = [], h = i, f = i, d = i, p = 0; p < r.length; p++) {
    var m = r[p];
    if (m.type === "kern")
      d += m.size;
    else {
      var g = m.elem, b = m.wrapperClasses || [], w = m.wrapperStyle || {}, k = Zn(b, [c, g], void 0, w);
      k.style.top = re(-s - d - g.depth), m.marginLeft && (k.style.marginLeft = m.marginLeft), m.marginRight && (k.style.marginRight = m.marginRight), u.push(k), d += g.height + g.depth;
    }
    h = Math.min(h, d), f = Math.max(f, d);
  }
  var T = Zn(["vlist"], u);
  T.style.height = re(f);
  var M;
  if (h < 0) {
    var C = Zn([], []), I = Zn(["vlist"], [C]);
    I.style.height = re(-h);
    var _ = Zn(["vlist-s"], [new ii("â€‹")]);
    M = [Zn(["vlist-r"], [T, _]), Zn(["vlist-r"], [I])];
  } else
    M = [Zn(["vlist-r"], [T])];
  var F = Zn(["vlist-t"], M);
  return M.length === 2 && F.classes.push("vlist-t2"), F.height = f, F.depth = -h, F;
}, zne = (n, e) => {
  var t = Zn(["mspace"], [], e), r = It(n, e);
  return t.style.marginRight = re(r), t;
}, Z0 = function(e, t, r) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var s;
  return t === "textbf" && r === "textit" ? s = "BoldItalic" : t === "textbf" ? s = "Bold" : t === "textit" ? s = "Italic" : s = "Regular", i + "-" + s;
}, iI = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, sI = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, _ne = function(e, t) {
  var [r, i, s] = sI[e], o = new Zo(r), l = new Js([o], {
    width: re(i),
    height: re(s),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + re(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * s,
    preserveAspectRatio: "xMinYMin"
  }), a = nI(["overlay"], [l], t);
  return a.height = s, a.style.height = re(s), a.style.width = re(i), a;
}, z = {
  fontMap: iI,
  makeSymbol: bi,
  mathsym: Ane,
  makeSpan: Zn,
  makeSvgSpan: nI,
  makeLineSpan: Nne,
  makeAnchor: Rne,
  makeFragment: rI,
  wrapFragment: Pne,
  makeVList: Bne,
  makeOrd: Ene,
  makeGlue: zne,
  staticSvg: _ne,
  svgData: sI,
  tryCombineChars: Dne
}, Ot = {
  number: 3,
  unit: "mu"
}, gl = {
  number: 4,
  unit: "mu"
}, bs = {
  number: 5,
  unit: "mu"
}, Fne = {
  mord: {
    mop: Ot,
    mbin: gl,
    mrel: bs,
    minner: Ot
  },
  mop: {
    mord: Ot,
    mop: Ot,
    mrel: bs,
    minner: Ot
  },
  mbin: {
    mord: gl,
    mop: gl,
    mopen: gl,
    minner: gl
  },
  mrel: {
    mord: bs,
    mop: bs,
    mopen: bs,
    minner: bs
  },
  mopen: {},
  mclose: {
    mop: Ot,
    mbin: gl,
    mrel: bs,
    minner: Ot
  },
  mpunct: {
    mord: Ot,
    mop: Ot,
    mrel: bs,
    mopen: Ot,
    mclose: Ot,
    mpunct: Ot,
    minner: Ot
  },
  minner: {
    mord: Ot,
    mop: Ot,
    mbin: gl,
    mrel: bs,
    mopen: Ot,
    mpunct: Ot,
    minner: Ot
  }
}, Hne = {
  mord: {
    mop: Ot
  },
  mop: {
    mord: Ot,
    mop: Ot
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: Ot
  },
  mpunct: {},
  minner: {
    mop: Ot
  }
}, oI = {}, e1 = {}, t1 = {};
function le(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, a = 0; a < t.length; ++a)
    oI[t[a]] = l;
  e && (s && (e1[e] = s), o && (t1[e] = o));
}
function Ea(n) {
  var {
    type: e,
    htmlBuilder: t,
    mathmlBuilder: r
  } = n;
  le({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: t,
    mathmlBuilder: r
  });
}
var n1 = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, zt = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, Xs = z.makeSpan, $ne = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Vne = ["rightmost", "mrel", "mclose", "mpunct"], qne = {
  display: Ae.DISPLAY,
  text: Ae.TEXT,
  script: Ae.SCRIPT,
  scriptscript: Ae.SCRIPTSCRIPT
}, Wne = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, Jt = function(e, t, r, i) {
  i === void 0 && (i = [null, null]);
  for (var s = [], o = 0; o < e.length; o++) {
    var l = Qe(e[o], t);
    if (l instanceof e0) {
      var a = l.children;
      s.push(...a);
    } else
      s.push(l);
  }
  if (z.tryCombineChars(s), !r)
    return s;
  var c = t;
  if (e.length === 1) {
    var u = e[0];
    u.type === "sizing" ? c = t.havingSize(u.size) : u.type === "styling" && (c = t.havingStyle(qne[u.style]));
  }
  var h = Xs([i[0] || "leftmost"], [], t), f = Xs([i[1] || "rightmost"], [], t), d = r === "root";
  return gk(s, (p, m) => {
    var g = m.classes[0], b = p.classes[0];
    g === "mbin" && xe.contains(Vne, b) ? m.classes[0] = "mord" : b === "mbin" && xe.contains($ne, g) && (p.classes[0] = "mord");
  }, {
    node: h
  }, f, d), gk(s, (p, m) => {
    var g = E5(m), b = E5(p), w = g && b ? p.hasClass("mtight") ? Hne[g][b] : Fne[g][b] : null;
    if (w)
      return z.makeGlue(w, c);
  }, {
    node: h
  }, f, d), s;
}, gk = function n(e, t, r, i, s) {
  i && e.push(i);
  for (var o = 0; o < e.length; o++) {
    var l = e[o], a = lI(l);
    if (a) {
      n(a.children, t, r, null, s);
      continue;
    }
    var c = !l.hasClass("mspace");
    if (c) {
      var u = t(l, r.node);
      u && (r.insertAfter ? r.insertAfter(u) : (e.unshift(u), o++));
    }
    c ? r.node = l : s && l.hasClass("newline") && (r.node = Xs(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((h) => (f) => {
      e.splice(h + 1, 0, f), o++;
    })(o);
  }
  i && e.pop();
}, lI = function(e) {
  return e instanceof e0 || e instanceof P7 || e instanceof t0 && e.hasClass("enclosing") ? e : null;
}, jne = function n(e, t) {
  var r = lI(e);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (t === "right")
        return n(i[i.length - 1], "right");
      if (t === "left")
        return n(i[0], "left");
    }
  }
  return e;
}, E5 = function(e, t) {
  return e ? (t && (e = jne(e, t)), Wne[e.classes[0]] || null) : null;
}, Zf = function(e, t) {
  var r = ["nulldelimiter"].concat(e.baseSizingClasses());
  return Xs(t.concat(r));
}, Qe = function(e, t, r) {
  if (!e)
    return Xs();
  if (e1[e.type]) {
    var i = e1[e.type](e, t);
    if (r && t.size !== r.size) {
      i = Xs(t.sizingClasses(r), [i], t);
      var s = t.sizeMultiplier / r.sizeMultiplier;
      i.height *= s, i.depth *= s;
    }
    return i;
  } else
    throw new Z("Got group of unknown type: '" + e.type + "'");
};
function Q0(n, e) {
  var t = Xs(["base"], n, e), r = Xs(["strut"]);
  return r.style.height = re(t.height + t.depth), t.depth && (r.style.verticalAlign = re(-t.depth)), t.children.unshift(r), t;
}
function I5(n, e) {
  var t = null;
  n.length === 1 && n[0].type === "tag" && (t = n[0].tag, n = n[0].body);
  var r = Jt(n, e, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var s = [], o = [], l = 0; l < r.length; l++)
    if (o.push(r[l]), r[l].hasClass("mbin") || r[l].hasClass("mrel") || r[l].hasClass("allowbreak")) {
      for (var a = !1; l < r.length - 1 && r[l + 1].hasClass("mspace") && !r[l + 1].hasClass("newline"); )
        l++, o.push(r[l]), r[l].hasClass("nobreak") && (a = !0);
      a || (s.push(Q0(o, e)), o = []);
    } else r[l].hasClass("newline") && (o.pop(), o.length > 0 && (s.push(Q0(o, e)), o = []), s.push(r[l]));
  o.length > 0 && s.push(Q0(o, e));
  var c;
  t ? (c = Q0(Jt(t, e, !0)), c.classes = ["tag"], s.push(c)) : i && s.push(i);
  var u = Xs(["katex-html"], s);
  if (u.setAttribute("aria-hidden", "true"), c) {
    var h = c.children[0];
    h.style.height = re(u.height + u.depth), u.depth && (h.style.verticalAlign = re(-u.depth));
  }
  return u;
}
function aI(n) {
  return new e0(n);
}
class Tr {
  constructor(e, t, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
    this.classes.length > 0 && (e.className = Xo(this.classes));
    for (var r = 0; r < this.children.length; r++)
      if (this.children[r] instanceof Ji && this.children[r + 1] instanceof Ji) {
        for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof Ji; )
          i += this.children[++r].toText();
        e.appendChild(new Ji(i).toNode());
      } else
        e.appendChild(this.children[r].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="', e += xe.escape(this.attributes[t]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + xe.escape(Xo(this.classes)) + '"'), e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class Ji {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return xe.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Une {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = "â€Š" : e >= 0.1666 && e <= 0.1667 ? this.character = "â€‰" : e >= 0.2222 && e <= 0.2223 ? this.character = "â€…" : e >= 0.2777 && e <= 0.2778 ? this.character = "â€…â€Š" : e >= -0.05556 && e <= -0.05555 ? this.character = "â€Šâ£" : e >= -0.1667 && e <= -0.1666 ? this.character = "â€‰â£" : e >= -0.2223 && e <= -0.2222 ? this.character = "âŸâ£" : e >= -0.2778 && e <= -0.2777 ? this.character = "â€…â£" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", re(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + re(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var X = {
  MathNode: Tr,
  TextNode: Ji,
  SpaceNode: Une,
  newDocumentFragment: aI
}, si = function(e, t, r) {
  return gt[t][e] && gt[t][e].replace && e.charCodeAt(0) !== 55349 && !(tI.hasOwnProperty(e) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (e = gt[t][e].replace), new X.TextNode(e);
}, B7 = function(e) {
  return e.length === 1 ? e[0] : new X.MathNode("mrow", e);
}, z7 = function(e, t) {
  if (t.fontFamily === "texttt")
    return "monospace";
  if (t.fontFamily === "textsf")
    return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (t.fontShape === "textit" && t.fontWeight === "textbf")
    return "bold-italic";
  if (t.fontShape === "textit")
    return "italic";
  if (t.fontWeight === "textbf")
    return "bold";
  var r = t.font;
  if (!r || r === "mathnormal")
    return null;
  var i = e.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathsfit")
    return "sans-serif-italic";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var s = e.text;
  if (xe.contains(["\\imath", "\\jmath"], s))
    return null;
  gt[i][s] && gt[i][s].replace && (s = gt[i][s].replace);
  var o = z.fontMap[r].fontName;
  return R7(s, o, i) ? z.fontMap[r].variant : null;
};
function a4(n) {
  if (!n)
    return !1;
  if (n.type === "mi" && n.children.length === 1) {
    var e = n.children[0];
    return e instanceof Ji && e.text === ".";
  } else if (n.type === "mo" && n.children.length === 1 && n.getAttribute("separator") === "true" && n.getAttribute("lspace") === "0em" && n.getAttribute("rspace") === "0em") {
    var t = n.children[0];
    return t instanceof Ji && t.text === ",";
  } else
    return !1;
}
var fr = function(e, t, r) {
  if (e.length === 1) {
    var i = dt(e[0], t);
    return r && i instanceof Tr && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var s = [], o, l = 0; l < e.length; l++) {
    var a = dt(e[l], t);
    if (a instanceof Tr && o instanceof Tr) {
      if (a.type === "mtext" && o.type === "mtext" && a.getAttribute("mathvariant") === o.getAttribute("mathvariant")) {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (a4(a) && o.type === "mn") {
        o.children.push(...a.children);
        continue;
      } else if (a.type === "mn" && a4(o))
        a.children = [...o.children, ...a.children], s.pop();
      else if ((a.type === "msup" || a.type === "msub") && a.children.length >= 1 && (o.type === "mn" || a4(o))) {
        var c = a.children[0];
        c instanceof Tr && c.type === "mn" && (c.children = [...o.children, ...c.children], s.pop());
      } else if (o.type === "mi" && o.children.length === 1) {
        var u = o.children[0];
        if (u instanceof Ji && u.text === "Ì¸" && (a.type === "mo" || a.type === "mi" || a.type === "mn")) {
          var h = a.children[0];
          h instanceof Ji && h.text.length > 0 && (h.text = h.text.slice(0, 1) + "Ì¸" + h.text.slice(1), s.pop());
        }
      }
    }
    s.push(a), o = a;
  }
  return s;
}, Qo = function(e, t, r) {
  return B7(fr(e, t, r));
}, dt = function(e, t) {
  if (!e)
    return new X.MathNode("mrow");
  if (t1[e.type]) {
    var r = t1[e.type](e, t);
    return r;
  } else
    throw new Z("Got group of unknown type: '" + e.type + "'");
};
function yk(n, e, t, r, i) {
  var s = fr(n, t), o;
  s.length === 1 && s[0] instanceof Tr && xe.contains(["mrow", "mtable"], s[0].type) ? o = s[0] : o = new X.MathNode("mrow", s);
  var l = new X.MathNode("annotation", [new X.TextNode(e)]);
  l.setAttribute("encoding", "application/x-tex");
  var a = new X.MathNode("semantics", [o, l]), c = new X.MathNode("math", [a]);
  c.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && c.setAttribute("display", "block");
  var u = i ? "katex" : "katex-mathml";
  return z.makeSpan([u], [c]);
}
var cI = function(e) {
  return new As({
    style: e.displayMode ? Ae.DISPLAY : Ae.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, uI = function(e, t) {
  if (t.displayMode) {
    var r = ["katex-display"];
    t.leqno && r.push("leqno"), t.fleqn && r.push("fleqn"), e = z.makeSpan(r, [e]);
  }
  return e;
}, Gne = function(e, t, r) {
  var i = cI(r), s;
  if (r.output === "mathml")
    return yk(e, t, i, r.displayMode, !0);
  if (r.output === "html") {
    var o = I5(e, i);
    s = z.makeSpan(["katex"], [o]);
  } else {
    var l = yk(e, t, i, r.displayMode, !1), a = I5(e, i);
    s = z.makeSpan(["katex"], [l, a]);
  }
  return uI(s, r);
}, Kne = function(e, t, r) {
  var i = cI(r), s = I5(e, i), o = z.makeSpan(["katex"], [s]);
  return uI(o, r);
}, Yne = {
  widehat: "^",
  widecheck: "Ë‡",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "â†",
  underleftarrow: "â†",
  xleftarrow: "â†",
  overrightarrow: "â†’",
  underrightarrow: "â†’",
  xrightarrow: "â†’",
  underbrace: "âŸ",
  overbrace: "âž",
  overgroup: "â ",
  undergroup: "â¡",
  overleftrightarrow: "â†”",
  underleftrightarrow: "â†”",
  xleftrightarrow: "â†”",
  Overrightarrow: "â‡’",
  xRightarrow: "â‡’",
  overleftharpoon: "â†¼",
  xleftharpoonup: "â†¼",
  overrightharpoon: "â‡€",
  xrightharpoonup: "â‡€",
  xLeftarrow: "â‡",
  xLeftrightarrow: "â‡”",
  xhookleftarrow: "â†©",
  xhookrightarrow: "â†ª",
  xmapsto: "â†¦",
  xrightharpoondown: "â‡",
  xleftharpoondown: "â†½",
  xrightleftharpoons: "â‡Œ",
  xleftrightharpoons: "â‡‹",
  xtwoheadleftarrow: "â†ž",
  xtwoheadrightarrow: "â† ",
  xlongequal: "=",
  xtofrom: "â‡„",
  xrightleftarrows: "â‡„",
  xrightequilibrium: "â‡Œ",
  // Not a perfect match.
  xleftequilibrium: "â‡‹",
  // None better available.
  "\\cdrightarrow": "â†’",
  "\\cdleftarrow": "â†",
  "\\cdlongequal": "="
}, Jne = function(e) {
  var t = new X.MathNode("mo", [new X.TextNode(Yne[e.replace(/^\\/, "")])]);
  return t.setAttribute("stretchy", "true"), t;
}, Xne = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, Zne = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, Qne = function(e, t) {
  function r() {
    var l = 4e5, a = e.label.slice(1);
    if (xe.contains(["widehat", "widecheck", "widetilde", "utilde"], a)) {
      var c = e, u = Zne(c.base), h, f, d;
      if (u > 5)
        a === "widehat" || a === "widecheck" ? (h = 420, l = 2364, d = 0.42, f = a + "4") : (h = 312, l = 2340, d = 0.34, f = "tilde4");
      else {
        var p = [1, 1, 2, 2, 3, 3][u];
        a === "widehat" || a === "widecheck" ? (l = [0, 1062, 2364, 2364, 2364][p], h = [0, 239, 300, 360, 420][p], d = [0, 0.24, 0.3, 0.3, 0.36, 0.42][p], f = a + p) : (l = [0, 600, 1033, 2339, 2340][p], h = [0, 260, 286, 306, 312][p], d = [0, 0.26, 0.286, 0.3, 0.306, 0.34][p], f = "tilde" + p);
      }
      var m = new Zo(f), g = new Js([m], {
        width: "100%",
        height: re(d),
        viewBox: "0 0 " + l + " " + h,
        preserveAspectRatio: "none"
      });
      return {
        span: z.makeSvgSpan([], [g], t),
        minWidth: 0,
        height: d
      };
    } else {
      var b = [], w = Xne[a], [k, T, M] = w, C = M / 1e3, I = k.length, _, F;
      if (I === 1) {
        var L = w[3];
        _ = ["hide-tail"], F = [L];
      } else if (I === 2)
        _ = ["halfarrow-left", "halfarrow-right"], F = ["xMinYMin", "xMaxYMin"];
      else if (I === 3)
        _ = ["brace-left", "brace-center", "brace-right"], F = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + I + " children.");
      for (var $ = 0; $ < I; $++) {
        var B = new Zo(k[$]), se = new Js([B], {
          width: "400em",
          height: re(C),
          viewBox: "0 0 " + l + " " + M,
          preserveAspectRatio: F[$] + " slice"
        }), te = z.makeSvgSpan([_[$]], [se], t);
        if (I === 1)
          return {
            span: te,
            minWidth: T,
            height: C
          };
        te.style.height = re(C), b.push(te);
      }
      return {
        span: z.makeSpan(["stretchy"], b, t),
        minWidth: T,
        height: C
      };
    }
  }
  var {
    span: i,
    minWidth: s,
    height: o
  } = r();
  return i.height = o, i.style.height = re(o), s > 0 && (i.style.minWidth = re(s)), i;
}, ere = function(e, t, r, i, s) {
  var o, l = e.height + e.depth + r + i;
  if (/fbox|color|angl/.test(t)) {
    if (o = z.makeSpan(["stretchy", t], [], s), t === "fbox") {
      var a = s.color && s.getColor();
      a && (o.style.borderColor = a);
    }
  } else {
    var c = [];
    /^[bx]cancel$/.test(t) && c.push(new A5({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(t) && c.push(new A5({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var u = new Js(c, {
      width: "100%",
      height: re(l)
    });
    o = z.makeSvgSpan([], [u], s);
  }
  return o.height = l, o.style.height = re(l), o;
}, Zs = {
  encloseSpan: ere,
  mathMLnode: Jne,
  svgSpan: Qne
};
function He(n, e) {
  if (!n || n.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (n ? "node of type " + n.type : String(n)));
  return n;
}
function _7(n) {
  var e = pg(n);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (n ? "node of type " + n.type : String(n)));
  return e;
}
function pg(n) {
  return n && (n.type === "atom" || Mne.hasOwnProperty(n.type)) ? n : null;
}
var F7 = (n, e) => {
  var t, r, i;
  n && n.type === "supsub" ? (r = He(n.base, "accent"), t = r.base, n.base = t, i = Sne(Qe(n, e)), n.base = r) : (r = He(n, "accent"), t = r.base);
  var s = Qe(t, e.havingCrampedStyle()), o = r.isShifty && xe.isCharacterBox(t), l = 0;
  if (o) {
    var a = xe.getBaseElem(t), c = Qe(a, e.havingCrampedStyle());
    l = uk(c).skew;
  }
  var u = r.label === "\\c", h = u ? s.height + s.depth : Math.min(s.height, e.fontMetrics().xHeight), f;
  if (r.isStretchy)
    f = Zs.svgSpan(r, e), f = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "elem",
        elem: f,
        wrapperClasses: ["svg-align"],
        wrapperStyle: l > 0 ? {
          width: "calc(100% - " + re(2 * l) + ")",
          marginLeft: re(2 * l)
        } : void 0
      }]
    }, e);
  else {
    var d, p;
    r.label === "\\vec" ? (d = z.staticSvg("vec", e), p = z.svgData.vec[1]) : (d = z.makeOrd({
      mode: r.mode,
      text: r.label
    }, e, "textord"), d = uk(d), d.italic = 0, p = d.width, u && (h += d.depth)), f = z.makeSpan(["accent-body"], [d]);
    var m = r.label === "\\textcircled";
    m && (f.classes.push("accent-full"), h = s.height);
    var g = l;
    m || (g -= p / 2), f.style.left = re(g), r.label === "\\textcircled" && (f.style.top = ".2em"), f = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: -h
      }, {
        type: "elem",
        elem: f
      }]
    }, e);
  }
  var b = z.makeSpan(["mord", "accent"], [f], e);
  return i ? (i.children[0] = b, i.height = Math.max(b.height, i.height), i.classes[0] = "mord", i) : b;
}, hI = (n, e) => {
  var t = n.isStretchy ? Zs.mathMLnode(n.label) : new X.MathNode("mo", [si(n.label, n.mode)]), r = new X.MathNode("mover", [dt(n.base, e), t]);
  return r.setAttribute("accent", "true"), r;
}, tre = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((n) => "\\" + n).join("|"));
le({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var t = n1(e[0]), r = !tre.test(n.funcName), i = !r || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: n.parser.mode,
      label: n.funcName,
      isStretchy: r,
      isShifty: i,
      base: t
    };
  },
  htmlBuilder: F7,
  mathmlBuilder: hI
});
le({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = e[0], r = n.parser.mode;
    return r === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: n.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: t
    };
  },
  htmlBuilder: F7,
  mathmlBuilder: hI
});
le({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (n, e) => {
    var t = Qe(n.base, e), r = Zs.svgSpan(n, e), i = n.label === "\\utilde" ? 0.12 : 0, s = z.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return z.makeSpan(["mord", "accentunder"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = Zs.mathMLnode(n.label), r = new X.MathNode("munder", [dt(n.base, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var ep = (n) => {
  var e = new X.MathNode("mpadded", n ? [n] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
le({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: e[0],
      below: t[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(n, e) {
    var t = e.style, r = e.havingStyle(t.sup()), i = z.wrapFragment(Qe(n.body, r, e), e), s = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(s + "-arrow-pad");
    var o;
    n.below && (r = e.havingStyle(t.sub()), o = z.wrapFragment(Qe(n.below, r, e), e), o.classes.push(s + "-arrow-pad"));
    var l = Zs.svgSpan(n, e), a = -e.fontMetrics().axisHeight + 0.5 * l.height, c = -e.fontMetrics().axisHeight - 0.5 * l.height - 0.111;
    (i.depth > 0.25 || n.label === "\\xleftequilibrium") && (c -= i.depth);
    var u;
    if (o) {
      var h = -e.fontMetrics().axisHeight + o.height + 0.5 * l.height + 0.111;
      u = z.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }, {
          type: "elem",
          elem: o,
          shift: h
        }]
      }, e);
    } else
      u = z.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: l,
          shift: a
        }]
      }, e);
    return u.children[0].children[0].children[1].classes.push("svg-align"), z.makeSpan(["mrel", "x-arrow"], [u], e);
  },
  mathmlBuilder(n, e) {
    var t = Zs.mathMLnode(n.label);
    t.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (n.body) {
      var i = ep(dt(n.body, e));
      if (n.below) {
        var s = ep(dt(n.below, e));
        r = new X.MathNode("munderover", [t, s, i]);
      } else
        r = new X.MathNode("mover", [t, i]);
    } else if (n.below) {
      var o = ep(dt(n.below, e));
      r = new X.MathNode("munder", [t, o]);
    } else
      r = ep(), r = new X.MathNode("mover", [t, r]);
    return r;
  }
});
var nre = z.makeSpan;
function fI(n, e) {
  var t = Jt(n.body, e, !0);
  return nre([n.mclass], t, e);
}
function dI(n, e) {
  var t, r = fr(n.body, e);
  return n.mclass === "minner" ? t = new X.MathNode("mpadded", r) : n.mclass === "mord" ? n.isCharacterBox ? (t = r[0], t.type = "mi") : t = new X.MathNode("mi", r) : (n.isCharacterBox ? (t = r[0], t.type = "mo") : t = new X.MathNode("mo", r), n.mclass === "mbin" ? (t.attributes.lspace = "0.22em", t.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0em") : n.mclass === "minner" && (t.attributes.lspace = "0.0556em", t.attributes.width = "+0.1111em")), t;
}
le({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: zt(i),
      isCharacterBox: xe.isCharacterBox(i)
    };
  },
  htmlBuilder: fI,
  mathmlBuilder: dI
});
var mg = (n) => {
  var e = n.type === "ordgroup" && n.body.length ? n.body[0] : n;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
le({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "mclass",
      mode: t.mode,
      mclass: mg(e[0]),
      body: zt(e[1]),
      isCharacterBox: xe.isCharacterBox(e[1])
    };
  }
});
le({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[1], s = e[0], o;
    r !== "\\stackrel" ? o = mg(i) : o = "mrel";
    var l = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: zt(i)
    }, a = {
      type: "supsub",
      mode: s.mode,
      base: l,
      sup: r === "\\underset" ? null : s,
      sub: r === "\\underset" ? s : null
    };
    return {
      type: "mclass",
      mode: t.mode,
      mclass: o,
      body: [a],
      isCharacterBox: xe.isCharacterBox(a)
    };
  },
  htmlBuilder: fI,
  mathmlBuilder: dI
});
le({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "pmb",
      mode: t.mode,
      mclass: mg(e[0]),
      body: zt(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = Jt(n.body, e, !0), r = z.makeSpan([n.mclass], t, e);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(n, e) {
    var t = fr(n.body, e), r = new X.MathNode("mstyle", t);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var rre = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, bk = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), vk = (n) => n.type === "textord" && n.text === "@", ire = (n, e) => (n.type === "mathord" || n.type === "atom") && n.text === e;
function sre(n, e, t) {
  var r = rre[n];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return t.callFunction(r, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = t.callFunction("\\\\cdleft", [e[0]], []), s = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, o = t.callFunction("\\Big", [s], []), l = t.callFunction("\\\\cdright", [e[1]], []), a = {
        type: "ordgroup",
        mode: "math",
        body: [i, o, l]
      };
      return t.callFunction("\\\\cdparent", [a], []);
    }
    case "\\\\cdlongequal":
      return t.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var c = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return t.callFunction("\\Big", [c], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function ore(n) {
  var e = [];
  for (n.gullet.beginGroup(), n.gullet.macros.set("\\cr", "\\\\\\relax"), n.gullet.beginGroup(); ; ) {
    e.push(n.parseExpression(!1, "\\\\")), n.gullet.endGroup(), n.gullet.beginGroup();
    var t = n.fetch().text;
    if (t === "&" || t === "\\\\")
      n.consume();
    else if (t === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new Z("Expected \\\\ or \\cr or \\end", n.nextToken);
  }
  for (var r = [], i = [r], s = 0; s < e.length; s++) {
    for (var o = e[s], l = bk(), a = 0; a < o.length; a++)
      if (!vk(o[a]))
        l.body.push(o[a]);
      else {
        r.push(l), a += 1;
        var c = _7(o[a]).text, u = new Array(2);
        if (u[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, u[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(c) > -1)) if ("<>AV".indexOf(c) > -1)
          for (var h = 0; h < 2; h++) {
            for (var f = !0, d = a + 1; d < o.length; d++) {
              if (ire(o[d], c)) {
                f = !1, a = d;
                break;
              }
              if (vk(o[d]))
                throw new Z("Missing a " + c + " character to complete a CD arrow.", o[d]);
              u[h].body.push(o[d]);
            }
            if (f)
              throw new Z("Missing a " + c + " character to complete a CD arrow.", o[a]);
          }
        else
          throw new Z('Expected one of "<>AV=|." after @', o[a]);
        var p = sre(c, u, n), m = {
          type: "styling",
          body: [p],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(m), l = bk();
      }
    s % 2 === 0 ? r.push(l) : r.shift(), r = [], i.push(r);
  }
  n.gullet.endGroup(), n.gullet.endGroup();
  var g = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: g,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
le({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "cdlabel",
      mode: t.mode,
      side: r.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = e.havingStyle(e.style.sup()), r = z.wrapFragment(Qe(n.label, t, e), e);
    return r.classes.push("cd-label-" + n.side), r.style.bottom = re(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mrow", [dt(n.label, e)]);
    return t = new X.MathNode("mpadded", [t]), t.setAttribute("width", "0"), n.side === "left" && t.setAttribute("lspace", "-1width"), t.setAttribute("voffset", "0.7em"), t = new X.MathNode("mstyle", [t]), t.setAttribute("displaystyle", "false"), t.setAttribute("scriptlevel", "1"), t;
  }
});
le({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = z.wrapFragment(Qe(n.fragment, e), e);
    return t.classes.push("cd-vert-arrow"), t;
  },
  mathmlBuilder(n, e) {
    return new X.MathNode("mrow", [dt(n.fragment, e)]);
  }
});
le({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    for (var {
      parser: t
    } = n, r = He(e[0], "ordgroup"), i = r.body, s = "", o = 0; o < i.length; o++) {
      var l = He(i[o], "textord");
      s += l.text;
    }
    var a = parseInt(s), c;
    if (isNaN(a))
      throw new Z("\\@char has non-numeric argument " + s);
    if (a < 0 || a >= 1114111)
      throw new Z("\\@char with invalid code point " + s);
    return a <= 65535 ? c = String.fromCharCode(a) : (a -= 65536, c = String.fromCharCode((a >> 10) + 55296, (a & 1023) + 56320)), {
      type: "textord",
      mode: t.mode,
      text: c
    };
  }
});
var pI = (n, e) => {
  var t = Jt(n.body, e.withColor(n.color), !1);
  return z.makeFragment(t);
}, mI = (n, e) => {
  var t = fr(n.body, e.withColor(n.color)), r = new X.MathNode("mstyle", t);
  return r.setAttribute("mathcolor", n.color), r;
};
le({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = He(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: t.mode,
      color: r,
      body: zt(i)
    };
  },
  htmlBuilder: pI,
  mathmlBuilder: mI
});
le({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(n, e) {
    var {
      parser: t,
      breakOnTokenText: r
    } = n, i = He(e[0], "color-token").color;
    t.gullet.macros.set("\\current@color", i);
    var s = t.parseExpression(!0, r);
    return {
      type: "color",
      mode: t.mode,
      color: i,
      body: s
    };
  },
  htmlBuilder: pI,
  mathmlBuilder: mI
});
le({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, s = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: s,
      size: i && He(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(n, e) {
    var t = z.makeSpan(["mspace"], [], e);
    return n.newLine && (t.classes.push("newline"), n.size && (t.style.marginTop = re(It(n.size, e)))), t;
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mspace");
    return n.newLine && (t.setAttribute("linebreak", "newline"), n.size && t.setAttribute("height", re(It(n.size, e)))), t;
  }
});
var D5 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, gI = (n) => {
  var e = n.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new Z("Expected a control sequence", n);
  return e;
}, lre = (n) => {
  var e = n.gullet.popToken();
  return e.text === "=" && (e = n.gullet.popToken(), e.text === " " && (e = n.gullet.popToken())), e;
}, yI = (n, e, t, r) => {
  var i = n.gullet.macros.get(t.text);
  i == null && (t.noexpand = !0, i = {
    tokens: [t],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !n.gullet.isExpandable(t.text)
  }), n.gullet.macros.set(e, i, r);
};
le({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    e.consumeSpaces();
    var r = e.fetch();
    if (D5[r.text])
      return (t === "\\global" || t === "\\\\globallong") && (r.text = D5[r.text]), He(e.parseFunction(), "internal");
    throw new Z("Invalid token after macro prefix", r);
  }
});
le({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = e.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new Z("Expected a control sequence", r);
    for (var s = 0, o, l = [[]]; e.gullet.future().text !== "{"; )
      if (r = e.gullet.popToken(), r.text === "#") {
        if (e.gullet.future().text === "{") {
          o = e.gullet.future(), l[s].push("{");
          break;
        }
        if (r = e.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new Z('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== s + 1)
          throw new Z('Argument number "' + r.text + '" out of order');
        s++, l.push([]);
      } else {
        if (r.text === "EOF")
          throw new Z("Expected a macro definition");
        l[s].push(r.text);
      }
    var {
      tokens: a
    } = e.gullet.consumeArg();
    return o && a.unshift(o), (t === "\\edef" || t === "\\xdef") && (a = e.gullet.expandTokens(a), a.reverse()), e.gullet.macros.set(i, {
      tokens: a,
      numArgs: s,
      delimiters: l
    }, t === D5[t]), {
      type: "internal",
      mode: e.mode
    };
  }
});
le({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = gI(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = lre(e);
    return yI(e, r, i, t === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
le({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = gI(e.gullet.popToken()), i = e.gullet.popToken(), s = e.gullet.popToken();
    return yI(e, r, s, t === "\\\\globalfuture"), e.gullet.pushToken(s), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var Mh = function(e, t, r) {
  var i = gt.math[e] && gt.math[e].replace, s = R7(i || e, t, r);
  if (!s)
    throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
  return s;
}, H7 = function(e, t, r, i) {
  var s = r.havingBaseStyle(t), o = z.makeSpan(i.concat(s.sizingClasses(r)), [e], r), l = s.sizeMultiplier / r.sizeMultiplier;
  return o.height *= l, o.depth *= l, o.maxFontSize = s.sizeMultiplier, o;
}, bI = function(e, t, r) {
  var i = t.havingBaseStyle(r), s = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = re(s), e.height -= s, e.depth += s;
}, are = function(e, t, r, i, s, o) {
  var l = z.makeSymbol(e, "Main-Regular", s, i), a = H7(l, t, i, o);
  return r && bI(a, i, t), a;
}, cre = function(e, t, r, i) {
  return z.makeSymbol(e, "Size" + t + "-Regular", r, i);
}, vI = function(e, t, r, i, s, o) {
  var l = cre(e, t, s, i), a = H7(z.makeSpan(["delimsizing", "size" + t], [l], i), Ae.TEXT, i, o);
  return r && bI(a, i, Ae.TEXT), a;
}, c4 = function(e, t, r) {
  var i;
  t === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var s = z.makeSpan(["delimsizinginner", i], [z.makeSpan([], [z.makeSymbol(e, t, r)])]);
  return {
    type: "elem",
    elem: s
  };
}, u4 = function(e, t, r) {
  var i = Yi["Size4-Regular"][e.charCodeAt(0)] ? Yi["Size4-Regular"][e.charCodeAt(0)][4] : Yi["Size1-Regular"][e.charCodeAt(0)][4], s = new Zo("inner", pne(e, Math.round(1e3 * t))), o = new Js([s], {
    width: re(i),
    height: re(t),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + re(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
    preserveAspectRatio: "xMinYMin"
  }), l = z.makeSvgSpan([], [o], r);
  return l.height = t, l.style.height = re(t), l.style.width = re(i), {
    type: "elem",
    elem: l
  };
}, N5 = 8e-3, tp = {
  type: "kern",
  size: -1 * N5
}, ure = ["|", "\\lvert", "\\rvert", "\\vert"], hre = ["\\|", "\\lVert", "\\rVert", "\\Vert"], wI = function(e, t, r, i, s, o) {
  var l, a, c, u, h = "", f = 0;
  l = c = u = e, a = null;
  var d = "Size1-Regular";
  e === "\\uparrow" ? c = u = "â" : e === "\\Uparrow" ? c = u = "â€–" : e === "\\downarrow" ? l = c = "â" : e === "\\Downarrow" ? l = c = "â€–" : e === "\\updownarrow" ? (l = "\\uparrow", c = "â", u = "\\downarrow") : e === "\\Updownarrow" ? (l = "\\Uparrow", c = "â€–", u = "\\Downarrow") : xe.contains(ure, e) ? (c = "âˆ£", h = "vert", f = 333) : xe.contains(hre, e) ? (c = "âˆ¥", h = "doublevert", f = 556) : e === "[" || e === "\\lbrack" ? (l = "âŽ¡", c = "âŽ¢", u = "âŽ£", d = "Size4-Regular", h = "lbrack", f = 667) : e === "]" || e === "\\rbrack" ? (l = "âŽ¤", c = "âŽ¥", u = "âŽ¦", d = "Size4-Regular", h = "rbrack", f = 667) : e === "\\lfloor" || e === "âŒŠ" ? (c = l = "âŽ¢", u = "âŽ£", d = "Size4-Regular", h = "lfloor", f = 667) : e === "\\lceil" || e === "âŒˆ" ? (l = "âŽ¡", c = u = "âŽ¢", d = "Size4-Regular", h = "lceil", f = 667) : e === "\\rfloor" || e === "âŒ‹" ? (c = l = "âŽ¥", u = "âŽ¦", d = "Size4-Regular", h = "rfloor", f = 667) : e === "\\rceil" || e === "âŒ‰" ? (l = "âŽ¤", c = u = "âŽ¥", d = "Size4-Regular", h = "rceil", f = 667) : e === "(" || e === "\\lparen" ? (l = "âŽ›", c = "âŽœ", u = "âŽ", d = "Size4-Regular", h = "lparen", f = 875) : e === ")" || e === "\\rparen" ? (l = "âŽž", c = "âŽŸ", u = "âŽ ", d = "Size4-Regular", h = "rparen", f = 875) : e === "\\{" || e === "\\lbrace" ? (l = "âŽ§", a = "âŽ¨", u = "âŽ©", c = "âŽª", d = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (l = "âŽ«", a = "âŽ¬", u = "âŽ­", c = "âŽª", d = "Size4-Regular") : e === "\\lgroup" || e === "âŸ®" ? (l = "âŽ§", u = "âŽ©", c = "âŽª", d = "Size4-Regular") : e === "\\rgroup" || e === "âŸ¯" ? (l = "âŽ«", u = "âŽ­", c = "âŽª", d = "Size4-Regular") : e === "\\lmoustache" || e === "âŽ°" ? (l = "âŽ§", u = "âŽ­", c = "âŽª", d = "Size4-Regular") : (e === "\\rmoustache" || e === "âŽ±") && (l = "âŽ«", u = "âŽ©", c = "âŽª", d = "Size4-Regular");
  var p = Mh(l, d, s), m = p.height + p.depth, g = Mh(c, d, s), b = g.height + g.depth, w = Mh(u, d, s), k = w.height + w.depth, T = 0, M = 1;
  if (a !== null) {
    var C = Mh(a, d, s);
    T = C.height + C.depth, M = 2;
  }
  var I = m + k + T, _ = Math.max(0, Math.ceil((t - I) / (M * b))), F = I + _ * M * b, L = i.fontMetrics().axisHeight;
  r && (L *= i.sizeMultiplier);
  var $ = F / 2 - L, B = [];
  if (h.length > 0) {
    var se = F - m - k, te = Math.round(F * 1e3), ie = mne(h, Math.round(se * 1e3)), Ce = new Zo(h, ie), Oe = (f / 1e3).toFixed(3) + "em", Re = (te / 1e3).toFixed(3) + "em", Be = new Js([Ce], {
      width: Oe,
      height: Re,
      viewBox: "0 0 " + f + " " + te
    }), D = z.makeSvgSpan([], [Be], i);
    D.height = te / 1e3, D.style.width = Oe, D.style.height = Re, B.push({
      type: "elem",
      elem: D
    });
  } else {
    if (B.push(c4(u, d, s)), B.push(tp), a === null) {
      var Me = F - m - k + 2 * N5;
      B.push(u4(c, Me, i));
    } else {
      var _e = (F - m - k - T) / 2 + 2 * N5;
      B.push(u4(c, _e, i)), B.push(tp), B.push(c4(a, d, s)), B.push(tp), B.push(u4(c, _e, i));
    }
    B.push(tp), B.push(c4(l, d, s));
  }
  var O = i.havingBaseStyle(Ae.TEXT), rt = z.makeVList({
    positionType: "bottom",
    positionData: $,
    children: B
  }, O);
  return H7(z.makeSpan(["delimsizing", "mult"], [rt], O), Ae.TEXT, i, o);
}, h4 = 80, f4 = 0.08, d4 = function(e, t, r, i, s) {
  var o = dne(e, i, r), l = new Zo(e, o), a = new Js([l], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: re(t),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return z.makeSvgSpan(["hide-tail"], [a], s);
}, fre = function(e, t) {
  var r = t.havingBaseSizing(), i = CI("\\surd", e * r.sizeMultiplier, SI, r), s = r.sizeMultiplier, o = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), l, a = 0, c = 0, u = 0, h;
  return i.type === "small" ? (u = 1e3 + 1e3 * o + h4, e < 1 ? s = 1 : e < 1.4 && (s = 0.7), a = (1 + o + f4) / s, c = (1 + o) / s, l = d4("sqrtMain", a, u, o, t), l.style.minWidth = "0.853em", h = 0.833 / s) : i.type === "large" ? (u = (1e3 + h4) * pf[i.size], c = (pf[i.size] + o) / s, a = (pf[i.size] + o + f4) / s, l = d4("sqrtSize" + i.size, a, u, o, t), l.style.minWidth = "1.02em", h = 1 / s) : (a = e + o + f4, c = e + o, u = Math.floor(1e3 * e + o) + h4, l = d4("sqrtTall", a, u, o, t), l.style.minWidth = "0.742em", h = 1.056), l.height = c, l.style.height = re(a), {
    span: l,
    advanceWidth: h,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (t.fontMetrics().sqrtRuleThickness + o) * s
  };
}, xI = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "âŒŠ", "âŒ‹", "\\lceil", "\\rceil", "âŒˆ", "âŒ‰", "\\surd"], dre = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "âŸ®", "âŸ¯", "\\lmoustache", "\\rmoustache", "âŽ°", "âŽ±"], kI = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], pf = [0, 1.2, 1.8, 2.4, 3], pre = function(e, t, r, i, s) {
  if (e === "<" || e === "\\lt" || e === "âŸ¨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "âŸ©") && (e = "\\rangle"), xe.contains(xI, e) || xe.contains(kI, e))
    return vI(e, t, !1, r, i, s);
  if (xe.contains(dre, e))
    return wI(e, pf[t], !1, r, i, s);
  throw new Z("Illegal delimiter: '" + e + "'");
}, mre = [{
  type: "small",
  style: Ae.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ae.SCRIPT
}, {
  type: "small",
  style: Ae.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], gre = [{
  type: "small",
  style: Ae.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ae.SCRIPT
}, {
  type: "small",
  style: Ae.TEXT
}, {
  type: "stack"
}], SI = [{
  type: "small",
  style: Ae.SCRIPTSCRIPT
}, {
  type: "small",
  style: Ae.SCRIPT
}, {
  type: "small",
  style: Ae.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], yre = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, CI = function(e, t, r, i) {
  for (var s = Math.min(2, 3 - i.style.size), o = s; o < r.length && r[o].type !== "stack"; o++) {
    var l = Mh(e, yre(r[o]), "math"), a = l.height + l.depth;
    if (r[o].type === "small") {
      var c = i.havingBaseStyle(r[o].style);
      a *= c.sizeMultiplier;
    }
    if (a > t)
      return r[o];
  }
  return r[r.length - 1];
}, MI = function(e, t, r, i, s, o) {
  e === "<" || e === "\\lt" || e === "âŸ¨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "âŸ©") && (e = "\\rangle");
  var l;
  xe.contains(kI, e) ? l = mre : xe.contains(xI, e) ? l = SI : l = gre;
  var a = CI(e, t, l, i);
  return a.type === "small" ? are(e, a.style, r, i, s, o) : a.type === "large" ? vI(e, a.size, r, i, s, o) : wI(e, t, r, i, s, o);
}, bre = function(e, t, r, i, s, o) {
  var l = i.fontMetrics().axisHeight * i.sizeMultiplier, a = 901, c = 5 / i.fontMetrics().ptPerEm, u = Math.max(t - l, r + l), h = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    u / 500 * a,
    2 * u - c
  );
  return MI(e, h, !0, i, s, o);
}, js = {
  sqrtImage: fre,
  sizedDelim: pre,
  sizeToMaxHeight: pf,
  customSizedDelim: MI,
  leftRightDelim: bre
}, wk = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, vre = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "âŒŠ", "âŒ‹", "\\lceil", "\\rceil", "âŒˆ", "âŒ‰", "<", ">", "\\langle", "âŸ¨", "\\rangle", "âŸ©", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "âŸ®", "âŸ¯", "\\lmoustache", "\\rmoustache", "âŽ°", "âŽ±", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function gg(n, e) {
  var t = pg(n);
  if (t && xe.contains(vre, t.text))
    return t;
  throw t ? new Z("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", n) : new Z("Invalid delimiter type '" + n.type + "'", n);
}
le({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = gg(e[0], n);
    return {
      type: "delimsizing",
      mode: n.parser.mode,
      size: wk[n.funcName].size,
      mclass: wk[n.funcName].mclass,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => n.delim === "." ? z.makeSpan([n.mclass]) : js.sizedDelim(n.delim, n.size, e, n.mode, [n.mclass]),
  mathmlBuilder: (n) => {
    var e = [];
    n.delim !== "." && e.push(si(n.delim, n.mode));
    var t = new X.MathNode("mo", e);
    n.mclass === "mopen" || n.mclass === "mclose" ? t.setAttribute("fence", "true") : t.setAttribute("fence", "false"), t.setAttribute("stretchy", "true");
    var r = re(js.sizeToMaxHeight[n.size]);
    return t.setAttribute("minsize", r), t.setAttribute("maxsize", r), t;
  }
});
function xk(n) {
  if (!n.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
le({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = n.parser.gullet.macros.get("\\current@color");
    if (t && typeof t != "string")
      throw new Z("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: n.parser.mode,
      delim: gg(e[0], n).text,
      color: t
      // undefined if not set via \color
    };
  }
});
le({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = gg(e[0], n), r = n.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var s = He(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: t.text,
      right: s.delim,
      rightColor: s.color
    };
  },
  htmlBuilder: (n, e) => {
    xk(n);
    for (var t = Jt(n.body, e, !0, ["mopen", "mclose"]), r = 0, i = 0, s = !1, o = 0; o < t.length; o++)
      t[o].isMiddle ? s = !0 : (r = Math.max(t[o].height, r), i = Math.max(t[o].depth, i));
    r *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var l;
    if (n.left === "." ? l = Zf(e, ["mopen"]) : l = js.leftRightDelim(n.left, r, i, e, n.mode, ["mopen"]), t.unshift(l), s)
      for (var a = 1; a < t.length; a++) {
        var c = t[a], u = c.isMiddle;
        u && (t[a] = js.leftRightDelim(u.delim, r, i, u.options, n.mode, []));
      }
    var h;
    if (n.right === ".")
      h = Zf(e, ["mclose"]);
    else {
      var f = n.rightColor ? e.withColor(n.rightColor) : e;
      h = js.leftRightDelim(n.right, r, i, f, n.mode, ["mclose"]);
    }
    return t.push(h), z.makeSpan(["minner"], t, e);
  },
  mathmlBuilder: (n, e) => {
    xk(n);
    var t = fr(n.body, e);
    if (n.left !== ".") {
      var r = new X.MathNode("mo", [si(n.left, n.mode)]);
      r.setAttribute("fence", "true"), t.unshift(r);
    }
    if (n.right !== ".") {
      var i = new X.MathNode("mo", [si(n.right, n.mode)]);
      i.setAttribute("fence", "true"), n.rightColor && i.setAttribute("mathcolor", n.rightColor), t.push(i);
    }
    return B7(t);
  }
});
le({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = gg(e[0], n);
    if (!n.parser.leftrightDepth)
      throw new Z("\\middle without preceding \\left", t);
    return {
      type: "middle",
      mode: n.parser.mode,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    if (n.delim === ".")
      t = Zf(e, []);
    else {
      t = js.sizedDelim(n.delim, 1, e, n.mode, []);
      var r = {
        delim: n.delim,
        options: e
      };
      t.isMiddle = r;
    }
    return t;
  },
  mathmlBuilder: (n, e) => {
    var t = n.delim === "\\vert" || n.delim === "|" ? si("|", "text") : si(n.delim, n.mode), r = new X.MathNode("mo", [t]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var $7 = (n, e) => {
  var t = z.wrapFragment(Qe(n.body, e), e), r = n.label.slice(1), i = e.sizeMultiplier, s, o = 0, l = xe.isCharacterBox(n.body);
  if (r === "sout")
    s = z.makeSpan(["stretchy", "sout"]), s.height = e.fontMetrics().defaultRuleThickness / i, o = -0.5 * e.fontMetrics().xHeight;
  else if (r === "phase") {
    var a = It({
      number: 0.6,
      unit: "pt"
    }, e), c = It({
      number: 0.35,
      unit: "ex"
    }, e), u = e.havingBaseSizing();
    i = i / u.sizeMultiplier;
    var h = t.height + t.depth + a + c;
    t.style.paddingLeft = re(h / 2 + a);
    var f = Math.floor(1e3 * h * i), d = hne(f), p = new Js([new Zo("phase", d)], {
      width: "400em",
      height: re(f / 1e3),
      viewBox: "0 0 400000 " + f,
      preserveAspectRatio: "xMinYMin slice"
    });
    s = z.makeSvgSpan(["hide-tail"], [p], e), s.style.height = re(h), o = t.depth + a + c;
  } else {
    /cancel/.test(r) ? l || t.classes.push("cancel-pad") : r === "angl" ? t.classes.push("anglpad") : t.classes.push("boxpad");
    var m = 0, g = 0, b = 0;
    /box/.test(r) ? (b = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), m = e.fontMetrics().fboxsep + (r === "colorbox" ? 0 : b), g = m) : r === "angl" ? (b = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), m = 4 * b, g = Math.max(0, 0.25 - t.depth)) : (m = l ? 0.2 : 0, g = m), s = Zs.encloseSpan(t, r, m, g, e), /fbox|boxed|fcolorbox/.test(r) ? (s.style.borderStyle = "solid", s.style.borderWidth = re(b)) : r === "angl" && b !== 0.049 && (s.style.borderTopWidth = re(b), s.style.borderRightWidth = re(b)), o = t.depth + g, n.backgroundColor && (s.style.backgroundColor = n.backgroundColor, n.borderColor && (s.style.borderColor = n.borderColor));
  }
  var w;
  if (n.backgroundColor)
    w = z.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: s,
          shift: o
        },
        {
          type: "elem",
          elem: t,
          shift: 0
        }
      ]
    }, e);
  else {
    var k = /cancel|phase/.test(r) ? ["svg-align"] : [];
    w = z.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: t,
          shift: 0
        },
        {
          type: "elem",
          elem: s,
          shift: o,
          wrapperClasses: k
        }
      ]
    }, e);
  }
  return /cancel/.test(r) && (w.height = t.height, w.depth = t.depth), /cancel/.test(r) && !l ? z.makeSpan(["mord", "cancel-lap"], [w], e) : z.makeSpan(["mord"], [w], e);
}, V7 = (n, e) => {
  var t = 0, r = new X.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [dt(n.body, e)]);
  switch (n.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * t + "pt"), r.setAttribute("height", "+" + 2 * t + "pt"), r.setAttribute("lspace", t + "pt"), r.setAttribute("voffset", t + "pt"), n.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(n.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return n.backgroundColor && r.setAttribute("mathbackground", n.backgroundColor), r;
};
le({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = He(e[0], "color-token").color, o = e[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: s,
      body: o
    };
  },
  htmlBuilder: $7,
  mathmlBuilder: V7
});
le({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = He(e[0], "color-token").color, o = He(e[1], "color-token").color, l = e[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: o,
      borderColor: s,
      body: l
    };
  },
  htmlBuilder: $7,
  mathmlBuilder: V7
});
le({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
le({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: $7,
  mathmlBuilder: V7
});
le({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var TI = {};
function hs(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, l = {
    type: e,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, a = 0; a < t.length; ++a)
    TI[t[a]] = l;
  s && (e1[e] = s), o && (t1[e] = o);
}
var AI = {};
function S(n, e) {
  AI[n] = e;
}
function kk(n) {
  var e = [];
  n.consumeSpaces();
  var t = n.fetch().text;
  for (t === "\\relax" && (n.consume(), n.consumeSpaces(), t = n.fetch().text); t === "\\hline" || t === "\\hdashline"; )
    n.consume(), e.push(t === "\\hdashline"), n.consumeSpaces(), t = n.fetch().text;
  return e;
}
var yg = (n) => {
  var e = n.parser.settings;
  if (!e.displayMode)
    throw new Z("{" + n.envName + "} can be used only in display mode.");
};
function q7(n) {
  if (n.indexOf("ed") === -1)
    return n.indexOf("*") === -1;
}
function al(n, e, t) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: s,
    arraystretch: o,
    colSeparationType: l,
    autoTag: a,
    singleRow: c,
    emptySingleRow: u,
    maxNumCols: h,
    leqno: f
  } = e;
  if (n.gullet.beginGroup(), c || n.gullet.macros.set("\\cr", "\\\\\\relax"), !o) {
    var d = n.gullet.expandMacroAsText("\\arraystretch");
    if (d == null)
      o = 1;
    else if (o = parseFloat(d), !o || o < 0)
      throw new Z("Invalid \\arraystretch: " + d);
  }
  n.gullet.beginGroup();
  var p = [], m = [p], g = [], b = [], w = a != null ? [] : void 0;
  function k() {
    a && n.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function T() {
    w && (n.gullet.macros.get("\\df@tag") ? (w.push(n.subparse([new Ir("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : w.push(!!a && n.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (k(), b.push(kk(n)); ; ) {
    var M = n.parseExpression(!1, c ? "\\end" : "\\\\");
    n.gullet.endGroup(), n.gullet.beginGroup(), M = {
      type: "ordgroup",
      mode: n.mode,
      body: M
    }, t && (M = {
      type: "styling",
      mode: n.mode,
      style: t,
      body: [M]
    }), p.push(M);
    var C = n.fetch().text;
    if (C === "&") {
      if (h && p.length === h) {
        if (c || l)
          throw new Z("Too many tab characters: &", n.nextToken);
        n.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      n.consume();
    } else if (C === "\\end") {
      T(), p.length === 1 && M.type === "styling" && M.body[0].body.length === 0 && (m.length > 1 || !u) && m.pop(), b.length < m.length + 1 && b.push([]);
      break;
    } else if (C === "\\\\") {
      n.consume();
      var I = void 0;
      n.gullet.future().text !== " " && (I = n.parseSizeGroup(!0)), g.push(I ? I.value : null), T(), b.push(kk(n)), p = [], m.push(p), k();
    } else
      throw new Z("Expected & or \\\\ or \\cr or \\end", n.nextToken);
  }
  return n.gullet.endGroup(), n.gullet.endGroup(), {
    type: "array",
    mode: n.mode,
    addJot: i,
    arraystretch: o,
    body: m,
    cols: s,
    rowGaps: g,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: b,
    colSeparationType: l,
    tags: w,
    leqno: f
  };
}
function W7(n) {
  return n.slice(0, 1) === "d" ? "display" : "text";
}
var fs = function(e, t) {
  var r, i, s = e.body.length, o = e.hLinesBeforeRow, l = 0, a = new Array(s), c = [], u = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    t.fontMetrics().arrayRuleWidth,
    t.minRuleThickness
    // User override.
  ), h = 1 / t.fontMetrics().ptPerEm, f = 5 * h;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var d = t.havingStyle(Ae.SCRIPT).sizeMultiplier;
    f = 0.2778 * (d / t.sizeMultiplier);
  }
  var p = e.colSeparationType === "CD" ? It({
    number: 3,
    unit: "ex"
  }, t) : 12 * h, m = 3 * h, g = e.arraystretch * p, b = 0.7 * g, w = 0.3 * g, k = 0;
  function T(Un) {
    for (var In = 0; In < Un.length; ++In)
      In > 0 && (k += 0.25), c.push({
        pos: k,
        isDashed: Un[In]
      });
  }
  for (T(o[0]), r = 0; r < e.body.length; ++r) {
    var M = e.body[r], C = b, I = w;
    l < M.length && (l = M.length);
    var _ = new Array(M.length);
    for (i = 0; i < M.length; ++i) {
      var F = Qe(M[i], t);
      I < F.depth && (I = F.depth), C < F.height && (C = F.height), _[i] = F;
    }
    var L = e.rowGaps[r], $ = 0;
    L && ($ = It(L, t), $ > 0 && ($ += w, I < $ && (I = $), $ = 0)), e.addJot && (I += m), _.height = C, _.depth = I, k += C, _.pos = k, k += I + $, a[r] = _, T(o[r + 1]);
  }
  var B = k / 2 + t.fontMetrics().axisHeight, se = e.cols || [], te = [], ie, Ce, Oe = [];
  if (e.tags && e.tags.some((Un) => Un))
    for (r = 0; r < s; ++r) {
      var Re = a[r], Be = Re.pos - B, D = e.tags[r], Me = void 0;
      D === !0 ? Me = z.makeSpan(["eqn-num"], [], t) : D === !1 ? Me = z.makeSpan([], [], t) : Me = z.makeSpan([], Jt(D, t, !0), t), Me.depth = Re.depth, Me.height = Re.height, Oe.push({
        type: "elem",
        elem: Me,
        shift: Be
      });
    }
  for (
    i = 0, Ce = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < l || Ce < se.length;
    ++i, ++Ce
  ) {
    for (var _e = se[Ce] || {}, O = !0; _e.type === "separator"; ) {
      if (O || (ie = z.makeSpan(["arraycolsep"], []), ie.style.width = re(t.fontMetrics().doubleRuleSep), te.push(ie)), _e.separator === "|" || _e.separator === ":") {
        var rt = _e.separator === "|" ? "solid" : "dashed", Le = z.makeSpan(["vertical-separator"], [], t);
        Le.style.height = re(k), Le.style.borderRightWidth = re(u), Le.style.borderRightStyle = rt, Le.style.margin = "0 " + re(-u / 2);
        var Ke = k - B;
        Ke && (Le.style.verticalAlign = re(-Ke)), te.push(Le);
      } else
        throw new Z("Invalid separator type: " + _e.separator);
      Ce++, _e = se[Ce] || {}, O = !1;
    }
    if (!(i >= l)) {
      var Dt = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (Dt = xe.deflt(_e.pregap, f), Dt !== 0 && (ie = z.makeSpan(["arraycolsep"], []), ie.style.width = re(Dt), te.push(ie)));
      var Pt = [];
      for (r = 0; r < s; ++r) {
        var Zt = a[r], on = Zt[i];
        if (on) {
          var Lr = Zt.pos - B;
          on.depth = Zt.depth, on.height = Zt.height, Pt.push({
            type: "elem",
            elem: on,
            shift: Lr
          });
        }
      }
      Pt = z.makeVList({
        positionType: "individualShift",
        children: Pt
      }, t), Pt = z.makeSpan(["col-align-" + (_e.align || "c")], [Pt]), te.push(Pt), (i < l - 1 || e.hskipBeforeAndAfter) && (Dt = xe.deflt(_e.postgap, f), Dt !== 0 && (ie = z.makeSpan(["arraycolsep"], []), ie.style.width = re(Dt), te.push(ie)));
    }
  }
  if (a = z.makeSpan(["mtable"], te), c.length > 0) {
    for (var dr = z.makeLineSpan("hline", t, u), ci = z.makeLineSpan("hdashline", t, u), vn = [{
      type: "elem",
      elem: a,
      shift: 0
    }]; c.length > 0; ) {
      var Br = c.pop(), zr = Br.pos - B;
      Br.isDashed ? vn.push({
        type: "elem",
        elem: ci,
        shift: zr
      }) : vn.push({
        type: "elem",
        elem: dr,
        shift: zr
      });
    }
    a = z.makeVList({
      positionType: "individualShift",
      children: vn
    }, t);
  }
  if (Oe.length === 0)
    return z.makeSpan(["mord"], [a], t);
  var wn = z.makeVList({
    positionType: "individualShift",
    children: Oe
  }, t);
  return wn = z.makeSpan(["tag"], [wn], t), z.makeFragment([a, wn]);
}, wre = {
  c: "center ",
  l: "left ",
  r: "right "
}, ds = function(e, t) {
  for (var r = [], i = new X.MathNode("mtd", [], ["mtr-glue"]), s = new X.MathNode("mtd", [], ["mml-eqn-num"]), o = 0; o < e.body.length; o++) {
    for (var l = e.body[o], a = [], c = 0; c < l.length; c++)
      a.push(new X.MathNode("mtd", [dt(l[c], t)]));
    e.tags && e.tags[o] && (a.unshift(i), a.push(i), e.leqno ? a.unshift(s) : a.push(s)), r.push(new X.MathNode("mtr", a));
  }
  var u = new X.MathNode("mtable", r), h = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  u.setAttribute("rowspacing", re(h));
  var f = "", d = "";
  if (e.cols && e.cols.length > 0) {
    var p = e.cols, m = "", g = !1, b = 0, w = p.length;
    p[0].type === "separator" && (f += "top ", b = 1), p[p.length - 1].type === "separator" && (f += "bottom ", w -= 1);
    for (var k = b; k < w; k++)
      p[k].type === "align" ? (d += wre[p[k].align], g && (m += "none "), g = !0) : p[k].type === "separator" && g && (m += p[k].separator === "|" ? "solid " : "dashed ", g = !1);
    u.setAttribute("columnalign", d.trim()), /[sd]/.test(m) && u.setAttribute("columnlines", m.trim());
  }
  if (e.colSeparationType === "align") {
    for (var T = e.cols || [], M = "", C = 1; C < T.length; C++)
      M += C % 2 ? "0em " : "1em ";
    u.setAttribute("columnspacing", M.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? u.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? u.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? u.setAttribute("columnspacing", "0.5em") : u.setAttribute("columnspacing", "1em");
  var I = "", _ = e.hLinesBeforeRow;
  f += _[0].length > 0 ? "left " : "", f += _[_.length - 1].length > 0 ? "right " : "";
  for (var F = 1; F < _.length - 1; F++)
    I += _[F].length === 0 ? "none " : _[F][0] ? "dashed " : "solid ";
  return /[sd]/.test(I) && u.setAttribute("rowlines", I.trim()), f !== "" && (u = new X.MathNode("menclose", [u]), u.setAttribute("notation", f.trim())), e.arraystretch && e.arraystretch < 1 && (u = new X.MathNode("mstyle", [u]), u.setAttribute("scriptlevel", "1")), u;
}, OI = function(e, t) {
  e.envName.indexOf("ed") === -1 && yg(e);
  var r = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", s = e.envName === "split", o = al(e.parser, {
    cols: r,
    addJot: !0,
    autoTag: s ? void 0 : q7(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: s ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), l, a = 0, c = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (t[0] && t[0].type === "ordgroup") {
    for (var u = "", h = 0; h < t[0].body.length; h++) {
      var f = He(t[0].body[h], "textord");
      u += f.text;
    }
    l = Number(u), a = l * 2;
  }
  var d = !a;
  o.body.forEach(function(b) {
    for (var w = 1; w < b.length; w += 2) {
      var k = He(b[w], "styling"), T = He(k.body[0], "ordgroup");
      T.body.unshift(c);
    }
    if (d)
      a < b.length && (a = b.length);
    else {
      var M = b.length / 2;
      if (l < M)
        throw new Z("Too many math in a row: " + ("expected " + l + ", but got " + M), b[0]);
    }
  });
  for (var p = 0; p < a; ++p) {
    var m = "r", g = 0;
    p % 2 === 1 ? m = "l" : p > 0 && d && (g = 1), r[p] = {
      type: "align",
      align: m,
      pregap: g,
      postgap: 0
    };
  }
  return o.colSeparationType = d ? "align" : "alignat", o;
};
hs({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = pg(e[0]), r = t ? [e[0]] : He(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = _7(o), a = l.text;
      if ("lcr".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      if (a === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (a === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new Z("Unknown column alignment: " + a, o);
    }), s = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return al(n.parser, s, W7(n.envName));
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[n.envName.replace("*", "")], t = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: t
      }]
    };
    if (n.envName.charAt(n.envName.length - 1) === "*") {
      var i = n.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), t = i.fetch().text, "lcr".indexOf(t) === -1)
          throw new Z("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: t
        }];
      }
    }
    var s = al(n.parser, r, W7(n.envName)), o = Math.max(0, ...s.body.map((l) => l.length));
    return s.cols = new Array(o).fill({
      type: "align",
      align: t
    }), e ? {
      type: "leftright",
      mode: n.mode,
      body: [s],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : s;
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 0.5
    }, t = al(n.parser, e, "script");
    return t.colSeparationType = "small", t;
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = pg(e[0]), r = t ? [e[0]] : He(e[0], "ordgroup").body, i = r.map(function(o) {
      var l = _7(o), a = l.text;
      if ("lc".indexOf(a) !== -1)
        return {
          type: "align",
          align: a
        };
      throw new Z("Unknown column alignment: " + a, o);
    });
    if (i.length > 1)
      throw new Z("{subarray} can contain only one column");
    var s = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (s = al(n.parser, s, "script"), s.body.length > 0 && s.body[0].length > 1)
      throw new Z("{subarray} can contain only one column");
    return s;
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, t = al(n.parser, e, W7(n.envName));
    return {
      type: "leftright",
      mode: n.mode,
      body: [t],
      left: n.envName.indexOf("r") > -1 ? "." : "\\{",
      right: n.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: OI,
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    xe.contains(["gather", "gather*"], n.envName) && yg(n);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: q7(n.envName),
      emptySingleRow: !0,
      leqno: n.parser.settings.leqno
    };
    return al(n.parser, e, "display");
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: OI,
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    yg(n);
    var e = {
      autoTag: q7(n.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: n.parser.settings.leqno
    };
    return al(n.parser, e, "display");
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
hs({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(n) {
    return yg(n), ore(n.parser);
  },
  htmlBuilder: fs,
  mathmlBuilder: ds
});
S("\\nonumber", "\\gdef\\@eqnsw{0}");
S("\\notag", "\\nonumber");
le({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(n, e) {
    throw new Z(n.funcName + " valid only within array environment");
  }
});
var Sk = TI;
le({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    if (i.type !== "ordgroup")
      throw new Z("Invalid environment name", i);
    for (var s = "", o = 0; o < i.body.length; ++o)
      s += He(i.body[o], "textord").text;
    if (r === "\\begin") {
      if (!Sk.hasOwnProperty(s))
        throw new Z("No such environment: " + s, i);
      var l = Sk[s], {
        args: a,
        optArgs: c
      } = t.parseArguments("\\begin{" + s + "}", l), u = {
        mode: t.mode,
        envName: s,
        parser: t
      }, h = l.handler(u, a, c);
      t.expect("\\end", !1);
      var f = t.nextToken, d = He(t.parseFunction(), "environment");
      if (d.name !== s)
        throw new Z("Mismatch: \\begin{" + s + "} matched by \\end{" + d.name + "}", f);
      return h;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: s,
      nameGroup: i
    };
  }
});
var EI = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return Qe(n.body, r);
}, II = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return dt(n.body, r);
}, Ck = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
le({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = n1(e[0]), s = r;
    return s in Ck && (s = Ck[s]), {
      type: "font",
      mode: t.mode,
      font: s.slice(1),
      body: i
    };
  },
  htmlBuilder: EI,
  mathmlBuilder: II
});
le({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0], i = xe.isCharacterBox(r);
    return {
      type: "mclass",
      mode: t.mode,
      mclass: mg(r),
      body: [{
        type: "font",
        mode: t.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
le({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      breakOnTokenText: i
    } = n, {
      mode: s
    } = t, o = t.parseExpression(!0, i), l = "math" + r.slice(1);
    return {
      type: "font",
      mode: s,
      font: l,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: o
      }
    };
  },
  htmlBuilder: EI,
  mathmlBuilder: II
});
var DI = (n, e) => {
  var t = e;
  return n === "display" ? t = t.id >= Ae.SCRIPT.id ? t.text() : Ae.DISPLAY : n === "text" && t.size === Ae.DISPLAY.size ? t = Ae.TEXT : n === "script" ? t = Ae.SCRIPT : n === "scriptscript" && (t = Ae.SCRIPTSCRIPT), t;
}, j7 = (n, e) => {
  var t = DI(n.size, e.style), r = t.fracNum(), i = t.fracDen(), s;
  s = e.havingStyle(r);
  var o = Qe(n.numer, s, e);
  if (n.continued) {
    var l = 8.5 / e.fontMetrics().ptPerEm, a = 3.5 / e.fontMetrics().ptPerEm;
    o.height = o.height < l ? l : o.height, o.depth = o.depth < a ? a : o.depth;
  }
  s = e.havingStyle(i);
  var c = Qe(n.denom, s, e), u, h, f;
  n.hasBarLine ? (n.barSize ? (h = It(n.barSize, e), u = z.makeLineSpan("frac-line", e, h)) : u = z.makeLineSpan("frac-line", e), h = u.height, f = u.height) : (u = null, h = 0, f = e.fontMetrics().defaultRuleThickness);
  var d, p, m;
  t.size === Ae.DISPLAY.size || n.size === "display" ? (d = e.fontMetrics().num1, h > 0 ? p = 3 * f : p = 7 * f, m = e.fontMetrics().denom1) : (h > 0 ? (d = e.fontMetrics().num2, p = f) : (d = e.fontMetrics().num3, p = 3 * f), m = e.fontMetrics().denom2);
  var g;
  if (u) {
    var w = e.fontMetrics().axisHeight;
    d - o.depth - (w + 0.5 * h) < p && (d += p - (d - o.depth - (w + 0.5 * h))), w - 0.5 * h - (c.height - m) < p && (m += p - (w - 0.5 * h - (c.height - m)));
    var k = -(w - 0.5 * h);
    g = z.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: u,
        shift: k
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  } else {
    var b = d - o.depth - (c.height - m);
    b < p && (d += 0.5 * (p - b), m += 0.5 * (p - b)), g = z.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: m
      }, {
        type: "elem",
        elem: o,
        shift: -d
      }]
    }, e);
  }
  s = e.havingStyle(t), g.height *= s.sizeMultiplier / e.sizeMultiplier, g.depth *= s.sizeMultiplier / e.sizeMultiplier;
  var T;
  t.size === Ae.DISPLAY.size ? T = e.fontMetrics().delim1 : t.size === Ae.SCRIPTSCRIPT.size ? T = e.havingStyle(Ae.SCRIPT).fontMetrics().delim2 : T = e.fontMetrics().delim2;
  var M, C;
  return n.leftDelim == null ? M = Zf(e, ["mopen"]) : M = js.customSizedDelim(n.leftDelim, T, !0, e.havingStyle(t), n.mode, ["mopen"]), n.continued ? C = z.makeSpan([]) : n.rightDelim == null ? C = Zf(e, ["mclose"]) : C = js.customSizedDelim(n.rightDelim, T, !0, e.havingStyle(t), n.mode, ["mclose"]), z.makeSpan(["mord"].concat(s.sizingClasses(e)), [M, z.makeSpan(["mfrac"], [g]), C], e);
}, U7 = (n, e) => {
  var t = new X.MathNode("mfrac", [dt(n.numer, e), dt(n.denom, e)]);
  if (!n.hasBarLine)
    t.setAttribute("linethickness", "0px");
  else if (n.barSize) {
    var r = It(n.barSize, e);
    t.setAttribute("linethickness", re(r));
  }
  var i = DI(n.size, e.style);
  if (i.size !== e.style.size) {
    t = new X.MathNode("mstyle", [t]);
    var s = i.size === Ae.DISPLAY.size ? "true" : "false";
    t.setAttribute("displaystyle", s), t.setAttribute("scriptlevel", "0");
  }
  if (n.leftDelim != null || n.rightDelim != null) {
    var o = [];
    if (n.leftDelim != null) {
      var l = new X.MathNode("mo", [new X.TextNode(n.leftDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), o.push(l);
    }
    if (o.push(t), n.rightDelim != null) {
      var a = new X.MathNode("mo", [new X.TextNode(n.rightDelim.replace("\\", ""))]);
      a.setAttribute("fence", "true"), o.push(a);
    }
    return B7(o);
  }
  return t;
};
le({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // canâ€™t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1], o, l = null, a = null, c = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        o = !0;
        break;
      case "\\\\atopfrac":
        o = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        o = !1, l = "(", a = ")";
        break;
      case "\\\\bracefrac":
        o = !1, l = "\\{", a = "\\}";
        break;
      case "\\\\brackfrac":
        o = !1, l = "[", a = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        c = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        c = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !1,
      numer: i,
      denom: s,
      hasBarLine: o,
      leftDelim: l,
      rightDelim: a,
      size: c,
      barSize: null
    };
  },
  htmlBuilder: j7,
  mathmlBuilder: U7
});
le({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !0,
      numer: i,
      denom: s,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
le({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t,
      token: r
    } = n, i;
    switch (t) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: r
    };
  }
});
var Mk = ["display", "text", "script", "scriptscript"], Tk = function(e) {
  var t = null;
  return e.length > 0 && (t = e, t = t === "." ? null : t), t;
};
le({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[4], i = e[5], s = n1(e[0]), o = s.type === "atom" && s.family === "open" ? Tk(s.text) : null, l = n1(e[1]), a = l.type === "atom" && l.family === "close" ? Tk(l.text) : null, c = He(e[2], "size"), u, h = null;
    c.isBlank ? u = !0 : (h = c.value, u = h.number > 0);
    var f = "auto", d = e[3];
    if (d.type === "ordgroup") {
      if (d.body.length > 0) {
        var p = He(d.body[0], "textord");
        f = Mk[Number(p.text)];
      }
    } else
      d = He(d, "textord"), f = Mk[Number(d.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: u,
      barSize: h,
      leftDelim: o,
      rightDelim: a,
      size: f
    };
  },
  htmlBuilder: j7,
  mathmlBuilder: U7
});
le({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n;
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      size: He(e[0], "size").value,
      token: i
    };
  }
});
le({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = Jte(He(e[1], "infix").size), o = e[2], l = s.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: i,
      denom: o,
      continued: !1,
      hasBarLine: l,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: j7,
  mathmlBuilder: U7
});
var NI = (n, e) => {
  var t = e.style, r, i;
  n.type === "supsub" ? (r = n.sup ? Qe(n.sup, e.havingStyle(t.sup()), e) : Qe(n.sub, e.havingStyle(t.sub()), e), i = He(n.base, "horizBrace")) : i = He(n, "horizBrace");
  var s = Qe(i.base, e.havingBaseStyle(Ae.DISPLAY)), o = Zs.svgSpan(i, e), l;
  if (i.isOver ? (l = z.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: o
    }]
  }, e), l.children[0].children[0].children[1].classes.push("svg-align")) : (l = z.makeVList({
    positionType: "bottom",
    positionData: s.depth + 0.1 + o.height,
    children: [{
      type: "elem",
      elem: o
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), l.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var a = z.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
    i.isOver ? l = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, e) : l = z.makeVList({
      positionType: "bottom",
      positionData: a.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: a
      }]
    }, e);
  }
  return z.makeSpan(["mord", i.isOver ? "mover" : "munder"], [l], e);
}, xre = (n, e) => {
  var t = Zs.mathMLnode(n.label);
  return new X.MathNode(n.isOver ? "mover" : "munder", [dt(n.base, e), t]);
};
le({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "horizBrace",
      mode: t.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: e[0]
    };
  },
  htmlBuilder: NI,
  mathmlBuilder: xre
});
le({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[1], i = He(e[0], "url").url;
    return t.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: t.mode,
      href: i,
      body: zt(r)
    } : t.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (n, e) => {
    var t = Jt(n.body, e, !1);
    return z.makeAnchor(n.href, [], t, e);
  },
  mathmlBuilder: (n, e) => {
    var t = Qo(n.body, e);
    return t instanceof Tr || (t = new Tr("mrow", [t])), t.setAttribute("href", n.href), t;
  }
});
le({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = He(e[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return t.formatUnsupportedCmd("\\url");
    for (var i = [], s = 0; s < r.length; s++) {
      var o = r[s];
      o === "~" && (o = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: o
      });
    }
    var l = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: t.mode,
      href: r,
      body: zt(l)
    };
  }
});
le({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "hbox",
      mode: t.mode,
      body: zt(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = Jt(n.body, e, !1);
    return z.makeFragment(t);
  },
  mathmlBuilder(n, e) {
    return new X.MathNode("mrow", fr(n.body, e));
  }
});
le({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n, s = He(e[0], "raw").string, o = e[1];
    t.settings.strict && t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var l, a = {};
    switch (r) {
      case "\\htmlClass":
        a.class = s, l = {
          command: "\\htmlClass",
          class: s
        };
        break;
      case "\\htmlId":
        a.id = s, l = {
          command: "\\htmlId",
          id: s
        };
        break;
      case "\\htmlStyle":
        a.style = s, l = {
          command: "\\htmlStyle",
          style: s
        };
        break;
      case "\\htmlData": {
        for (var c = s.split(","), u = 0; u < c.length; u++) {
          var h = c[u].split("=");
          if (h.length !== 2)
            throw new Z("Error parsing key-value for \\htmlData");
          a["data-" + h[0].trim()] = h[1].trim();
        }
        l = {
          command: "\\htmlData",
          attributes: a
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return t.settings.isTrusted(l) ? {
      type: "html",
      mode: t.mode,
      attributes: a,
      body: zt(o)
    } : t.formatUnsupportedCmd(r);
  },
  htmlBuilder: (n, e) => {
    var t = Jt(n.body, e, !1), r = ["enclosing"];
    n.attributes.class && r.push(...n.attributes.class.trim().split(/\s+/));
    var i = z.makeSpan(r, t, e);
    for (var s in n.attributes)
      s !== "class" && n.attributes.hasOwnProperty(s) && i.setAttribute(s, n.attributes[s]);
    return i;
  },
  mathmlBuilder: (n, e) => Qo(n.body, e)
});
le({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "htmlmathml",
      mode: t.mode,
      html: zt(e[0]),
      mathml: zt(e[1])
    };
  },
  htmlBuilder: (n, e) => {
    var t = Jt(n.html, e, !1);
    return z.makeFragment(t);
  },
  mathmlBuilder: (n, e) => Qo(n.mathml, e)
});
var p4 = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!t)
    throw new Z("Invalid size: '" + e + "' in \\includegraphics");
  var r = {
    number: +(t[1] + t[2]),
    // sign + magnitude, cast to number
    unit: t[3]
  };
  if (!XE(r))
    throw new Z("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
le({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = {
      number: 0,
      unit: "em"
    }, s = {
      number: 0.9,
      unit: "em"
    }, o = {
      number: 0,
      unit: "em"
    }, l = "";
    if (t[0])
      for (var a = He(t[0], "raw").string, c = a.split(","), u = 0; u < c.length; u++) {
        var h = c[u].split("=");
        if (h.length === 2) {
          var f = h[1].trim();
          switch (h[0].trim()) {
            case "alt":
              l = f;
              break;
            case "width":
              i = p4(f);
              break;
            case "height":
              s = p4(f);
              break;
            case "totalheight":
              o = p4(f);
              break;
            default:
              throw new Z("Invalid key: '" + h[0] + "' in \\includegraphics.");
          }
        }
      }
    var d = He(e[0], "url").url;
    return l === "" && (l = d, l = l.replace(/^.*[\\/]/, ""), l = l.substring(0, l.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: d
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: l,
      width: i,
      height: s,
      totalheight: o,
      src: d
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (n, e) => {
    var t = It(n.height, e), r = 0;
    n.totalheight.number > 0 && (r = It(n.totalheight, e) - t);
    var i = 0;
    n.width.number > 0 && (i = It(n.width, e));
    var s = {
      height: re(t + r)
    };
    i > 0 && (s.width = re(i)), r > 0 && (s.verticalAlign = re(-r));
    var o = new xne(n.src, n.alt, s);
    return o.height = t, o.depth = r, o;
  },
  mathmlBuilder: (n, e) => {
    var t = new X.MathNode("mglyph", []);
    t.setAttribute("alt", n.alt);
    var r = It(n.height, e), i = 0;
    if (n.totalheight.number > 0 && (i = It(n.totalheight, e) - r, t.setAttribute("valign", re(-i))), t.setAttribute("height", re(r + i)), n.width.number > 0) {
      var s = It(n.width, e);
      t.setAttribute("width", re(s));
    }
    return t.setAttribute("src", n.src), t;
  }
});
le({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = He(e[0], "size");
    if (t.settings.strict) {
      var s = r[1] === "m", o = i.value.unit === "mu";
      s ? (o || t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), t.mode !== "math" && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : o && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: i.value
    };
  },
  htmlBuilder(n, e) {
    return z.makeGlue(n.dimension, e);
  },
  mathmlBuilder(n, e) {
    var t = It(n.dimension, e);
    return new X.SpaceNode(t);
  }
});
le({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    n.alignment === "clap" ? (t = z.makeSpan([], [Qe(n.body, e)]), t = z.makeSpan(["inner"], [t], e)) : t = z.makeSpan(["inner"], [Qe(n.body, e)]);
    var r = z.makeSpan(["fix"], []), i = z.makeSpan([n.alignment], [t, r], e), s = z.makeSpan(["strut"]);
    return s.style.height = re(i.height + i.depth), i.depth && (s.style.verticalAlign = re(-i.depth)), i.children.unshift(s), i = z.makeSpan(["thinbox"], [i], e), z.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new X.MathNode("mpadded", [dt(n.body, e)]);
    if (n.alignment !== "rlap") {
      var r = n.alignment === "llap" ? "-1" : "-0.5";
      t.setAttribute("lspace", r + "width");
    }
    return t.setAttribute("width", "0px"), t;
  }
});
le({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    var {
      funcName: t,
      parser: r
    } = n, i = r.mode;
    r.switchMode("math");
    var s = t === "\\(" ? "\\)" : "$", o = r.parseExpression(!1, s);
    return r.expect(s), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: o
    };
  }
});
le({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    throw new Z("Mismatched " + n.funcName);
  }
});
var Ak = (n, e) => {
  switch (e.style.size) {
    case Ae.DISPLAY.size:
      return n.display;
    case Ae.TEXT.size:
      return n.text;
    case Ae.SCRIPT.size:
      return n.script;
    case Ae.SCRIPTSCRIPT.size:
      return n.scriptscript;
    default:
      return n.text;
  }
};
le({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "mathchoice",
      mode: t.mode,
      display: zt(e[0]),
      text: zt(e[1]),
      script: zt(e[2]),
      scriptscript: zt(e[3])
    };
  },
  htmlBuilder: (n, e) => {
    var t = Ak(n, e), r = Jt(t, e, !1);
    return z.makeFragment(r);
  },
  mathmlBuilder: (n, e) => {
    var t = Ak(n, e);
    return Qo(t, e);
  }
});
var RI = (n, e, t, r, i, s, o) => {
  n = z.makeSpan([], [n]);
  var l = t && xe.isCharacterBox(t), a, c;
  if (e) {
    var u = Qe(e, r.havingStyle(i.sup()), r);
    c = {
      elem: u,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - u.depth)
    };
  }
  if (t) {
    var h = Qe(t, r.havingStyle(i.sub()), r);
    a = {
      elem: h,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - h.height)
    };
  }
  var f;
  if (c && a) {
    var d = r.fontMetrics().bigOpSpacing5 + a.elem.height + a.elem.depth + a.kern + n.depth + o;
    f = z.makeVList({
      positionType: "bottom",
      positionData: d,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: re(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: re(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (a) {
    var p = n.height - o;
    f = z.makeVList({
      positionType: "top",
      positionData: p,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: a.elem,
        marginLeft: re(-s)
      }, {
        type: "kern",
        size: a.kern
      }, {
        type: "elem",
        elem: n
      }]
    }, r);
  } else if (c) {
    var m = n.depth + o;
    f = z.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: re(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return n;
  var g = [f];
  if (a && s !== 0 && !l) {
    var b = z.makeSpan(["mspace"], [], r);
    b.style.marginRight = re(s), g.unshift(b);
  }
  return z.makeSpan(["mop", "op-limits"], g, r);
}, PI = ["\\smallint"], Tu = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = He(n.base, "op"), i = !0) : s = He(n, "op");
  var o = e.style, l = !1;
  o.size === Ae.DISPLAY.size && s.symbol && !xe.contains(PI, s.name) && (l = !0);
  var a;
  if (s.symbol) {
    var c = l ? "Size2-Regular" : "Size1-Regular", u = "";
    if ((s.name === "\\oiint" || s.name === "\\oiiint") && (u = s.name.slice(1), s.name = u === "oiint" ? "\\iint" : "\\iiint"), a = z.makeSymbol(s.name, c, "math", e, ["mop", "op-symbol", l ? "large-op" : "small-op"]), u.length > 0) {
      var h = a.italic, f = z.staticSvg(u + "Size" + (l ? "2" : "1"), e);
      a = z.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: a,
          shift: 0
        }, {
          type: "elem",
          elem: f,
          shift: l ? 0.08 : 0
        }]
      }, e), s.name = "\\" + u, a.classes.unshift("mop"), a.italic = h;
    }
  } else if (s.body) {
    var d = Jt(s.body, e, !0);
    d.length === 1 && d[0] instanceof ii ? (a = d[0], a.classes[0] = "mop") : a = z.makeSpan(["mop"], d, e);
  } else {
    for (var p = [], m = 1; m < s.name.length; m++)
      p.push(z.mathsym(s.name[m], s.mode, e));
    a = z.makeSpan(["mop"], p, e);
  }
  var g = 0, b = 0;
  return (a instanceof ii || s.name === "\\oiint" || s.name === "\\oiiint") && !s.suppressBaseShift && (g = (a.height - a.depth) / 2 - e.fontMetrics().axisHeight, b = a.italic), i ? RI(a, t, r, e, o, b, g) : (g && (a.style.position = "relative", a.style.top = re(g)), a);
}, n0 = (n, e) => {
  var t;
  if (n.symbol)
    t = new Tr("mo", [si(n.name, n.mode)]), xe.contains(PI, n.name) && t.setAttribute("largeop", "false");
  else if (n.body)
    t = new Tr("mo", fr(n.body, e));
  else {
    t = new Tr("mi", [new Ji(n.name.slice(1))]);
    var r = new Tr("mo", [si("â¡", "text")]);
    n.parentIsSupSub ? t = new Tr("mrow", [t, r]) : t = aI([t, r]);
  }
  return t;
}, kre = {
  "âˆ": "\\prod",
  "âˆ": "\\coprod",
  "âˆ‘": "\\sum",
  "â‹€": "\\bigwedge",
  "â‹": "\\bigvee",
  "â‹‚": "\\bigcap",
  "â‹ƒ": "\\bigcup",
  "â¨€": "\\bigodot",
  "â¨": "\\bigoplus",
  "â¨‚": "\\bigotimes",
  "â¨„": "\\biguplus",
  "â¨†": "\\bigsqcup"
};
le({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "âˆ", "âˆ", "âˆ‘", "â‹€", "â‹", "â‹‚", "â‹ƒ", "â¨€", "â¨", "â¨‚", "â¨„", "â¨†"],
  props: {
    numArgs: 0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = r;
    return i.length === 1 && (i = kre[i]), {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: Tu,
  mathmlBuilder: n0
});
le({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: zt(r)
    };
  },
  htmlBuilder: Tu,
  mathmlBuilder: n0
});
var Sre = {
  "âˆ«": "\\int",
  "âˆ¬": "\\iint",
  "âˆ­": "\\iiint",
  "âˆ®": "\\oint",
  "âˆ¯": "\\oiint",
  "âˆ°": "\\oiiint"
};
le({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: Tu,
  mathmlBuilder: n0
});
le({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: Tu,
  mathmlBuilder: n0
});
le({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "âˆ«", "âˆ¬", "âˆ­", "âˆ®", "âˆ¯", "âˆ°"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = t;
    return r.length === 1 && (r = Sre[r]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: Tu,
  mathmlBuilder: n0
});
var LI = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = He(n.base, "operatorname"), i = !0) : s = He(n, "operatorname");
  var o;
  if (s.body.length > 0) {
    for (var l = s.body.map((h) => {
      var f = h.text;
      return typeof f == "string" ? {
        type: "textord",
        mode: h.mode,
        text: f
      } : h;
    }), a = Jt(l, e.withFont("mathrm"), !0), c = 0; c < a.length; c++) {
      var u = a[c];
      u instanceof ii && (u.text = u.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    o = z.makeSpan(["mop"], a, e);
  } else
    o = z.makeSpan(["mop"], [], e);
  return i ? RI(o, t, r, e, e.style, 0, 0) : o;
}, Cre = (n, e) => {
  for (var t = fr(n.body, e.withFont("mathrm")), r = !0, i = 0; i < t.length; i++) {
    var s = t[i];
    if (!(s instanceof X.SpaceNode)) if (s instanceof X.MathNode)
      switch (s.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var o = s.children[0];
          s.children.length === 1 && o instanceof X.TextNode ? o.text = o.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var l = t.map((u) => u.toText()).join("");
    t = [new X.TextNode(l)];
  }
  var a = new X.MathNode("mi", t);
  a.setAttribute("mathvariant", "normal");
  var c = new X.MathNode("mo", [si("â¡", "text")]);
  return n.parentIsSupSub ? new X.MathNode("mrow", [a, c]) : X.newDocumentFragment([a, c]);
};
le({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "operatorname",
      mode: t.mode,
      body: zt(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: LI,
  mathmlBuilder: Cre
});
S("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
Ea({
  type: "ordgroup",
  htmlBuilder(n, e) {
    return n.semisimple ? z.makeFragment(Jt(n.body, e, !1)) : z.makeSpan(["mord"], Jt(n.body, e, !0), e);
  },
  mathmlBuilder(n, e) {
    return Qo(n.body, e, !0);
  }
});
le({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "overline",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder(n, e) {
    var t = Qe(n.body, e.havingCrampedStyle()), r = z.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, s = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return z.makeSpan(["mord", "overline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mo", [new X.TextNode("â€¾")]);
    t.setAttribute("stretchy", "true");
    var r = new X.MathNode("mover", [dt(n.body, e), t]);
    return r.setAttribute("accent", "true"), r;
  }
});
le({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: zt(r)
    };
  },
  htmlBuilder: (n, e) => {
    var t = Jt(n.body, e.withPhantom(), !1);
    return z.makeFragment(t);
  },
  mathmlBuilder: (n, e) => {
    var t = fr(n.body, e);
    return new X.MathNode("mphantom", t);
  }
});
le({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = z.makeSpan([], [Qe(n.body, e.withPhantom())]);
    if (t.height = 0, t.depth = 0, t.children)
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0, t.children[r].depth = 0;
    return t = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e), z.makeSpan(["mord"], [t], e);
  },
  mathmlBuilder: (n, e) => {
    var t = fr(zt(n.body), e), r = new X.MathNode("mphantom", t), i = new X.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
le({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = z.makeSpan(["inner"], [Qe(n.body, e.withPhantom())]), r = z.makeSpan(["fix"], []);
    return z.makeSpan(["mord", "rlap"], [t, r], e);
  },
  mathmlBuilder: (n, e) => {
    var t = fr(zt(n.body), e), r = new X.MathNode("mphantom", t), i = new X.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
le({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = He(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: t.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(n, e) {
    var t = Qe(n.body, e), r = It(n.dy, e);
    return z.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mpadded", [dt(n.body, e)]), r = n.dy.number + n.dy.unit;
    return t.setAttribute("voffset", r), t;
  }
});
le({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(n) {
    var {
      parser: e
    } = n;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
le({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = He(e[0], "size"), o = He(e[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && He(i, "size").value,
      width: s.value,
      height: o.value
    };
  },
  htmlBuilder(n, e) {
    var t = z.makeSpan(["mord", "rule"], [], e), r = It(n.width, e), i = It(n.height, e), s = n.shift ? It(n.shift, e) : 0;
    return t.style.borderRightWidth = re(r), t.style.borderTopWidth = re(i), t.style.bottom = re(s), t.width = r, t.height = i + s, t.depth = -s, t.maxFontSize = i * 1.125 * e.sizeMultiplier, t;
  },
  mathmlBuilder(n, e) {
    var t = It(n.width, e), r = It(n.height, e), i = n.shift ? It(n.shift, e) : 0, s = e.color && e.getColor() || "black", o = new X.MathNode("mspace");
    o.setAttribute("mathbackground", s), o.setAttribute("width", re(t)), o.setAttribute("height", re(r));
    var l = new X.MathNode("mpadded", [o]);
    return i >= 0 ? l.setAttribute("height", re(i)) : (l.setAttribute("height", re(i)), l.setAttribute("depth", re(-i))), l.setAttribute("voffset", re(i)), l;
  }
});
function BI(n, e, t) {
  for (var r = Jt(n, e, !1), i = e.sizeMultiplier / t.sizeMultiplier, s = 0; s < r.length; s++) {
    var o = r[s].classes.indexOf("sizing");
    o < 0 ? Array.prototype.push.apply(r[s].classes, e.sizingClasses(t)) : r[s].classes[o + 1] === "reset-size" + e.size && (r[s].classes[o + 1] = "reset-size" + t.size), r[s].height *= i, r[s].depth *= i;
  }
  return z.makeFragment(r);
}
var Ok = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], Mre = (n, e) => {
  var t = e.havingSize(n.size);
  return BI(n.body, t, e);
};
le({
  type: "sizing",
  names: Ok,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!1, t);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: Ok.indexOf(r) + 1,
      body: s
    };
  },
  htmlBuilder: Mre,
  mathmlBuilder: (n, e) => {
    var t = e.havingSize(n.size), r = fr(n.body, t), i = new X.MathNode("mstyle", r);
    return i.setAttribute("mathsize", re(t.sizeMultiplier)), i;
  }
});
le({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = !1, s = !1, o = t[0] && He(t[0], "ordgroup");
    if (o)
      for (var l = "", a = 0; a < o.body.length; ++a) {
        var c = o.body[a];
        if (l = c.text, l === "t")
          i = !0;
        else if (l === "b")
          s = !0;
        else {
          i = !1, s = !1;
          break;
        }
      }
    else
      i = !0, s = !0;
    var u = e[0];
    return {
      type: "smash",
      mode: r.mode,
      body: u,
      smashHeight: i,
      smashDepth: s
    };
  },
  htmlBuilder: (n, e) => {
    var t = z.makeSpan([], [Qe(n.body, e)]);
    if (!n.smashHeight && !n.smashDepth)
      return t;
    if (n.smashHeight && (t.height = 0, t.children))
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0;
    if (n.smashDepth && (t.depth = 0, t.children))
      for (var i = 0; i < t.children.length; i++)
        t.children[i].depth = 0;
    var s = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
    return z.makeSpan(["mord"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new X.MathNode("mpadded", [dt(n.body, e)]);
    return n.smashHeight && t.setAttribute("height", "0px"), n.smashDepth && t.setAttribute("depth", "0px"), t;
  }
});
le({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = e[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: s,
      index: i
    };
  },
  htmlBuilder(n, e) {
    var t = Qe(n.body, e.havingCrampedStyle());
    t.height === 0 && (t.height = e.fontMetrics().xHeight), t = z.wrapFragment(t, e);
    var r = e.fontMetrics(), i = r.defaultRuleThickness, s = i;
    e.style.id < Ae.TEXT.id && (s = e.fontMetrics().xHeight);
    var o = i + s / 4, l = t.height + t.depth + o + i, {
      span: a,
      ruleWidth: c,
      advanceWidth: u
    } = js.sqrtImage(l, e), h = a.height - c;
    h > t.height + t.depth + o && (o = (o + h - t.height - t.depth) / 2);
    var f = a.height - t.height - o - c;
    t.style.paddingLeft = re(u);
    var d = z.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(t.height + f)
      }, {
        type: "elem",
        elem: a
      }, {
        type: "kern",
        size: c
      }]
    }, e);
    if (n.index) {
      var p = e.havingStyle(Ae.SCRIPTSCRIPT), m = Qe(n.index, p, e), g = 0.6 * (d.height - d.depth), b = z.makeVList({
        positionType: "shift",
        positionData: -g,
        children: [{
          type: "elem",
          elem: m
        }]
      }, e), w = z.makeSpan(["root"], [b]);
      return z.makeSpan(["mord", "sqrt"], [w, d], e);
    } else
      return z.makeSpan(["mord", "sqrt"], [d], e);
  },
  mathmlBuilder(n, e) {
    var {
      body: t,
      index: r
    } = n;
    return r ? new X.MathNode("mroot", [dt(t, e), dt(r, e)]) : new X.MathNode("msqrt", [dt(t, e)]);
  }
});
var Ek = {
  display: Ae.DISPLAY,
  text: Ae.TEXT,
  script: Ae.SCRIPT,
  scriptscript: Ae.SCRIPTSCRIPT
};
le({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!0, t), o = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: o,
      body: s
    };
  },
  htmlBuilder(n, e) {
    var t = Ek[n.style], r = e.havingStyle(t).withFont("");
    return BI(n.body, r, e);
  },
  mathmlBuilder(n, e) {
    var t = Ek[n.style], r = e.havingStyle(t), i = fr(n.body, r), s = new X.MathNode("mstyle", i), o = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, l = o[n.style];
    return s.setAttribute("scriptlevel", l[0]), s.setAttribute("displaystyle", l[1]), s;
  }
});
var Tre = function(e, t) {
  var r = e.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (t.style.size === Ae.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? Tu : null;
    } else if (r.type === "operatorname") {
      var s = r.alwaysHandleSupSub && (t.style.size === Ae.DISPLAY.size || r.limits);
      return s ? LI : null;
    } else {
      if (r.type === "accent")
        return xe.isCharacterBox(r.base) ? F7 : null;
      if (r.type === "horizBrace") {
        var o = !e.sub;
        return o === r.isOver ? NI : null;
      } else
        return null;
    }
  else return null;
};
Ea({
  type: "supsub",
  htmlBuilder(n, e) {
    var t = Tre(n, e);
    if (t)
      return t(n, e);
    var {
      base: r,
      sup: i,
      sub: s
    } = n, o = Qe(r, e), l, a, c = e.fontMetrics(), u = 0, h = 0, f = r && xe.isCharacterBox(r);
    if (i) {
      var d = e.havingStyle(e.style.sup());
      l = Qe(i, d, e), f || (u = o.height - d.fontMetrics().supDrop * d.sizeMultiplier / e.sizeMultiplier);
    }
    if (s) {
      var p = e.havingStyle(e.style.sub());
      a = Qe(s, p, e), f || (h = o.depth + p.fontMetrics().subDrop * p.sizeMultiplier / e.sizeMultiplier);
    }
    var m;
    e.style === Ae.DISPLAY ? m = c.sup1 : e.style.cramped ? m = c.sup3 : m = c.sup2;
    var g = e.sizeMultiplier, b = re(0.5 / c.ptPerEm / g), w = null;
    if (a) {
      var k = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
      (o instanceof ii || k) && (w = re(-o.italic));
    }
    var T;
    if (l && a) {
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), h = Math.max(h, c.sub2);
      var M = c.defaultRuleThickness, C = 4 * M;
      if (u - l.depth - (a.height - h) < C) {
        h = C - (u - l.depth) + a.height;
        var I = 0.8 * c.xHeight - (u - l.depth);
        I > 0 && (u += I, h -= I);
      }
      var _ = [{
        type: "elem",
        elem: a,
        shift: h,
        marginRight: b,
        marginLeft: w
      }, {
        type: "elem",
        elem: l,
        shift: -u,
        marginRight: b
      }];
      T = z.makeVList({
        positionType: "individualShift",
        children: _
      }, e);
    } else if (a) {
      h = Math.max(h, c.sub1, a.height - 0.8 * c.xHeight);
      var F = [{
        type: "elem",
        elem: a,
        marginLeft: w,
        marginRight: b
      }];
      T = z.makeVList({
        positionType: "shift",
        positionData: h,
        children: F
      }, e);
    } else if (l)
      u = Math.max(u, m, l.depth + 0.25 * c.xHeight), T = z.makeVList({
        positionType: "shift",
        positionData: -u,
        children: [{
          type: "elem",
          elem: l,
          marginRight: b
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var L = E5(o, "right") || "mord";
    return z.makeSpan([L], [o, z.makeSpan(["msupsub"], [T])], e);
  },
  mathmlBuilder(n, e) {
    var t = !1, r, i;
    n.base && n.base.type === "horizBrace" && (i = !!n.sup, i === n.base.isOver && (t = !0, r = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
    var s = [dt(n.base, e)];
    n.sub && s.push(dt(n.sub, e)), n.sup && s.push(dt(n.sup, e));
    var o;
    if (t)
      o = r ? "mover" : "munder";
    else if (n.sub)
      if (n.sup) {
        var c = n.base;
        c && c.type === "op" && c.limits && e.style === Ae.DISPLAY || c && c.type === "operatorname" && c.alwaysHandleSupSub && (e.style === Ae.DISPLAY || c.limits) ? o = "munderover" : o = "msubsup";
      } else {
        var a = n.base;
        a && a.type === "op" && a.limits && (e.style === Ae.DISPLAY || a.alwaysHandleSupSub) || a && a.type === "operatorname" && a.alwaysHandleSupSub && (a.limits || e.style === Ae.DISPLAY) ? o = "munder" : o = "msub";
      }
    else {
      var l = n.base;
      l && l.type === "op" && l.limits && (e.style === Ae.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === Ae.DISPLAY) ? o = "mover" : o = "msup";
    }
    return new X.MathNode(o, s);
  }
});
Ea({
  type: "atom",
  htmlBuilder(n, e) {
    return z.mathsym(n.text, n.mode, e, ["m" + n.family]);
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mo", [si(n.text, n.mode)]);
    if (n.family === "bin") {
      var r = z7(n, e);
      r === "bold-italic" && t.setAttribute("mathvariant", r);
    } else n.family === "punct" ? t.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && t.setAttribute("stretchy", "false");
    return t;
  }
});
var zI = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
Ea({
  type: "mathord",
  htmlBuilder(n, e) {
    return z.makeOrd(n, e, "mathord");
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mi", [si(n.text, n.mode, e)]), r = z7(n, e) || "italic";
    return r !== zI[t.type] && t.setAttribute("mathvariant", r), t;
  }
});
Ea({
  type: "textord",
  htmlBuilder(n, e) {
    return z.makeOrd(n, e, "textord");
  },
  mathmlBuilder(n, e) {
    var t = si(n.text, n.mode, e), r = z7(n, e) || "normal", i;
    return n.mode === "text" ? i = new X.MathNode("mtext", [t]) : /[0-9]/.test(n.text) ? i = new X.MathNode("mn", [t]) : n.text === "\\prime" ? i = new X.MathNode("mo", [t]) : i = new X.MathNode("mi", [t]), r !== zI[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var m4 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, g4 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
Ea({
  type: "spacing",
  htmlBuilder(n, e) {
    if (g4.hasOwnProperty(n.text)) {
      var t = g4[n.text].className || "";
      if (n.mode === "text") {
        var r = z.makeOrd(n, e, "textord");
        return r.classes.push(t), r;
      } else
        return z.makeSpan(["mspace", t], [z.mathsym(n.text, n.mode, e)], e);
    } else {
      if (m4.hasOwnProperty(n.text))
        return z.makeSpan(["mspace", m4[n.text]], [], e);
      throw new Z('Unknown type of space "' + n.text + '"');
    }
  },
  mathmlBuilder(n, e) {
    var t;
    if (g4.hasOwnProperty(n.text))
      t = new X.MathNode("mtext", [new X.TextNode("Â ")]);
    else {
      if (m4.hasOwnProperty(n.text))
        return new X.MathNode("mspace");
      throw new Z('Unknown type of space "' + n.text + '"');
    }
    return t;
  }
});
var Ik = () => {
  var n = new X.MathNode("mtd", []);
  return n.setAttribute("width", "50%"), n;
};
Ea({
  type: "tag",
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mtable", [new X.MathNode("mtr", [Ik(), new X.MathNode("mtd", [Qo(n.body, e)]), Ik(), new X.MathNode("mtd", [Qo(n.tag, e)])])]);
    return t.setAttribute("width", "100%"), t;
  }
});
var Dk = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, Nk = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, Are = {
  "\\textit": "textit",
  "\\textup": "textup"
}, Rk = (n, e) => {
  var t = n.font;
  if (t) {
    if (Dk[t])
      return e.withTextFontFamily(Dk[t]);
    if (Nk[t])
      return e.withTextFontWeight(Nk[t]);
    if (t === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(Are[t]);
};
le({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "text",
      mode: t.mode,
      body: zt(i),
      font: r
    };
  },
  htmlBuilder(n, e) {
    var t = Rk(n, e), r = Jt(n.body, t, !0);
    return z.makeSpan(["mord", "text"], r, t);
  },
  mathmlBuilder(n, e) {
    var t = Rk(n, e);
    return Qo(n.body, t);
  }
});
le({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "underline",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = Qe(n.body, e), r = z.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, s = z.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return z.makeSpan(["mord", "underline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new X.MathNode("mo", [new X.TextNode("â€¾")]);
    t.setAttribute("stretchy", "true");
    var r = new X.MathNode("munder", [dt(n.body, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
le({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "vcenter",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = Qe(n.body, e), r = e.fontMetrics().axisHeight, i = 0.5 * (t.height - r - (t.depth + r));
    return z.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    return new X.MathNode("mpadded", [dt(n.body, e)], ["vcenter"]);
  }
});
le({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    throw new Z("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(n, e) {
    for (var t = Pk(n), r = [], i = e.havingStyle(e.style.text()), s = 0; s < t.length; s++) {
      var o = t[s];
      o === "~" && (o = "\\textasciitilde"), r.push(z.makeSymbol(o, "Typewriter-Regular", n.mode, i, ["mord", "texttt"]));
    }
    return z.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), z.tryCombineChars(r), i);
  },
  mathmlBuilder(n, e) {
    var t = new X.TextNode(Pk(n)), r = new X.MathNode("mtext", [t]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var Pk = (n) => n.body.replace(/ /g, n.star ? "â£" : "Â "), zo = oI, _I = `[ \r
	]`, Ore = "\\\\[a-zA-Z@]+", Ere = "\\\\[^\uD800-\uDFFF]", Ire = "(" + Ore + ")" + _I + "*", Dre = `\\\\(
|[ \r	]+
?)[ \r	]*`, R5 = "[Ì€-Í¯]", Nre = new RegExp(R5 + "+$"), Rre = "(" + _I + "+)|" + // whitespace
(Dre + "|") + // \whitespace
"([!-\\[\\]-â€§â€ª-íŸ¿ï¤€-ï¿¿]" + // single codepoint
(R5 + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(R5 + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Ire) + // \macroName + spaces
("|" + Ere + ")");
class Lk {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, t) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = new RegExp(Rre, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, t) {
    this.catcodes[e] = t;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, t = this.tokenRegex.lastIndex;
    if (t === e.length)
      return new Ir("EOF", new Qn(this, t, t));
    var r = this.tokenRegex.exec(e);
    if (r === null || r.index !== t)
      throw new Z("Unexpected character: '" + e[t] + "'", new Ir(e[t], new Qn(this, t, t + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var s = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return s === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = s + 1, this.lex();
    }
    return new Ir(i, new Qn(this, t, this.tokenRegex.lastIndex));
  }
}
class Pre {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, t) {
    e === void 0 && (e = {}), t === void 0 && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new Z("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var t in e)
      e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : this.current[t] = e[t]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, t, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
    } else {
      var s = this.undefStack[this.undefStack.length - 1];
      s && !s.hasOwnProperty(e) && (s[e] = this.current[e]);
    }
    t == null ? delete this.current[e] : this.current[e] = t;
  }
}
var Lre = AI;
S("\\noexpand", function(n) {
  var e = n.popToken();
  return n.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\expandafter", function(n) {
  var e = n.popToken();
  return n.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
S("\\@firstoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
S("\\@secondoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
S("\\@ifnextchar", function(n) {
  var e = n.consumeArgs(3);
  n.consumeSpaces();
  var t = n.future();
  return e[0].length === 1 && e[0][0].text === t.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
S("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
S("\\TextOrMath", function(n) {
  var e = n.consumeArgs(2);
  return n.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var Bk = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
S("\\char", function(n) {
  var e = n.popToken(), t, r = "";
  if (e.text === "'")
    t = 8, e = n.popToken();
  else if (e.text === '"')
    t = 16, e = n.popToken();
  else if (e.text === "`")
    if (e = n.popToken(), e.text[0] === "\\")
      r = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new Z("\\char` missing argument");
      r = e.text.charCodeAt(0);
    }
  else
    t = 10;
  if (t) {
    if (r = Bk[e.text], r == null || r >= t)
      throw new Z("Invalid base-" + t + " digit " + e.text);
    for (var i; (i = Bk[n.future().text]) != null && i < t; )
      r *= t, r += i, n.popToken();
  }
  return "\\@char{" + r + "}";
});
var G7 = (n, e, t, r) => {
  var i = n.consumeArg().tokens;
  if (i.length !== 1)
    throw new Z("\\newcommand's first argument must be a macro name");
  var s = i[0].text, o = n.isDefined(s);
  if (o && !e)
    throw new Z("\\newcommand{" + s + "} attempting to redefine " + (s + "; use \\renewcommand"));
  if (!o && !t)
    throw new Z("\\renewcommand{" + s + "} when command " + s + " does not yet exist; use \\newcommand");
  var l = 0;
  if (i = n.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var a = "", c = n.expandNextToken(); c.text !== "]" && c.text !== "EOF"; )
      a += c.text, c = n.expandNextToken();
    if (!a.match(/^\s*[0-9]+\s*$/))
      throw new Z("Invalid number of arguments: " + a);
    l = parseInt(a), i = n.consumeArg().tokens;
  }
  return o && r || n.macros.set(s, {
    tokens: i,
    numArgs: l
  }), "";
};
S("\\newcommand", (n) => G7(n, !1, !0, !1));
S("\\renewcommand", (n) => G7(n, !0, !1, !1));
S("\\providecommand", (n) => G7(n, !0, !0, !0));
S("\\message", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.log(e.reverse().map((t) => t.text).join("")), "";
});
S("\\errmessage", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.error(e.reverse().map((t) => t.text).join("")), "";
});
S("\\show", (n) => {
  var e = n.popToken(), t = e.text;
  return console.log(e, n.macros.get(t), zo[t], gt.math[t], gt.text[t]), "";
});
S("\\bgroup", "{");
S("\\egroup", "}");
S("~", "\\nobreakspace");
S("\\lq", "`");
S("\\rq", "'");
S("\\aa", "\\r a");
S("\\AA", "\\r A");
S("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`Â©}");
S("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
S("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`Â®}");
S("â„¬", "\\mathscr{B}");
S("â„°", "\\mathscr{E}");
S("â„±", "\\mathscr{F}");
S("â„‹", "\\mathscr{H}");
S("â„", "\\mathscr{I}");
S("â„’", "\\mathscr{L}");
S("â„³", "\\mathscr{M}");
S("â„›", "\\mathscr{R}");
S("â„­", "\\mathfrak{C}");
S("â„Œ", "\\mathfrak{H}");
S("â„¨", "\\mathfrak{Z}");
S("\\Bbbk", "\\Bbb{k}");
S("Â·", "\\cdotp");
S("\\llap", "\\mathllap{\\textrm{#1}}");
S("\\rlap", "\\mathrlap{\\textrm{#1}}");
S("\\clap", "\\mathclap{\\textrm{#1}}");
S("\\mathstrut", "\\vphantom{(}");
S("\\underbar", "\\underline{\\text{#1}}");
S("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
S("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`â‰ }}");
S("\\ne", "\\neq");
S("â‰ ", "\\neq");
S("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`âˆ‰}}");
S("âˆ‰", "\\notin");
S("â‰˜", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`â‰˜}}");
S("â‰™", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`â‰˜}}");
S("â‰š", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`â‰š}}");
S("â‰›", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`â‰›}}");
S("â‰", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`â‰}}");
S("â‰ž", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`â‰ž}}");
S("â‰Ÿ", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`â‰Ÿ}}");
S("âŸ‚", "\\perp");
S("â€¼", "\\mathclose{!\\mkern-0.8mu!}");
S("âˆŒ", "\\notni");
S("âŒœ", "\\ulcorner");
S("âŒ", "\\urcorner");
S("âŒž", "\\llcorner");
S("âŒŸ", "\\lrcorner");
S("Â©", "\\copyright");
S("Â®", "\\textregistered");
S("ï¸", "\\textregistered");
S("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
S("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
S("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
S("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
S("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
S("â‹®", "\\vdots");
S("\\varGamma", "\\mathit{\\Gamma}");
S("\\varDelta", "\\mathit{\\Delta}");
S("\\varTheta", "\\mathit{\\Theta}");
S("\\varLambda", "\\mathit{\\Lambda}");
S("\\varXi", "\\mathit{\\Xi}");
S("\\varPi", "\\mathit{\\Pi}");
S("\\varSigma", "\\mathit{\\Sigma}");
S("\\varUpsilon", "\\mathit{\\Upsilon}");
S("\\varPhi", "\\mathit{\\Phi}");
S("\\varPsi", "\\mathit{\\Psi}");
S("\\varOmega", "\\mathit{\\Omega}");
S("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
S("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
S("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
S("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
S("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
S("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
S("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
S("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var zk = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
S("\\dots", function(n) {
  var e = "\\dotso", t = n.expandAfterFuture().text;
  return t in zk ? e = zk[t] : (t.slice(0, 4) === "\\not" || t in gt.math && xe.contains(["bin", "rel"], gt.math[t].group)) && (e = "\\dotsb"), e;
});
var K7 = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
S("\\dotso", function(n) {
  var e = n.future().text;
  return e in K7 ? "\\ldots\\," : "\\ldots";
});
S("\\dotsc", function(n) {
  var e = n.future().text;
  return e in K7 && e !== "," ? "\\ldots\\," : "\\ldots";
});
S("\\cdots", function(n) {
  var e = n.future().text;
  return e in K7 ? "\\@cdots\\," : "\\@cdots";
});
S("\\dotsb", "\\cdots");
S("\\dotsm", "\\cdots");
S("\\dotsi", "\\!\\cdots");
S("\\dotsx", "\\ldots\\,");
S("\\DOTSI", "\\relax");
S("\\DOTSB", "\\relax");
S("\\DOTSX", "\\relax");
S("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
S("\\,", "\\tmspace+{3mu}{.1667em}");
S("\\thinspace", "\\,");
S("\\>", "\\mskip{4mu}");
S("\\:", "\\tmspace+{4mu}{.2222em}");
S("\\medspace", "\\:");
S("\\;", "\\tmspace+{5mu}{.2777em}");
S("\\thickspace", "\\;");
S("\\!", "\\tmspace-{3mu}{.1667em}");
S("\\negthinspace", "\\!");
S("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
S("\\negthickspace", "\\tmspace-{5mu}{.277em}");
S("\\enspace", "\\kern.5em ");
S("\\enskip", "\\hskip.5em\\relax");
S("\\quad", "\\hskip1em\\relax");
S("\\qquad", "\\hskip2em\\relax");
S("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
S("\\tag@paren", "\\tag@literal{({#1})}");
S("\\tag@literal", (n) => {
  if (n.macros.get("\\df@tag"))
    throw new Z("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
S("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
S("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
S("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
S("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
S("\\newline", "\\\\\\relax");
S("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var FI = re(Yi["Main-Regular"][84][1] - 0.7 * Yi["Main-Regular"][65][1]);
S("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + FI + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
S("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + FI + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
S("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
S("\\@hspace", "\\hskip #1\\relax");
S("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
S("\\ordinarycolon", ":");
S("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
S("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
S("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
S("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
S("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
S("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
S("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
S("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
S("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
S("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
S("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
S("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
S("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
S("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
S("âˆ·", "\\dblcolon");
S("âˆ¹", "\\eqcolon");
S("â‰”", "\\coloneqq");
S("â‰•", "\\eqqcolon");
S("â©´", "\\Coloneqq");
S("\\ratio", "\\vcentcolon");
S("\\coloncolon", "\\dblcolon");
S("\\colonequals", "\\coloneqq");
S("\\coloncolonequals", "\\Coloneqq");
S("\\equalscolon", "\\eqqcolon");
S("\\equalscoloncolon", "\\Eqqcolon");
S("\\colonminus", "\\coloneq");
S("\\coloncolonminus", "\\Coloneq");
S("\\minuscolon", "\\eqcolon");
S("\\minuscoloncolon", "\\Eqcolon");
S("\\coloncolonapprox", "\\Colonapprox");
S("\\coloncolonsim", "\\Colonsim");
S("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
S("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
S("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`âˆŒ}}");
S("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
S("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
S("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
S("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
S("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
S("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
S("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
S("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
S("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{â‰©}");
S("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{â‰¨}");
S("\\ngeqq", "\\html@mathml{\\@ngeqq}{â‰±}");
S("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{â‰±}");
S("\\nleqq", "\\html@mathml{\\@nleqq}{â‰°}");
S("\\nleqslant", "\\html@mathml{\\@nleqslant}{â‰°}");
S("\\nshortmid", "\\html@mathml{\\@nshortmid}{âˆ¤}");
S("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{âˆ¦}");
S("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{âŠˆ}");
S("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{âŠ‰}");
S("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{âŠŠ}");
S("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{â«‹}");
S("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{âŠ‹}");
S("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{â«Œ}");
S("\\imath", "\\html@mathml{\\@imath}{Ä±}");
S("\\jmath", "\\html@mathml{\\@jmath}{È·}");
S("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`âŸ¦}}");
S("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`âŸ§}}");
S("âŸ¦", "\\llbracket");
S("âŸ§", "\\rrbracket");
S("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`â¦ƒ}}");
S("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`â¦„}}");
S("â¦ƒ", "\\lBrace");
S("â¦„", "\\rBrace");
S("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`â¦µ}}");
S("â¦µ", "\\minuso");
S("\\darr", "\\downarrow");
S("\\dArr", "\\Downarrow");
S("\\Darr", "\\Downarrow");
S("\\lang", "\\langle");
S("\\rang", "\\rangle");
S("\\uarr", "\\uparrow");
S("\\uArr", "\\Uparrow");
S("\\Uarr", "\\Uparrow");
S("\\N", "\\mathbb{N}");
S("\\R", "\\mathbb{R}");
S("\\Z", "\\mathbb{Z}");
S("\\alef", "\\aleph");
S("\\alefsym", "\\aleph");
S("\\Alpha", "\\mathrm{A}");
S("\\Beta", "\\mathrm{B}");
S("\\bull", "\\bullet");
S("\\Chi", "\\mathrm{X}");
S("\\clubs", "\\clubsuit");
S("\\cnums", "\\mathbb{C}");
S("\\Complex", "\\mathbb{C}");
S("\\Dagger", "\\ddagger");
S("\\diamonds", "\\diamondsuit");
S("\\empty", "\\emptyset");
S("\\Epsilon", "\\mathrm{E}");
S("\\Eta", "\\mathrm{H}");
S("\\exist", "\\exists");
S("\\harr", "\\leftrightarrow");
S("\\hArr", "\\Leftrightarrow");
S("\\Harr", "\\Leftrightarrow");
S("\\hearts", "\\heartsuit");
S("\\image", "\\Im");
S("\\infin", "\\infty");
S("\\Iota", "\\mathrm{I}");
S("\\isin", "\\in");
S("\\Kappa", "\\mathrm{K}");
S("\\larr", "\\leftarrow");
S("\\lArr", "\\Leftarrow");
S("\\Larr", "\\Leftarrow");
S("\\lrarr", "\\leftrightarrow");
S("\\lrArr", "\\Leftrightarrow");
S("\\Lrarr", "\\Leftrightarrow");
S("\\Mu", "\\mathrm{M}");
S("\\natnums", "\\mathbb{N}");
S("\\Nu", "\\mathrm{N}");
S("\\Omicron", "\\mathrm{O}");
S("\\plusmn", "\\pm");
S("\\rarr", "\\rightarrow");
S("\\rArr", "\\Rightarrow");
S("\\Rarr", "\\Rightarrow");
S("\\real", "\\Re");
S("\\reals", "\\mathbb{R}");
S("\\Reals", "\\mathbb{R}");
S("\\Rho", "\\mathrm{P}");
S("\\sdot", "\\cdot");
S("\\sect", "\\S");
S("\\spades", "\\spadesuit");
S("\\sub", "\\subset");
S("\\sube", "\\subseteq");
S("\\supe", "\\supseteq");
S("\\Tau", "\\mathrm{T}");
S("\\thetasym", "\\vartheta");
S("\\weierp", "\\wp");
S("\\Zeta", "\\mathrm{Z}");
S("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
S("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
S("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
S("\\bra", "\\mathinner{\\langle{#1}|}");
S("\\ket", "\\mathinner{|{#1}\\rangle}");
S("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
S("\\Bra", "\\left\\langle#1\\right|");
S("\\Ket", "\\left|#1\\right\\rangle");
var HI = (n) => (e) => {
  var t = e.consumeArg().tokens, r = e.consumeArg().tokens, i = e.consumeArg().tokens, s = e.consumeArg().tokens, o = e.macros.get("|"), l = e.macros.get("\\|");
  e.macros.beginGroup();
  var a = (h) => (f) => {
    n && (f.macros.set("|", o), i.length && f.macros.set("\\|", l));
    var d = h;
    if (!h && i.length) {
      var p = f.future();
      p.text === "|" && (f.popToken(), d = !0);
    }
    return {
      tokens: d ? i : r,
      numArgs: 0
    };
  };
  e.macros.set("|", a(!1)), i.length && e.macros.set("\\|", a(!0));
  var c = e.consumeArg().tokens, u = e.expandTokens([
    ...s,
    ...c,
    ...t
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: u.reverse(),
    numArgs: 0
  };
};
S("\\bra@ket", HI(!1));
S("\\bra@set", HI(!0));
S("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
S("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
S("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
S("\\angln", "{\\angl n}");
S("\\blue", "\\textcolor{##6495ed}{#1}");
S("\\orange", "\\textcolor{##ffa500}{#1}");
S("\\pink", "\\textcolor{##ff00af}{#1}");
S("\\red", "\\textcolor{##df0030}{#1}");
S("\\green", "\\textcolor{##28ae7b}{#1}");
S("\\gray", "\\textcolor{gray}{#1}");
S("\\purple", "\\textcolor{##9d38bd}{#1}");
S("\\blueA", "\\textcolor{##ccfaff}{#1}");
S("\\blueB", "\\textcolor{##80f6ff}{#1}");
S("\\blueC", "\\textcolor{##63d9ea}{#1}");
S("\\blueD", "\\textcolor{##11accd}{#1}");
S("\\blueE", "\\textcolor{##0c7f99}{#1}");
S("\\tealA", "\\textcolor{##94fff5}{#1}");
S("\\tealB", "\\textcolor{##26edd5}{#1}");
S("\\tealC", "\\textcolor{##01d1c1}{#1}");
S("\\tealD", "\\textcolor{##01a995}{#1}");
S("\\tealE", "\\textcolor{##208170}{#1}");
S("\\greenA", "\\textcolor{##b6ffb0}{#1}");
S("\\greenB", "\\textcolor{##8af281}{#1}");
S("\\greenC", "\\textcolor{##74cf70}{#1}");
S("\\greenD", "\\textcolor{##1fab54}{#1}");
S("\\greenE", "\\textcolor{##0d923f}{#1}");
S("\\goldA", "\\textcolor{##ffd0a9}{#1}");
S("\\goldB", "\\textcolor{##ffbb71}{#1}");
S("\\goldC", "\\textcolor{##ff9c39}{#1}");
S("\\goldD", "\\textcolor{##e07d10}{#1}");
S("\\goldE", "\\textcolor{##a75a05}{#1}");
S("\\redA", "\\textcolor{##fca9a9}{#1}");
S("\\redB", "\\textcolor{##ff8482}{#1}");
S("\\redC", "\\textcolor{##f9685d}{#1}");
S("\\redD", "\\textcolor{##e84d39}{#1}");
S("\\redE", "\\textcolor{##bc2612}{#1}");
S("\\maroonA", "\\textcolor{##ffbde0}{#1}");
S("\\maroonB", "\\textcolor{##ff92c6}{#1}");
S("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
S("\\maroonD", "\\textcolor{##ca337c}{#1}");
S("\\maroonE", "\\textcolor{##9e034e}{#1}");
S("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
S("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
S("\\purpleC", "\\textcolor{##aa87ff}{#1}");
S("\\purpleD", "\\textcolor{##7854ab}{#1}");
S("\\purpleE", "\\textcolor{##543b78}{#1}");
S("\\mintA", "\\textcolor{##f5f9e8}{#1}");
S("\\mintB", "\\textcolor{##edf2df}{#1}");
S("\\mintC", "\\textcolor{##e0e5cc}{#1}");
S("\\grayA", "\\textcolor{##f6f7f7}{#1}");
S("\\grayB", "\\textcolor{##f0f1f2}{#1}");
S("\\grayC", "\\textcolor{##e3e5e6}{#1}");
S("\\grayD", "\\textcolor{##d6d8da}{#1}");
S("\\grayE", "\\textcolor{##babec2}{#1}");
S("\\grayF", "\\textcolor{##888d93}{#1}");
S("\\grayG", "\\textcolor{##626569}{#1}");
S("\\grayH", "\\textcolor{##3b3e40}{#1}");
S("\\grayI", "\\textcolor{##21242c}{#1}");
S("\\kaBlue", "\\textcolor{##314453}{#1}");
S("\\kaGreen", "\\textcolor{##71B307}{#1}");
var $I = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class Bre {
  constructor(e, t, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new Pre(Lre, t.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new Lk(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var t, r, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      t = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: t,
        end: r
      } = this.consumeArg());
    return this.pushToken(new Ir("EOF", r.loc)), this.pushTokens(i), new Ir("", Qn.range(t, r));
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var t = [], r = e && e.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), s, o = 0, l = 0;
    do {
      if (s = this.popToken(), t.push(s), s.text === "{")
        ++o;
      else if (s.text === "}") {
        if (--o, o === -1)
          throw new Z("Extra }", s);
      } else if (s.text === "EOF")
        throw new Z("Unexpected end of input in a macro argument, expected '" + (e && r ? e[l] : "}") + "'", s);
      if (e && r)
        if ((o === 0 || o === 1 && e[l] === "{") && s.text === e[l]) {
          if (++l, l === e.length) {
            t.splice(-l, l);
            break;
          }
        } else
          l = 0;
    } while (o !== 0 || r);
    return i.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()), t.reverse(), {
      tokens: t,
      start: i,
      end: s
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, t) {
    if (t) {
      if (t.length !== e + 1)
        throw new Z("The length of delimiters doesn't match the number of args!");
      for (var r = t[0], i = 0; i < r.length; i++) {
        var s = this.popToken();
        if (r[i] !== s.text)
          throw new Z("Use of the macro doesn't match its definition", s);
      }
    }
    for (var o = [], l = 0; l < e; l++)
      o.push(this.consumeArg(t && t[l + 1]).tokens);
    return o;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new Z("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var t = this.popToken(), r = t.text, i = t.noexpand ? null : this._getExpansion(r);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new Z("Undefined control sequence: " + r);
      return this.pushToken(t), !1;
    }
    this.countExpansion(1);
    var s = i.tokens, o = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      s = s.slice();
      for (var l = s.length - 1; l >= 0; --l) {
        var a = s[l];
        if (a.text === "#") {
          if (l === 0)
            throw new Z("Incomplete placeholder at end of macro body", a);
          if (a = s[--l], a.text === "#")
            s.splice(l + 1, 1);
          else if (/^[1-9]$/.test(a.text))
            s.splice(l, 2, ...o[+a.text - 1]);
          else
            throw new Z("Not a valid argument number", a);
        }
      }
    }
    return this.pushTokens(s), s.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new Ir(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var t = [], r = this.stack.length;
    for (this.pushTokens(e); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
      }
    return this.countExpansion(t.length), t;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var t = this.expandMacro(e);
    return t && t.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var t = this.macros.get(e);
    if (t == null)
      return t;
    if (e.length === 1) {
      var r = this.lexer.catcodes[e];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof t == "function" ? t(this) : t;
    if (typeof i == "string") {
      var s = 0;
      if (i.indexOf("#") !== -1)
        for (var o = i.replace(/##/g, ""); o.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      for (var l = new Lk(i, this.settings), a = [], c = l.lex(); c.text !== "EOF"; )
        a.push(c), c = l.lex();
      a.reverse();
      var u = {
        tokens: a,
        numArgs: s
      };
      return u;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || zo.hasOwnProperty(e) || gt.math.hasOwnProperty(e) || gt.text.hasOwnProperty(e) || $I.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var t = this.macros.get(e);
    return t != null ? typeof t == "string" || typeof t == "function" || !t.unexpandable : zo.hasOwnProperty(e) && !zo[e].primitive;
  }
}
var _k = /^[â‚Šâ‚‹â‚Œâ‚â‚Žâ‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“áµ¦áµ§áµ¨áµ©áµª]/, np = Object.freeze({
  "â‚Š": "+",
  "â‚‹": "-",
  "â‚Œ": "=",
  "â‚": "(",
  "â‚Ž": ")",
  "â‚€": "0",
  "â‚": "1",
  "â‚‚": "2",
  "â‚ƒ": "3",
  "â‚„": "4",
  "â‚…": "5",
  "â‚†": "6",
  "â‚‡": "7",
  "â‚ˆ": "8",
  "â‚‰": "9",
  "â‚": "a",
  "â‚‘": "e",
  "â‚•": "h",
  "áµ¢": "i",
  "â±¼": "j",
  "â‚–": "k",
  "â‚—": "l",
  "â‚˜": "m",
  "â‚™": "n",
  "â‚’": "o",
  "â‚š": "p",
  "áµ£": "r",
  "â‚›": "s",
  "â‚œ": "t",
  "áµ¤": "u",
  "áµ¥": "v",
  "â‚“": "x",
  "áµ¦": "Î²",
  "áµ§": "Î³",
  "áµ¨": "Ï",
  "áµ©": "Ï•",
  "áµª": "Ï‡",
  "âº": "+",
  "â»": "-",
  "â¼": "=",
  "â½": "(",
  "â¾": ")",
  "â°": "0",
  "Â¹": "1",
  "Â²": "2",
  "Â³": "3",
  "â´": "4",
  "âµ": "5",
  "â¶": "6",
  "â·": "7",
  "â¸": "8",
  "â¹": "9",
  "á´¬": "A",
  "á´®": "B",
  "á´°": "D",
  "á´±": "E",
  "á´³": "G",
  "á´´": "H",
  "á´µ": "I",
  "á´¶": "J",
  "á´·": "K",
  "á´¸": "L",
  "á´¹": "M",
  "á´º": "N",
  "á´¼": "O",
  "á´¾": "P",
  "á´¿": "R",
  "áµ€": "T",
  "áµ": "U",
  "â±½": "V",
  "áµ‚": "W",
  "áµƒ": "a",
  "áµ‡": "b",
  "á¶œ": "c",
  "áµˆ": "d",
  "áµ‰": "e",
  "á¶ ": "f",
  "áµ": "g",
  Ê°: "h",
  "â±": "i",
  Ê²: "j",
  "áµ": "k",
  Ë¡: "l",
  "áµ": "m",
  â¿: "n",
  "áµ’": "o",
  "áµ–": "p",
  Ê³: "r",
  Ë¢: "s",
  "áµ—": "t",
  "áµ˜": "u",
  "áµ›": "v",
  Ê·: "w",
  Ë£: "x",
  Ê¸: "y",
  "á¶»": "z",
  "áµ": "Î²",
  "áµž": "Î³",
  "áµŸ": "Î´",
  "áµ ": "Ï•",
  "áµ¡": "Ï‡",
  "á¶¿": "Î¸"
}), y4 = {
  "Ì": {
    text: "\\'",
    math: "\\acute"
  },
  "Ì€": {
    text: "\\`",
    math: "\\grave"
  },
  "Ìˆ": {
    text: '\\"',
    math: "\\ddot"
  },
  "Ìƒ": {
    text: "\\~",
    math: "\\tilde"
  },
  "Ì„": {
    text: "\\=",
    math: "\\bar"
  },
  "Ì†": {
    text: "\\u",
    math: "\\breve"
  },
  "ÌŒ": {
    text: "\\v",
    math: "\\check"
  },
  "Ì‚": {
    text: "\\^",
    math: "\\hat"
  },
  "Ì‡": {
    text: "\\.",
    math: "\\dot"
  },
  "ÌŠ": {
    text: "\\r",
    math: "\\mathring"
  },
  "Ì‹": {
    text: "\\H"
  },
  "Ì§": {
    text: "\\c"
  }
}, Fk = {
  Ã¡: "aÌ",
  Ã : "aÌ€",
  Ã¤: "aÌˆ",
  ÇŸ: "aÌˆÌ„",
  Ã£: "aÌƒ",
  Ä: "aÌ„",
  Äƒ: "aÌ†",
  áº¯: "aÌ†Ì",
  áº±: "aÌ†Ì€",
  áºµ: "aÌ†Ìƒ",
  ÇŽ: "aÌŒ",
  Ã¢: "aÌ‚",
  áº¥: "aÌ‚Ì",
  áº§: "aÌ‚Ì€",
  áº«: "aÌ‚Ìƒ",
  È§: "aÌ‡",
  Ç¡: "aÌ‡Ì„",
  Ã¥: "aÌŠ",
  Ç»: "aÌŠÌ",
  á¸ƒ: "bÌ‡",
  Ä‡: "cÌ",
  á¸‰: "cÌ§Ì",
  Ä: "cÌŒ",
  Ä‰: "cÌ‚",
  Ä‹: "cÌ‡",
  Ã§: "cÌ§",
  Ä: "dÌŒ",
  á¸‹: "dÌ‡",
  á¸‘: "dÌ§",
  Ã©: "eÌ",
  Ã¨: "eÌ€",
  Ã«: "eÌˆ",
  áº½: "eÌƒ",
  Ä“: "eÌ„",
  á¸—: "eÌ„Ì",
  á¸•: "eÌ„Ì€",
  Ä•: "eÌ†",
  á¸: "eÌ§Ì†",
  Ä›: "eÌŒ",
  Ãª: "eÌ‚",
  áº¿: "eÌ‚Ì",
  á»: "eÌ‚Ì€",
  á»…: "eÌ‚Ìƒ",
  Ä—: "eÌ‡",
  È©: "eÌ§",
  á¸Ÿ: "fÌ‡",
  Çµ: "gÌ",
  á¸¡: "gÌ„",
  ÄŸ: "gÌ†",
  Ç§: "gÌŒ",
  Ä: "gÌ‚",
  Ä¡: "gÌ‡",
  Ä£: "gÌ§",
  á¸§: "hÌˆ",
  ÈŸ: "hÌŒ",
  Ä¥: "hÌ‚",
  á¸£: "hÌ‡",
  á¸©: "hÌ§",
  Ã­: "iÌ",
  Ã¬: "iÌ€",
  Ã¯: "iÌˆ",
  á¸¯: "iÌˆÌ",
  Ä©: "iÌƒ",
  Ä«: "iÌ„",
  Ä­: "iÌ†",
  Ç: "iÌŒ",
  Ã®: "iÌ‚",
  Ç°: "jÌŒ",
  Äµ: "jÌ‚",
  á¸±: "kÌ",
  Ç©: "kÌŒ",
  Ä·: "kÌ§",
  Äº: "lÌ",
  Ä¾: "lÌŒ",
  Ä¼: "lÌ§",
  á¸¿: "mÌ",
  á¹: "mÌ‡",
  Å„: "nÌ",
  Ç¹: "nÌ€",
  Ã±: "nÌƒ",
  Åˆ: "nÌŒ",
  á¹…: "nÌ‡",
  Å†: "nÌ§",
  Ã³: "oÌ",
  Ã²: "oÌ€",
  Ã¶: "oÌˆ",
  È«: "oÌˆÌ„",
  Ãµ: "oÌƒ",
  á¹: "oÌƒÌ",
  á¹: "oÌƒÌˆ",
  È­: "oÌƒÌ„",
  Å: "oÌ„",
  á¹“: "oÌ„Ì",
  á¹‘: "oÌ„Ì€",
  Å: "oÌ†",
  Ç’: "oÌŒ",
  Ã´: "oÌ‚",
  á»‘: "oÌ‚Ì",
  á»“: "oÌ‚Ì€",
  á»—: "oÌ‚Ìƒ",
  È¯: "oÌ‡",
  È±: "oÌ‡Ì„",
  Å‘: "oÌ‹",
  á¹•: "pÌ",
  á¹—: "pÌ‡",
  Å•: "rÌ",
  Å™: "rÌŒ",
  á¹™: "rÌ‡",
  Å—: "rÌ§",
  Å›: "sÌ",
  á¹¥: "sÌÌ‡",
  Å¡: "sÌŒ",
  á¹§: "sÌŒÌ‡",
  Å: "sÌ‚",
  á¹¡: "sÌ‡",
  ÅŸ: "sÌ§",
  áº—: "tÌˆ",
  Å¥: "tÌŒ",
  á¹«: "tÌ‡",
  Å£: "tÌ§",
  Ãº: "uÌ",
  Ã¹: "uÌ€",
  Ã¼: "uÌˆ",
  Ç˜: "uÌˆÌ",
  Çœ: "uÌˆÌ€",
  Ç–: "uÌˆÌ„",
  Çš: "uÌˆÌŒ",
  Å©: "uÌƒ",
  á¹¹: "uÌƒÌ",
  Å«: "uÌ„",
  á¹»: "uÌ„Ìˆ",
  Å­: "uÌ†",
  Ç”: "uÌŒ",
  Ã»: "uÌ‚",
  Å¯: "uÌŠ",
  Å±: "uÌ‹",
  á¹½: "vÌƒ",
  áºƒ: "wÌ",
  áº: "wÌ€",
  áº…: "wÌˆ",
  Åµ: "wÌ‚",
  áº‡: "wÌ‡",
  áº˜: "wÌŠ",
  áº: "xÌˆ",
  áº‹: "xÌ‡",
  Ã½: "yÌ",
  á»³: "yÌ€",
  Ã¿: "yÌˆ",
  á»¹: "yÌƒ",
  È³: "yÌ„",
  Å·: "yÌ‚",
  áº: "yÌ‡",
  áº™: "yÌŠ",
  Åº: "zÌ",
  Å¾: "zÌŒ",
  áº‘: "zÌ‚",
  Å¼: "zÌ‡",
  Ã: "AÌ",
  Ã€: "AÌ€",
  Ã„: "AÌˆ",
  Çž: "AÌˆÌ„",
  Ãƒ: "AÌƒ",
  Ä€: "AÌ„",
  Ä‚: "AÌ†",
  áº®: "AÌ†Ì",
  áº°: "AÌ†Ì€",
  áº´: "AÌ†Ìƒ",
  Ç: "AÌŒ",
  Ã‚: "AÌ‚",
  áº¤: "AÌ‚Ì",
  áº¦: "AÌ‚Ì€",
  áºª: "AÌ‚Ìƒ",
  È¦: "AÌ‡",
  Ç : "AÌ‡Ì„",
  Ã…: "AÌŠ",
  Çº: "AÌŠÌ",
  á¸‚: "BÌ‡",
  Ä†: "CÌ",
  á¸ˆ: "CÌ§Ì",
  ÄŒ: "CÌŒ",
  Äˆ: "CÌ‚",
  ÄŠ: "CÌ‡",
  Ã‡: "CÌ§",
  ÄŽ: "DÌŒ",
  á¸Š: "DÌ‡",
  á¸: "DÌ§",
  Ã‰: "EÌ",
  Ãˆ: "EÌ€",
  Ã‹: "EÌˆ",
  áº¼: "EÌƒ",
  Ä’: "EÌ„",
  á¸–: "EÌ„Ì",
  á¸”: "EÌ„Ì€",
  Ä”: "EÌ†",
  á¸œ: "EÌ§Ì†",
  Äš: "EÌŒ",
  ÃŠ: "EÌ‚",
  áº¾: "EÌ‚Ì",
  á»€: "EÌ‚Ì€",
  á»„: "EÌ‚Ìƒ",
  Ä–: "EÌ‡",
  È¨: "EÌ§",
  á¸ž: "FÌ‡",
  Ç´: "GÌ",
  á¸ : "GÌ„",
  Äž: "GÌ†",
  Ç¦: "GÌŒ",
  Äœ: "GÌ‚",
  Ä : "GÌ‡",
  Ä¢: "GÌ§",
  á¸¦: "HÌˆ",
  Èž: "HÌŒ",
  Ä¤: "HÌ‚",
  á¸¢: "HÌ‡",
  á¸¨: "HÌ§",
  Ã: "IÌ",
  ÃŒ: "IÌ€",
  Ã: "IÌˆ",
  á¸®: "IÌˆÌ",
  Ä¨: "IÌƒ",
  Äª: "IÌ„",
  Ä¬: "IÌ†",
  Ç: "IÌŒ",
  ÃŽ: "IÌ‚",
  Ä°: "IÌ‡",
  Ä´: "JÌ‚",
  á¸°: "KÌ",
  Ç¨: "KÌŒ",
  Ä¶: "KÌ§",
  Ä¹: "LÌ",
  Ä½: "LÌŒ",
  Ä»: "LÌ§",
  á¸¾: "MÌ",
  á¹€: "MÌ‡",
  Åƒ: "NÌ",
  Ç¸: "NÌ€",
  Ã‘: "NÌƒ",
  Å‡: "NÌŒ",
  á¹„: "NÌ‡",
  Å…: "NÌ§",
  Ã“: "OÌ",
  Ã’: "OÌ€",
  Ã–: "OÌˆ",
  Èª: "OÌˆÌ„",
  Ã•: "OÌƒ",
  á¹Œ: "OÌƒÌ",
  á¹Ž: "OÌƒÌˆ",
  È¬: "OÌƒÌ„",
  ÅŒ: "OÌ„",
  á¹’: "OÌ„Ì",
  á¹: "OÌ„Ì€",
  ÅŽ: "OÌ†",
  Ç‘: "OÌŒ",
  Ã”: "OÌ‚",
  á»: "OÌ‚Ì",
  á»’: "OÌ‚Ì€",
  á»–: "OÌ‚Ìƒ",
  È®: "OÌ‡",
  È°: "OÌ‡Ì„",
  Å: "OÌ‹",
  á¹”: "PÌ",
  á¹–: "PÌ‡",
  Å”: "RÌ",
  Å˜: "RÌŒ",
  á¹˜: "RÌ‡",
  Å–: "RÌ§",
  Åš: "SÌ",
  á¹¤: "SÌÌ‡",
  Å : "SÌŒ",
  á¹¦: "SÌŒÌ‡",
  Åœ: "SÌ‚",
  á¹ : "SÌ‡",
  Åž: "SÌ§",
  Å¤: "TÌŒ",
  á¹ª: "TÌ‡",
  Å¢: "TÌ§",
  Ãš: "UÌ",
  Ã™: "UÌ€",
  Ãœ: "UÌˆ",
  Ç—: "UÌˆÌ",
  Ç›: "UÌˆÌ€",
  Ç•: "UÌˆÌ„",
  Ç™: "UÌˆÌŒ",
  Å¨: "UÌƒ",
  á¹¸: "UÌƒÌ",
  Åª: "UÌ„",
  á¹º: "UÌ„Ìˆ",
  Å¬: "UÌ†",
  Ç“: "UÌŒ",
  Ã›: "UÌ‚",
  Å®: "UÌŠ",
  Å°: "UÌ‹",
  á¹¼: "VÌƒ",
  áº‚: "WÌ",
  áº€: "WÌ€",
  áº„: "WÌˆ",
  Å´: "WÌ‚",
  áº†: "WÌ‡",
  áºŒ: "XÌˆ",
  áºŠ: "XÌ‡",
  Ã: "YÌ",
  á»²: "YÌ€",
  Å¸: "YÌˆ",
  á»¸: "YÌƒ",
  È²: "YÌ„",
  Å¶: "YÌ‚",
  áºŽ: "YÌ‡",
  Å¹: "ZÌ",
  Å½: "ZÌŒ",
  áº: "ZÌ‚",
  Å»: "ZÌ‡",
  Î¬: "Î±Ì",
  á½°: "Î±Ì€",
  á¾±: "Î±Ì„",
  á¾°: "Î±Ì†",
  Î­: "ÎµÌ",
  á½²: "ÎµÌ€",
  Î®: "Î·Ì",
  á½´: "Î·Ì€",
  Î¯: "Î¹Ì",
  á½¶: "Î¹Ì€",
  ÏŠ: "Î¹Ìˆ",
  Î: "Î¹ÌˆÌ",
  á¿’: "Î¹ÌˆÌ€",
  á¿‘: "Î¹Ì„",
  á¿: "Î¹Ì†",
  ÏŒ: "Î¿Ì",
  á½¸: "Î¿Ì€",
  Ï: "Ï…Ì",
  á½º: "Ï…Ì€",
  Ï‹: "Ï…Ìˆ",
  Î°: "Ï…ÌˆÌ",
  á¿¢: "Ï…ÌˆÌ€",
  á¿¡: "Ï…Ì„",
  á¿ : "Ï…Ì†",
  ÏŽ: "Ï‰Ì",
  á½¼: "Ï‰Ì€",
  ÎŽ: "Î¥Ì",
  á¿ª: "Î¥Ì€",
  Î«: "Î¥Ìˆ",
  á¿©: "Î¥Ì„",
  á¿¨: "Î¥Ì†",
  Î: "Î©Ì",
  á¿º: "Î©Ì€"
};
class bg {
  constructor(e, t) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new Bre(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, t) {
    if (t === void 0 && (t = !0), this.fetch().text !== e)
      throw new Z("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    t && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var t = this.nextToken;
    this.consume(), this.gullet.pushToken(new Ir("}")), this.gullet.pushTokens(e);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = t, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, t) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (bg.endOfExpression.indexOf(i.text) !== -1 || t && i.text === t || e && zo[i.text] && zo[i.text].infix)
        break;
      var s = this.parseAtom(t);
      if (s) {
        if (s.type === "internal")
          continue;
      } else break;
      r.push(s);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var t = -1, r, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (t !== -1)
          throw new Z("only one infix operator per group", e[i].token);
        t = i, r = e[i].replaceWith;
      }
    if (t !== -1 && r) {
      var s, o, l = e.slice(0, t), a = e.slice(t + 1);
      l.length === 1 && l[0].type === "ordgroup" ? s = l[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      }, a.length === 1 && a[0].type === "ordgroup" ? o = a[0] : o = {
        type: "ordgroup",
        mode: this.mode,
        body: a
      };
      var c;
      return r === "\\\\abovefrac" ? c = this.callFunction(r, [s, e[t], o], []) : c = this.callFunction(r, [s, o], []), [c];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var t = this.fetch(), r = t.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var s;
      i = this.parseGroup(e);
    } while (((s = i) == null ? void 0 : s.type) === "internal");
    if (!i)
      throw new Z("Expected group after '" + r + "'", t);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push({
        type: "textord",
        mode: "text",
        text: e[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: t
    }, s = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return s;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var t = this.parseGroup("atom", e);
    if ((t == null ? void 0 : t.type) === "internal" || this.mode === "text")
      return t;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var s = this.fetch();
      if (s.text === "\\limits" || s.text === "\\nolimits") {
        if (t && t.type === "op") {
          var o = s.text === "\\limits";
          t.limits = o, t.alwaysHandleSupSub = !0;
        } else if (t && t.type === "operatorname")
          t.alwaysHandleSupSub && (t.limits = s.text === "\\limits");
        else
          throw new Z("Limit controls must follow a math operator", s);
        this.consume();
      } else if (s.text === "^") {
        if (r)
          throw new Z("Double superscript", s);
        r = this.handleSupSubscript("superscript");
      } else if (s.text === "_") {
        if (i)
          throw new Z("Double subscript", s);
        i = this.handleSupSubscript("subscript");
      } else if (s.text === "'") {
        if (r)
          throw new Z("Double superscript", s);
        var l = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, a = [l];
        for (this.consume(); this.fetch().text === "'"; )
          a.push(l), this.consume();
        this.fetch().text === "^" && a.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: a
        };
      } else if (np[s.text]) {
        var c = _k.test(s.text), u = [];
        for (u.push(new Ir(np[s.text])), this.consume(); ; ) {
          var h = this.fetch().text;
          if (!np[h] || _k.test(h) !== c)
            break;
          u.unshift(new Ir(np[h])), this.consume();
        }
        var f = this.subparse(u);
        c ? i = {
          type: "ordgroup",
          mode: "math",
          body: f
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: f
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: t,
      sup: r,
      sub: i
    } : t;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, t) {
    var r = this.fetch(), i = r.text, s = zo[i];
    if (!s)
      return null;
    if (this.consume(), t && t !== "atom" && !s.allowedInArgument)
      throw new Z("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), r);
    if (this.mode === "text" && !s.allowedInText)
      throw new Z("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && s.allowedInMath === !1)
      throw new Z("Can't use function '" + i + "' in math mode", r);
    var {
      args: o,
      optArgs: l
    } = this.parseArguments(i, s);
    return this.callFunction(i, o, l, r, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, t, r, i, s) {
    var o = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: s
    }, l = zo[e];
    if (l && l.handler)
      return l.handler(o, t, r);
    throw new Z("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, t) {
    var r = t.numArgs + t.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], s = [], o = 0; o < r; o++) {
      var l = t.argTypes && t.argTypes[o], a = o < t.numOptionalArgs;
      (t.primitive && l == null || // \sqrt expands into primitive if optional argument doesn't exist
      t.type === "sqrt" && o === 1 && s[0] == null) && (l = "primitive");
      var c = this.parseGroupOfType("argument to '" + e + "'", l, a);
      if (a)
        s.push(c);
      else if (c != null)
        i.push(c);
      else
        throw new Z("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: s
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, t, r) {
    switch (t) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, t);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new Z("A primitive argument cannot be optional");
        var o = this.parseGroup(e);
        if (o == null)
          throw new Z("Expected group as " + e, this.fetch());
        return o;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new Z("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, t) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    for (var i = "", s; (s = this.fetch()).text !== "EOF"; )
      i += s.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, t) {
    for (var r = this.fetch(), i = r, s = "", o; (o = this.fetch()).text !== "EOF" && e.test(s + o.text); )
      i = o, s += i.text, this.consume();
    if (s === "")
      throw new Z("Invalid " + t + ": '" + r.text + "'", r);
    return r.range(i, s);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var t = this.parseStringGroup("color", e);
    if (t == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
    if (!r)
      throw new Z("Invalid color: '" + t.text + "'", t);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var t, r = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : t = this.parseStringGroup("size", e), !t)
      return null;
    !e && t.text.length === 0 && (t.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
    if (!i)
      throw new Z("Invalid size: '" + t.text + "'", t);
    var s = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!XE(s))
      throw new Z("Invalid unit: '" + s.unit + "'", t);
    return {
      type: "size",
      mode: this.mode,
      value: s,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var t = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null)
      return null;
    var r = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, t) {
    var r = this.gullet.scanArgument(e);
    if (r == null)
      return null;
    var i = this.mode;
    t && this.switchMode(t), this.gullet.beginGroup();
    var s = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var o = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: s
    };
    return t && this.switchMode(i), o;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, t) {
    var r = this.fetch(), i = r.text, s;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var o = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var l = this.parseExpression(!1, o), a = this.fetch();
      this.expect(o), this.gullet.endGroup(), s = {
        type: "ordgroup",
        mode: this.mode,
        loc: Qn.range(r, a),
        body: l,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (s = this.parseFunction(t, e) || this.parseSymbol(), s == null && i[0] === "\\" && !$I.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new Z("Undefined control sequence: " + i, r);
      s = this.formatUnsupportedCmd(i), this.consume();
    }
    return s;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var t = e.length - 1, r = 0; r < t; ++r) {
      var i = e[r], s = i.text;
      s === "-" && e[r + 1].text === "-" && (r + 1 < t && e[r + 2].text === "-" ? (e.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: Qn.range(i, e[r + 2]),
        text: "---"
      }), t -= 2) : (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Qn.range(i, e[r + 1]),
        text: "--"
      }), t -= 1)), (s === "'" || s === "`") && e[r + 1].text === s && (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Qn.range(i, e[r + 1]),
        text: s + s
      }), t -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), t = e.text;
    if (/^\\verb[^a-zA-Z]/.test(t)) {
      this.consume();
      var r = t.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new Z(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    Fk.hasOwnProperty(t[0]) && !gt[this.mode][t[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + t[0] + '" used in math mode', e), t = Fk[t[0]] + t.slice(1));
    var s = Nre.exec(t);
    s && (t = t.substring(0, s.index), t === "i" ? t = "Ä±" : t === "j" && (t = "È·"));
    var o;
    if (gt[this.mode][t]) {
      this.settings.strict && this.mode === "math" && O5.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + t[0] + '" used in math mode', e);
      var l = gt[this.mode][t].group, a = Qn.range(e), c;
      if (Cne.hasOwnProperty(l)) {
        var u = l;
        c = {
          type: "atom",
          mode: this.mode,
          family: u,
          loc: a,
          text: t
        };
      } else
        c = {
          type: l,
          mode: this.mode,
          loc: a,
          text: t
        };
      o = c;
    } else if (t.charCodeAt(0) >= 128)
      this.settings.strict && (JE(t.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + t[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"), e)), o = {
        type: "textord",
        mode: "text",
        loc: Qn.range(e),
        text: t
      };
    else
      return null;
    if (this.consume(), s)
      for (var h = 0; h < s[0].length; h++) {
        var f = s[0][h];
        if (!y4[f])
          throw new Z("Unknown accent ' " + f + "'", e);
        var d = y4[f][this.mode] || y4[f].text;
        if (!d)
          throw new Z("Accent " + f + " unsupported in " + this.mode + " mode", e);
        o = {
          type: "accent",
          mode: this.mode,
          loc: Qn.range(e),
          label: d,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: o
        };
      }
    return o;
  }
}
bg.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var Y7 = function(e, t) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new bg(e, t);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!t.displayMode)
      throw new Z("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new Ir("\\df@tag")])
    }];
  }
  return i;
}, VI = function(e, t, r) {
  t.textContent = "";
  var i = J7(e, r).toNode();
  t.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), VI = function() {
  throw new Z("KaTeX doesn't work in quirks mode.");
});
var zre = function(e, t) {
  var r = J7(e, t).toMarkup();
  return r;
}, _re = function(e, t) {
  var r = new D7(t);
  return Y7(e, r);
}, qI = function(e, t, r) {
  if (r.throwOnError || !(e instanceof Z))
    throw e;
  var i = z.makeSpan(["katex-error"], [new ii(t)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, J7 = function(e, t) {
  var r = new D7(t);
  try {
    var i = Y7(e, r);
    return Gne(i, e, r);
  } catch (s) {
    return qI(s, e, r);
  }
}, Fre = function(e, t) {
  var r = new D7(t);
  try {
    var i = Y7(e, r);
    return Kne(i, e, r);
  } catch (s) {
    return qI(s, e, r);
  }
}, Hre = "0.16.23", $re = {
  Span: t0,
  Anchor: P7,
  SymbolNode: ii,
  SvgNode: Js,
  PathNode: Zo,
  LineNode: A5
}, WI = {
  /**
   * Current KaTeX version
   */
  version: Hre,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: VI,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: zre,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: Z,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: qp,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: _re,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: J7,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: Fre,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: gne,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: y,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: le,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: S,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: $re
}, kd, Sd, zc, _c, Cd, Fc, Hc, $c, Vc, Md, o1, jI;
class vg {
  constructor(e) {
    ee(this, o1);
    /// @internal
    ee(this, kd);
    /// @internal
    ee(this, Sd);
    /// @internal
    ee(this, zc);
    /// @internal
    ee(this, _c);
    /// @internal
    ee(this, Cd);
    ee(this, Fc);
    /// @internal
    ee(this, Hc);
    /// @internal
    ee(this, $c);
    /// @internal
    ee(this, Vc);
    ee(this, Md);
    W(this, Fc, !1), this.onShow = () => {
    }, this.onHide = () => {
    }, W(this, Md, (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: l } = i, { ranges: a } = o, c = Math.min(...a.map((d) => d.$from.pos)), u = Math.max(...a.map((d) => d.$to.pos)), h = r && r.doc.eq(l) && r.selection.eq(o);
      if (N(this, Fc) || ((N(this, Cd) ?? t.dom.parentElement ?? document.body).appendChild(this.element), W(this, Fc, !0)), s || h) return;
      if (!N(this, Sd).call(this, t, r)) {
        this.hide();
        return;
      }
      Ti({
        getBoundingClientRect: () => O1(t, c, u)
      }, this.element, {
        placement: N(this, _c).placement ?? "top",
        middleware: [
          Hm(),
          Jo(N(this, Hc)),
          W8(N(this, $c)),
          ...N(this, zc)
        ]
      }).then(({ x: d, y: p }) => {
        Object.assign(this.element.style, {
          left: `${d}px`,
          top: `${p}px`
        });
      }).catch(console.error), this.show();
    }), this.update = (t, r) => {
      N(this, Vc).call(this, t, r);
    }, this.destroy = () => {
      N(this, Vc).cancel();
    }, this.show = (t) => {
      this.element.dataset.show = "true", t && Ti(t, this.element, {
        placement: "top",
        middleware: [
          Hm(),
          Jo(N(this, Hc)),
          W8(N(this, $c)),
          ...N(this, zc)
        ],
        ...N(this, _c)
      }).then(({ x: r, y: i }) => {
        Object.assign(this.element.style, {
          left: `${r}px`,
          top: `${i}px`
        });
      }).catch(console.error), this.onShow();
    }, this.hide = () => {
      this.element.dataset.show !== "false" && (this.element.dataset.show = "false", this.onHide());
    }, this.element = e.content, W(this, kd, e.debounce ?? 200), W(this, Sd, e.shouldShow ?? u0(this, o1, jI)), W(this, Hc, e.offset), W(this, $c, e.shift), W(this, zc, e.middleware ?? []), W(this, _c, e.floatingUIOptions ?? {}), W(this, Cd, e.root), this.element.dataset.show = "false", W(this, Vc, f1(N(this, Md), N(this, kd)));
  }
}
kd = new WeakMap(), Sd = new WeakMap(), zc = new WeakMap(), _c = new WeakMap(), Cd = new WeakMap(), Fc = new WeakMap(), Hc = new WeakMap(), $c = new WeakMap(), Vc = new WeakMap(), Md = new WeakMap(), o1 = new WeakSet(), /// @internal
jI = function(e) {
  const { doc: t, selection: r } = e.state, { empty: i, from: s, to: o } = r, l = !t.textBetween(s, o).length && e.state.selection instanceof ge, a = this.element.contains(document.activeElement), c = !e.hasFocus() && !a, u = !e.editable;
  return !(c || i || l || u);
};
function wg(n) {
  const e = it(
    {},
    `${n}_TOOLTIP_SPEC`
  ), t = Ut((i) => {
    const s = i.get(e.key);
    return new xt({
      key: new kt(`${n}_TOOLTIP`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${n}`
  }, r;
}
function Vre() {
  return {
    enter: {
      mathFlow: n,
      mathFlowFenceMeta: e,
      mathText: s
    },
    exit: {
      mathFlow: i,
      mathFlowFence: r,
      mathFlowFenceMeta: t,
      mathFlowValue: l,
      mathText: o,
      mathTextData: l
    }
  };
  function n(a) {
    const c = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [c] }
      },
      a
    );
  }
  function e() {
    this.buffer();
  }
  function t() {
    const a = this.resume(), c = this.stack[this.stack.length - 1];
    c.type, c.meta = a;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function i(a) {
    const c = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c;
    const h = (
      /** @type {HastElement} */
      u.data.hChildren[0]
    );
    h.type, h.tagName, h.children.push({ type: "text", value: c }), this.data.mathFlowInside = void 0;
  }
  function s(a) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      a
    ), this.buffer();
  }
  function o(a) {
    const c = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, this.exit(a), u.value = c, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    u.data.hChildren.push({ type: "text", value: c });
  }
  function l(a) {
    this.config.enter.data.call(this, a), this.config.exit.data.call(this, a);
  }
}
function qre(n) {
  let e = (n || {}).singleDollarTextMath;
  return e == null && (e = !0), r.peek = i, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: e ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: t, inlineMath: r }
  };
  function t(s, o, l, a) {
    const c = s.value || "", u = l.createTracker(a), h = "$".repeat(Math.max(jM(c, "$") + 1, 2)), f = l.enter("mathFlow");
    let d = u.move(h);
    if (s.meta) {
      const p = l.enter("mathFlowMeta");
      d += u.move(
        l.safe(s.meta, {
          after: `
`,
          before: d,
          encode: ["$"],
          ...u.current()
        })
      ), p();
    }
    return d += u.move(`
`), c && (d += u.move(c + `
`)), d += u.move(h), f(), d;
  }
  function r(s, o, l) {
    let a = s.value || "", c = 1;
    for (e || c++; new RegExp("(^|[^$])" + "\\$".repeat(c) + "([^$]|$)").test(a); )
      c++;
    const u = "$".repeat(c);
    // Contains non-space.
    /[^ \r\n]/.test(a) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(a) && /[ \r\n]$/.test(a) || // Starts or ends with dollar.
    /^\$|\$$/.test(a)) && (a = " " + a + " ");
    let h = -1;
    for (; ++h < l.unsafe.length; ) {
      const f = l.unsafe[h];
      if (!f.atBreak) continue;
      const d = l.compilePattern(f);
      let p;
      for (; p = d.exec(a); ) {
        let m = p.index;
        a.codePointAt(m) === 10 && a.codePointAt(m - 1) === 13 && m--, a = a.slice(0, m) + " " + a.slice(p.index + 1);
      }
    }
    return u + a + u;
  }
  function i() {
    return "$";
  }
}
const Wre = {
  tokenize: jre,
  concrete: !0,
  name: "mathFlow"
}, Hk = {
  tokenize: Ure,
  partial: !0
};
function jre(n, e, t) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0;
  return l;
  function l(w) {
    return n.enter("mathFlow"), n.enter("mathFlowFence"), n.enter("mathFlowFenceSequence"), a(w);
  }
  function a(w) {
    return w === 36 ? (n.consume(w), o++, a) : o < 2 ? t(w) : (n.exit("mathFlowFenceSequence"), qe(n, c, "whitespace")(w));
  }
  function c(w) {
    return w === null || ye(w) ? h(w) : (n.enter("mathFlowFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), u(w));
  }
  function u(w) {
    return w === null || ye(w) ? (n.exit("chunkString"), n.exit("mathFlowFenceMeta"), h(w)) : w === 36 ? t(w) : (n.consume(w), u);
  }
  function h(w) {
    return n.exit("mathFlowFence"), r.interrupt ? e(w) : n.attempt(Hk, f, g)(w);
  }
  function f(w) {
    return n.attempt({
      tokenize: b,
      partial: !0
    }, g, d)(w);
  }
  function d(w) {
    return (s ? qe(n, p, "linePrefix", s + 1) : p)(w);
  }
  function p(w) {
    return w === null ? g(w) : ye(w) ? n.attempt(Hk, f, g)(w) : (n.enter("mathFlowValue"), m(w));
  }
  function m(w) {
    return w === null || ye(w) ? (n.exit("mathFlowValue"), p(w)) : (n.consume(w), m);
  }
  function g(w) {
    return n.exit("mathFlow"), e(w);
  }
  function b(w, k, T) {
    let M = 0;
    return qe(w, C, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function C(F) {
      return w.enter("mathFlowFence"), w.enter("mathFlowFenceSequence"), I(F);
    }
    function I(F) {
      return F === 36 ? (M++, w.consume(F), I) : M < o ? T(F) : (w.exit("mathFlowFenceSequence"), qe(w, _, "whitespace")(F));
    }
    function _(F) {
      return F === null || ye(F) ? (w.exit("mathFlowFence"), k(F)) : T(F);
    }
  }
}
function Ure(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Gre(n) {
  let t = (n || {}).singleDollarTextMath;
  return t == null && (t = !0), {
    tokenize: r,
    resolve: Kre,
    previous: Yre,
    name: "mathText"
  };
  function r(i, s, o) {
    let l = 0, a, c;
    return u;
    function u(m) {
      return i.enter("mathText"), i.enter("mathTextSequence"), h(m);
    }
    function h(m) {
      return m === 36 ? (i.consume(m), l++, h) : l < 2 && !t ? o(m) : (i.exit("mathTextSequence"), f(m));
    }
    function f(m) {
      return m === null ? o(m) : m === 36 ? (c = i.enter("mathTextSequence"), a = 0, p(m)) : m === 32 ? (i.enter("space"), i.consume(m), i.exit("space"), f) : ye(m) ? (i.enter("lineEnding"), i.consume(m), i.exit("lineEnding"), f) : (i.enter("mathTextData"), d(m));
    }
    function d(m) {
      return m === null || m === 32 || m === 36 || ye(m) ? (i.exit("mathTextData"), f(m)) : (i.consume(m), d);
    }
    function p(m) {
      return m === 36 ? (i.consume(m), a++, p) : a === l ? (i.exit("mathTextSequence"), i.exit("mathText"), s(m)) : (c.type = "mathTextData", d(m));
    }
  }
}
function Kre(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "mathTextData") {
        n[e][1].type = "mathTextPadding", n[t][1].type = "mathTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "mathTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function Yre(n) {
  return n !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Jre(n) {
  return {
    flow: {
      36: Wre
    },
    text: {
      36: Gre(n)
    }
  };
}
const Xre = {};
function Zre(n) {
  const e = (
    /** @type {Processor} */
    this
  ), t = n || Xre, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(Jre(t)), s.push(Vre()), o.push(qre(t));
}
var Qre = Object.defineProperty, $k = Object.getOwnPropertySymbols, eie = Object.prototype.hasOwnProperty, tie = Object.prototype.propertyIsEnumerable, Vk = (n, e, t) => e in n ? Qre(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, nie = (n, e) => {
  for (var t in e || (e = {}))
    eie.call(e, t) && Vk(n, t, e[t]);
  if ($k)
    for (var t of $k(e))
      tie.call(e, t) && Vk(n, t, e[t]);
  return n;
};
function Ia(n, e) {
  return Object.assign(n, {
    meta: nie({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var rie = Object.defineProperty, qk = Object.getOwnPropertySymbols, iie = Object.prototype.hasOwnProperty, sie = Object.prototype.propertyIsEnumerable, Wk = (n, e, t) => e in n ? rie(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, X7 = (n, e) => {
  for (var t in e || (e = {}))
    iie.call(e, t) && Wk(n, t, e[t]);
  if (qk)
    for (var t of qk(e))
      sie.call(e, t) && Wk(n, t, e[t]);
  return n;
};
const oie = {
  mode: "preview"
}, Qs = it(X7({}, oie), "linkTooltipStateCtx");
Ia(Qs, {
  displayName: "State<link-tooltip>",
  group: "LinkTooltip"
});
const lie = {
  addLink: () => {
  },
  editLink: () => {
  },
  removeLink: () => {
  }
}, ou = it(X7({}, lie), "linkTooltipAPICtx");
Ia(Qs, {
  displayName: "API<link-tooltip>",
  group: "LinkTooltip"
});
const aie = {
  linkIcon: "ðŸ”—",
  editButton: "âœŽ",
  removeButton: "âŒ«",
  confirmButton: "Confirm âŽ",
  onCopyLink: () => {
  },
  inputPlaceholder: "Paste link..."
}, lu = it(
  X7({}, aie),
  "linkTooltipConfigCtx"
);
Ia(Qs, {
  displayName: "Config<link-tooltip>",
  group: "LinkTooltip"
});
const UI = De("ToggleLink", (n) => () => (e) => {
  const { doc: t, selection: r } = e, i = xi.type(n);
  return t.rangeHasMark(r.from, r.to, i) ? (n.get(ou.key).removeLink(r.from, r.to), !0) : (n.get(ou.key).addLink(r.from, r.to), !0);
}), r0 = wg("LINK_PREVIEW");
Ia(r0[0], {
  displayName: "PreviewTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
Ia(r0[1], {
  displayName: "PreviewTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
const xg = wg("LINK_EDIT");
Ia(xg[0], {
  displayName: "EditTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
Ia(xg[1], {
  displayName: "EditTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
function mf({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
mf.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const cie = Xt({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onConfirm: {
      type: Function,
      required: !0
    },
    onCancel: {
      type: Function,
      required: !0
    }
  },
  setup({ config: n, src: e, onConfirm: t, onCancel: r }) {
    const i = ce(e);
    W5(e, (l) => {
      i.value = l;
    });
    const s = () => {
      t(i.value);
    }, o = (l) => {
      l.stopPropagation(), l.key === "Enter" && (l.preventDefault(), s()), l.key === "Escape" && (l.preventDefault(), r());
    };
    return () => /* @__PURE__ */ V("div", { class: "link-edit" }, /* @__PURE__ */ V(
      "input",
      {
        class: "input-area",
        placeholder: n.value.inputPlaceholder,
        onKeydown: o,
        onInput: (l) => {
          i.value = l.target.value;
        },
        value: i.value
      }
    ), i.value ? /* @__PURE__ */ V(
      mf,
      {
        class: "button confirm",
        icon: n.value.confirmButton,
        onClick: s
      }
    ) : null);
  }
});
var uie = Object.defineProperty, hie = Object.defineProperties, fie = Object.getOwnPropertyDescriptors, jk = Object.getOwnPropertySymbols, die = Object.prototype.hasOwnProperty, pie = Object.prototype.propertyIsEnumerable, GI = (n) => {
  throw TypeError(n);
}, Uk = (n, e, t) => e in n ? uie(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, rp = (n, e) => {
  for (var t in e || (e = {}))
    die.call(e, t) && Uk(n, t, e[t]);
  if (jk)
    for (var t of jk(e))
      pie.call(e, t) && Uk(n, t, e[t]);
  return n;
}, Gk = (n, e) => hie(n, fie(e)), KI = (n, e, t) => e.has(n) || GI("Cannot " + t), At = (n, e, t) => (KI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), vs = (n, e, t) => e.has(n) ? GI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), yl = (n, e, t, r) => (KI(n, e, "write to private field"), e.set(n, t), t), Th, yo, bo, jp, Ah, Up, kl, P5, Gp;
const Kk = {
  from: -1,
  to: -1,
  mark: null
};
class mie {
  constructor(e, t) {
    this.ctx = e, vs(this, Th), vs(this, yo), vs(this, bo, rp({}, Kk)), vs(this, jp), vs(this, Ah), vs(this, Up, ce("")), vs(this, kl, () => {
      At(this, yo).hide(), this.ctx.update(Qs.key, (s) => Gk(rp({}, s), {
        mode: "preview"
      })), yl(this, bo, rp({}, Kk));
    }), vs(this, P5, (s) => {
      const o = this.ctx.get(pt), { from: l, to: a, mark: c } = At(this, bo), u = xi.type(this.ctx), h = Ii.sanitize(s);
      if (c && c.attrs.href === h) {
        At(this, kl).call(this);
        return;
      }
      const f = o.state.tr;
      c && f.removeMark(l, a, c), f.addMark(l, a, u.create({ href: h })), o.dispatch(f), At(this, kl).call(this);
    }), vs(this, Gp, (s, o, l) => {
      const a = this.ctx.get(lu.key);
      At(this, Ah).value = a, At(this, Up).value = s, this.ctx.update(Qs.key, (u) => Gk(rp({}, u), {
        mode: "edit"
      }));
      const c = this.ctx.get(pt);
      c.dispatch(
        c.state.tr.setSelection(ge.create(c.state.doc, o, l))
      ), At(this, yo).show({
        getBoundingClientRect: () => O1(c, o, l)
      }), requestAnimationFrame(() => {
        var u;
        (u = At(this, Th).querySelector("input")) == null || u.focus();
      });
    }), this.update = (s) => {
      const { state: o } = s, { selection: l } = o;
      if (!(l instanceof ge)) return;
      const { from: a, to: c } = l;
      a === At(this, bo).from && c === At(this, bo).to || At(this, kl).call(this);
    }, this.destroy = () => {
      At(this, jp).unmount(), At(this, yo).destroy(), At(this, Th).remove();
    }, this.addLink = (s, o) => {
      yl(this, bo, {
        from: s,
        to: o,
        mark: null
      }), At(this, Gp).call(this, "", s, o);
    }, this.editLink = (s, o, l) => {
      yl(this, bo, {
        from: o,
        to: l,
        mark: s
      }), At(this, Gp).call(this, s.attrs.href, o, l);
    }, this.removeLink = (s, o) => {
      const l = this.ctx.get(pt), a = l.state.tr;
      a.removeMark(s, o, xi.type(this.ctx)), l.dispatch(a), At(this, kl).call(this);
    }, yl(this, Ah, ce(this.ctx.get(lu.key)));
    const r = document.createElement("div");
    r.className = "milkdown-link-edit";
    const i = oi(cie, {
      config: At(this, Ah),
      src: At(this, Up),
      onConfirm: At(this, P5),
      onCancel: At(this, kl)
    });
    i.mount(r), yl(this, jp, i), yl(this, Th, r), yl(this, yo, new vg({
      content: r,
      debounce: 0,
      shouldShow: () => !1
    })), At(this, yo).onHide = () => {
      requestAnimationFrame(() => {
        t.dom.focus({ preventScroll: !0 });
      });
    }, At(this, yo).update(t);
  }
}
Th = /* @__PURE__ */ new WeakMap();
yo = /* @__PURE__ */ new WeakMap();
bo = /* @__PURE__ */ new WeakMap();
jp = /* @__PURE__ */ new WeakMap();
Ah = /* @__PURE__ */ new WeakMap();
Up = /* @__PURE__ */ new WeakMap();
kl = /* @__PURE__ */ new WeakMap();
P5 = /* @__PURE__ */ new WeakMap();
Gp = /* @__PURE__ */ new WeakMap();
var gie = Object.defineProperty, yie = Object.defineProperties, bie = Object.getOwnPropertyDescriptors, Yk = Object.getOwnPropertySymbols, vie = Object.prototype.hasOwnProperty, wie = Object.prototype.propertyIsEnumerable, Jk = (n, e, t) => e in n ? gie(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, xie = (n, e) => {
  for (var t in e || (e = {}))
    vie.call(e, t) && Jk(n, t, e[t]);
  if (Yk)
    for (var t of Yk(e))
      wie.call(e, t) && Jk(n, t, e[t]);
  return n;
}, kie = (n, e) => yie(n, bie(e));
function Sie(n) {
  let e;
  n.update(ou.key, (t) => kie(xie({}, t), {
    addLink: (r, i) => {
      e == null || e.addLink(r, i);
    },
    editLink: (r, i, s) => {
      e == null || e.editLink(r, i, s);
    },
    removeLink: (r, i) => {
      e == null || e.removeLink(r, i);
    }
  })), n.set(xg.key, {
    view: (t) => (e = new mie(n, t), e)
  });
}
function Cie(n, e, t, r, i) {
  let s = { start: -1, end: -1 };
  return t.nodesBetween(r, i, (o, l) => {
    if (s.start > -1) return !1;
    s.start === -1 && n.isInSet(o.marks) && e === o && (s = {
      start: l,
      end: l + Math.max(o.textContent.length, 1)
    });
  }), s;
}
function Mie(n, e, t) {
  const r = e.posAtCoords({ left: t.clientX, top: t.clientY });
  if (!r) return;
  const { pos: i } = r, s = e.state.doc.nodeAt(i);
  if (!s) return;
  const o = s.marks.find(
    (a) => a.type === xi.mark.type(n)
  );
  if (!(!o || !r0.pluginKey()))
    return { show: !0, pos: i, node: s, mark: o };
}
const Tie = Xt({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onEdit: {
      type: Object,
      required: !0
    },
    onRemove: {
      type: Object,
      required: !0
    }
  },
  setup({ config: n, src: e, onEdit: t, onRemove: r }) {
    const i = (l) => {
      l.preventDefault(), l.stopPropagation(), t.value();
    }, s = (l) => {
      l.preventDefault(), l.stopPropagation(), r.value();
    }, o = (l) => {
      l.preventDefault();
      const a = e.value;
      navigator.clipboard && a && navigator.clipboard.writeText(a).then(() => {
        n.value.onCopyLink(a);
      }).catch((c) => console.error(c));
    };
    return () => /* @__PURE__ */ V("div", { class: "link-preview" }, /* @__PURE__ */ V(
      mf,
      {
        class: "button link-icon",
        icon: n.value.linkIcon,
        onClick: o
      }
    ), /* @__PURE__ */ V("a", { href: e.value, target: "_blank", class: "link-display" }, e.value), /* @__PURE__ */ V(
      mf,
      {
        class: "button link-edit-button",
        icon: n.value.editButton,
        onClick: i
      }
    ), /* @__PURE__ */ V(
      mf,
      {
        class: "button link-remove-button",
        icon: n.value.removeButton,
        onClick: s
      }
    ));
  }
});
var YI = (n) => {
  throw TypeError(n);
}, JI = (n, e, t) => e.has(n) || YI("Cannot " + t), Je = (n, e, t) => (JI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), yr = (n, e, t) => e.has(n) ? YI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), bl = (n, e, t, r) => (JI(n, e, "write to private field"), e.set(n, t), t), Sl, di, Oh, Eh, Kp, Yp, Jp, Ih, Dh, Xp, Zp, Qp, Nh;
class Aie {
  constructor(e, t) {
    this.ctx = e, yr(this, Sl), yr(this, di), yr(this, Oh, this.ctx.use(Qs.key)), yr(this, Eh), yr(this, Kp, ce("")), yr(this, Yp, ce(() => {
    })), yr(this, Jp, ce(() => {
    })), yr(this, Ih), yr(this, Dh, !1), yr(this, Xp, ({ mode: r }) => {
      r === "edit" && Je(this, Nh).call(this);
    }), yr(this, Zp, () => {
      bl(this, Dh, !0);
    }), yr(this, Qp, () => {
      bl(this, Dh, !1);
    }), yr(this, Nh, () => {
      Je(this, di).hide(), Je(this, di).element.removeEventListener("mouseenter", Je(this, Zp)), Je(this, di).element.removeEventListener("mouseleave", Je(this, Qp));
    }), this.show = (r, i, s, o) => {
      Je(this, Eh).value = this.ctx.get(lu.key), Je(this, Kp).value = r.attrs.href, Je(this, Yp).value = () => {
        this.ctx.get(ou.key).editLink(r, i, s);
      }, Je(this, Jp).value = () => {
        this.ctx.get(ou.key).removeLink(i, s), Je(this, Nh).call(this);
      }, Je(this, di).show({
        getBoundingClientRect: () => o
      }), Je(this, di).element.addEventListener("mouseenter", Je(this, Zp)), Je(this, di).element.addEventListener("mouseleave", Je(this, Qp));
    }, this.hide = () => {
      Je(this, Dh) || Je(this, Nh).call(this);
    }, this.update = () => {
    }, this.destroy = () => {
      Je(this, Ih).unmount(), Je(this, Oh).off(Je(this, Xp)), Je(this, di).destroy(), Je(this, Sl).remove();
    }, bl(this, Eh, ce(this.ctx.get(lu.key))), bl(this, Ih, oi(Tie, {
      config: Je(this, Eh),
      src: Je(this, Kp),
      onEdit: Je(this, Yp),
      onRemove: Je(this, Jp)
    })), bl(this, Sl, document.createElement("div")), Je(this, Sl).className = "milkdown-link-preview", Je(this, Ih).mount(Je(this, Sl)), bl(this, di, new vg({
      debounce: 0,
      content: Je(this, Sl),
      shouldShow: () => !1
    })), Je(this, di).update(t), bl(this, Oh, e.use(Qs.key)), Je(this, Oh).on(Je(this, Xp));
  }
}
Sl = /* @__PURE__ */ new WeakMap();
di = /* @__PURE__ */ new WeakMap();
Oh = /* @__PURE__ */ new WeakMap();
Eh = /* @__PURE__ */ new WeakMap();
Kp = /* @__PURE__ */ new WeakMap();
Yp = /* @__PURE__ */ new WeakMap();
Jp = /* @__PURE__ */ new WeakMap();
Ih = /* @__PURE__ */ new WeakMap();
Dh = /* @__PURE__ */ new WeakMap();
Xp = /* @__PURE__ */ new WeakMap();
Zp = /* @__PURE__ */ new WeakMap();
Qp = /* @__PURE__ */ new WeakMap();
Nh = /* @__PURE__ */ new WeakMap();
function Oie(n) {
  let e;
  const r = h1((s, o) => {
    if (!e || !s.hasFocus() || n.get(Qs.key).mode === "edit") return;
    const a = Mie(n, s, o);
    if (a) {
      const c = s.state.doc.resolve(a.pos), u = Cie(
        a.mark,
        a.node,
        s.state.doc,
        c.before(),
        c.after()
      ), h = u.start, f = u.end;
      e.show(
        a.mark,
        h,
        f,
        O1(s, h, f)
      );
      return;
    }
    e.hide();
  }, 50), i = () => {
    setTimeout(() => {
      e == null || e.hide();
    }, 50);
  };
  n.set(r0.key, {
    props: {
      handleDOMEvents: {
        mousemove: r,
        mouseleave: i
      }
    },
    view: (s) => (e = new Aie(n, s), e)
  });
}
function Eie(n) {
  Oie(n), Sie(n);
}
const Iie = [
  Qs,
  ou,
  lu,
  r0,
  xg,
  UI
].flat();
var Die = Object.defineProperty, Xk = Object.getOwnPropertySymbols, Nie = Object.prototype.hasOwnProperty, Rie = Object.prototype.propertyIsEnumerable, Zk = (n, e, t) => e in n ? Die(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Pie = (n, e) => {
  for (var t in e || (e = {}))
    Nie.call(e, t) && Zk(n, t, e[t]);
  if (Xk)
    for (var t of Xk(e))
      Rie.call(e, t) && Zk(n, t, e[t]);
  return n;
};
function XI(n, e) {
  return Object.assign(n, {
    meta: Pie({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Lie = {
  renderLabel: ({ label: n, listType: e, checked: t }) => t == null ? e === "bullet" ? "â¦¿" : n : t ? "â˜‘" : "â–¡"
}, kg = it(
  Lie,
  "listItemBlockConfigCtx"
);
XI(kg, {
  displayName: "Config<list-item-block>",
  group: "ListItemBlock"
});
function ZI({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
ZI.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const Bie = Xt({
  props: {
    label: {
      type: Object,
      required: !0
    },
    checked: {
      type: Object,
      required: !0
    },
    listType: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    }
  },
  setup({
    label: n,
    checked: e,
    listType: t,
    config: r,
    readonly: i,
    setAttr: s,
    onMount: o,
    selected: l
  }) {
    const a = (f) => {
      f != null && f instanceof Element && o(f);
    }, c = (f) => {
      f.stopPropagation(), f.preventDefault(), e.value != null && s("checked", !e.value);
    }, u = sa(() => r.renderLabel({
      label: n.value,
      listType: t.value,
      checked: e.value,
      readonly: i.value
    })), h = sa(() => e.value == null ? t.value === "bullet" ? "bullet" : "ordered" : e.value ? "checked" : "unchecked");
    return () => /* @__PURE__ */ V(
      "li",
      {
        class: bn(
          "list-item",
          l.value && "ProseMirror-selectednode"
        )
      },
      /* @__PURE__ */ V(
        "div",
        {
          class: "label-wrapper",
          onPointerdown: c,
          contenteditable: !1
        },
        /* @__PURE__ */ V(
          ZI,
          {
            class: bn(
              "label",
              i.value && "readonly",
              h.value
            ),
            icon: u.value
          }
        )
      ),
      /* @__PURE__ */ V("div", { class: "children", ref: a })
    );
  }
}), QI = Hd(
  Ei.node,
  (n) => (e, t, r) => {
    const i = document.createElement("div");
    i.className = "milkdown-list-item-block";
    const s = document.createElement("div");
    s.setAttribute("data-content-dom", "true"), s.classList.add("content-dom");
    const o = ce(e.attrs.label), l = ce(e.attrs.checked), a = ce(e.attrs.listType), c = ce(!t.editable), u = n.get(kg.key), h = ce(!1), f = (k, T) => {
      if (!t.editable) return;
      const M = r();
      M != null && (t.hasFocus() || t.focus(), t.dispatch(t.state.tr.setNodeAttribute(M, k, T)));
    }, d = au(() => {
      h.value ? i.classList.add("selected") : i.classList.remove("selected");
    });
    let p = 0;
    const g = oi(Bie, {
      label: o,
      checked: l,
      listType: a,
      readonly: c,
      config: u,
      selected: h,
      setAttr: f,
      onMount: (k) => {
        const { anchor: T, head: M } = t.state.selection;
        k.appendChild(s);
        const C = t.state.doc.resolve(T), I = t.state.doc.resolve(M);
        p = requestAnimationFrame(() => {
          if (cancelAnimationFrame(p), !C.doc.eq(t.state.doc)) return;
          const _ = new ge(C, I);
          t.dispatch(t.state.tr.setSelection(_));
        });
      }
    });
    g.mount(i);
    const b = (k) => {
      a.value = k.attrs.listType, o.value = k.attrs.label, l.value = k.attrs.checked, c.value = !t.editable;
    };
    b(e);
    let w = e;
    return {
      dom: i,
      contentDOM: s,
      update: (k) => k.type !== e.type ? !1 : (k.sameMarkup(w) && k.content.eq(w.content) || (w = k, b(k)), !0),
      ignoreMutation: (k) => !i || !s ? !0 : k.type === "selection" ? !1 : s === k.target && k.type === "attributes" ? !0 : !s.contains(k.target),
      selectNode: () => {
        h.value = !0;
      },
      deselectNode: () => {
        h.value = !1;
      },
      destroy: () => {
        d(), g.unmount(), i.remove(), s.remove();
      }
    };
  }
);
XI(QI, {
  displayName: "NodeView<list-item-block>",
  group: "ListItemBlock"
});
const zie = [
  kg,
  QI
];
var _ie = Object.defineProperty, Qk = Object.getOwnPropertySymbols, Fie = Object.prototype.hasOwnProperty, Hie = Object.prototype.propertyIsEnumerable, e9 = (n, e, t) => e in n ? _ie(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, $ie = (n, e) => {
  for (var t in e || (e = {}))
    Fie.call(e, t) && e9(n, t, e[t]);
  if (Qk)
    for (var t of Qk(e))
      Hie.call(e, t) && e9(n, t, e[t]);
  return n;
};
function eD(n, e) {
  return Object.assign(n, {
    meta: $ie({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var Vie = Object.defineProperty, t9 = Object.getOwnPropertySymbols, qie = Object.prototype.hasOwnProperty, Wie = Object.prototype.propertyIsEnumerable, n9 = (n, e, t) => e in n ? Vie(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, jie = (n, e) => {
  for (var t in e || (e = {}))
    qie.call(e, t) && n9(n, t, e[t]);
  if (t9)
    for (var t of t9(e))
      Wie.call(e, t) && n9(n, t, e[t]);
  return n;
};
const Uie = {
  renderButton: (n) => {
    switch (n) {
      case "add_row":
        return "+";
      case "add_col":
        return "+";
      case "delete_row":
        return "-";
      case "delete_col":
        return "-";
      case "align_col_left":
        return "left";
      case "align_col_center":
        return "center";
      case "align_col_right":
        return "right";
      case "col_drag_handle":
        return "=";
      case "row_drag_handle":
        return "=";
    }
  }
}, Sg = it(
  jie({}, Uie),
  "tableBlockConfigCtx"
);
eD(Sg, {
  displayName: "Config<table-block>",
  group: "TableBlock"
});
function Hi({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ V(
    "span",
    {
      class: bn("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Ii.sanitize(n.trim()));
      }
    }
  );
}
Hi.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
function tD(n) {
  const {
    dragPreviewRef: e,
    tableWrapperRef: t,
    contentWrapperRef: r,
    yLineHandleRef: i,
    xLineHandleRef: s,
    colHandleRef: o,
    rowHandleRef: l
  } = n, a = e.value;
  if (!a) return;
  const c = t.value;
  if (!c) return;
  const u = r.value;
  if (!u) return;
  const h = u.querySelector("tbody");
  if (!h) return;
  const f = a.querySelector("tbody");
  if (!f) return;
  const d = i.value;
  if (!d) return;
  const p = s.value;
  if (!p) return;
  const m = o.value;
  if (!m) return;
  const g = l.value;
  return g ? {
    preview: a,
    wrapper: c,
    content: u,
    contentRoot: h,
    previewRoot: f,
    yHandle: d,
    xHandle: p,
    colHandle: m,
    rowHandle: g
  } : void 0;
}
function nD(n) {
  for (; n.firstChild; ) n.removeChild(n.firstChild);
}
function rD(n, e, t, r, i) {
  const { width: s, height: o } = r.querySelector("tbody").getBoundingClientRect();
  if (n === "y") {
    const a = r.querySelectorAll("tr")[i];
    if (!a) return;
    t.appendChild(a.cloneNode(!0));
    const c = a.getBoundingClientRect().height;
    Object.assign(e.style, {
      width: `${s}px`,
      height: `${c}px`
    }), e.dataset.show = "true";
    return;
  }
  if (n === "x") {
    const l = r.querySelectorAll("tr");
    let a;
    Array.from(l).forEach((c) => {
      const u = c.children[i];
      if (!u) return;
      a === void 0 && (a = u.getBoundingClientRect().width);
      const h = u.parentElement.cloneNode(!1), f = u.cloneNode(!0);
      h.appendChild(f), t.appendChild(h);
    }), Object.assign(e.style, {
      width: `${a}px`,
      height: `${o}px`
    }), e.dataset.show = "true";
    return;
  }
}
function Gie(n, e) {
  return (t) => {
    sD(n, t, e, (r) => {
      iD("y", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r;
      nD(o);
      const { hoverIndex: l } = n, [a] = l.value;
      rD("y", i, o, s, a);
    });
  };
}
function Kie(n, e) {
  return (t) => {
    sD(n, t, e, (r) => {
      iD("x", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r, { hoverIndex: l } = n, [a, c] = l.value;
      nD(o), rD("x", i, o, s, c);
    });
  };
}
function iD(n, e, t, r) {
  const { xHandle: i, yHandle: s, colHandle: o, rowHandle: l, preview: a } = t;
  i.dataset.displayType = n === "y" ? "indicator" : "none", s.dataset.displayType = n === "x" ? "indicator" : "none", n === "y" ? (o.dataset.show = "false", r9(l)) : (l.dataset.show = "false", r9(o));
  const { hoverIndex: c, dragInfo: u } = r, [h, f] = c.value;
  u.value = {
    startCoords: [e.clientX, e.clientY],
    startIndex: n === "y" ? h : f,
    endIndex: n === "y" ? h : f,
    type: n === "y" ? "row" : "col"
  }, a.dataset.direction = n === "y" ? "vertical" : "horizontal";
}
function sD(n, e, t, r) {
  const i = t == null ? void 0 : t.get(pt);
  if (!(i != null && i.editable)) return;
  e.stopPropagation(), e.dataTransfer && (e.dataTransfer.effectAllowed = "move");
  const s = tD(n);
  s && requestAnimationFrame(() => {
    r(s);
  });
}
function r9(n) {
  var e;
  (e = n.querySelector(".button-group")) == null || e.setAttribute("data-show", "false");
}
function L5(n, e) {
  for (let t = 0; t < n.childCount; t++)
    if (n.child(t) === e) return t;
  return -1;
}
function Yie(n, e) {
  var t, r, i;
  if (e)
    try {
      const s = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
      });
      if (!s) return;
      const o = s == null ? void 0 : s.inside;
      if (o == null || o < 0) return;
      const l = e.state.doc.resolve(o), a = e.state.doc.nodeAt(o);
      if (!a) return;
      const c = ["table_cell", "table_header"], u = ["table_row", "table_header_row"], h = c.includes(a.type.name) ? a : (t = Zi((g) => c.includes(g.type.name))(l)) == null ? void 0 : t.node, f = (r = Zi((g) => u.includes(g.type.name))(
        l
      )) == null ? void 0 : r.node, d = (i = Zi((g) => g.type.name === "table")(l)) == null ? void 0 : i.node;
      if (!h || !f || !d) return;
      const p = L5(f, h);
      return [L5(d, f), p];
    } catch {
      return;
    }
}
function Cg(n, [e, t]) {
  const r = n.value;
  if (!r) return;
  const i = r.querySelectorAll("tr"), s = i[e];
  if (!s) return;
  const o = i[0];
  if (!o) return;
  const l = o.children[t];
  if (!l) return;
  const a = s.children[t];
  if (a)
    return {
      row: s,
      col: a,
      headerCol: l
    };
}
function Jie(n, e, t) {
  if (!t || !e) return;
  const { selection: r } = e.state;
  if (!(r instanceof ft)) return;
  const { $from: i } = r, s = wu(i);
  if (!(!s || s.node !== t)) {
    if (r.isColSelection()) {
      const { $head: o } = r, l = o.index(o.depth - 1);
      Z7({
        refs: n,
        index: [0, l],
        before: (a) => {
          var c;
          (c = a.querySelector(".button-group")) == null || c.setAttribute("data-show", "true");
        }
      });
      return;
    }
    if (r.isRowSelection()) {
      const { $head: o } = r, l = Zi(
        (c) => c.type.name === "table_row" || c.type.name === "table_header_row"
      )(o);
      if (!l) return;
      const a = L5(s.node, l.node);
      Q7({
        refs: n,
        index: [a, 0],
        before: (c) => {
          var u;
          a > 0 && ((u = c.querySelector(".button-group")) == null || u.setAttribute("data-show", "true"));
        }
      });
    }
  }
}
function Z7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, colHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = Cg(i, e);
  if (!a) return;
  const { headerCol: c } = a;
  l.dataset.show = "true", t && t(l), Ti(c, l, { placement: "top" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function Q7({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, rowHandleRef: s, hoverIndex: o } = n, l = s.value;
  if (!l) return;
  o.value = e;
  const a = Cg(i, e);
  if (!a) return;
  const { row: c } = a;
  l.dataset.show = "true", t && t(l), Ti(c, l, { placement: "left" }).then(({ x: u, y: h }) => {
    Object.assign(l.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(l);
  }).catch(console.error);
}
function oD(n, e, t) {
  const r = t === "x" ? "left" : "top", i = t === "x" ? "right" : "bottom", s = n.length - 1, o = n.findIndex((a, c) => {
    const u = a.getBoundingClientRect(), h = u[r], f = u[i];
    return h <= e && e <= f || c === s && e > f || c === 0 && e < h;
  }), l = n[o];
  return l ? [l, o] : void 0;
}
function Xie(n, e) {
  const t = n.querySelector("tr");
  if (!t) return;
  const r = Array.from(t.children);
  return oD(r, e, "x");
}
function Zie(n, e) {
  const t = Array.from(n.querySelectorAll("tr"));
  return oD(t, e, "y");
}
function Qie(n) {
  return f1((e) => {
    const t = tD(n);
    if (!t) return;
    const { preview: r, content: i, contentRoot: s, xHandle: o, yHandle: l } = t, { dragInfo: a, hoverIndex: c } = n;
    if (r.dataset.show === "false") return;
    const u = Cg(n.contentWrapperRef, c.value);
    if (!u || !s.querySelector("tr")) return;
    const f = a.value;
    if (!f || !s.offsetParent) return;
    const d = s.offsetParent.offsetTop, p = s.offsetParent.offsetLeft;
    if (f.type === "col") {
      const m = u.col.getBoundingClientRect().width, { left: g, width: b } = s.getBoundingClientRect(), w = p - g, k = e.clientX + w - m / 2, [T] = f.startCoords, M = T < e.clientX ? "right" : "left";
      r.style.top = `${d}px`;
      const C = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.left = `${C}px`;
      const I = Xie(s, e.clientX);
      if (I) {
        const [_, F] = I, L = l.getBoundingClientRect().width, $ = i.getBoundingClientRect();
        f.endIndex = F, Ti(_, l, {
          placement: M === "left" ? "left" : "right",
          middleware: [Jo(M === "left" ? -1 * L : 0)]
        }).then(({ x: B }) => {
          l.dataset.show = "true", Object.assign(l.style, {
            height: `${$.height}px`,
            left: `${B}px`,
            top: `${d}px`
          });
        }).catch(console.error);
      }
    } else if (f.type === "row") {
      const m = u.row.getBoundingClientRect().height, { top: g, height: b } = s.getBoundingClientRect(), w = d - g, k = e.clientY + w - m / 2, [T, M] = f.startCoords, C = M < e.clientY ? "down" : "up", I = k < g + w - 20 ? g + w - 20 : k > g + b + w - m + 20 ? g + b + w - m + 20 : k;
      r.style.top = `${I}px`, r.style.left = `${p}px`;
      const _ = Zie(s, e.clientY);
      if (_) {
        const [F, L] = _, $ = o.getBoundingClientRect().height, B = i.getBoundingClientRect();
        f.endIndex = L, Ti(F, o, {
          placement: C === "up" ? "top" : "bottom",
          middleware: [Jo(C === "up" ? -1 * $ : 0)]
        }).then(({ y: se }) => {
          o.dataset.show = "true", Object.assign(o.style, {
            width: `${B.width}px`,
            top: `${se}px`
          });
        }).catch(console.error);
      }
    }
  }, 20);
}
function ese(n, e, t) {
  const { dragPreviewRef: r, yLineHandleRef: i, xLineHandleRef: s, dragInfo: o } = n, l = Gie(n, e), a = Kie(n, e), c = () => {
    const f = r.value;
    if (!f || f.dataset.show === "false") return;
    const d = f == null ? void 0 : f.querySelector("tbody");
    for (; d != null && d.firstChild; )
      d == null || d.removeChild(d.firstChild);
    f && (f.dataset.show = "false");
  }, u = () => {
    var f;
    const d = r.value;
    if (!d) return;
    const p = i.value;
    if (!p) return;
    const m = s.value;
    if (!m) return;
    const g = o.value;
    if (!g || !e || d.dataset.show === "false" || !n.colHandleRef.value || !n.rowHandleRef.value || (p.dataset.show = "false", m.dataset.show = "false", g.startIndex === g.endIndex)) return;
    const k = e.get(pe), T = {
      from: g.startIndex,
      to: g.endIndex,
      pos: ((f = t == null ? void 0 : t()) != null ? f : 0) + 1
    };
    if (g.type === "col") {
      k.call(Pl.key, {
        pos: T.pos,
        index: g.startIndex
      }), k.call(r7.key, T);
      const M = [0, g.endIndex];
      Z7({
        refs: n,
        index: M
      });
    } else {
      k.call(Rl.key, {
        pos: T.pos,
        index: g.startIndex
      }), k.call(n7.key, T);
      const M = [g.endIndex, 0];
      Q7({
        refs: n,
        index: M
      });
    }
    requestAnimationFrame(() => {
      e.get(pt).focus();
    });
  }, h = Qie(n);
  return Td(() => {
    window.addEventListener("dragover", h), window.addEventListener("dragend", c), window.addEventListener("drop", u);
  }), l1(() => {
    window.removeEventListener("dragover", h), window.removeEventListener("dragend", c), window.removeEventListener("drop", u);
  }), {
    dragRow: l,
    dragCol: a
  };
}
function tse(n, e, t) {
  const {
    xLineHandleRef: r,
    contentWrapperRef: i,
    colHandleRef: s,
    rowHandleRef: o,
    hoverIndex: l,
    lineHoverIndex: a
  } = n;
  return {
    onAddRow: () => {
      var m, g, b;
      if (!e) return;
      const w = r.value;
      if (!w) return;
      const [k] = a.value;
      if (k < 0 || !e.get(pt).editable) return;
      const T = Array.from(
        (g = (m = i.value) == null ? void 0 : m.querySelectorAll("tr")) != null ? g : []
      ), M = e.get(pe), C = ((b = t == null ? void 0 : t()) != null ? b : 0) + 1;
      T.length === k ? (M.call(Rl.key, { pos: C, index: k - 1 }), M.call(a7.key)) : (M.call(Rl.key, { pos: C, index: k }), M.call(l7.key)), M.call(Rl.key, { pos: C, index: k }), w.dataset.show = "false";
    },
    onAddCol: () => {
      var m, g, b, w;
      if (!e || !r.value) return;
      const [T, M] = a.value;
      if (M < 0 || !e.get(pt).editable) return;
      const C = Array.from(
        (b = (g = (m = i.value) == null ? void 0 : m.querySelector("tr")) == null ? void 0 : g.children) != null ? b : []
      ), I = e.get(pe), _ = ((w = t == null ? void 0 : t()) != null ? w : 0) + 1;
      C.length === M ? (I.call(Pl.key, { pos: _, index: M - 1 }), I.call(o7.key)) : (I.call(Pl.key, { pos: _, index: M }), I.call(s7.key)), I.call(Pl.key, { pos: _, index: M });
    },
    selectCol: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(pe), T = ((m = t == null ? void 0 : t()) != null ? m : 0) + 1;
      k.call(Pl.key, { pos: T, index: w });
      const M = (g = s.value) == null ? void 0 : g.querySelector(".button-group");
      M && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    selectRow: () => {
      var m, g;
      if (!e) return;
      const [b, w] = l.value, k = e.get(pe), T = ((m = t == null ? void 0 : t()) != null ? m : 0) + 1;
      k.call(Rl.key, { pos: T, index: b });
      const M = (g = o.value) == null ? void 0 : g.querySelector(".button-group");
      M && b > 0 && (M.dataset.show = M.dataset.show === "true" ? "false" : "true");
    },
    deleteSelected: (m) => {
      if (!e || !e.get(pt).editable) return;
      m.preventDefault(), m.stopPropagation(), e.get(pe).call(i7.key), requestAnimationFrame(() => {
        e.get(pt).focus();
      });
    },
    onAlign: (m) => (g) => {
      if (!e || !e.get(pt).editable) return;
      g.preventDefault(), g.stopPropagation(), e.get(pe).call(c7.key, m), requestAnimationFrame(() => {
        e.get(pt).focus();
      });
    }
  };
}
function nse(n, e) {
  return f1((t) => {
    if (!(e != null && e.editable)) return;
    const {
      contentWrapperRef: r,
      yLineHandleRef: i,
      xLineHandleRef: s,
      colHandleRef: o,
      rowHandleRef: l,
      hoverIndex: a,
      lineHoverIndex: c
    } = n, u = i.value;
    if (!u) return;
    const h = s.value;
    if (!h) return;
    const f = r.value;
    if (!f) return;
    const d = l.value;
    if (!d) return;
    const p = o.value;
    if (!p) return;
    const m = Yie(t, e);
    if (!m) return;
    const g = Cg(r, m);
    if (!g) return;
    const [b, w] = m, k = g.col.getBoundingClientRect(), T = Math.abs(t.clientX - k.left) < 8, M = Math.abs(k.right - t.clientX) < 8, C = Math.abs(t.clientY - k.top) < 8, I = Math.abs(k.bottom - t.clientY) < 8, _ = T || M || C || I, F = d.querySelector(".button-group"), L = p.querySelector(".button-group");
    if (F && (F.dataset.show = "false"), L && (L.dataset.show = "false"), _) {
      const $ = f.getBoundingClientRect();
      d.dataset.show = "false", p.dataset.show = "false", h.dataset.displayType = "tool", u.dataset.displayType = "tool";
      const B = u.getBoundingClientRect().width, se = h.getBoundingClientRect().height;
      T || M ? (c.value[1] = T ? w : w + 1, Ti(g.col, u, {
        placement: T ? "left" : "right",
        middleware: [Jo(T ? -1 * B : 0)]
      }).then(({ x: te }) => {
        u.dataset.show = "true", Object.assign(u.style, {
          height: `${$.height}px`,
          left: `${te}px`
        });
      }).catch(console.error)) : u.dataset.show = "false", m[0] !== 0 && (C || I) ? (c.value[0] = C ? b : b + 1, Ti(g.row, h, {
        placement: C ? "top" : "bottom",
        middleware: [Jo(C ? -1 * se : 0)]
      }).then(({ y: te }) => {
        h.dataset.show = "true", Object.assign(h.style, {
          width: `${$.width}px`,
          top: `${te}px`
        });
      }).catch(console.error)) : h.dataset.show = "false";
      return;
    }
    c.value = [-1, -1], u.dataset.show = "false", h.dataset.show = "false", d.dataset.show = "true", p.dataset.show = "true", Q7({
      refs: n,
      index: m
    }), Z7({
      refs: n,
      index: m
    }), a.value = m;
  }, 20);
}
function rse(n) {
  return () => {
    const { rowHandleRef: e, colHandleRef: t, yLineHandleRef: r, xLineHandleRef: i } = n;
    setTimeout(() => {
      const s = e.value;
      if (!s) return;
      const o = t.value;
      if (!o) return;
      const l = r.value;
      if (!l) return;
      const a = i.value;
      a && (s.dataset.show = "false", o.dataset.show = "false", l.dataset.show = "false", a.dataset.show = "false");
    }, 200);
  };
}
function ise(n, e) {
  const t = nse(n, e), r = rse(n);
  return {
    pointerMove: t,
    pointerLeave: r
  };
}
const sse = Xt({
  props: {
    view: {
      type: Object,
      required: !0
    },
    ctx: {
      type: Object,
      required: !0
    },
    getPos: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    },
    node: {
      type: Object,
      required: !0
    }
  },
  setup({ view: n, node: e, ctx: t, getPos: r, config: i, onMount: s }) {
    const o = ce(), l = (B) => {
      B != null && (B instanceof HTMLElement ? (o.value = B, s(B)) : o.value = void 0);
    }, a = ce(), c = ce(), u = ce(), h = ce(), f = ce(), d = ce(), p = ce([0, 0]), m = ce([-1, -1]), g = ce(), b = {
      dragPreviewRef: d,
      tableWrapperRef: f,
      contentWrapperRef: o,
      yLineHandleRef: h,
      xLineHandleRef: u,
      colHandleRef: a,
      rowHandleRef: c,
      hoverIndex: p,
      lineHoverIndex: m,
      dragInfo: g
    }, { pointerLeave: w, pointerMove: k } = ise(b, n), { dragRow: T, dragCol: M } = ese(b, t, r), {
      onAddRow: C,
      onAddCol: I,
      selectCol: _,
      selectRow: F,
      deleteSelected: L,
      onAlign: $
    } = tse(b, t, r);
    return Td(() => {
      requestAnimationFrame(() => {
        n.editable && Jie(b, n, e.value);
      });
    }), () => /* @__PURE__ */ V(
      "div",
      {
        onDragstart: (B) => B.preventDefault(),
        onDragover: (B) => B.preventDefault(),
        onDragleave: (B) => B.preventDefault(),
        onPointermove: k,
        onPointerleave: w
      },
      /* @__PURE__ */ V(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "col-drag-handle",
          class: "handle cell-handle",
          onDragstart: M,
          onClick: _,
          onPointerdown: (B) => B.stopPropagation(),
          onPointermove: (B) => B.stopPropagation(),
          ref: a
        },
        /* @__PURE__ */ V(Hi, { icon: i.renderButton("col_drag_handle") }),
        /* @__PURE__ */ V(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (B) => B.stopPropagation()
          },
          /* @__PURE__ */ V("button", { type: "button", onPointerdown: $("left") }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("align_col_left") })),
          /* @__PURE__ */ V("button", { type: "button", onPointerdown: $("center") }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("align_col_center") })),
          /* @__PURE__ */ V("button", { type: "button", onPointerdown: $("right") }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("align_col_right") })),
          /* @__PURE__ */ V("button", { type: "button", onPointerdown: L }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("delete_col") }))
        )
      ),
      /* @__PURE__ */ V(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "row-drag-handle",
          class: "handle cell-handle",
          onDragstart: T,
          onClick: F,
          onPointerdown: (B) => B.stopPropagation(),
          onPointermove: (B) => B.stopPropagation(),
          ref: c
        },
        /* @__PURE__ */ V(Hi, { icon: i.renderButton("row_drag_handle") }),
        /* @__PURE__ */ V(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (B) => B.stopPropagation()
          },
          /* @__PURE__ */ V("button", { type: "button", onPointerdown: L }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("delete_row") }))
        )
      ),
      /* @__PURE__ */ V("div", { class: "table-wrapper", ref: f }, /* @__PURE__ */ V(
        "div",
        {
          "data-show": "false",
          class: "drag-preview",
          "data-direction": "vertical",
          ref: d
        },
        /* @__PURE__ */ V("table", null, /* @__PURE__ */ V("tbody", null))
      ), /* @__PURE__ */ V(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "x-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (B) => B.stopPropagation(),
          ref: u
        },
        /* @__PURE__ */ V("button", { type: "button", onClick: C, class: "add-button" }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("add_row") }))
      ), /* @__PURE__ */ V(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "y-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (B) => B.stopPropagation(),
          ref: h
        },
        /* @__PURE__ */ V("button", { type: "button", onClick: I, class: "add-button" }, /* @__PURE__ */ V(Hi, { icon: i.renderButton("add_col") }))
      ), /* @__PURE__ */ V("table", { ref: l, class: "children" }))
    );
  }
});
var lD = (n) => {
  throw TypeError(n);
}, ose = (n, e, t) => e.has(n) || lD("Cannot " + t), lse = (n, e, t) => e.has(n) ? lD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), ase = (n, e, t) => (ose(n, e, "access private method"), t), B5, aD;
class cse {
  constructor(e, t, r, i) {
    this.ctx = e, this.node = t, this.view = r, this.getPos = i, lse(this, B5);
    const s = document.createElement("div");
    s.className = "milkdown-table-block";
    const o = document.createElement("tbody");
    this.contentDOM = o, o.setAttribute("data-content-dom", "true"), o.classList.add("content-dom"), this.nodeRef = cm(t);
    const l = oi(sse, {
      view: r,
      ctx: e,
      getPos: i,
      config: e.get(Sg.key),
      onMount: (a) => {
        a.appendChild(o);
      },
      node: this.nodeRef
    });
    l.mount(s), this.app = l, this.dom = s;
  }
  update(e) {
    return e.type !== this.node.type || e.sameMarkup(this.node) && e.content.eq(this.node.content) ? !1 : (this.node = e, this.nodeRef.value = e, !0);
  }
  stopEvent(e) {
    if (e.type === "drop" || e.type.startsWith("drag")) return !0;
    if (e.type === "mousedown" || e.type === "pointerdown") {
      if (e.target instanceof Element && e.target.closest("button")) return !0;
      const t = e.target;
      if (t instanceof HTMLElement && (t.closest("th") || t.closest("td"))) {
        const r = e;
        return ase(this, B5, aD).call(this, r);
      }
    }
    return !1;
  }
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : e.type === "selection" ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  destroy() {
    this.app.unmount(), this.dom.remove(), this.contentDOM.remove();
  }
}
B5 = /* @__PURE__ */ new WeakSet();
aD = function(n) {
  const e = this.view;
  if (!e.editable) return !1;
  const { state: t, dispatch: r } = e, i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  if (!i) return !1;
  const s = t.doc.resolve(i.inside), o = Zi(
    (c) => c.type.name === "table_cell" || c.type.name === "table_header"
  )(s);
  if (!o) return !1;
  if (t.selection instanceof ge) {
    const c = Zi(
      (u) => u.type.name === "table_cell" || u.type.name === "table_header"
    )(t.selection.$from);
    if ((c == null ? void 0 : c.node) === o.node) return !1;
  }
  const { from: l } = o, a = ve.create(t.doc, l + 1);
  return t.selection.eq(a) ? !1 : (t.selection instanceof ft ? setTimeout(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }, 20) : requestAnimationFrame(() => {
    r(t.tr.setSelection(a).scrollIntoView());
  }), !0);
};
const cD = Hd(
  Oa.node,
  (n) => (e, t, r) => new cse(n, e, t, r)
);
eD(cD, {
  displayName: "NodeView<table-block>",
  group: "TableBlock"
});
const use = [Sg, cD];
function z5(n) {
  if (!n) return !1;
  if (Array.isArray(n))
    return n.length > 1 ? !1 : z5(n[0]);
  const e = n.content;
  return e ? z5(e) : n.type === "text";
}
const uD = Ut((n) => {
  const e = n.get(Qi);
  n.update(uf, (i) => ({
    ...i,
    editable: i.editable ?? (() => !0)
  }));
  const t = new kt("MILKDOWN_CLIPBOARD");
  return new xt({
    key: t,
    props: {
      handlePaste: (i, s) => {
        var b, w;
        const o = n.get(af), l = (w = (b = i.props).editable) == null ? void 0 : w.call(b, i.state), { clipboardData: a } = s;
        if (!l || !a || i.state.selection.$from.node().type.spec.code) return !1;
        const u = a.getData("text/plain"), h = a.getData("vscode-editor-data");
        if (h) {
          const k = JSON.parse(h), T = k == null ? void 0 : k.mode;
          if (u && T) {
            const { tr: M } = i.state, C = zH("code_block", e);
            return M.replaceSelectionWith(C.create({ language: T })).setSelection(
              ge.near(
                M.doc.resolve(Math.max(0, M.selection.from - 2))
              )
            ).insertText(u.replace(/\r\n?/g, `
`)), i.dispatch(M), !0;
          }
        }
        const f = a.getData("text/html");
        if (f.length === 0 && u.length === 0) return !1;
        const d = pa.fromSchema(e);
        let p;
        if (f.length === 0) {
          const k = o(u);
          if (!k || typeof k == "string") return !1;
          p = Sa.fromSchema(e).serializeFragment(
            k.content
          );
        } else {
          const k = document.createElement("template");
          k.innerHTML = f, p = k.content.cloneNode(!0), k.remove();
        }
        const m = d.parseSlice(p), g = LH(m);
        return g ? (i.dispatch(i.state.tr.replaceSelectionWith(g, !0)), !0) : (i.dispatch(i.state.tr.replaceSelection(m)), !0);
      },
      clipboardTextSerializer: (i) => {
        const s = n.get(ac);
        if (z5(i.content.toJSON()))
          return i.content.textBetween(
            0,
            i.content.size,
            `

`
          );
        const l = e.topNodeType.createAndFill(void 0, i.content);
        return l ? s(l) : "";
      }
    }
  });
});
uD.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};
function Au(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-history",
      ...e
    }
  }), n;
}
const ev = De("Undo", () => () => ag);
Au(ev, {
  displayName: "Command<undo>"
});
const tv = De("Redo", () => () => nu);
Au(tv, {
  displayName: "Command<redo>"
});
const nv = it({}, "historyProviderConfig");
Au(nv, {
  displayName: "Ctx<historyProviderConfig>"
});
const hD = Ut(
  (n) => lQ(n.get(nv.key))
);
Au(hD, {
  displayName: "Ctx<historyProviderPlugin>"
});
const rv = hr("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(ev.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (n) => {
      const e = n.get(pe);
      return () => e.call(tv.key);
    }
  }
});
Au(rv.ctx, {
  displayName: "KeymapCtx<history>"
});
Au(rv.shortcuts, {
  displayName: "Keymap<history>"
});
const hse = [
  nv,
  hD,
  rv,
  ev,
  tv
].flat();
function fse(n, e) {
  const { doc: t, selection: r } = n;
  if (!t || !r || !(r instanceof ge || r instanceof or))
    return n;
  const { to: i } = r, s = e.type === "space" ? Array(e.size).fill(" ").join("") : "	";
  return n.insertText(s, i);
}
const Mg = it(
  { type: "space", size: 2 },
  "indentConfig"
);
Mg.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
const fD = lA((n) => ({
  Tab: (e, t) => {
    const r = n.get(Mg.key), { tr: i } = e, s = fse(i, r);
    return s.docChanged ? (t == null || t(s), !0) : !1;
  }
}));
fD.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
const dse = [Mg, fD];
class dD {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.selectionUpdatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (e) => (this.beforeMountedListeners.push(e), this), this.mounted = (e) => (this.mountedListeners.push(e), this), this.updated = (e) => (this.updatedListeners.push(e), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners,
      selectionUpdated: this.selectionUpdatedListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(e) {
    return this.markdownUpdatedListeners.push(e), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(e) {
    return this.blurListeners.push(e), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(e) {
    return this.focusListeners.push(e), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(e) {
    return this.destroyListeners.push(e), this;
  }
  /// Subscribe to the selectionUpdated event.
  /// This event will be triggered when the editor selection is updated.
  selectionUpdated(e) {
    return this.selectionUpdatedListeners.push(e), this;
  }
}
const r1 = Ge(
  new dD(),
  "listener"
), pse = new kt("MILKDOWN_LISTENER"), pD = (n) => (n.inject(r1, new dD()), async () => {
  await n.wait(ta);
  const e = n.get(r1), { listeners: t } = e;
  t.beforeMount.forEach((a) => a(n)), await n.wait(cf);
  const r = n.get(ac);
  let i = null, s = null, o = null;
  const l = new xt({
    key: pse,
    view: () => ({
      destroy: () => {
        t.destroy.forEach((a) => a(n));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (t.focus.forEach((a) => a(n)), !1),
        blur: () => (t.blur.forEach((a) => a(n)), !1)
      }
    },
    state: {
      init: (a, c) => {
        i = c.doc, s = r(c.doc);
      },
      apply: (a) => {
        const c = a.selection;
        return (!o && c || o && !c.eq(o)) && (t.selectionUpdated.forEach((h) => {
          h(n, c, o);
        }), o = c), !a.docChanged || a.getMeta("addToHistory") === !1 ? void 0 : h1(() => {
          const { doc: h } = a;
          if (t.updated.length > 0 && i && !i.eq(h) && t.updated.forEach((f) => {
            f(n, h, i);
          }), t.markdownUpdated.length > 0 && i && !i.eq(h)) {
            const f = r(h);
            t.markdownUpdated.forEach((d) => {
              d(n, f, s);
            }), s = f;
          }
          i = h;
        }, 200)();
      }
    }
  });
  n.update(Ko, (a) => a.concat(l)), await n.wait(Bp), t.mounted.forEach((a) => a(n));
});
pD.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
const iv = it(
  {
    shouldAppend: (n) => !(!n || ["heading", "paragraph"].includes(n.type.name)),
    getNode: (n) => n.schema.nodes.paragraph.create()
  },
  "trailingConfig"
);
iv.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
const mD = Ut((n) => {
  const e = new kt("MILKDOWN_TRAILING"), { shouldAppend: t, getNode: r } = n.get(iv.key), i = new xt({
    key: e,
    state: {
      init: (s, o) => {
        const l = o.tr.doc.lastChild;
        return t(l, o);
      },
      apply: (s, o, l, a) => {
        if (!s.docChanged) return o;
        const c = s.doc.lastChild;
        return t(c, a);
      }
    },
    appendTransaction: (s, o, l) => {
      const { doc: a, tr: c } = l, u = r == null ? void 0 : r(l), h = i.getState(l), f = a.content.size;
      if (!(!h || !u))
        return c.insert(f, u);
    }
  });
  return i;
});
mD.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
const mse = [iv, mD];
var st = /* @__PURE__ */ ((n) => (n.CodeMirror = "code-mirror", n.ListItem = "list-item", n.LinkTooltip = "link-tooltip", n.Cursor = "cursor", n.ImageBlock = "image-block", n.BlockEdit = "block-edit", n.Toolbar = "toolbar", n.Placeholder = "placeholder", n.Table = "table", n.Latex = "latex", n))(st || {});
const gse = {
  cursor: !0,
  "list-item": !0,
  "link-tooltip": !0,
  "image-block": !0,
  "block-edit": !0,
  placeholder: !0,
  toolbar: !0,
  "code-mirror": !0,
  table: !0,
  latex: !0
}, yse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM8.25 16.625C8.0375 16.625 7.85942 16.5531 7.71575 16.4093C7.57192 16.2654 7.5 16.0872 7.5 15.8748C7.5 15.6621 7.57192 15.484 7.71575 15.3405C7.85942 15.1968 8.0375 15.125 8.25 15.125H15.75C15.9625 15.125 16.1406 15.1969 16.2843 15.3408C16.4281 15.4846 16.5 15.6628 16.5 15.8753C16.5 16.0879 16.4281 16.266 16.2843 16.4095C16.1406 16.5532 15.9625 16.625 15.75 16.625H8.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM8.25 8.875C8.0375 8.875 7.85942 8.80308 7.71575 8.65925C7.57192 8.51542 7.5 8.33725 7.5 8.12475C7.5 7.91208 7.57192 7.734 7.71575 7.5905C7.85942 7.44683 8.0375 7.375 8.25 7.375H15.75C15.9625 7.375 16.1406 7.44692 16.2843 7.59075C16.4281 7.73458 16.5 7.91275 16.5 8.12525C16.5 8.33792 16.4281 8.516 16.2843 8.6595C16.1406 8.80317 15.9625 8.875 15.75 8.875H8.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, bse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM4.25 16.625C4.0375 16.625 3.85942 16.5531 3.71575 16.4093C3.57192 16.2654 3.5 16.0872 3.5 15.8748C3.5 15.6621 3.57192 15.484 3.71575 15.3405C3.85942 15.1968 4.0375 15.125 4.25 15.125H13.75C13.9625 15.125 14.1406 15.1969 14.2843 15.3408C14.4281 15.4846 14.5 15.6628 14.5 15.8753C14.5 16.0879 14.4281 16.266 14.2843 16.4095C14.1406 16.5532 13.9625 16.625 13.75 16.625H4.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM4.25 8.875C4.0375 8.875 3.85942 8.80308 3.71575 8.65925C3.57192 8.51542 3.5 8.33725 3.5 8.12475C3.5 7.91208 3.57192 7.734 3.71575 7.5905C3.85942 7.44683 4.0375 7.375 4.25 7.375H13.75C13.9625 7.375 14.1406 7.44692 14.2843 7.59075C14.4281 7.73458 14.5 7.91275 14.5 8.12525C14.5 8.33792 14.4281 8.516 14.2843 8.6595C14.1406 8.80317 13.9625 8.875 13.75 8.875H4.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, vse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25ZM10.25 8.875C10.0375 8.875 9.85942 8.80308 9.71575 8.65925C9.57192 8.51542 9.5 8.33725 9.5 8.12475C9.5 7.91208 9.57192 7.734 9.71575 7.5905C9.85942 7.44683 10.0375 7.375 10.25 7.375H19.75C19.9625 7.375 20.1406 7.44692 20.2843 7.59075C20.4281 7.73458 20.5 7.91275 20.5 8.12525C20.5 8.33792 20.4281 8.516 20.2843 8.6595C20.1406 8.80317 19.9625 8.875 19.75 8.875H10.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM10.25 16.625C10.0375 16.625 9.85942 16.5531 9.71575 16.4093C9.57192 16.2654 9.5 16.0872 9.5 15.8748C9.5 15.6621 9.57192 15.484 9.71575 15.3405C9.85942 15.1968 10.0375 15.125 10.25 15.125H19.75C19.9625 15.125 20.1406 15.1969 20.2843 15.3408C20.4281 15.4846 20.5 15.6628 20.5 15.8753C20.5 16.0879 20.4281 16.266 20.2843 16.4095C20.1406 16.5532 19.9625 16.625 19.75 16.625H10.25ZM4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25Z"
    />
  </svg>
`, wse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M8.85758 18.625C8.4358 18.625 8.07715 18.4772 7.78163 18.1817C7.48613 17.8862 7.33838 17.5275 7.33838 17.1058V6.8942C7.33838 6.47242 7.48613 6.11377 7.78163 5.81825C8.07715 5.52275 8.4358 5.375 8.85758 5.375H12.1999C13.2191 5.375 14.1406 5.69231 14.9643 6.32693C15.788 6.96154 16.1999 7.81603 16.1999 8.89038C16.1999 9.63779 16.0194 10.2471 15.6585 10.7183C15.2976 11.1894 14.9088 11.5314 14.4922 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3157 16.6614 14.0192 16.6614 14.9038C16.6614 16.182 16.1902 17.1217 15.2479 17.723C14.3056 18.3243 13.3563 18.625 12.3999 18.625H8.85758ZM9.4883 16.6327H12.3191C13.1063 16.6327 13.6627 16.4141 13.9884 15.9769C14.314 15.5397 14.4768 15.1205 14.4768 14.7192C14.4768 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8057 12.273 12.8057H9.4883V16.6327ZM9.4883 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5278 10.3539C13.8836 10.0064 14.0615 9.59037 14.0615 9.10575C14.0615 8.59035 13.8733 8.16918 13.497 7.84225C13.1207 7.51533 12.6595 7.35188 12.1133 7.35188H9.4883V10.875Z"
    />
  </svg>
`, xse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_952_6527)">
      <circle cx="12" cy="12" r="3" />
    </g>
    <defs>
      <clipPath id="clip0_952_6527">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, kse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8070)">
      <path
        d="M4 10.5C3.17 10.5 2.5 11.17 2.5 12C2.5 12.83 3.17 13.5 4 13.5C4.83 13.5 5.5 12.83 5.5 12C5.5 11.17 4.83 10.5 4 10.5ZM4 4.5C3.17 4.5 2.5 5.17 2.5 6C2.5 6.83 3.17 7.5 4 7.5C4.83 7.5 5.5 6.83 5.5 6C5.5 5.17 4.83 4.5 4 4.5ZM4 16.5C3.17 16.5 2.5 17.18 2.5 18C2.5 18.82 3.18 19.5 4 19.5C4.82 19.5 5.5 18.82 5.5 18C5.5 17.18 4.83 16.5 4 16.5ZM8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19ZM8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13ZM7 6C7 6.55 7.45 7 8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8070">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Sse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M9 22a1 1 0 0 1-1-1v-3H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6.1l-3.7 3.71c-.2.19-.45.29-.7.29zm1-6v3.08L13.08 16H20V4H4v12z"
    />
  </svg>
`, Cse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_1151)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10.71 16.29C10.32 16.68 9.69 16.68 9.3 16.29L5.71 12.7C5.32 12.31 5.32 11.68 5.71 11.29C6.1 10.9 6.73 10.9 7.12 11.29L10 14.17L16.88 7.29C17.27 6.9 17.9 6.9 18.29 7.29C18.68 7.68 18.68 8.31 18.29 8.7L10.71 16.29Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_1151">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Mse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_535)">
      <path
        d="M18 19H6C5.45 19 5 18.55 5 18V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_535">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, gD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M19.5 8.25l-7.5 7.5-7.5-7.5"
    />
  </svg>
`, yD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1098_15553)">
      <path
        d="M18.3007 5.70973C17.9107 5.31973 17.2807 5.31973 16.8907 5.70973L12.0007 10.5897L7.1107 5.69973C6.7207 5.30973 6.0907 5.30973 5.7007 5.69973C5.3107 6.08973 5.3107 6.71973 5.7007 7.10973L10.5907 11.9997L5.7007 16.8897C5.3107 17.2797 5.3107 17.9097 5.7007 18.2997C6.0907 18.6897 6.7207 18.6897 7.1107 18.2997L12.0007 13.4097L16.8907 18.2997C17.2807 18.6897 17.9107 18.6897 18.3007 18.2997C18.6907 17.9097 18.6907 17.2797 18.3007 16.8897L13.4107 11.9997L18.3007 7.10973C18.6807 6.72973 18.6807 6.08973 18.3007 5.70973Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1098_15553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, bD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8081)">
      <path
        d="M9.4 16.6L4.8 12L9.4 7.4L8 6L2 12L8 18L9.4 16.6ZM14.6 16.6L19.2 12L14.6 7.4L16 6L22 12L16 18L14.6 16.6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8081">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, sv = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
  >
    <g clip-path="url(#clip0_1013_1606)">
      <path
        d="M9.00012 16.1998L5.50012 12.6998C5.11012 12.3098 4.49012 12.3098 4.10012 12.6998C3.71012 13.0898 3.71012 13.7098 4.10012 14.0998L8.29012 18.2898C8.68012 18.6798 9.31012 18.6798 9.70012 18.2898L20.3001 7.69982C20.6901 7.30982 20.6901 6.68982 20.3001 6.29982C19.9101 5.90982 19.2901 5.90982 18.9001 6.29982L9.00012 16.1998Z"
        fill="#817567"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1606">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, vD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
    fill="none"
  >
    <path
      d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"
    />
  </svg>
`, Tse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7900)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M19 13H5C4.45 13 4 12.55 4 12C4 11.45 4.45 11 5 11H19C19.55 11 20 11.45 20 12C20 12.55 19.55 13 19 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7900">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, i9 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="16"
    height="16"
    viewBox="0 0 16 16"
  >
    <path
      d="M3.5 9.83366C3.35833 9.83366 3.23961 9.78571 3.14383 9.68983C3.04794 9.59394 3 9.47516 3 9.33349C3 9.19171 3.04794 9.07299 3.14383 8.97733C3.23961 8.88155 3.35833 8.83366 3.5 8.83366H12.5C12.6417 8.83366 12.7604 8.8816 12.8562 8.97749C12.9521 9.07338 13 9.19216 13 9.33383C13 9.4756 12.9521 9.59433 12.8562 9.68999C12.7604 9.78577 12.6417 9.83366 12.5 9.83366H3.5ZM3.5 7.16699C3.35833 7.16699 3.23961 7.11905 3.14383 7.02316C3.04794 6.92727 3 6.80849 3 6.66683C3 6.52505 3.04794 6.40633 3.14383 6.31066C3.23961 6.21488 3.35833 6.16699 3.5 6.16699H12.5C12.6417 6.16699 12.7604 6.21494 12.8562 6.31083C12.9521 6.40671 13 6.52549 13 6.66716C13 6.80894 12.9521 6.92766 12.8562 7.02333C12.7604 7.1191 12.6417 7.16699 12.5 7.16699H3.5Z"
    />
  </svg>
`, ov = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1013_1585)">
      <path
        d="M14.06 9.02L14.98 9.94L5.92 19H5V18.08L14.06 9.02ZM17.66 3C17.41 3 17.15 3.1 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C18.17 3.09 17.92 3 17.66 3ZM14.06 6.19L3 17.25V21H6.75L17.81 9.94L14.06 6.19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1585">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ase = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5553)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM12 17H14V7H10V9H12V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ose = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5559)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15H11V13H13C14.1 13 15 12.11 15 11V9C15 7.89 14.1 7 13 7H9V9H13V11H11C9.9 11 9 11.89 9 13V17H15V15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5559">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ese = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5565)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13.5C15 12.67 14.33 12 13.5 12C14.33 12 15 11.33 15 10.5V9C15 7.89 14.1 7 13 7H9V9H13V11H11V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5565">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ise = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7757)">
      <path
        d="M19.04 3H5.04004C3.94004 3 3.04004 3.9 3.04004 5V19C3.04004 20.1 3.94004 21 5.04004 21H19.04C20.14 21 21.04 20.1 21.04 19V5C21.04 3.9 20.14 3 19.04 3ZM19.04 19H5.04004V5H19.04V19ZM13.04 17H15.04V7H13.04V11H11.04V7H9.04004V13H13.04V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7757">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Dse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7760)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H9V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7760">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Nse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7763)">
      <path
        d="M11 17H13C14.1 17 15 16.11 15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H11C9.9 7 9 7.89 9 9V15C9 16.11 9.9 17 11 17ZM11 13H13V15H11V13ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7763">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, _5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8075)">
      <path
        d="M19 5V19H5V5H19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14.14 11.86L11.14 15.73L9 13.14L6 17H18L14.14 11.86Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8075">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Rse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M6.29811 18.625C6.04505 18.625 5.83115 18.5375 5.65641 18.3626C5.48166 18.1877 5.39429 17.9736 5.39429 17.7203C5.39429 17.467 5.48166 17.2532 5.65641 17.0788C5.83115 16.9045 6.04505 16.8173 6.29811 16.8173H9.21159L12.452 7.18265H9.53851C9.28545 7.18265 9.07155 7.0952 8.89681 6.9203C8.72206 6.7454 8.63469 6.5313 8.63469 6.278C8.63469 6.02472 8.72206 5.81089 8.89681 5.63652C9.07155 5.46217 9.28545 5.375 9.53851 5.375H16.8847C17.1377 5.375 17.3516 5.46245 17.5264 5.63735C17.7011 5.81225 17.7885 6.02634 17.7885 6.27962C17.7885 6.53293 17.7011 6.74676 17.5264 6.92113C17.3516 7.09548 17.1377 7.18265 16.8847 7.18265H14.2789L11.0385 16.8173H13.6443C13.8973 16.8173 14.1112 16.9048 14.286 17.0797C14.4607 17.2546 14.5481 17.4687 14.5481 17.722C14.5481 17.9752 14.4607 18.1891 14.286 18.3634C14.1112 18.5378 13.8973 18.625 13.6443 18.625H6.29811Z"
    />
  </svg>
`, Pse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M17.0385 19.5003V16.5388H14.0769V15.0388H17.0385V12.0773H18.5384V15.0388H21.5V16.5388H18.5384V19.5003H17.0385ZM10.8077 16.5388H7.03845C5.78282 16.5388 4.7125 16.0963 3.8275 15.2114C2.9425 14.3266 2.5 13.2564 2.5 12.0009C2.5 10.7454 2.9425 9.67504 3.8275 8.78979C4.7125 7.90454 5.78282 7.46191 7.03845 7.46191H10.8077V8.96186H7.03845C6.1987 8.96186 5.48235 9.25834 4.8894 9.85129C4.29645 10.4442 3.99998 11.1606 3.99998 12.0003C3.99998 12.8401 4.29645 13.5564 4.8894 14.1494C5.48235 14.7423 6.1987 15.0388 7.03845 15.0388H10.8077V16.5388ZM8.25 12.7503V11.2504H15.75V12.7503H8.25ZM21.5 12.0003H20C20 11.1606 19.7035 10.4442 19.1106 9.85129C18.5176 9.25834 17.8013 8.96186 16.9615 8.96186H13.1923V7.46191H16.9615C18.2171 7.46191 19.2875 7.90441 20.1725 8.78939C21.0575 9.67439 21.5 10.7447 21.5 12.0003Z"
    />
  </svg>
`, Lse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7680)">
      <path
        d="M11 18C11 19.1 10.1 20 9 20C7.9 20 7 19.1 7 18C7 16.9 7.9 16 9 16C10.1 16 11 16.9 11 18ZM9 10C7.9 10 7 10.9 7 12C7 13.1 7.9 14 9 14C10.1 14 11 13.1 11 12C11 10.9 10.1 10 9 10ZM9 4C7.9 4 7 4.9 7 6C7 7.1 7.9 8 9 8C10.1 8 11 7.1 11 6C11 4.9 10.1 4 9 4ZM15 8C16.1 8 17 7.1 17 6C17 4.9 16.1 4 15 4C13.9 4 13 4.9 13 6C13 7.1 13.9 8 15 8ZM15 10C13.9 10 13 10.9 13 12C13 13.1 13.9 14 15 14C16.1 14 17 13.1 17 12C17 10.9 16.1 10 15 10ZM15 16C13.9 16 13 16.9 13 18C13 19.1 13.9 20 15 20C16.1 20 17 19.1 17 18C17 16.9 16.1 16 15 16Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7680">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Bse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8067)">
      <path
        d="M8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6C7 6.55 7.45 7 8 7ZM20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17ZM20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11ZM4.5 16H2.5C2.22 16 2 16.22 2 16.5C2 16.78 2.22 17 2.5 17H4V17.5H3.5C3.22 17.5 3 17.72 3 18C3 18.28 3.22 18.5 3.5 18.5H4V19H2.5C2.22 19 2 19.22 2 19.5C2 19.78 2.22 20 2.5 20H4.5C4.78 20 5 19.78 5 19.5V16.5C5 16.22 4.78 16 4.5 16ZM2.5 5H3V7.5C3 7.78 3.22 8 3.5 8C3.78 8 4 7.78 4 7.5V4.5C4 4.22 3.78 4 3.5 4H2.5C2.22 4 2 4.22 2 4.5C2 4.78 2.22 5 2.5 5ZM4.5 10H2.5C2.22 10 2 10.22 2 10.5C2 10.78 2.22 11 2.5 11H3.8L2.12 12.96C2.04 13.05 2 13.17 2 13.28V13.5C2 13.78 2.22 14 2.5 14H4.5C4.78 14 5 13.78 5 13.5C5 13.22 4.78 13 4.5 13H3.2L4.88 11.04C4.96 10.95 5 10.83 5 10.72V10.5C5 10.22 4.78 10 4.5 10Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8067">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, F5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7676)">
      <path
        d="M18 13H13V18C13 18.55 12.55 19 12 19C11.45 19 11 18.55 11 18V13H6C5.45 13 5 12.55 5 12C5 11.45 5.45 11 6 11H11V6C11 5.45 11.45 5 12 5C12.55 5 13 5.45 13 6V11H18C18.55 11 19 11.45 19 12C19 12.55 18.55 13 18 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7676">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, zse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7897)">
      <path
        d="M7.17 17C7.68 17 8.15 16.71 8.37 16.26L9.79 13.42C9.93 13.14 10 12.84 10 12.53V8C10 7.45 9.55 7 9 7H5C4.45 7 4 7.45 4 8V12C4 12.55 4.45 13 5 13H7L5.97 15.06C5.52 15.95 6.17 17 7.17 17ZM17.17 17C17.68 17 18.15 16.71 18.37 16.26L19.79 13.42C19.93 13.14 20 12.84 20 12.53V8C20 7.45 19.55 7 19 7H15C14.45 7 14 7.45 14 8V12C14 12.55 14.45 13 15 13H17L15.97 15.06C15.52 15.95 16.17 17 17.17 17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7897">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, H5 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M7.30775 20.4997C6.81058 20.4997 6.385 20.3227 6.031 19.9687C5.677 19.6147 5.5 19.1892 5.5 18.692V5.99973H5.25C5.0375 5.99973 4.85942 5.92782 4.71575 5.78398C4.57192 5.64015 4.5 5.46198 4.5 5.24948C4.5 5.03682 4.57192 4.85873 4.71575 4.71523C4.85942 4.57157 5.0375 4.49973 5.25 4.49973H9C9 4.2549 9.08625 4.04624 9.25875 3.87374C9.43108 3.7014 9.63967 3.61523 9.8845 3.61523H14.1155C14.3603 3.61523 14.5689 3.7014 14.7413 3.87374C14.9138 4.04624 15 4.2549 15 4.49973H18.75C18.9625 4.49973 19.1406 4.57165 19.2843 4.71548C19.4281 4.85932 19.5 5.03748 19.5 5.24998C19.5 5.46265 19.4281 5.64073 19.2843 5.78423C19.1406 5.9279 18.9625 5.99973 18.75 5.99973H18.5V18.692C18.5 19.1892 18.323 19.6147 17.969 19.9687C17.615 20.3227 17.1894 20.4997 16.6923 20.4997H7.30775ZM17 5.99973H7V18.692C7 18.7818 7.02883 18.8556 7.0865 18.9132C7.14417 18.9709 7.21792 18.9997 7.30775 18.9997H16.6923C16.7821 18.9997 16.8558 18.9709 16.9135 18.9132C16.9712 18.8556 17 18.7818 17 18.692V5.99973ZM10.1543 16.9997C10.3668 16.9997 10.5448 16.9279 10.6885 16.7842C10.832 16.6404 10.9037 16.4622 10.9037 16.2497V8.74973C10.9037 8.53723 10.8318 8.35907 10.688 8.21523C10.5443 8.07157 10.3662 7.99973 10.1535 7.99973C9.941 7.99973 9.76292 8.07157 9.61925 8.21523C9.47575 8.35907 9.404 8.53723 9.404 8.74973V16.2497C9.404 16.4622 9.47583 16.6404 9.6195 16.7842C9.76333 16.9279 9.94158 16.9997 10.1543 16.9997ZM13.8465 16.9997C14.059 16.9997 14.2371 16.9279 14.3807 16.7842C14.5243 16.6404 14.596 16.4622 14.596 16.2497V8.74973C14.596 8.53723 14.5242 8.35907 14.3805 8.21523C14.2367 8.07157 14.0584 7.99973 13.8458 7.99973C13.6333 7.99973 13.4552 8.07157 13.3115 8.21523C13.168 8.35907 13.0962 8.53723 13.0962 8.74973V16.2497C13.0962 16.4622 13.1682 16.6404 13.312 16.7842C13.4557 16.9279 13.6338 16.9997 13.8465 16.9997Z"
    />
  </svg>
`, wD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    />
  </svg>
`, _se = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M3.25 13.7404C3.0375 13.7404 2.85938 13.6684 2.71563 13.5246C2.57188 13.3808 2.5 13.2026 2.5 12.99C2.5 12.7774 2.57188 12.5993 2.71563 12.4558C2.85938 12.3122 3.0375 12.2404 3.25 12.2404H20.75C20.9625 12.2404 21.1406 12.3123 21.2843 12.4561C21.4281 12.5999 21.5 12.7781 21.5 12.9907C21.5 13.2033 21.4281 13.3814 21.2843 13.525C21.1406 13.6686 20.9625 13.7404 20.75 13.7404H3.25ZM10.9423 10.2596V6.62495H6.5673C6.2735 6.62495 6.02377 6.52201 5.8181 6.31613C5.61245 6.11026 5.50963 5.86027 5.50963 5.56615C5.50963 5.27205 5.61245 5.02083 5.8181 4.8125C6.02377 4.60417 6.2735 4.5 6.5673 4.5H17.4423C17.7361 4.5 17.9858 4.60294 18.1915 4.80883C18.3971 5.01471 18.5 5.2647 18.5 5.5588C18.5 5.85292 18.3971 6.10413 18.1915 6.31245C17.9858 6.52078 17.7361 6.62495 17.4423 6.62495H13.0673V10.2596H10.9423ZM10.9423 15.7211H13.0673V18.4423C13.0673 18.7361 12.9643 18.9858 12.7584 19.1915C12.5526 19.3971 12.3026 19.5 12.0085 19.5C11.7144 19.5 11.4631 19.3962 11.2548 19.1887C11.0465 18.9811 10.9423 18.7291 10.9423 18.4327V15.7211Z"
    />
  </svg>
`, Fse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8078)">
      <path
        d="M20 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM20 5V8H5V5H20ZM15 19H10V10H15V19ZM5 10H8V19H5V10ZM17 19V10H20V19H17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8078">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Hse = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5547)">
      <path
        d="M5 5.5C5 6.33 5.67 7 6.5 7H10.5V17.5C10.5 18.33 11.17 19 12 19C12.83 19 13.5 18.33 13.5 17.5V7H17.5C18.33 7 19 6.33 19 5.5C19 4.67 18.33 4 17.5 4H6.5C5.67 4 5 4.67 5 5.5Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5547">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, $se = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M5.66936 16.3389L9.39244 12.6158C9.54115 12.4671 9.71679 12.3937 9.91936 12.3957C10.1219 12.3976 10.2975 12.4761 10.4463 12.6312C10.5847 12.7823 10.654 12.9585 10.654 13.1599C10.654 13.3613 10.5847 13.5363 10.4463 13.6851L6.32704 17.8197C6.14627 18.0004 5.93538 18.0908 5.69436 18.0908C5.45333 18.0908 5.24243 18.0004 5.06166 17.8197L3.01744 15.7754C2.87899 15.637 2.81136 15.4629 2.81456 15.2533C2.81776 15.0437 2.88859 14.8697 3.02706 14.7312C3.16551 14.5928 3.34008 14.5235 3.55076 14.5235C3.76144 14.5235 3.93494 14.5928 4.07126 14.7312L5.66936 16.3389ZM5.66936 8.72359L9.39244 5.00049C9.54115 4.85177 9.71679 4.77838 9.91936 4.78031C10.1219 4.78223 10.2975 4.86075 10.4463 5.01586C10.5847 5.16691 10.654 5.34314 10.654 5.54454C10.654 5.74592 10.5847 5.92097 10.4463 6.06969L6.32704 10.2043C6.14627 10.3851 5.93538 10.4755 5.69436 10.4755C5.45333 10.4755 5.24243 10.3851 5.06166 10.2043L3.01744 8.16009C2.87899 8.02162 2.81136 7.84759 2.81456 7.63799C2.81776 7.42837 2.88859 7.25433 3.02706 7.11586C3.16551 6.97741 3.34008 6.90819 3.55076 6.90819C3.76144 6.90819 3.93494 6.97741 4.07126 7.11586L5.66936 8.72359ZM13.7597 16.5581C13.5472 16.5581 13.3691 16.4862 13.2253 16.3424C13.0816 16.1986 13.0097 16.0204 13.0097 15.8078C13.0097 15.5952 13.0816 15.4171 13.2253 15.2735C13.3691 15.13 13.5472 15.0582 13.7597 15.0582H20.7597C20.9722 15.0582 21.1503 15.1301 21.2941 15.2739C21.4378 15.4177 21.5097 15.5959 21.5097 15.8085C21.5097 16.0211 21.4378 16.1992 21.2941 16.3427C21.1503 16.4863 20.9722 16.5581 20.7597 16.5581H13.7597ZM13.7597 8.94276C13.5472 8.94276 13.3691 8.87085 13.2253 8.72704C13.0816 8.58324 13.0097 8.40504 13.0097 8.19244C13.0097 7.97985 13.0816 7.80177 13.2253 7.65819C13.3691 7.5146 13.5472 7.44281 13.7597 7.44281H20.7597C20.9722 7.44281 21.1503 7.51471 21.2941 7.65851C21.4378 7.80233 21.5097 7.98053 21.5097 8.19311C21.5097 8.40571 21.4378 8.5838 21.2941 8.72739C21.1503 8.87097 20.9722 8.94276 20.7597 8.94276H13.7597Z"
    />
  </svg>
`, xD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M7 19v-.808L13.096 12L7 5.808V5h10v1.25H9.102L14.727 12l-5.625 5.77H17V19z"
    />
  </svg>
`, kD = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
  >
    <path
      d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"
    />
  </svg>
`, Vse = {
  [st.CodeMirror]: {
    theme: lF,
    languages: J_,
    expandIcon: gD,
    searchIcon: wD,
    clearSearchIcon: yD,
    searchPlaceholder: "Search language",
    noResultText: "No result",
    previewToggleIcon: (n) => n ? ov : kD
  }
}, qse = Ge([], "FeaturesCtx"), Wse = Ge({}, "CrepeCtx");
function jse(n) {
  return n.get("CrepeCtx");
}
function Tg(n) {
  return n.use("FeaturesCtx");
}
function ps(n) {
  return (e) => {
    Tg(e).update((t) => t.includes(n) ? t : [...t, n]);
  };
}
function SD(n) {
  return n.$from.parent.type.name === "code_block";
}
function CD(n) {
  var e;
  const t = (e = n.$from.node(n.$from.depth - 1)) == null ? void 0 : e.type;
  return (t == null ? void 0 : t.name) === "list_item";
}
var MD = (n) => {
  throw TypeError(n);
}, TD = (n, e, t) => e.has(n) || MD("Cannot " + t), nh = (n, e, t) => (TD(n, e, "read from private field"), t ? t.call(n) : e.get(n)), s9 = (n, e, t) => e.has(n) ? MD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Use = (n, e, t, r) => (TD(n, e, "write to private field"), e.set(n, t), t), Xa, em;
class AD {
  constructor() {
    s9(this, Xa, []), this.clear = () => (Use(this, Xa, []), this), s9(this, em, (e) => {
      const t = {
        group: e,
        addItem: (r, i) => {
          const s = { ...i, key: r };
          return e.items.push(s), t;
        },
        clear: () => (e.items = [], t)
      };
      return t;
    }), this.addGroup = (e, t) => {
      const i = {
        key: e,
        label: t,
        items: []
      };
      return nh(this, Xa).push(i), nh(this, em).call(this, i);
    }, this.getGroup = (e) => {
      const t = nh(this, Xa).find((r) => r.key === e);
      if (!t) throw new Error(`Group with key ${e} not found`);
      return nh(this, em).call(this, t);
    }, this.build = () => nh(this, Xa);
  }
}
Xa = /* @__PURE__ */ new WeakMap();
em = /* @__PURE__ */ new WeakMap();
function Gse(n, e, t) {
  var r, i, s, o, l, a, c, u, h, f, d, p, m, g, b, w, k, T, M, C, I, _, F, L, $, B, se, te, ie, Ce, Oe, Re, Be, D, Me, _e, O, rt, Le, Ke, Dt, Pt, Zt, on, Lr, dr, ci, vn, Br, zr, wn, Un, In, lo, cl, Da, ao, Ri, ui, q, ne, Ee, Fe, Ye, ln, Dn, an, Qt, Nn, Ft, pr, Gn, ul, hl, i0, co, s0, o0, Lt, ms, l0, Ou, Na, Eu, Iu, a0, mr, Pi, Du, Nu, Ra, Ru, _r, Pu, Lu, Bu, zu, c0, be, R, Q, me, ot, Kt, Tt, cn, Fr, gs, Pa, Ht, _u, Fu, uv, hv, fv, dv, pv, mv, gv;
  const La = t && Tg(t).get(), $D = La == null ? void 0 : La.includes(st.Latex), VD = La == null ? void 0 : La.includes(st.ImageBlock), qD = La == null ? void 0 : La.includes(st.Table), Hu = new AD();
  if ((e == null ? void 0 : e.textGroup) !== null) {
    const tt = Hu.addGroup(
      "text",
      (i = (r = e == null ? void 0 : e.textGroup) == null ? void 0 : r.label) != null ? i : "Text"
    );
    ((s = e == null ? void 0 : e.textGroup) == null ? void 0 : s.text) !== null && tt.addItem("text", {
      label: (a = (l = (o = e == null ? void 0 : e.textGroup) == null ? void 0 : o.text) == null ? void 0 : l.label) != null ? a : "Text",
      icon: (h = (u = (c = e == null ? void 0 : e.textGroup) == null ? void 0 : c.text) == null ? void 0 : u.icon) != null ? h : Hse,
      onRun: (we) => {
        const ke = we.get(pe), et = cs.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et
        });
      }
    }), ((f = e == null ? void 0 : e.textGroup) == null ? void 0 : f.h1) !== null && tt.addItem("h1", {
      label: (m = (p = (d = e == null ? void 0 : e.textGroup) == null ? void 0 : d.h1) == null ? void 0 : p.label) != null ? m : "Heading 1",
      icon: (w = (b = (g = e == null ? void 0 : e.textGroup) == null ? void 0 : g.h1) == null ? void 0 : b.icon) != null ? w : Ase,
      onRun: (we) => {
        const ke = we.get(pe), et = Sr.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et,
          attrs: {
            level: 1
          }
        });
      }
    }), ((k = e == null ? void 0 : e.textGroup) == null ? void 0 : k.h2) !== null && tt.addItem("h2", {
      label: (C = (M = (T = e == null ? void 0 : e.textGroup) == null ? void 0 : T.h2) == null ? void 0 : M.label) != null ? C : "Heading 2",
      icon: (F = (_ = (I = e == null ? void 0 : e.textGroup) == null ? void 0 : I.h2) == null ? void 0 : _.icon) != null ? F : Ose,
      onRun: (we) => {
        const ke = we.get(pe), et = Sr.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et,
          attrs: {
            level: 2
          }
        });
      }
    }), ((L = e == null ? void 0 : e.textGroup) == null ? void 0 : L.h3) !== null && tt.addItem("h3", {
      label: (se = (B = ($ = e == null ? void 0 : e.textGroup) == null ? void 0 : $.h3) == null ? void 0 : B.label) != null ? se : "Heading 3",
      icon: (Ce = (ie = (te = e == null ? void 0 : e.textGroup) == null ? void 0 : te.h3) == null ? void 0 : ie.icon) != null ? Ce : Ese,
      onRun: (we) => {
        const ke = we.get(pe), et = Sr.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et,
          attrs: {
            level: 3
          }
        });
      }
    }), ((Oe = e == null ? void 0 : e.textGroup) == null ? void 0 : Oe.h4) !== null && tt.addItem("h4", {
      label: (D = (Be = (Re = e == null ? void 0 : e.textGroup) == null ? void 0 : Re.h4) == null ? void 0 : Be.label) != null ? D : "Heading 4",
      icon: (O = (_e = (Me = e == null ? void 0 : e.textGroup) == null ? void 0 : Me.h4) == null ? void 0 : _e.icon) != null ? O : Ise,
      onRun: (we) => {
        const ke = we.get(pe), et = Sr.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et,
          attrs: {
            level: 4
          }
        });
      }
    }), ((rt = e == null ? void 0 : e.textGroup) == null ? void 0 : rt.h5) !== null && tt.addItem("h5", {
      label: (Dt = (Ke = (Le = e == null ? void 0 : e.textGroup) == null ? void 0 : Le.h5) == null ? void 0 : Ke.label) != null ? Dt : "Heading 5",
      icon: (on = (Zt = (Pt = e == null ? void 0 : e.textGroup) == null ? void 0 : Pt.h5) == null ? void 0 : Zt.icon) != null ? on : Dse,
      onRun: (we) => {
        const ke = we.get(pe), et = Sr.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et,
          attrs: {
            level: 5
          }
        });
      }
    }), ((Lr = e == null ? void 0 : e.textGroup) == null ? void 0 : Lr.h6) !== null && tt.addItem("h6", {
      label: (vn = (ci = (dr = e == null ? void 0 : e.textGroup) == null ? void 0 : dr.h6) == null ? void 0 : ci.label) != null ? vn : "Heading 6",
      icon: (wn = (zr = (Br = e == null ? void 0 : e.textGroup) == null ? void 0 : Br.h6) == null ? void 0 : zr.icon) != null ? wn : Nse,
      onRun: (we) => {
        const ke = we.get(pe), et = Sr.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et,
          attrs: {
            level: 6
          }
        });
      }
    }), ((Un = e == null ? void 0 : e.textGroup) == null ? void 0 : Un.quote) !== null && tt.addItem("quote", {
      label: (cl = (lo = (In = e == null ? void 0 : e.textGroup) == null ? void 0 : In.quote) == null ? void 0 : lo.label) != null ? cl : "Quote",
      icon: (Ri = (ao = (Da = e == null ? void 0 : e.textGroup) == null ? void 0 : Da.quote) == null ? void 0 : ao.icon) != null ? Ri : zse,
      onRun: (we) => {
        const ke = we.get(pe), et = bu.type(we);
        ke.call(un.key), ke.call(kh.key, {
          nodeType: et
        });
      }
    }), ((ui = e == null ? void 0 : e.textGroup) == null ? void 0 : ui.divider) !== null && tt.addItem("divider", {
      label: (Ee = (ne = (q = e == null ? void 0 : e.textGroup) == null ? void 0 : q.divider) == null ? void 0 : ne.label) != null ? Ee : "Divider",
      icon: (ln = (Ye = (Fe = e == null ? void 0 : e.textGroup) == null ? void 0 : Fe.divider) == null ? void 0 : Ye.icon) != null ? ln : Tse,
      onRun: (we) => {
        const ke = we.get(pe), et = vu.type(we);
        ke.call(un.key), ke.call(Sh.key, {
          nodeType: et
        });
      }
    });
  }
  if ((e == null ? void 0 : e.listGroup) !== null) {
    const tt = Hu.addGroup(
      "list",
      (an = (Dn = e == null ? void 0 : e.listGroup) == null ? void 0 : Dn.label) != null ? an : "List"
    );
    ((Qt = e == null ? void 0 : e.listGroup) == null ? void 0 : Qt.bulletList) !== null && tt.addItem("bullet-list", {
      label: (pr = (Ft = (Nn = e == null ? void 0 : e.listGroup) == null ? void 0 : Nn.bulletList) == null ? void 0 : Ft.label) != null ? pr : "Bullet List",
      icon: (hl = (ul = (Gn = e == null ? void 0 : e.listGroup) == null ? void 0 : Gn.bulletList) == null ? void 0 : ul.icon) != null ? hl : kse,
      onRun: (we) => {
        const ke = we.get(pe), et = Ta.type(we);
        ke.call(un.key), ke.call(kh.key, {
          nodeType: et
        });
      }
    }), ((i0 = e == null ? void 0 : e.listGroup) == null ? void 0 : i0.orderedList) !== null && tt.addItem("ordered-list", {
      label: (o0 = (s0 = (co = e == null ? void 0 : e.listGroup) == null ? void 0 : co.orderedList) == null ? void 0 : s0.label) != null ? o0 : "Ordered List",
      icon: (l0 = (ms = (Lt = e == null ? void 0 : e.listGroup) == null ? void 0 : Lt.orderedList) == null ? void 0 : ms.icon) != null ? l0 : Bse,
      onRun: (we) => {
        const ke = we.get(pe), et = Aa.type(we);
        ke.call(un.key), ke.call(kh.key, {
          nodeType: et
        });
      }
    }), ((Ou = e == null ? void 0 : e.listGroup) == null ? void 0 : Ou.taskList) !== null && tt.addItem("task-list", {
      label: (Iu = (Eu = (Na = e == null ? void 0 : e.listGroup) == null ? void 0 : Na.taskList) == null ? void 0 : Eu.label) != null ? Iu : "Task List",
      icon: (Pi = (mr = (a0 = e == null ? void 0 : e.listGroup) == null ? void 0 : a0.taskList) == null ? void 0 : mr.icon) != null ? Pi : $se,
      onRun: (we) => {
        const ke = we.get(pe), et = Ei.type(we);
        ke.call(un.key), ke.call(kh.key, {
          nodeType: et,
          attrs: { checked: !1 }
        });
      }
    });
  }
  if ((e == null ? void 0 : e.advancedGroup) !== null) {
    const tt = Hu.addGroup(
      "advanced",
      (Nu = (Du = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Du.label) != null ? Nu : "Advanced"
    );
    ((Ra = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Ra.image) !== null && VD && tt.addItem("image", {
      label: (Pu = (_r = (Ru = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Ru.image) == null ? void 0 : _r.label) != null ? Pu : "Image",
      icon: (zu = (Bu = (Lu = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Lu.image) == null ? void 0 : Bu.icon) != null ? zu : _5,
      onRun: (we) => {
        const ke = we.get(pe), et = Q1.type(we);
        ke.call(un.key), ke.call(Sh.key, {
          nodeType: et
        });
      }
    }), ((c0 = e == null ? void 0 : e.advancedGroup) == null ? void 0 : c0.codeBlock) !== null && tt.addItem("code", {
      label: (Q = (R = (be = e == null ? void 0 : e.advancedGroup) == null ? void 0 : be.codeBlock) == null ? void 0 : R.label) != null ? Q : "Code",
      icon: (Kt = (ot = (me = e == null ? void 0 : e.advancedGroup) == null ? void 0 : me.codeBlock) == null ? void 0 : ot.icon) != null ? Kt : bD,
      onRun: (we) => {
        const ke = we.get(pe), et = ss.type(we);
        ke.call(un.key), ke.call(xs.key, {
          nodeType: et
        });
      }
    }), ((Tt = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Tt.table) !== null && qD && tt.addItem("table", {
      label: (gs = (Fr = (cn = e == null ? void 0 : e.advancedGroup) == null ? void 0 : cn.table) == null ? void 0 : Fr.label) != null ? gs : "Table",
      icon: (_u = (Ht = (Pa = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Pa.table) == null ? void 0 : Ht.icon) != null ? _u : Fse,
      onRun: (we) => {
        const ke = we.get(pe), et = we.get(pt);
        ke.call(un.key);
        const { from: WD } = et.state.selection;
        ke.call(Sh.key, {
          nodeType: Zb(we, 3, 3)
        }), ke.call(VA.key, {
          pos: WD
        });
      }
    }), ((Fu = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Fu.math) !== null && $D && tt.addItem("math", {
      label: (fv = (hv = (uv = e == null ? void 0 : e.advancedGroup) == null ? void 0 : uv.math) == null ? void 0 : hv.label) != null ? fv : "Math",
      icon: (mv = (pv = (dv = e == null ? void 0 : e.advancedGroup) == null ? void 0 : dv.math) == null ? void 0 : pv.icon) != null ? mv : xD,
      onRun: (we) => {
        const ke = we.get(pe), et = ss.type(we);
        ke.call(un.key), ke.call(Sh.key, {
          nodeType: et,
          attrs: { language: "LaTex" }
        });
      }
    });
  }
  (gv = e == null ? void 0 : e.buildMenu) == null || gv.call(e, Hu);
  let $u = Hu.build();
  n && ($u = $u.map((tt) => {
    const we = tt.items.filter(
      (ke) => ke.label.toLowerCase().includes(n.toLowerCase())
    );
    return {
      ...tt,
      items: we
    };
  }).filter((tt) => tt.items.length > 0));
  const yv = $u.flatMap((tt) => tt.items);
  return yv.forEach((tt, we) => {
    Object.assign(tt, { index: we });
  }), $u.reduce((tt, we) => {
    const ke = tt + we.items.length;
    return Object.assign(we, {
      range: [tt, ke]
    }), ke;
  }, 0), {
    groups: $u,
    size: yv.length
  };
}
const Kse = Xt({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    filter: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup({ ctx: n, show: e, filter: t, hide: r, config: i }) {
    const s = ce(), o = sa(() => Gse(t.value, i, n)), l = ce(0), a = ce({ x: -999, y: -999 }), c = (m) => {
      const { x: g, y: b } = m;
      a.value = { x: g, y: b };
    };
    W5([o, e], () => {
      const { size: m } = o.value;
      m === 0 && e.value ? r() : l.value >= m && (l.value = 0);
    });
    const u = (m, g) => {
      const b = l.value, w = typeof m == "function" ? m(b) : m;
      g == null || g(w), l.value = w;
    }, h = (m) => {
      var g, b;
      const w = (g = s.value) == null ? void 0 : g.querySelector(
        `[data-index="${m}"]`
      ), k = (b = s.value) == null ? void 0 : b.querySelector(".menu-groups");
      !w || !k || (k.scrollTop = w.offsetTop - k.offsetTop);
    }, f = (m) => {
      const g = o.value.groups.flatMap((b) => b.items).at(m);
      g && n && g.onRun(n), r();
    }, d = (m) => {
      const { size: g, groups: b } = o.value;
      if (m.key === "Escape") {
        m.preventDefault(), r == null || r();
        return;
      }
      if (m.key === "ArrowDown")
        return m.preventDefault(), u(
          (w) => w < g - 1 ? w + 1 : w,
          h
        );
      if (m.key === "ArrowUp")
        return m.preventDefault(), u(
          (w) => w <= 0 ? w : w - 1,
          h
        );
      if (m.key === "ArrowLeft")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const T = b[b.indexOf(k) - 1];
          return T ? T.range[1] - 1 : w;
        }, h);
      if (m.key === "ArrowRight")
        return m.preventDefault(), u((w) => {
          const k = b.find(
            (M) => M.range[0] <= w && M.range[1] > w
          );
          if (!k) return w;
          const T = b[b.indexOf(k) + 1];
          return T ? T.range[0] : w;
        }, h);
      m.key === "Enter" && (m.preventDefault(), f(l.value));
    }, p = (m) => (g) => {
      const b = a.value;
      if (!b) return;
      const { x: w, y: k } = g;
      w === b.x && k === b.y || u(m);
    };
    return au(() => {
      e.value ? window.addEventListener("keydown", d, { capture: !0 }) : window.removeEventListener("keydown", d, { capture: !0 });
    }), l1(() => {
      window.removeEventListener("keydown", d, { capture: !0 });
    }), () => /* @__PURE__ */ V("div", { ref: s, onPointerdown: (m) => m.preventDefault() }, /* @__PURE__ */ V("nav", { class: "tab-group" }, /* @__PURE__ */ V("ul", null, o.value.groups.map((m) => /* @__PURE__ */ V(
      "li",
      {
        key: m.key,
        onPointerdown: () => u(m.range[0], h),
        class: l.value >= m.range[0] && l.value < m.range[1] ? "selected" : ""
      },
      m.label
    )))), /* @__PURE__ */ V("div", { class: "menu-groups", onPointermove: c }, o.value.groups.map((m) => /* @__PURE__ */ V("div", { key: m.key, class: "menu-group" }, /* @__PURE__ */ V("h6", null, m.label), /* @__PURE__ */ V("ul", null, m.items.map((g) => /* @__PURE__ */ V(
      "li",
      {
        key: g.key,
        "data-index": g.index,
        class: l.value === g.index ? "hover" : "",
        onPointerenter: p(g.index),
        onPointerdown: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.add("active");
        },
        onPointerup: () => {
          var b, w;
          (w = (b = s.value) == null ? void 0 : b.querySelector(`[data-index="${g.index}"]`)) == null || w.classList.remove("active"), f(g.index);
        }
      },
      /* @__PURE__ */ V(tu, { icon: g.icon }),
      /* @__PURE__ */ V("span", null, g.label)
    )))))));
  }
});
var OD = (n) => {
  throw TypeError(n);
}, ED = (n, e, t) => e.has(n) || OD("Cannot " + t), hi = (n, e, t) => (ED(n, e, "read from private field"), t ? t.call(n) : e.get(n)), rh = (n, e, t) => e.has(n) ? OD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), vl = (n, e, t, r) => (ED(n, e, "write to private field"), e.set(n, t), t), Rh, tm, nm, Cs, Za;
const ID = ZG("CREPE_MENU"), lv = it(
  {
    show: () => {
    },
    hide: () => {
    }
  },
  "menuAPICtx"
);
function Yse(n, e) {
  n.set(ID.key, {
    view: (t) => new Jse(n, t, e)
  });
}
class Jse {
  constructor(e, t, r) {
    rh(this, Rh), rh(this, tm), rh(this, nm), rh(this, Cs), rh(this, Za, null), this.update = (u) => {
      hi(this, Cs).update(u);
    }, this.show = (u) => {
      vl(this, Za, u), hi(this, nm).value = "", hi(this, Cs).show();
    }, this.hide = () => {
      vl(this, Za, null), hi(this, Cs).hide();
    }, this.destroy = () => {
      hi(this, Cs).destroy(), hi(this, tm).unmount(), hi(this, Rh).remove();
    };
    const i = document.createElement("div");
    i.classList.add("milkdown-slash-menu");
    const s = ce(!1), o = ce("");
    vl(this, nm, o);
    const l = this.hide, a = oi(Kse, {
      ctx: e,
      config: r,
      show: s,
      filter: o,
      hide: l
    });
    vl(this, tm, a), a.mount(i), vl(this, Rh, i);
    const c = this;
    vl(this, Cs, new QG({
      content: hi(this, Rh),
      debounce: 20,
      shouldShow(u) {
        if (SD(u.state.selection) || CD(u.state.selection))
          return !1;
        const h = this.getContent(
          u,
          (d) => ["paragraph", "heading"].includes(d.type.name)
        );
        if (h == null || !Xse(u.state.selection))
          return !1;
        const f = hi(c, Za);
        if (o.value = h.startsWith("/") ? h.slice(1) : h, typeof f == "number") {
          const d = u.state.doc.nodeSize - 2, p = Math.min(f, d);
          return u.state.doc.resolve(p).node() !== u.state.doc.resolve(u.state.selection.from).node() ? (vl(c, Za, null), !1) : !0;
        }
        return !!h.startsWith("/");
      },
      offset: 10
    })), hi(this, Cs).onShow = () => {
      s.value = !0;
    }, hi(this, Cs).onHide = () => {
      s.value = !1;
    }, this.update(t), e.set(lv.key, {
      show: (u) => this.show(u),
      hide: () => this.hide()
    });
  }
}
Rh = /* @__PURE__ */ new WeakMap();
tm = /* @__PURE__ */ new WeakMap();
nm = /* @__PURE__ */ new WeakMap();
Cs = /* @__PURE__ */ new WeakMap();
Za = /* @__PURE__ */ new WeakMap();
function Xse(n) {
  if (!(n instanceof ge)) return !1;
  const { $head: e } = n, t = e.parent;
  return e.parentOffset === t.content.size;
}
const Zse = Xt({
  props: {
    onAdd: {
      type: Function,
      required: !0
    },
    addIcon: {
      type: String,
      required: !0
    },
    handleIcon: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = ce();
    return () => /* @__PURE__ */ V(xa, null, /* @__PURE__ */ V(
      "div",
      {
        ref: e,
        class: "operation-item",
        onPointerdown: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.add("active");
        },
        onPointerup: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.remove("active"), n.onAdd();
        }
      },
      /* @__PURE__ */ V(tu, { icon: n.addIcon })
    ), /* @__PURE__ */ V("div", { class: "operation-item" }, /* @__PURE__ */ V(tu, { icon: n.handleIcon })));
  }
});
var DD = (n) => {
  throw TypeError(n);
}, ND = (n, e, t) => e.has(n) || DD("Cannot " + t), wl = (n, e, t) => (ND(n, e, "read from private field"), t ? t.call(n) : e.get(n)), ip = (n, e, t) => e.has(n) ? DD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), sp = (n, e, t, r) => (ND(n, e, "write to private field"), e.set(n, t), t), rm, Cl, im, sm;
class Qse {
  constructor(e, t) {
    ip(this, rm), ip(this, Cl), ip(this, im), ip(this, sm), this.update = () => {
      wl(this, Cl).update();
    }, this.destroy = () => {
      wl(this, Cl).destroy(), wl(this, rm).remove(), wl(this, im).unmount();
    }, this.onAdd = () => {
      const c = wl(this, sm), u = c.get(pt);
      u.hasFocus() || u.focus();
      const { state: h, dispatch: f } = u, d = wl(this, Cl).active;
      if (!d) return;
      const m = d.$pos.pos + d.node.nodeSize;
      let g = h.tr.insert(m, cs.type(c).create());
      g = g.setSelection(ge.near(g.doc.resolve(m))), f(g.scrollIntoView()), wl(this, Cl).hide(), c.get(lv.key).show(g.selection.from);
    };
    var r, i, s;
    sp(this, sm, e);
    const o = document.createElement("div");
    o.classList.add("milkdown-block-handle");
    const l = oi(Zse, {
      onAdd: this.onAdd,
      addIcon: (r = t == null ? void 0 : t.handleAddIcon) != null ? r : F5,
      handleIcon: (i = t == null ? void 0 : t.handleDragIcon) != null ? i : Lse
    });
    l.mount(o), sp(this, im, l), sp(this, rm, o);
    const a = (s = t == null ? void 0 : t.blockHandle) != null ? s : {};
    sp(this, Cl, new TG({
      ctx: e,
      content: o,
      getOffset: () => 16,
      getPlacement: ({ active: c, blockDom: u }) => {
        if (c.node.type.name === "heading") return "left";
        let h = 0;
        c.node.descendants((T) => {
          h += T.childCount;
        });
        const f = c.el, d = f.getBoundingClientRect(), p = u.getBoundingClientRect(), m = window.getComputedStyle(f), g = Number.parseInt(m.paddingTop, 10) || 0, b = Number.parseInt(m.paddingBottom, 10) || 0, w = d.height - g - b, k = p.height;
        return h > 2 || k < w ? "left-start" : "left";
      },
      ...a
    })), this.update();
  }
}
rm = /* @__PURE__ */ new WeakMap();
Cl = /* @__PURE__ */ new WeakMap();
im = /* @__PURE__ */ new WeakMap();
sm = /* @__PURE__ */ new WeakMap();
function eoe(n, e) {
  n.set(q1.key, {
    filterNodes: (t) => !Zi(
      (i) => ["table", "blockquote", "math_inline"].includes(i.type.name)
    )(t)
  }), n.set(U1.key, {
    view: () => new Qse(n, e)
  });
}
const toe = (n, e) => {
  n.config(ps(st.BlockEdit)).config((t) => eoe(t, e)).config((t) => Yse(t, e)).use(lv).use(U1).use(ID);
}, noe = (n, e = {}) => {
  n.config(ps(st.CodeMirror)).config((t) => {
    const { languages: r = [], theme: i } = e, s = [
      du.of(pE.concat(ZZ)),
      lte
    ];
    i && s.push(i), e.extensions && s.push(...e.extensions), t.update(Jd.key, (o) => ({
      extensions: s,
      languages: r,
      expandIcon: e.expandIcon || gD,
      searchIcon: e.searchIcon || wD,
      clearSearchIcon: e.clearSearchIcon || yD,
      searchPlaceholder: e.searchPlaceholder || "Search language",
      copyText: e.copyText || "Copy",
      copyIcon: e.copyIcon || vD,
      onCopy: e.onCopy || (() => {
      }),
      noResultText: e.noResultText || "No result",
      renderLanguage: e.renderLanguage || o.renderLanguage,
      renderPreview: e.renderPreview || o.renderPreview,
      previewToggleButton: (l) => {
        var a, c;
        const u = ((a = e.previewToggleIcon) == null ? void 0 : a.call(e, l)) || (l ? ov : kD), h = ((c = e.previewToggleText) == null ? void 0 : c.call(e, l)) || (l ? "Edit" : "Hide");
        return [u, h].map((f) => f.trim()).join(" ");
      },
      previewLabel: e.previewLabel || o.previewLabel
    }));
  }).use(kQ);
}, roe = (n, e) => {
  if (n.config(ps(st.Cursor)).config((r) => {
    r.update(ug.key, () => {
      var i, s;
      return {
        class: "crepe-drop-cursor",
        width: (i = e == null ? void 0 : e.width) != null ? i : 4,
        color: (s = e == null ? void 0 : e.color) != null ? s : !1
      };
    });
  }).use(Tte), (e == null ? void 0 : e.virtual) === !1)
    return;
  const t = Ate();
  n.use(Ut(() => t));
}, ioe = (n, e) => {
  n.config(ps(st.ImageBlock)).config((t) => {
    t.update(hg.key, (r) => {
      var i, s, o, l, a, c;
      return {
        uploadButton: (i = e == null ? void 0 : e.inlineUploadButton) != null ? i : "Upload",
        imageIcon: (s = e == null ? void 0 : e.inlineImageIcon) != null ? s : _5,
        confirmButton: (o = e == null ? void 0 : e.inlineConfirmButton) != null ? o : sv,
        uploadPlaceholderText: (l = e == null ? void 0 : e.inlineUploadPlaceholderText) != null ? l : "or paste link",
        onUpload: (c = (a = e == null ? void 0 : e.inlineOnUpload) != null ? a : e == null ? void 0 : e.onUpload) != null ? c : r.onUpload,
        proxyDomURL: e == null ? void 0 : e.proxyDomURL
      };
    }), t.update(Z1.key, (r) => {
      var i, s, o, l, a, c, u, h;
      return {
        uploadButton: (i = e == null ? void 0 : e.blockUploadButton) != null ? i : "Upload file",
        imageIcon: (s = e == null ? void 0 : e.blockImageIcon) != null ? s : _5,
        captionIcon: (o = e == null ? void 0 : e.blockCaptionIcon) != null ? o : Sse,
        confirmButton: (l = e == null ? void 0 : e.blockConfirmButton) != null ? l : "Confirm",
        captionPlaceholderText: (a = e == null ? void 0 : e.blockCaptionPlaceholderText) != null ? a : "Write Image Caption",
        uploadPlaceholderText: (c = e == null ? void 0 : e.blockUploadPlaceholderText) != null ? c : "or paste link",
        onUpload: (h = (u = e == null ? void 0 : e.blockOnUpload) != null ? u : e == null ? void 0 : e.onUpload) != null ? h : r.onUpload,
        proxyDomURL: e == null ? void 0 : e.proxyDomURL
      };
    });
  }).use(FK).use($te);
}, soe = ss.extendSchema((n) => (e) => {
  const t = n(e);
  return {
    ...t,
    toMarkdown: {
      match: t.toMarkdown.match,
      runner: (r, i) => {
        var s, o;
        if (((s = i.attrs.language) != null ? s : "").toLowerCase() === "latex")
          r.addNode(
            "math",
            void 0,
            ((o = i.content.firstChild) == null ? void 0 : o.text) || ""
          );
        else
          return t.toMarkdown.runner(r, i);
      }
    }
  };
}), Ph = "math_inline", Qf = _t(Ph, () => ({
  group: "inline",
  inline: !0,
  draggable: !0,
  atom: !0,
  attrs: {
    value: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `span[data-type="${Ph}"]`,
      getAttrs: (n) => {
        var e;
        return {
          value: (e = n.dataset.value) != null ? e : ""
        };
      }
    }
  ],
  toDOM: (n) => {
    const e = n.attrs.value, t = document.createElement("span");
    return t.dataset.type = Ph, t.dataset.value = e, WI.render(e, t, {
      throwOnError: !1
    }), t;
  },
  parseMarkdown: {
    match: (n) => n.type === "inlineMath",
    runner: (n, e, t) => {
      n.addNode(t, { value: e.value });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === Ph,
    runner: (n, e) => {
      n.addNode("inlineMath", void 0, e.attrs.value);
    }
  }
})), RD = De("ToggleLatex", (n) => () => (e, t) => {
  const {
    hasNode: r,
    pos: i,
    target: s
  } = TM(e, Qf.type(n)), { selection: o, doc: l, tr: a } = e;
  if (!r) {
    const d = l.textBetween(o.from, o.to);
    let p = a.replaceSelectionWith(
      Qf.type(n).create({
        value: d
      })
    );
    return t && t(
      p.setSelection(ve.create(p.doc, o.from))
    ), !0;
  }
  const { from: c, to: u } = o;
  if (!s || i < 0) return !1;
  let h = a.delete(i, i + 1);
  const f = s.attrs.value;
  return h = h.insertText(f, i), t && t(
    h.setSelection(
      ge.create(h.doc, c, u + f.length - 1)
    )
  ), !0;
}), o9 = wg("INLINE_LATEX"), ooe = Xt({
  props: {
    config: {
      type: Object,
      required: !0
    },
    innerView: {
      type: Object,
      required: !0
    },
    updateValue: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = (r) => {
      if (!(!r || !(r instanceof HTMLElement))) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
        n.innerView.value && r.appendChild(n.innerView.value.dom);
      }
    }, t = (r) => {
      r.preventDefault(), n.updateValue.value();
    };
    return () => /* @__PURE__ */ V("div", { class: "container" }, n.innerView && /* @__PURE__ */ V("div", { ref: e }), /* @__PURE__ */ V("button", { onPointerdown: t }, /* @__PURE__ */ V(tu, { icon: n.config.inlineEditConfirm })));
  }
});
var PD = (n) => {
  throw TypeError(n);
}, LD = (n, e, t) => e.has(n) || PD("Cannot " + t), en = (n, e, t) => (LD(n, e, "read from private field"), t ? t.call(n) : e.get(n)), mo = (n, e, t) => e.has(n) ? PD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), op = (n, e, t, r) => (LD(n, e, "write to private field"), e.set(n, t), t), Lh, Qa, om, Ml, Bh, zh, $5, V5;
class loe {
  constructor(e, t, r) {
    this.ctx = e, mo(this, Lh), mo(this, Qa), mo(this, om), mo(this, Ml, cm(null)), mo(this, Bh, cm(() => {
    })), mo(this, zh), mo(this, $5, () => {
      en(this, Ml).value && (en(this, Ml).value.destroy(), en(this, Ml).value = null);
    }), mo(this, V5, (s) => {
      const l = (() => {
        const { selection: a, schema: c } = s.state;
        if (a.empty || !(a instanceof ve)) return !1;
        const u = a.node;
        if (u.type.name !== Ph) return !1;
        const h = a.from, f = c.nodes.paragraph.create(
          null,
          c.text(u.attrs.value)
        ), d = new Y3(en(this, om), {
          state: Il.create({
            doc: f,
            schema: new eM({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              gT({
                "Mod-z": ag,
                "Mod-Z": nu,
                "Mod-y": nu,
                Enter: () => (en(this, Bh).value(), !0)
              })
            ]
          })
        });
        return en(this, Ml).value = d, en(this, Bh).value = () => {
          const { tr: p } = s.state;
          p.setNodeAttribute(h, "value", d.state.doc.textContent), s.dispatch(p), requestAnimationFrame(() => {
            s.focus();
          });
        }, !0;
      })();
      return l || en(this, $5).call(this), l;
    }), this.update = (s, o) => {
      en(this, Qa).update(s, o);
    }, this.destroy = () => {
      en(this, zh).unmount(), en(this, Qa).destroy(), en(this, Lh).remove();
    };
    const i = document.createElement("div");
    i.className = "milkdown-latex-inline-edit", op(this, Lh, i), op(this, zh, oi(ooe, {
      config: r,
      innerView: en(this, Ml),
      updateValue: en(this, Bh)
    })), en(this, zh).mount(i), op(this, Qa, new vg({
      debounce: 0,
      content: en(this, Lh),
      shouldShow: en(this, V5),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    })), en(this, Qa).update(t), op(this, om, document.createElement("div"));
  }
}
Lh = /* @__PURE__ */ new WeakMap();
Qa = /* @__PURE__ */ new WeakMap();
om = /* @__PURE__ */ new WeakMap();
Ml = /* @__PURE__ */ new WeakMap();
Bh = /* @__PURE__ */ new WeakMap();
zh = /* @__PURE__ */ new WeakMap();
$5 = /* @__PURE__ */ new WeakMap();
V5 = /* @__PURE__ */ new WeakMap();
const aoe = On(
  (n) => TH(/(?:\$)([^$]+)(?:\$)$/, Qf.type(n), {
    getAttr: (e) => {
      var t;
      return {
        value: (t = e[1]) != null ? t : ""
      };
    }
  })
), coe = On(
  (n) => M3(/^\$\$[\s\n]$/, ss.type(n), () => ({
    language: "LaTeX"
  }))
), uoe = as(
  "remarkMath",
  () => Zre
);
function hoe(n) {
  return rl(
    n,
    "math",
    (e, t, r) => {
      const { value: i } = e, s = {
        type: "code",
        lang: "LaTeX",
        value: i
      };
      r.children.splice(t, 1, s);
    }
  );
}
const foe = as(
  "remarkMathBlock",
  () => () => hoe
), doe = (n, e) => {
  n.config(ps(st.Latex)).config((t) => {
    if (!Tg(t).get().includes(st.CodeMirror))
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    t.update(Jd.key, (s) => ({
      ...s,
      renderPreview: (o, l) => {
        if (o.toLowerCase() === "latex" && l.length > 0)
          return poe(l, e == null ? void 0 : e.katexOptions);
        const a = s.renderPreview;
        return a(o, l);
      }
    })), t.set(o9.key, {
      view: (s) => {
        var o;
        return new loe(t, s, {
          inlineEditConfirm: (o = e == null ? void 0 : e.inlineEditConfirm) != null ? o : sv,
          ...e
        });
      }
    });
  }).use(uoe).use(foe).use(Qf).use(o9).use(aoe).use(coe).use(soe).use(RD);
};
function poe(n, e) {
  return WI.renderToString(n, {
    ...e,
    throwOnError: !1,
    displayMode: !0
  });
}
const moe = (n, e) => {
  n.config(ps(st.LinkTooltip)).config(Eie).config((t) => {
    t.update(lu.key, (r) => {
      var i, s, o, l, a, c;
      return {
        ...r,
        linkIcon: (i = e == null ? void 0 : e.linkIcon) != null ? i : vD,
        editButton: (s = e == null ? void 0 : e.editButton) != null ? s : ov,
        removeButton: (o = e == null ? void 0 : e.removeButton) != null ? o : H5,
        confirmButton: (l = e == null ? void 0 : e.confirmButton) != null ? l : sv,
        inputPlaceholder: (a = e == null ? void 0 : e.inputPlaceholder) != null ? a : "Paste link...",
        onCopyLink: (c = e == null ? void 0 : e.onCopyLink) != null ? c : () => {
        }
      };
    });
  }).use(Iie);
};
function goe(n, e) {
  n.set(kg.key, {
    renderLabel: ({ label: t, listType: r, checked: i }) => {
      var s, o, l;
      return i == null ? r === "bullet" ? (s = e == null ? void 0 : e.bulletIcon) != null ? s : xse : t : i ? (o = e == null ? void 0 : e.checkBoxCheckedIcon) != null ? o : Cse : (l = e == null ? void 0 : e.checkBoxUncheckedIcon) != null ? l : Mse;
    }
  });
}
const yoe = (n, e) => {
  n.config(ps(st.ListItem)).config((t) => goe(t, e)).use(zie);
};
function boe(n) {
  var e;
  return n.childCount <= 1 && !((e = n.firstChild) != null && e.content.size);
}
function voe(n, e) {
  const { selection: t } = n;
  if (!t.empty) return null;
  const r = t.$anchor, i = r.parent;
  if (i.content.size > 0 || Zi((l) => l.type.name === "table")(r)) return null;
  const o = r.before();
  return Wt.node(o, o + i.nodeSize, {
    class: "crepe-placeholder",
    "data-placeholder": e
  });
}
const q5 = it(
  {
    text: "Please enter...",
    mode: "block"
  },
  "placeholderConfigCtx"
), woe = Ut((n) => new xt({
  key: new kt("CREPE_PLACEHOLDER"),
  props: {
    decorations: (e) => {
      var t;
      if (jse(n).readonly) return null;
      const i = n.get(q5.key);
      if (i.mode === "doc" && !boe(e.doc) || SD(e.selection) || CD(e.selection))
        return null;
      const s = (t = i.text) != null ? t : "Please enter...", o = voe(e, s);
      return o ? ct.create(e.doc, [o]) : null;
    }
  }
})), xoe = (n, e) => {
  n.config(ps(st.Placeholder)).config((t) => {
    e && t.update(q5.key, (r) => ({
      ...r,
      ...e
    }));
  }).use(woe).use(q5);
}, koe = (n, e) => {
  n.config(ps(st.Table)).config((t) => {
    t.update(Sg.key, (r) => ({
      ...r,
      renderButton: (i) => {
        var s, o, l, a, c, u, h, f, d;
        switch (i) {
          case "add_row":
            return (s = e == null ? void 0 : e.addRowIcon) != null ? s : F5;
          case "add_col":
            return (o = e == null ? void 0 : e.addColIcon) != null ? o : F5;
          case "delete_row":
            return (l = e == null ? void 0 : e.deleteRowIcon) != null ? l : H5;
          case "delete_col":
            return (a = e == null ? void 0 : e.deleteColIcon) != null ? a : H5;
          case "align_col_left":
            return (c = e == null ? void 0 : e.alignLeftIcon) != null ? c : bse;
          case "align_col_center":
            return (u = e == null ? void 0 : e.alignCenterIcon) != null ? u : yse;
          case "align_col_right":
            return (h = e == null ? void 0 : e.alignRightIcon) != null ? h : vse;
          case "col_drag_handle":
            return (f = e == null ? void 0 : e.colDragHandleIcon) != null ? f : i9;
          case "row_drag_handle":
            return (d = e == null ? void 0 : e.rowDragHandleIcon) != null ? d : i9;
        }
      }
    }));
  }).use(use);
};
function Soe(n, e) {
  var t, r, i, s, o, l, a;
  const c = new AD();
  c.addGroup("formatting", "Formatting").addItem("bold", {
    icon: (t = n == null ? void 0 : n.boldIcon) != null ? t : wse,
    active: (d) => d.get(pe).call(ja.key, yu.type(d)),
    onRun: (d) => {
      d.get(pe).call(K1.key);
    }
  }).addItem("italic", {
    icon: (r = n == null ? void 0 : n.italicIcon) != null ? r : Rse,
    active: (d) => d.get(pe).call(
      ja.key,
      Ca.type(d)
    ),
    onRun: (d) => {
      d.get(pe).call(G1.key);
    }
  }).addItem("strikethrough", {
    icon: (i = n == null ? void 0 : n.strikethroughIcon) != null ? i : _se,
    active: (d) => d.get(pe).call(
      ja.key,
      xu.type(d)
    ),
    onRun: (d) => {
      d.get(pe).call(tg.key);
    }
  });
  const u = c.addGroup("function", "Function");
  u.addItem("code", {
    icon: (s = n == null ? void 0 : n.codeIcon) != null ? s : bD,
    active: (d) => d.get(pe).call(
      ja.key,
      _s.type(d)
    ),
    onRun: (d) => {
      d.get(pe).call(Y1.key);
    }
  });
  const h = e && Tg(e).get();
  return (h == null ? void 0 : h.includes(st.Latex)) && u.addItem("latex", {
    icon: (o = n == null ? void 0 : n.latexIcon) != null ? o : xD,
    active: (d) => d.get(pe).call(
      $A.key,
      Qf.type(d)
    ),
    onRun: (d) => {
      d.get(pe).call(RD.key);
    }
  }), u.addItem("link", {
    icon: (l = n == null ? void 0 : n.linkIcon) != null ? l : Pse,
    active: (d) => d.get(pe).call(ja.key, xi.type(d)),
    onRun: (d) => {
      d.get(pe).call(UI.key);
    }
  }), (a = n == null ? void 0 : n.buildToolbar) == null || a.call(n, c), c.build();
}
const Coe = Xt({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    selection: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup(n) {
    const { ctx: e, config: t } = n, r = (o) => (l) => {
      l.preventDefault(), e && o(e);
    };
    function i(o) {
      return n.selection.value, e.get(t5).status !== Bm.Created ? !1 : o(e);
    }
    const s = sa(() => Soe(t, e));
    return () => /* @__PURE__ */ V(xa, null, s.value.map((o) => o.items.map((l) => /* @__PURE__ */ V(
      "button",
      {
        type: "button",
        class: bn(
          "toolbar-item",
          e && i(l.active) && "active"
        ),
        onPointerdown: r(l.onRun)
      },
      /* @__PURE__ */ V(tu, { icon: l.icon })
    ))).reduce((o, l, a) => (a === 0 ? o.push(...l) : o.push(/* @__PURE__ */ V("div", { class: "divider" }), ...l), o), []));
  }
});
var BD = (n) => {
  throw TypeError(n);
}, zD = (n, e, t) => e.has(n) || BD("Cannot " + t), br = (n, e, t) => (zD(n, e, "read from private field"), t ? t.call(n) : e.get(n)), ih = (n, e, t) => e.has(n) ? BD("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), lp = (n, e, t, r) => (zD(n, e, "write to private field"), e.set(n, t), t), vo, _h, lm, Fh, Hh;
const l9 = wg("CREPE_TOOLBAR");
class Moe {
  constructor(e, t, r) {
    ih(this, vo), ih(this, _h), ih(this, lm), ih(this, Fh), ih(this, Hh, ce(!1)), this.update = (o, l) => {
      br(this, vo).update(o, l), br(this, Fh).value = o.state.selection;
    }, this.destroy = () => {
      br(this, vo).destroy(), br(this, lm).unmount(), br(this, _h).remove();
    }, this.hide = () => {
      br(this, vo).hide();
    };
    const i = document.createElement("div");
    i.className = "milkdown-toolbar", lp(this, Fh, cm(t.state.selection));
    const s = oi(Coe, {
      ctx: e,
      hide: this.hide,
      config: r,
      selection: br(this, Fh),
      show: br(this, Hh)
    });
    s.mount(i), lp(this, _h, i), lp(this, lm, s), lp(this, vo, new vg({
      content: br(this, _h),
      debounce: 20,
      offset: 10,
      shouldShow(o) {
        const { doc: l, selection: a } = o.state, { empty: c, from: u, to: h } = a, f = !l.textBetween(u, h).length && a instanceof ge, d = !(a instanceof ge), p = o.dom.getRootNode().activeElement, m = i.contains(p), g = !o.hasFocus() && !m, b = !o.editable;
        return !(g || d || c || f || b);
      }
    })), br(this, vo).onShow = () => {
      br(this, Hh).value = !0;
    }, br(this, vo).onHide = () => {
      br(this, Hh).value = !1;
    }, this.update(t);
  }
}
vo = /* @__PURE__ */ new WeakMap();
_h = /* @__PURE__ */ new WeakMap();
lm = /* @__PURE__ */ new WeakMap();
Fh = /* @__PURE__ */ new WeakMap();
Hh = /* @__PURE__ */ new WeakMap();
const Toe = (n, e) => {
  n.config(ps(st.Toolbar)).config((t) => {
    t.set(l9.key, {
      view: (r) => new Moe(t, r, e)
    });
  }).use(l9);
};
function Aoe(n, e, t) {
  switch (n) {
    case st.CodeMirror:
      return noe(e, t);
    case st.ListItem:
      return yoe(e, t);
    case st.LinkTooltip:
      return moe(e, t);
    case st.ImageBlock:
      return ioe(e, t);
    case st.Cursor:
      return roe(e, t);
    case st.BlockEdit:
      return toe(e, t);
    case st.Placeholder:
      return xoe(e, t);
    case st.Toolbar:
      return Toe(e, t);
    case st.Table:
      return koe(e, t);
    case st.Latex:
      return doe(e, t);
  }
}
var _D = (n) => {
  throw TypeError(n);
}, FD = (n, e, t) => e.has(n) || _D("Cannot " + t), vr = (n, e, t) => (FD(n, e, "read from private field"), t ? t.call(n) : e.get(n)), b4 = (n, e, t) => e.has(n) ? _D("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), v4 = (n, e, t, r) => (FD(n, e, "write to private field"), e.set(n, t), t), wr, am, $h;
class Ooe {
  /// The constructor of the crepe builder.
  /// You can pass configs to the builder to configure the editor.
  constructor({ root: e, defaultValue: t = "" } = {}) {
    b4(this, wr), b4(this, am), b4(this, $h, !0), this.addFeature = (i, s) => (i(vr(this, wr), s), this), this.create = () => vr(this, wr).create(), this.destroy = () => vr(this, wr).destroy(), this.setReadonly = (i) => (v4(this, $h, !i), vr(this, wr).action((s) => {
      vr(this, wr).status === Bm.Created && s.get(pt).setProps({
        editable: () => !i
      });
    }), this), this.getMarkdown = () => vr(this, wr).action(LU()), this.on = (i) => vr(this, wr).status !== Bm.Created ? (vr(this, wr).config((s) => {
      const o = s.get(r1);
      i(o);
    }), this) : (vr(this, wr).action((s) => {
      const o = s.get(r1);
      i(o);
    }), this);
    var r;
    v4(this, am, (r = typeof e == "string" ? document.querySelector(e) : e) != null ? r : document.body), v4(this, wr, i5.make().config((i) => {
      i.inject(Wse, this), i.inject(qse, []);
    }).config((i) => {
      i.set(zp, vr(this, am)), i.set(Pp, t), i.set(uf, {
        editable: () => vr(this, $h)
      }), i.update(Mg.key, (s) => ({
        ...s,
        size: 4
      }));
    }).use(XG).use(pD).use(hse).use(dse).use(mse).use(uD).use(HX));
  }
  /// Get the milkdown editor instance.
  get editor() {
    return vr(this, wr);
  }
  /// Get the readonly state of the editor.
  get readonly() {
    return !vr(this, $h);
  }
}
wr = /* @__PURE__ */ new WeakMap();
am = /* @__PURE__ */ new WeakMap();
$h = /* @__PURE__ */ new WeakMap();
class HD extends Ooe {
  /// The constructor of the crepe editor.
  /// You can pass configs to the editor to configure the editor.
  /// Calling the constructor will not create the editor, you need to call `create` to create the editor.
  constructor({
    features: e = {},
    featureConfigs: t = {},
    ...r
  } = {}) {
    super(r);
    const i = PP(t, Vse);
    Object.entries({
      ...gse,
      ...e
    }).filter(([, o]) => o).map(([o]) => o).forEach((o) => {
      const l = i[o];
      Aoe(o, this.editor, l);
    });
  }
}
HD.Feature = st;
class Eoe {
  constructor(e, t, r) {
    this.rootElemId = e, this.firstLoad = !0, this.editor = new HD({
      root: document.getElementById(e),
      defaultValue: t
    }), this.editor.on((i) => {
      i.markdownUpdated(() => {
        !this.firstLoad && r.callbacks.afterContentChange ? r.callbacks.afterContentChange(this) : this.firstLoad = !1;
      });
    }), this.editor.create().then(() => {
      r.callbacks.afterRender && r.callbacks.afterRender(this), console.log("[mdnotes] Crepe editor created!");
    });
  }
  getMarkdownContent() {
    return this.editor.getMarkdown();
  }
  getScrollTop() {
    return document.getElementById(this.rootElemId).parentElement.scrollTop;
  }
  setScrollTop(e) {
    let r = document.getElementById(this.rootElemId).parentElement;
    console.log("[mdnotes] Setting scrollTop value to ", e), r.scrollTo({
      top: e,
      left: 0,
      behavior: "smooth"
    });
  }
  gc() {
    this.editor.destroy();
  }
}
const Ioe = { class: "endericedragon-sticky-buttons" }, Doe = /* @__PURE__ */ Xt({
  __name: "EditorModal",
  setup(n) {
    const e = ce(""), t = ce(""), r = ce(!1), i = ce(0), s = ce(!1), o = ce(!1), l = sa(() => s.value ? `${e.value}*` : e.value), a = ce(null);
    Td(() => {
      window.addEventListener(x4.showEditor, c);
    }), l1(() => {
      window.removeEventListener(x4.showEditor, c);
    });
    function c(m) {
      let g = m.detail, b = g.content, w = g.rel_file_path;
      e.value !== w && (e.value = w, i.value = 0), t.value = b, r.value = !0;
    }
    function u() {
      var g;
      const m = (g = a.value) == null ? void 0 : g.getMarkdownContent();
      m !== t.value && (t.value = m, f9(
        Yl,
        u9.saveContent,
        new h9(
          m,
          e.value
        )
      ).then((b) => {
        Yl.extensionManager.toast.add({
          severity: "success",
          summary: "MDNotes",
          detail: "Note is saved!",
          life: 2e3
        });
      }));
    }
    class h {
      static ok() {
        o.value = !0, r.value = !1;
      }
      static cancel() {
        r.value = !1;
      }
    }
    function f() {
      s.value = !1, o.value = !1, a.value = new Eoe(
        "mde-point",
        t.value,
        {
          // cdnURL: comfyApp.extensionManager.setting.get(OPTIONS.cdnSwitch) as string,
          callbacks: {
            afterRender: (m) => {
              m.setScrollTop(i.value);
            },
            afterContentChange: (m) => {
              s.value = !0, Yl.extensionManager.setting.get(k4.saveOnClose) && (o.value = !0);
            }
          }
        }
      );
    }
    function d() {
      var m;
      o.value && u(), (m = a.value) == null || m.gc();
    }
    function p() {
      var m;
      i.value = (m = a.value) == null ? void 0 : m.getScrollTop();
    }
    return (m, g) => (c9(), a9(Og(YD), {
      visible: r.value,
      "onUpdate:visible": g[0] || (g[0] = (b) => r.value = b),
      onShow: f,
      onHide: p,
      onAfterHide: d,
      header: l.value,
      "close-on-escape": ""
    }, {
      default: Eg(() => [
        g[3] || (g[3] = h0("div", { id: "mde-point" }, null, -1)),
        h0("div", Ioe, [
          vv(Og(wv), {
            severity: "danger",
            onClick: h.cancel
          }, {
            default: Eg(() => [...g[1] || (g[1] = [
              h0("i", { class: "bi bi-x-circle" }, null, -1)
            ])]),
            _: 1
          }, 8, ["onClick"]),
          vv(Og(wv), {
            severity: "success",
            onClick: h.ok
          }, {
            default: Eg(() => [...g[2] || (g[2] = [
              h0("i", { class: "bi bi-check2-circle" }, null, -1)
            ])]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      _: 1
    }, 8, ["visible", "header"]));
  }
}), Noe = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, i] of e)
    t[r] = i;
  return t;
}, Roe = /* @__PURE__ */ Noe(Doe, [["__scopeId", "data-v-43b1fb58"]]), Poe = /* @__PURE__ */ Xt({
  __name: "App",
  setup(n) {
    return (e, t) => (c9(), a9(Roe, {
      onKeydown: t[0] || (t[0] = jD(() => {
      }, ["stop"]))
    }));
  }
}), Loe = "extensions/comfyui-mdnotes/assets/main.css";
KD.addStylesheet(Loe);
const w4 = "3.11.2", ap = {
  npmmirror: `https://registry.npmmirror.com/vditor/${w4}/files`,
  jsDelivr: `https://cdn.jsdelivr.net/npm/vditor@${w4}`,
  unpkg: `https://unpkg.com/vditor@${w4}`
};
Yl.registerExtension({
  name: "endericedragon.comfyui-mdnotes",
  settings: [
    {
      id: k4.saveOnClose,
      name: "Always save on close?",
      type: "boolean",
      defaultValue: !1
    },
    {
      id: k4.cdnSwitch,
      name: "CDN for vditor",
      type: "combo",
      defaultValue: ap.unpkg,
      options: [
        { text: "unpkg", value: ap.unpkg },
        { text: "jsDelivr", value: ap.jsDelivr },
        { text: "npmmirror", value: ap.npmmirror }
      ]
    }
  ],
  async beforeRegisterNodeDef(n, e, t) {
    let r = n.prototype.getExtraMenuOptions;
    n.prototype.getExtraMenuOptions = function(i, s) {
      r == null || r.apply(this, arguments);
      let o = this.widgets.find((u) => u.name === "ckpt_name"), l = this.widgets.filter((u) => u.name.includes("lora") && u.name.includes("name")), a = [];
      function c(u, h) {
        f9(Yl, u9.sendCurrentModel, { model_type: h, model_path: u }).then((f) => {
          let d = f.content, p = f.rel_file_path;
          window.dispatchEvent(new CustomEvent(x4.showEditor, {
            detail: new h9(d, p)
          }));
        });
      }
      if (o) {
        const u = o.value;
        a.push({
          content: "Show note of checkpoint",
          callback: () => {
            c(u, S4.CKPT);
          }
        });
      }
      for (let [u, h] of l.entries()) {
        const f = h.value;
        f !== "None" && a.push({
          content: `Show note of lora${u + 1}`,
          callback: () => {
            c(f, S4.LORA);
          }
        });
      }
      return s.unshift(...a), s;
    };
  },
  async setup() {
    let n = document.createElement("div");
    n.id = "mdnotes-ui", document.body.appendChild(n), oi(Poe).use(UD).mount(n);
  }
});
export {
  El as A,
  Ct as B,
  OE as C,
  H as D,
  de as E,
  my as F,
  H_ as G,
  BP as H,
  Et as I,
  n_ as J,
  s_ as L,
  Voe as N,
  B9 as P,
  qr as T,
  py as a,
  ile as b,
  Qoe as c,
  ZQ as d,
  yn as e,
  g_ as f,
  Xoe as g,
  Zoe as h,
  yC as i,
  ele as j,
  sle as k,
  G as l,
  Nr as m,
  We as n,
  J5 as o,
  Woe as p,
  mt as q,
  m_ as r,
  Xz as s,
  j as t,
  el as u,
  du as v,
  Gr as w,
  mC as x,
  fu as y,
  y1 as z
};
