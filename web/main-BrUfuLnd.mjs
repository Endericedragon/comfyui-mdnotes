var rk = (n) => {
  throw TypeError(n);
};
var Yy = (n, e, t) => e.has(n) || rk("Cannot " + t);
var G = (n, e, t) => (Yy(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Se = (n, e, t) => e.has(n) ? rk("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), re = (n, e, t, r) => (Yy(n, e, "write to private field"), r ? r.call(n, t) : e.set(n, t), t), Cp = (n, e, t) => (Yy(n, e, "access private method"), t);
import { ref as Be, computed as Qa, h as te, defineComponent as Xn, Fragment as Rc, createApp as ns, watchEffect as Ch, watch as hw, onMounted as R0, onUnmounted as k1, shallowRef as Sg, createBlock as JC, openBlock as YC, unref as Yc, withCtx as Xy, createElementVNode as Mp, createVNode as ik, withModifiers as j_ } from "vue";
import W_ from "primevue/config";
import { app as U_ } from "../../../scripts/app.js";
import * as K_ from "../../../scripts/utils.js";
import { Dialog as G_, Button as sk } from "primevue";
const Ci = U_, fw = {
  sendCurrentModel: "/mdnotes/current_model",
  saveContent: "/mdnotes/save",
  setCDN: "/mdnotes/setCDN"
}, q2 = {
  showEditor: "endericedragon-show-editor"
}, Uo = {
  saveOnClose: "comfyui-mdnotes.savingOptions.saveOnClose",
  editorSwitch: "comfyui-mdnotes.markdownEditor.editorSwitch",
  cdnSwitch: "comfyui-mdnotes.markdownEditor.cdnSwitch",
  useLocalCDN: "comfyui-mdnotes.markdownEditor.useLocalCDN"
}, mu = {
  npmmirror: "https://registry.npmmirror.com/vditor/3.11.2/files",
  jsDelivr: "https://cdn.jsdelivr.net/npm/vditor@3.11.2",
  unpkg: "https://unpkg.com/vditor@3.11.2",
  localCachedCDN: "mdnotes"
};
var Ks = /* @__PURE__ */ ((n) => (n[n.vditor = 0] = "vditor", n[n.milkdown = 1] = "milkdown", n))(Ks || {}), $2 = /* @__PURE__ */ ((n) => (n.CKPT = "ckpt", n.LORA = "lora", n.UNKNOWN = "unknown", n))($2 || {});
class XC {
  constructor(e, t) {
    this.content = e, this.rel_file_path = t;
  }
  toJSON() {
    return {
      content: this.content,
      rel_file_path: this.rel_file_path
    };
  }
}
async function ZC(n, e, t) {
  return n.api.fetchApi(e, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(t)
  }).then((r) => {
    switch (r.status) {
      case 201:
        Ci.extensionManager.toast.add({
          severity: "warn",
          summary: "MDNotes Warning",
          detail: "Note not found, ready to create one",
          life: 3e3
        });
      case 200:
        return r.json();
      default:
        return Ci.extensionManager.toast.add({
          severity: "error",
          summary: "MDNotes Error",
          detail: `Status code = ${r.status}`,
          life: 3e3
        }), Promise.reject(r.status);
    }
  });
}
async function J_(n, e, t) {
  return n.api.fetchApi(e, {
    method: "POST",
    headers: { "Content-Type": "text/plain" },
    body: t
  }).then((r) => {
    switch (r.status) {
      case 200:
        return r.text();
      default:
        return Ci.extensionManager.toast.add({
          severity: "error",
          summary: "MDNotes Error",
          detail: `Status code = ${r.status}`,
          life: 3e3
        }), Promise.reject(r.status);
    }
  });
}
function Y_() {
  const n = Be(""), e = Be(""), t = Be(!1), r = Be(0), i = Be(!1), s = Be(!1), o = Qa(() => i.value ? `${n.value}*` : n.value), a = Qa(() => Ci.extensionManager.setting.get(Uo.useLocalCDN) ? (J_(Ci, fw.setCDN, Ci.extensionManager.setting.get(Uo.cdnSwitch)).then(), mu.localCachedCDN) : Ci.extensionManager.setting.get(Uo.cdnSwitch));
  return {
    notePath: n,
    mdContent: e,
    isModalShown: t,
    scrollTopVal: r,
    unsaveMark: i,
    needSaving: s,
    dialogTitle: o,
    cdnToUse: a
  };
}
function QC(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var xm = { exports: {} };
/*!
 * Vditor v3.11.2 - A markdown editor written in TypeScript.
 *
 * MIT License
 *
 * Copyright (c) 2018-present B3log 开源, b3log.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */
var X_ = xm.exports, ok;
function Z_() {
  return ok || (ok = 1, function(n, e) {
    (function(r, i) {
      n.exports = i();
    })(X_, function() {
      return (
        /******/
        (() => {
          var t = {
            /***/
            173: (
              /***/
              (o) => {
                var a = function() {
                  this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = 0.5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = 0.5, this.Patch_Margin = 4, this.Match_MaxBits = 32;
                }, l = -1, c = 1, u = 0;
                a.Diff = function(h, f) {
                  return [h, f];
                }, a.prototype.diff_main = function(h, f, m, y) {
                  typeof y > "u" && (this.Diff_Timeout <= 0 ? y = Number.MAX_VALUE : y = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3);
                  var b = y;
                  if (h == null || f == null)
                    throw new Error("Null input. (diff_main)");
                  if (h == f)
                    return h ? [new a.Diff(u, h)] : [];
                  typeof m > "u" && (m = !0);
                  var k = m, x = this.diff_commonPrefix(h, f), M = h.substring(0, x);
                  h = h.substring(x), f = f.substring(x), x = this.diff_commonSuffix(h, f);
                  var T = h.substring(h.length - x);
                  h = h.substring(0, h.length - x), f = f.substring(0, f.length - x);
                  var E = this.diff_compute_(h, f, k, b);
                  return M && E.unshift(new a.Diff(u, M)), T && E.push(new a.Diff(u, T)), this.diff_cleanupMerge(E), E;
                }, a.prototype.diff_compute_ = function(h, f, m, y) {
                  var b;
                  if (!h)
                    return [new a.Diff(c, f)];
                  if (!f)
                    return [new a.Diff(l, h)];
                  var k = h.length > f.length ? h : f, x = h.length > f.length ? f : h, M = k.indexOf(x);
                  if (M != -1)
                    return b = [new a.Diff(c, k.substring(0, M)), new a.Diff(u, x), new a.Diff(c, k.substring(M + x.length))], h.length > f.length && (b[0][0] = b[2][0] = l), b;
                  if (x.length == 1)
                    return [new a.Diff(l, h), new a.Diff(c, f)];
                  var T = this.diff_halfMatch_(h, f);
                  if (T) {
                    var E = T[0], C = T[1], O = T[2], R = T[3], F = T[4], H = this.diff_main(E, O, m, y), z = this.diff_main(C, R, m, y);
                    return H.concat([new a.Diff(u, F)], z);
                  }
                  return m && h.length > 100 && f.length > 100 ? this.diff_lineMode_(h, f, y) : this.diff_bisect_(h, f, y);
                }, a.prototype.diff_lineMode_ = function(h, f, m) {
                  var y = this.diff_linesToChars_(h, f);
                  h = y.chars1, f = y.chars2;
                  var b = y.lineArray, k = this.diff_main(h, f, !1, m);
                  this.diff_charsToLines_(k, b), this.diff_cleanupSemantic(k), k.push(new a.Diff(u, ""));
                  for (var x = 0, M = 0, T = 0, E = "", C = ""; x < k.length; ) {
                    switch (k[x][0]) {
                      case c:
                        T++, C += k[x][1];
                        break;
                      case l:
                        M++, E += k[x][1];
                        break;
                      case u:
                        if (M >= 1 && T >= 1) {
                          k.splice(x - M - T, M + T), x = x - M - T;
                          for (var O = this.diff_main(E, C, !1, m), R = O.length - 1; R >= 0; R--)
                            k.splice(x, 0, O[R]);
                          x = x + O.length;
                        }
                        T = 0, M = 0, E = "", C = "";
                        break;
                    }
                    x++;
                  }
                  return k.pop(), k;
                }, a.prototype.diff_bisect_ = function(h, f, m) {
                  for (var y = h.length, b = f.length, k = Math.ceil((y + b) / 2), x = k, M = 2 * k, T = new Array(M), E = new Array(M), C = 0; C < M; C++)
                    T[C] = -1, E[C] = -1;
                  T[x + 1] = 0, E[x + 1] = 0;
                  for (var O = y - b, R = O % 2 != 0, F = 0, H = 0, z = 0, K = 0, U = 0; U < k && !((/* @__PURE__ */ new Date()).getTime() > m); U++) {
                    for (var ae = -U + F; ae <= U - H; ae += 2) {
                      var ie = x + ae, he;
                      ae == -U || ae != U && T[ie - 1] < T[ie + 1] ? he = T[ie + 1] : he = T[ie - 1] + 1;
                      for (var Ie = he - ae; he < y && Ie < b && h.charAt(he) == f.charAt(Ie); )
                        he++, Ie++;
                      if (T[ie] = he, he > y)
                        H += 2;
                      else if (Ie > b)
                        F += 2;
                      else if (R) {
                        var Oe = x + O - ae;
                        if (Oe >= 0 && Oe < M && E[Oe] != -1) {
                          var Ne = y - E[Oe];
                          if (he >= Ne)
                            return this.diff_bisectSplit_(h, f, he, Ie, m);
                        }
                      }
                    }
                    for (var We = -U + z; We <= U - K; We += 2) {
                      var Oe = x + We, Ne;
                      We == -U || We != U && E[Oe - 1] < E[Oe + 1] ? Ne = E[Oe + 1] : Ne = E[Oe - 1] + 1;
                      for (var q = Ne - We; Ne < y && q < b && h.charAt(y - Ne - 1) == f.charAt(b - q - 1); )
                        Ne++, q++;
                      if (E[Oe] = Ne, Ne > y)
                        K += 2;
                      else if (q > b)
                        z += 2;
                      else if (!R) {
                        var ie = x + O - We;
                        if (ie >= 0 && ie < M && T[ie] != -1) {
                          var he = T[ie], Ie = x + he - ie;
                          if (Ne = y - Ne, he >= Ne)
                            return this.diff_bisectSplit_(h, f, he, Ie, m);
                        }
                      }
                    }
                  }
                  return [new a.Diff(l, h), new a.Diff(c, f)];
                }, a.prototype.diff_bisectSplit_ = function(h, f, m, y, b) {
                  var k = h.substring(0, m), x = f.substring(0, y), M = h.substring(m), T = f.substring(y), E = this.diff_main(k, x, !1, b), C = this.diff_main(M, T, !1, b);
                  return E.concat(C);
                }, a.prototype.diff_linesToChars_ = function(h, f) {
                  var m = [], y = {};
                  m[0] = "";
                  function b(T) {
                    for (var E = "", C = 0, O = -1, R = m.length; O < T.length - 1; ) {
                      O = T.indexOf(`
`, C), O == -1 && (O = T.length - 1);
                      var F = T.substring(C, O + 1);
                      (y.hasOwnProperty ? y.hasOwnProperty(F) : y[F] !== void 0) ? E += String.fromCharCode(y[F]) : (R == k && (F = T.substring(C), O = T.length), E += String.fromCharCode(R), y[F] = R, m[R++] = F), C = O + 1;
                    }
                    return E;
                  }
                  var k = 4e4, x = b(h);
                  k = 65535;
                  var M = b(f);
                  return {
                    chars1: x,
                    chars2: M,
                    lineArray: m
                  };
                }, a.prototype.diff_charsToLines_ = function(h, f) {
                  for (var m = 0; m < h.length; m++) {
                    for (var y = h[m][1], b = [], k = 0; k < y.length; k++)
                      b[k] = f[y.charCodeAt(k)];
                    h[m][1] = b.join("");
                  }
                }, a.prototype.diff_commonPrefix = function(h, f) {
                  if (!h || !f || h.charAt(0) != f.charAt(0))
                    return 0;
                  for (var m = 0, y = Math.min(h.length, f.length), b = y, k = 0; m < b; )
                    h.substring(k, b) == f.substring(k, b) ? (m = b, k = m) : y = b, b = Math.floor((y - m) / 2 + m);
                  return b;
                }, a.prototype.diff_commonSuffix = function(h, f) {
                  if (!h || !f || h.charAt(h.length - 1) != f.charAt(f.length - 1))
                    return 0;
                  for (var m = 0, y = Math.min(h.length, f.length), b = y, k = 0; m < b; )
                    h.substring(h.length - b, h.length - k) == f.substring(f.length - b, f.length - k) ? (m = b, k = m) : y = b, b = Math.floor((y - m) / 2 + m);
                  return b;
                }, a.prototype.diff_commonOverlap_ = function(h, f) {
                  var m = h.length, y = f.length;
                  if (m == 0 || y == 0)
                    return 0;
                  m > y ? h = h.substring(m - y) : m < y && (f = f.substring(0, m));
                  var b = Math.min(m, y);
                  if (h == f)
                    return b;
                  for (var k = 0, x = 1; ; ) {
                    var M = h.substring(b - x), T = f.indexOf(M);
                    if (T == -1)
                      return k;
                    x += T, (T == 0 || h.substring(b - x) == f.substring(0, x)) && (k = x, x++);
                  }
                }, a.prototype.diff_halfMatch_ = function(h, f) {
                  if (this.Diff_Timeout <= 0)
                    return null;
                  var m = h.length > f.length ? h : f, y = h.length > f.length ? f : h;
                  if (m.length < 4 || y.length * 2 < m.length)
                    return null;
                  var b = this;
                  function k(H, z, K) {
                    for (var U = H.substring(K, K + Math.floor(H.length / 4)), ae = -1, ie = "", he, Ie, Oe, Ne; (ae = z.indexOf(U, ae + 1)) != -1; ) {
                      var We = b.diff_commonPrefix(H.substring(K), z.substring(ae)), q = b.diff_commonSuffix(H.substring(0, K), z.substring(0, ae));
                      ie.length < q + We && (ie = z.substring(ae - q, ae) + z.substring(ae, ae + We), he = H.substring(0, K - q), Ie = H.substring(K + We), Oe = z.substring(0, ae - q), Ne = z.substring(ae + We));
                    }
                    return ie.length * 2 >= H.length ? [he, Ie, Oe, Ne, ie] : null;
                  }
                  var x = k(m, y, Math.ceil(m.length / 4)), M = k(m, y, Math.ceil(m.length / 2)), T;
                  if (!x && !M)
                    return null;
                  M ? x ? T = x[4].length > M[4].length ? x : M : T = M : T = x;
                  var E, C, O, R;
                  h.length > f.length ? (E = T[0], C = T[1], O = T[2], R = T[3]) : (O = T[0], R = T[1], E = T[2], C = T[3]);
                  var F = T[4];
                  return [E, C, O, R, F];
                }, a.prototype.diff_cleanupSemantic = function(h) {
                  for (var f = !1, m = [], y = 0, b = null, k = 0, x = 0, M = 0, T = 0, E = 0; k < h.length; )
                    h[k][0] == u ? (m[y++] = k, x = T, M = E, T = 0, E = 0, b = h[k][1]) : (h[k][0] == c ? T += h[k][1].length : E += h[k][1].length, b && b.length <= Math.max(x, M) && b.length <= Math.max(T, E) && (h.splice(m[y - 1], 0, new a.Diff(l, b)), h[m[y - 1] + 1][0] = c, y--, y--, k = y > 0 ? m[y - 1] : -1, x = 0, M = 0, T = 0, E = 0, b = null, f = !0)), k++;
                  for (f && this.diff_cleanupMerge(h), this.diff_cleanupSemanticLossless(h), k = 1; k < h.length; ) {
                    if (h[k - 1][0] == l && h[k][0] == c) {
                      var C = h[k - 1][1], O = h[k][1], R = this.diff_commonOverlap_(C, O), F = this.diff_commonOverlap_(O, C);
                      R >= F ? (R >= C.length / 2 || R >= O.length / 2) && (h.splice(k, 0, new a.Diff(u, O.substring(0, R))), h[k - 1][1] = C.substring(0, C.length - R), h[k + 1][1] = O.substring(R), k++) : (F >= C.length / 2 || F >= O.length / 2) && (h.splice(k, 0, new a.Diff(u, C.substring(0, F))), h[k - 1][0] = c, h[k - 1][1] = O.substring(0, O.length - F), h[k + 1][0] = l, h[k + 1][1] = C.substring(F), k++), k++;
                    }
                    k++;
                  }
                }, a.prototype.diff_cleanupSemanticLossless = function(h) {
                  function f(F, H) {
                    if (!F || !H)
                      return 6;
                    var z = F.charAt(F.length - 1), K = H.charAt(0), U = z.match(a.nonAlphaNumericRegex_), ae = K.match(a.nonAlphaNumericRegex_), ie = U && z.match(a.whitespaceRegex_), he = ae && K.match(a.whitespaceRegex_), Ie = ie && z.match(a.linebreakRegex_), Oe = he && K.match(a.linebreakRegex_), Ne = Ie && F.match(a.blanklineEndRegex_), We = Oe && H.match(a.blanklineStartRegex_);
                    return Ne || We ? 5 : Ie || Oe ? 4 : U && !ie && he ? 3 : ie || he ? 2 : U || ae ? 1 : 0;
                  }
                  for (var m = 1; m < h.length - 1; ) {
                    if (h[m - 1][0] == u && h[m + 1][0] == u) {
                      var y = h[m - 1][1], b = h[m][1], k = h[m + 1][1], x = this.diff_commonSuffix(y, b);
                      if (x) {
                        var M = b.substring(b.length - x);
                        y = y.substring(0, y.length - x), b = M + b.substring(0, b.length - x), k = M + k;
                      }
                      for (var T = y, E = b, C = k, O = f(y, b) + f(b, k); b.charAt(0) === k.charAt(0); ) {
                        y += b.charAt(0), b = b.substring(1) + k.charAt(0), k = k.substring(1);
                        var R = f(y, b) + f(b, k);
                        R >= O && (O = R, T = y, E = b, C = k);
                      }
                      h[m - 1][1] != T && (T ? h[m - 1][1] = T : (h.splice(m - 1, 1), m--), h[m][1] = E, C ? h[m + 1][1] = C : (h.splice(m + 1, 1), m--));
                    }
                    m++;
                  }
                }, a.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, a.whitespaceRegex_ = /\s/, a.linebreakRegex_ = /[\r\n]/, a.blanklineEndRegex_ = /\n\r?\n$/, a.blanklineStartRegex_ = /^\r?\n\r?\n/, a.prototype.diff_cleanupEfficiency = function(h) {
                  for (var f = !1, m = [], y = 0, b = null, k = 0, x = !1, M = !1, T = !1, E = !1; k < h.length; )
                    h[k][0] == u ? (h[k][1].length < this.Diff_EditCost && (T || E) ? (m[y++] = k, x = T, M = E, b = h[k][1]) : (y = 0, b = null), T = E = !1) : (h[k][0] == l ? E = !0 : T = !0, b && (x && M && T && E || b.length < this.Diff_EditCost / 2 && x + M + T + E == 3) && (h.splice(m[y - 1], 0, new a.Diff(l, b)), h[m[y - 1] + 1][0] = c, y--, b = null, x && M ? (T = E = !0, y = 0) : (y--, k = y > 0 ? m[y - 1] : -1, T = E = !1), f = !0)), k++;
                  f && this.diff_cleanupMerge(h);
                }, a.prototype.diff_cleanupMerge = function(h) {
                  h.push(new a.Diff(u, ""));
                  for (var f = 0, m = 0, y = 0, b = "", k = "", x; f < h.length; )
                    switch (h[f][0]) {
                      case c:
                        y++, k += h[f][1], f++;
                        break;
                      case l:
                        m++, b += h[f][1], f++;
                        break;
                      case u:
                        m + y > 1 ? (m !== 0 && y !== 0 && (x = this.diff_commonPrefix(k, b), x !== 0 && (f - m - y > 0 && h[f - m - y - 1][0] == u ? h[f - m - y - 1][1] += k.substring(0, x) : (h.splice(0, 0, new a.Diff(u, k.substring(0, x))), f++), k = k.substring(x), b = b.substring(x)), x = this.diff_commonSuffix(k, b), x !== 0 && (h[f][1] = k.substring(k.length - x) + h[f][1], k = k.substring(0, k.length - x), b = b.substring(0, b.length - x))), f -= m + y, h.splice(f, m + y), b.length && (h.splice(f, 0, new a.Diff(l, b)), f++), k.length && (h.splice(f, 0, new a.Diff(c, k)), f++), f++) : f !== 0 && h[f - 1][0] == u ? (h[f - 1][1] += h[f][1], h.splice(f, 1)) : f++, y = 0, m = 0, b = "", k = "";
                        break;
                    }
                  h[h.length - 1][1] === "" && h.pop();
                  var M = !1;
                  for (f = 1; f < h.length - 1; )
                    h[f - 1][0] == u && h[f + 1][0] == u && (h[f][1].substring(h[f][1].length - h[f - 1][1].length) == h[f - 1][1] ? (h[f][1] = h[f - 1][1] + h[f][1].substring(0, h[f][1].length - h[f - 1][1].length), h[f + 1][1] = h[f - 1][1] + h[f + 1][1], h.splice(f - 1, 1), M = !0) : h[f][1].substring(0, h[f + 1][1].length) == h[f + 1][1] && (h[f - 1][1] += h[f + 1][1], h[f][1] = h[f][1].substring(h[f + 1][1].length) + h[f + 1][1], h.splice(f + 1, 1), M = !0)), f++;
                  M && this.diff_cleanupMerge(h);
                }, a.prototype.diff_xIndex = function(h, f) {
                  var m = 0, y = 0, b = 0, k = 0, x;
                  for (x = 0; x < h.length && (h[x][0] !== c && (m += h[x][1].length), h[x][0] !== l && (y += h[x][1].length), !(m > f)); x++)
                    b = m, k = y;
                  return h.length != x && h[x][0] === l ? k : k + (f - b);
                }, a.prototype.diff_prettyHtml = function(h) {
                  for (var f = [], m = /&/g, y = /</g, b = />/g, k = /\n/g, x = 0; x < h.length; x++) {
                    var M = h[x][0], T = h[x][1], E = T.replace(m, "&amp;").replace(y, "&lt;").replace(b, "&gt;").replace(k, "&para;<br>");
                    switch (M) {
                      case c:
                        f[x] = '<ins style="background:#e6ffe6;">' + E + "</ins>";
                        break;
                      case l:
                        f[x] = '<del style="background:#ffe6e6;">' + E + "</del>";
                        break;
                      case u:
                        f[x] = "<span>" + E + "</span>";
                        break;
                    }
                  }
                  return f.join("");
                }, a.prototype.diff_text1 = function(h) {
                  for (var f = [], m = 0; m < h.length; m++)
                    h[m][0] !== c && (f[m] = h[m][1]);
                  return f.join("");
                }, a.prototype.diff_text2 = function(h) {
                  for (var f = [], m = 0; m < h.length; m++)
                    h[m][0] !== l && (f[m] = h[m][1]);
                  return f.join("");
                }, a.prototype.diff_levenshtein = function(h) {
                  for (var f = 0, m = 0, y = 0, b = 0; b < h.length; b++) {
                    var k = h[b][0], x = h[b][1];
                    switch (k) {
                      case c:
                        m += x.length;
                        break;
                      case l:
                        y += x.length;
                        break;
                      case u:
                        f += Math.max(m, y), m = 0, y = 0;
                        break;
                    }
                  }
                  return f += Math.max(m, y), f;
                }, a.prototype.diff_toDelta = function(h) {
                  for (var f = [], m = 0; m < h.length; m++)
                    switch (h[m][0]) {
                      case c:
                        f[m] = "+" + encodeURI(h[m][1]);
                        break;
                      case l:
                        f[m] = "-" + h[m][1].length;
                        break;
                      case u:
                        f[m] = "=" + h[m][1].length;
                        break;
                    }
                  return f.join("	").replace(/%20/g, " ");
                }, a.prototype.diff_fromDelta = function(h, f) {
                  for (var m = [], y = 0, b = 0, k = f.split(/\t/g), x = 0; x < k.length; x++) {
                    var M = k[x].substring(1);
                    switch (k[x].charAt(0)) {
                      case "+":
                        try {
                          m[y++] = new a.Diff(c, decodeURI(M));
                        } catch {
                          throw new Error("Illegal escape in diff_fromDelta: " + M);
                        }
                        break;
                      case "-":
                      // Fall through.
                      case "=":
                        var T = parseInt(M, 10);
                        if (isNaN(T) || T < 0)
                          throw new Error("Invalid number in diff_fromDelta: " + M);
                        var E = h.substring(b, b += T);
                        k[x].charAt(0) == "=" ? m[y++] = new a.Diff(u, E) : m[y++] = new a.Diff(l, E);
                        break;
                      default:
                        if (k[x])
                          throw new Error("Invalid diff operation in diff_fromDelta: " + k[x]);
                    }
                  }
                  if (b != h.length)
                    throw new Error("Delta length (" + b + ") does not equal source text length (" + h.length + ").");
                  return m;
                }, a.prototype.match_main = function(h, f, m) {
                  if (h == null || f == null || m == null)
                    throw new Error("Null input. (match_main)");
                  return m = Math.max(0, Math.min(m, h.length)), h == f ? 0 : h.length ? h.substring(m, m + f.length) == f ? m : this.match_bitap_(h, f, m) : -1;
                }, a.prototype.match_bitap_ = function(h, f, m) {
                  if (f.length > this.Match_MaxBits)
                    throw new Error("Pattern too long for this browser.");
                  var y = this.match_alphabet_(f), b = this;
                  function k(he, Ie) {
                    var Oe = he / f.length, Ne = Math.abs(m - Ie);
                    return b.Match_Distance ? Oe + Ne / b.Match_Distance : Ne ? 1 : Oe;
                  }
                  var x = this.Match_Threshold, M = h.indexOf(f, m);
                  M != -1 && (x = Math.min(k(0, M), x), M = h.lastIndexOf(f, m + f.length), M != -1 && (x = Math.min(k(0, M), x)));
                  var T = 1 << f.length - 1;
                  M = -1;
                  for (var E, C, O = f.length + h.length, R, F = 0; F < f.length; F++) {
                    for (E = 0, C = O; E < C; )
                      k(F, m + C) <= x ? E = C : O = C, C = Math.floor((O - E) / 2 + E);
                    O = C;
                    var H = Math.max(1, m - C + 1), z = Math.min(m + C, h.length) + f.length, K = Array(z + 2);
                    K[z + 1] = (1 << F) - 1;
                    for (var U = z; U >= H; U--) {
                      var ae = y[h.charAt(U - 1)];
                      if (F === 0 ? K[U] = (K[U + 1] << 1 | 1) & ae : K[U] = (K[U + 1] << 1 | 1) & ae | ((R[U + 1] | R[U]) << 1 | 1) | R[U + 1], K[U] & T) {
                        var ie = k(F, U - 1);
                        if (ie <= x)
                          if (x = ie, M = U - 1, M > m)
                            H = Math.max(1, 2 * m - M);
                          else
                            break;
                      }
                    }
                    if (k(F + 1, m) > x)
                      break;
                    R = K;
                  }
                  return M;
                }, a.prototype.match_alphabet_ = function(h) {
                  for (var f = {}, m = 0; m < h.length; m++)
                    f[h.charAt(m)] = 0;
                  for (var m = 0; m < h.length; m++)
                    f[h.charAt(m)] |= 1 << h.length - m - 1;
                  return f;
                }, a.prototype.patch_addContext_ = function(h, f) {
                  if (f.length != 0) {
                    if (h.start2 === null)
                      throw Error("patch not initialized");
                    for (var m = f.substring(h.start2, h.start2 + h.length1), y = 0; f.indexOf(m) != f.lastIndexOf(m) && m.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin; )
                      y += this.Patch_Margin, m = f.substring(h.start2 - y, h.start2 + h.length1 + y);
                    y += this.Patch_Margin;
                    var b = f.substring(h.start2 - y, h.start2);
                    b && h.diffs.unshift(new a.Diff(u, b));
                    var k = f.substring(h.start2 + h.length1, h.start2 + h.length1 + y);
                    k && h.diffs.push(new a.Diff(u, k)), h.start1 -= b.length, h.start2 -= b.length, h.length1 += b.length + k.length, h.length2 += b.length + k.length;
                  }
                }, a.prototype.patch_make = function(h, f, m) {
                  var y, b;
                  if (typeof h == "string" && typeof f == "string" && typeof m > "u")
                    y = /** @type {string} */
                    h, b = this.diff_main(
                      y,
                      /** @type {string} */
                      f,
                      !0
                    ), b.length > 2 && (this.diff_cleanupSemantic(b), this.diff_cleanupEfficiency(b));
                  else if (h && typeof h == "object" && typeof f > "u" && typeof m > "u")
                    b = /** @type {!Array.<!diff_match_patch.Diff>} */
                    h, y = this.diff_text1(b);
                  else if (typeof h == "string" && f && typeof f == "object" && typeof m > "u")
                    y = /** @type {string} */
                    h, b = /** @type {!Array.<!diff_match_patch.Diff>} */
                    f;
                  else if (typeof h == "string" && typeof f == "string" && m && typeof m == "object")
                    y = /** @type {string} */
                    h, b = /** @type {!Array.<!diff_match_patch.Diff>} */
                    m;
                  else
                    throw new Error("Unknown call format to patch_make.");
                  if (b.length === 0)
                    return [];
                  for (var k = [], x = new a.patch_obj(), M = 0, T = 0, E = 0, C = y, O = y, R = 0; R < b.length; R++) {
                    var F = b[R][0], H = b[R][1];
                    switch (!M && F !== u && (x.start1 = T, x.start2 = E), F) {
                      case c:
                        x.diffs[M++] = b[R], x.length2 += H.length, O = O.substring(0, E) + H + O.substring(E);
                        break;
                      case l:
                        x.length1 += H.length, x.diffs[M++] = b[R], O = O.substring(0, E) + O.substring(E + H.length);
                        break;
                      case u:
                        H.length <= 2 * this.Patch_Margin && M && b.length != R + 1 ? (x.diffs[M++] = b[R], x.length1 += H.length, x.length2 += H.length) : H.length >= 2 * this.Patch_Margin && M && (this.patch_addContext_(x, C), k.push(x), x = new a.patch_obj(), M = 0, C = O, T = E);
                        break;
                    }
                    F !== c && (T += H.length), F !== l && (E += H.length);
                  }
                  return M && (this.patch_addContext_(x, C), k.push(x)), k;
                }, a.prototype.patch_deepCopy = function(h) {
                  for (var f = [], m = 0; m < h.length; m++) {
                    var y = h[m], b = new a.patch_obj();
                    b.diffs = [];
                    for (var k = 0; k < y.diffs.length; k++)
                      b.diffs[k] = new a.Diff(y.diffs[k][0], y.diffs[k][1]);
                    b.start1 = y.start1, b.start2 = y.start2, b.length1 = y.length1, b.length2 = y.length2, f[m] = b;
                  }
                  return f;
                }, a.prototype.patch_apply = function(h, f) {
                  if (h.length == 0)
                    return [f, []];
                  h = this.patch_deepCopy(h);
                  var m = this.patch_addPadding(h);
                  f = m + f + m, this.patch_splitMax(h);
                  for (var y = 0, b = [], k = 0; k < h.length; k++) {
                    var x = h[k].start2 + y, M = this.diff_text1(h[k].diffs), T, E = -1;
                    if (M.length > this.Match_MaxBits ? (T = this.match_main(f, M.substring(0, this.Match_MaxBits), x), T != -1 && (E = this.match_main(f, M.substring(M.length - this.Match_MaxBits), x + M.length - this.Match_MaxBits), (E == -1 || T >= E) && (T = -1))) : T = this.match_main(f, M, x), T == -1)
                      b[k] = !1, y -= h[k].length2 - h[k].length1;
                    else {
                      b[k] = !0, y = T - x;
                      var C;
                      if (E == -1 ? C = f.substring(T, T + M.length) : C = f.substring(T, E + this.Match_MaxBits), M == C)
                        f = f.substring(0, T) + this.diff_text2(h[k].diffs) + f.substring(T + M.length);
                      else {
                        var O = this.diff_main(M, C, !1);
                        if (M.length > this.Match_MaxBits && this.diff_levenshtein(O) / M.length > this.Patch_DeleteThreshold)
                          b[k] = !1;
                        else {
                          this.diff_cleanupSemanticLossless(O);
                          for (var R = 0, F, H = 0; H < h[k].diffs.length; H++) {
                            var z = h[k].diffs[H];
                            z[0] !== u && (F = this.diff_xIndex(O, R)), z[0] === c ? f = f.substring(0, T + F) + z[1] + f.substring(T + F) : z[0] === l && (f = f.substring(0, T + F) + f.substring(T + this.diff_xIndex(O, R + z[1].length))), z[0] !== l && (R += z[1].length);
                          }
                        }
                      }
                    }
                  }
                  return f = f.substring(m.length, f.length - m.length), [f, b];
                }, a.prototype.patch_addPadding = function(h) {
                  for (var f = this.Patch_Margin, m = "", y = 1; y <= f; y++)
                    m += String.fromCharCode(y);
                  for (var y = 0; y < h.length; y++)
                    h[y].start1 += f, h[y].start2 += f;
                  var b = h[0], k = b.diffs;
                  if (k.length == 0 || k[0][0] != u)
                    k.unshift(new a.Diff(u, m)), b.start1 -= f, b.start2 -= f, b.length1 += f, b.length2 += f;
                  else if (f > k[0][1].length) {
                    var x = f - k[0][1].length;
                    k[0][1] = m.substring(k[0][1].length) + k[0][1], b.start1 -= x, b.start2 -= x, b.length1 += x, b.length2 += x;
                  }
                  if (b = h[h.length - 1], k = b.diffs, k.length == 0 || k[k.length - 1][0] != u)
                    k.push(new a.Diff(u, m)), b.length1 += f, b.length2 += f;
                  else if (f > k[k.length - 1][1].length) {
                    var x = f - k[k.length - 1][1].length;
                    k[k.length - 1][1] += m.substring(0, x), b.length1 += x, b.length2 += x;
                  }
                  return m;
                }, a.prototype.patch_splitMax = function(h) {
                  for (var f = this.Match_MaxBits, m = 0; m < h.length; m++)
                    if (!(h[m].length1 <= f)) {
                      var y = h[m];
                      h.splice(m--, 1);
                      for (var b = y.start1, k = y.start2, x = ""; y.diffs.length !== 0; ) {
                        var M = new a.patch_obj(), T = !0;
                        for (M.start1 = b - x.length, M.start2 = k - x.length, x !== "" && (M.length1 = M.length2 = x.length, M.diffs.push(new a.Diff(u, x))); y.diffs.length !== 0 && M.length1 < f - this.Patch_Margin; ) {
                          var E = y.diffs[0][0], C = y.diffs[0][1];
                          E === c ? (M.length2 += C.length, k += C.length, M.diffs.push(y.diffs.shift()), T = !1) : E === l && M.diffs.length == 1 && M.diffs[0][0] == u && C.length > 2 * f ? (M.length1 += C.length, b += C.length, T = !1, M.diffs.push(new a.Diff(E, C)), y.diffs.shift()) : (C = C.substring(0, f - M.length1 - this.Patch_Margin), M.length1 += C.length, b += C.length, E === u ? (M.length2 += C.length, k += C.length) : T = !1, M.diffs.push(new a.Diff(E, C)), C == y.diffs[0][1] ? y.diffs.shift() : y.diffs[0][1] = y.diffs[0][1].substring(C.length));
                        }
                        x = this.diff_text2(M.diffs), x = x.substring(x.length - this.Patch_Margin);
                        var O = this.diff_text1(y.diffs).substring(0, this.Patch_Margin);
                        O !== "" && (M.length1 += O.length, M.length2 += O.length, M.diffs.length !== 0 && M.diffs[M.diffs.length - 1][0] === u ? M.diffs[M.diffs.length - 1][1] += O : M.diffs.push(new a.Diff(u, O))), T || h.splice(++m, 0, M);
                      }
                    }
                }, a.prototype.patch_toText = function(h) {
                  for (var f = [], m = 0; m < h.length; m++)
                    f[m] = h[m];
                  return f.join("");
                }, a.prototype.patch_fromText = function(h) {
                  var f = [];
                  if (!h)
                    return f;
                  for (var m = h.split(`
`), y = 0, b = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; y < m.length; ) {
                    var k = m[y].match(b);
                    if (!k)
                      throw new Error("Invalid patch string: " + m[y]);
                    var x = new a.patch_obj();
                    for (f.push(x), x.start1 = parseInt(k[1], 10), k[2] === "" ? (x.start1--, x.length1 = 1) : k[2] == "0" ? x.length1 = 0 : (x.start1--, x.length1 = parseInt(k[2], 10)), x.start2 = parseInt(k[3], 10), k[4] === "" ? (x.start2--, x.length2 = 1) : k[4] == "0" ? x.length2 = 0 : (x.start2--, x.length2 = parseInt(k[4], 10)), y++; y < m.length; ) {
                      var M = m[y].charAt(0);
                      try {
                        var T = decodeURI(m[y].substring(1));
                      } catch {
                        throw new Error("Illegal escape in patch_fromText: " + T);
                      }
                      if (M == "-")
                        x.diffs.push(new a.Diff(l, T));
                      else if (M == "+")
                        x.diffs.push(new a.Diff(c, T));
                      else if (M == " ")
                        x.diffs.push(new a.Diff(u, T));
                      else {
                        if (M == "@")
                          break;
                        if (M !== "") throw new Error('Invalid patch mode "' + M + '" in: ' + T);
                      }
                      y++;
                    }
                  }
                  return f;
                }, a.patch_obj = function() {
                  this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0;
                }, a.patch_obj.prototype.toString = function() {
                  var h, f;
                  this.length1 === 0 ? h = this.start1 + ",0" : this.length1 == 1 ? h = this.start1 + 1 : h = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? f = this.start2 + ",0" : this.length2 == 1 ? f = this.start2 + 1 : f = this.start2 + 1 + "," + this.length2;
                  for (var m = ["@@ -" + h + " +" + f + ` @@
`], y, b = 0; b < this.diffs.length; b++) {
                    switch (this.diffs[b][0]) {
                      case c:
                        y = "+";
                        break;
                      case l:
                        y = "-";
                        break;
                      case u:
                        y = " ";
                        break;
                    }
                    m[b + 1] = y + encodeURI(this.diffs[b][1]) + `
`;
                  }
                  return m.join("").replace(/%20/g, " ");
                }, o.exports = a, o.exports.diff_match_patch = a, o.exports.DIFF_DELETE = l, o.exports.DIFF_INSERT = c, o.exports.DIFF_EQUAL = u;
              }
            ),
            /***/
            408: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  default: () => (
                    /* binding */
                    mt
                  )
                });
                var c = l(135), u = l(840), h = l(775), f = l(428), m = l(325), y = l(483), b = l(999), k = function(le) {
                  le === void 0 && (le = document);
                  var tt = function(xe) {
                    var ge = document.createElement("img");
                    ge.src = xe.getAttribute("data-src"), ge.addEventListener("load", function() {
                      !xe.getAttribute("style") && !xe.getAttribute("class") && !xe.getAttribute("width") && !xe.getAttribute("height") && ge.naturalHeight > ge.naturalWidth && ge.naturalWidth / ge.naturalHeight < document.querySelector(".vditor-reset").clientWidth / (window.innerHeight - 40) && ge.naturalHeight > window.innerHeight - 40 && (xe.style.height = window.innerHeight - 40 + "px"), xe.src = ge.src;
                    }), xe.removeAttribute("data-src");
                  };
                  if (!("IntersectionObserver" in window))
                    return le.querySelectorAll("img").forEach(function(xe) {
                      xe.getAttribute("data-src") && tt(xe);
                    }), !1;
                  window.vditorImageIntersectionObserver ? (window.vditorImageIntersectionObserver.disconnect(), le.querySelectorAll("img").forEach(function(xe) {
                    window.vditorImageIntersectionObserver.observe(xe);
                  })) : (window.vditorImageIntersectionObserver = new IntersectionObserver(function(xe) {
                    xe.forEach(function(ge) {
                      (typeof ge.isIntersecting > "u" ? ge.intersectionRatio !== 0 : ge.isIntersecting) && ge.target.getAttribute("data-src") && tt(ge.target);
                    });
                  }), le.querySelectorAll("img").forEach(function(xe) {
                    window.vditorImageIntersectionObserver.observe(xe);
                  }));
                }, x = l(472), M = l(280), T = l(637), E = l(825), C = l(11), O = l(194), R = l(436), F = l(229), H = l(145), z = l(538), K = l(413), U = l(106), ae = l(673), ie = function(le) {
                  document.querySelectorAll(".vditor-anchor").forEach(function(tt) {
                    le === 1 && tt.classList.add("vditor-anchor--left"), tt.onclick = function() {
                      var xe = tt.getAttribute("href").substr(1), ge = document.getElementById("vditorAnchor-" + xe).offsetTop;
                      document.querySelector("html").scrollTop = ge;
                    };
                  }), window.onhashchange = function() {
                    var tt = document.getElementById("vditorAnchor-" + decodeURIComponent(window.location.hash.substr(1)));
                    tt && (document.querySelector("html").scrollTop = tt.offsetTop);
                  };
                }, he = l(214), Ie = l(810), Oe = function(le, tt) {
                  if (tt === void 0 && (tt = "zh_CN"), !(typeof speechSynthesis > "u" || typeof SpeechSynthesisUtterance > "u")) {
                    var xe = function() {
                      var Vt = speechSynthesis.getVoices(), Ue, yt;
                      return Vt.forEach(function(Ut) {
                        Ut.lang === tt.replace("_", "-") && (Ue = Ut), Ut.default && (yt = Ut);
                      }), Ue || (Ue = yt), Ue;
                    }, ge = '<svg><use xlink:href="#vditor-icon-play"></use></svg>', Ot = '<svg><use xlink:href="#vditor-icon-pause"></use></svg>';
                    document.getElementById("vditorIconScript") || (ge = '<svg viewBox="0 0 32 32"><path d="M3.436 0l25.128 16-25.128 16v-32z"></path></svg>', Ot = '<svg viewBox="0 0 32 32"><path d="M20.617 0h9.128v32h-9.128v-32zM2.255 32v-32h9.128v32h-9.128z"></path></svg>');
                    var Ee = document.querySelector(".vditor-speech");
                    Ee || (Ee = document.createElement("button"), Ee.className = "vditor-speech", le.insertAdjacentElement("beforeend", Ee), speechSynthesis.onvoiceschanged !== void 0 && (speechSynthesis.onvoiceschanged = xe));
                    var Ft = xe(), ft = new SpeechSynthesisUtterance();
                    ft.voice = Ft, ft.onend = ft.onerror = function() {
                      Ee.style.display = "none", speechSynthesis.cancel(), Ee.classList.remove("vditor-speech--current"), Ee.innerHTML = ge;
                    }, le.addEventListener(window.ontouchstart !== void 0 ? "touchend" : "click", function(Vt) {
                      var Ue = Vt.target;
                      if (Ue.classList.contains("vditor-speech") || Ue.parentElement.classList.contains("vditor-speech")) {
                        Ee.classList.contains("vditor-speech--current") ? speechSynthesis.speaking && (speechSynthesis.paused ? (speechSynthesis.resume(), Ee.innerHTML = Ot) : (speechSynthesis.pause(), Ee.innerHTML = ge)) : (ft.text = Ee.getAttribute("data-text"), speechSynthesis.speak(ft), Ee.classList.add("vditor-speech--current"), Ee.innerHTML = Ot), (0, Ie.Hc)(window.vditorSpeechRange), le.focus();
                        return;
                      }
                      if (Ee.style.display = "none", speechSynthesis.cancel(), Ee.classList.remove("vditor-speech--current"), Ee.innerHTML = ge, getSelection().rangeCount !== 0) {
                        var yt = getSelection().getRangeAt(0), Ut = yt.toString().trim();
                        if (Ut) {
                          window.vditorSpeechRange = yt.cloneRange();
                          var Kt = yt.getBoundingClientRect();
                          Ee.innerHTML = ge, Ee.style.display = "block", Ee.style.top = Kt.top + Kt.height + document.querySelector("html").scrollTop - 20 + "px", window.ontouchstart !== void 0 ? Ee.style.left = Vt.changedTouches[Vt.changedTouches.length - 1].pageX + 2 + "px" : Ee.style.left = Vt.clientX + 2 + "px", Ee.setAttribute("data-text", Ut);
                        }
                      }
                    });
                  }
                }, Ne = function(le, tt, xe, ge) {
                  function Ot(Ee) {
                    return Ee instanceof xe ? Ee : new xe(function(Ft) {
                      Ft(Ee);
                    });
                  }
                  return new (xe || (xe = Promise))(function(Ee, Ft) {
                    function ft(yt) {
                      try {
                        Ue(ge.next(yt));
                      } catch (Ut) {
                        Ft(Ut);
                      }
                    }
                    function Vt(yt) {
                      try {
                        Ue(ge.throw(yt));
                      } catch (Ut) {
                        Ft(Ut);
                      }
                    }
                    function Ue(yt) {
                      yt.done ? Ee(yt.value) : Ot(yt.value).then(ft, Vt);
                    }
                    Ue((ge = ge.apply(le, tt || [])).next());
                  });
                }, We = function(le, tt) {
                  var xe = { label: 0, sent: function() {
                    if (Ee[0] & 1) throw Ee[1];
                    return Ee[1];
                  }, trys: [], ops: [] }, ge, Ot, Ee, Ft;
                  return Ft = { next: ft(0), throw: ft(1), return: ft(2) }, typeof Symbol == "function" && (Ft[Symbol.iterator] = function() {
                    return this;
                  }), Ft;
                  function ft(Ue) {
                    return function(yt) {
                      return Vt([Ue, yt]);
                    };
                  }
                  function Vt(Ue) {
                    if (ge) throw new TypeError("Generator is already executing.");
                    for (; Ft && (Ft = 0, Ue[0] && (xe = 0)), xe; ) try {
                      if (ge = 1, Ot && (Ee = Ue[0] & 2 ? Ot.return : Ue[0] ? Ot.throw || ((Ee = Ot.return) && Ee.call(Ot), 0) : Ot.next) && !(Ee = Ee.call(Ot, Ue[1])).done) return Ee;
                      switch (Ot = 0, Ee && (Ue = [Ue[0] & 2, Ee.value]), Ue[0]) {
                        case 0:
                        case 1:
                          Ee = Ue;
                          break;
                        case 4:
                          return xe.label++, { value: Ue[1], done: !1 };
                        case 5:
                          xe.label++, Ot = Ue[1], Ue = [0];
                          continue;
                        case 7:
                          Ue = xe.ops.pop(), xe.trys.pop();
                          continue;
                        default:
                          if (Ee = xe.trys, !(Ee = Ee.length > 0 && Ee[Ee.length - 1]) && (Ue[0] === 6 || Ue[0] === 2)) {
                            xe = 0;
                            continue;
                          }
                          if (Ue[0] === 3 && (!Ee || Ue[1] > Ee[0] && Ue[1] < Ee[3])) {
                            xe.label = Ue[1];
                            break;
                          }
                          if (Ue[0] === 6 && xe.label < Ee[1]) {
                            xe.label = Ee[1], Ee = Ue;
                            break;
                          }
                          if (Ee && xe.label < Ee[2]) {
                            xe.label = Ee[2], xe.ops.push(Ue);
                            break;
                          }
                          Ee[2] && xe.ops.pop(), xe.trys.pop();
                          continue;
                      }
                      Ue = tt.call(le, xe);
                    } catch (yt) {
                      Ue = [6, yt], Ot = 0;
                    } finally {
                      ge = Ee = 0;
                    }
                    if (Ue[0] & 5) throw Ue[1];
                    return { value: Ue[0] ? Ue[1] : void 0, done: !0 };
                  }
                }, q = function(le) {
                  var tt, xe = {
                    anchor: 0,
                    cdn: H.g.CDN,
                    customEmoji: {},
                    emojiPath: "".concat(H.g.CDN, "/dist/images/emoji"),
                    hljs: H.g.HLJS_OPTIONS,
                    icon: "ant",
                    lang: "zh_CN",
                    markdown: H.g.MARKDOWN_OPTIONS,
                    math: H.g.MATH_OPTIONS,
                    mode: "light",
                    speech: {
                      enable: !1
                    },
                    render: {
                      media: {
                        enable: !0
                      }
                    },
                    theme: H.g.THEME_OPTIONS
                  };
                  return le.cdn && (!((tt = le.theme) === null || tt === void 0) && tt.path || (xe.theme.path = "".concat(le.cdn, "/dist/css/content-theme")), le.emojiPath || (xe.emojiPath = "".concat(le.cdn, "/dist/images/emoji"))), (0, ae.T)(xe, le);
                }, Re = function(le, tt) {
                  var xe = q(tt);
                  return (0, K.G)("".concat(xe.cdn, "/dist/js/lute/lute.min.js"), "vditorLuteScript").then(function() {
                    var ge = (0, he.X)({
                      autoSpace: xe.markdown.autoSpace,
                      gfmAutoLink: xe.markdown.gfmAutoLink,
                      codeBlockPreview: xe.markdown.codeBlockPreview,
                      emojiSite: xe.emojiPath,
                      emojis: xe.customEmoji,
                      fixTermTypo: xe.markdown.fixTermTypo,
                      footnotes: xe.markdown.footnotes,
                      headingAnchor: xe.anchor !== 0,
                      inlineMathDigit: xe.math.inlineDigit,
                      lazyLoadImage: xe.lazyLoadImage,
                      linkBase: xe.markdown.linkBase,
                      linkPrefix: xe.markdown.linkPrefix,
                      listStyle: xe.markdown.listStyle,
                      mark: xe.markdown.mark,
                      mathBlockPreview: xe.markdown.mathBlockPreview,
                      paragraphBeginningSpace: xe.markdown.paragraphBeginningSpace,
                      sanitize: xe.markdown.sanitize,
                      toc: xe.markdown.toc
                    });
                    return tt != null && tt.renderers && ge.SetJSRenderers({
                      renderers: {
                        Md2HTML: tt.renderers
                      }
                    }), ge.SetHeadingID(!0), ge.Md2HTML(le);
                  });
                }, J = function(le, tt, xe) {
                  return Ne(void 0, void 0, void 0, function() {
                    var ge, Ot, Ee, Ft;
                    return We(this, function(ft) {
                      switch (ft.label) {
                        case 0:
                          return ge = q(xe), [4, Re(tt, ge)];
                        case 1:
                          if (Ot = ft.sent(), ge.transform && (Ot = ge.transform(Ot)), le.innerHTML = Ot, le.classList.add("vditor-reset"), ge.i18n) return [3, 5];
                          if (["de_DE", "en_US", "es_ES", "fr_FR", "ja_JP", "ko_KR", "pt_BR", "ru_RU", "sv_SE", "vi_VN", "zh_CN", "zh_TW"].includes(ge.lang)) return [3, 2];
                          throw new Error("options.lang error, see https://ld246.com/article/1549638745630#options");
                        case 2:
                          return Ee = "vditorI18nScript", Ft = Ee + ge.lang, document.querySelectorAll('head script[id^="'.concat(Ee, '"]')).forEach(function(Vt) {
                            Vt.id !== Ft && document.head.removeChild(Vt);
                          }), [4, (0, K.G)("".concat(ge.cdn, "/dist/js/i18n/").concat(ge.lang, ".js"), Ft)];
                        case 3:
                          ft.sent(), ft.label = 4;
                        case 4:
                          return [3, 6];
                        case 5:
                          window.VditorI18n = ge.i18n, ft.label = 6;
                        case 6:
                          return ge.icon ? [4, (0, K.G)("".concat(ge.cdn, "/dist/js/icons/").concat(ge.icon, ".js"), "vditorIconScript")] : [3, 8];
                        case 7:
                          ft.sent(), ft.label = 8;
                        case 8:
                          return (0, z.Z)(ge.theme.current, ge.theme.path), ge.anchor === 1 && le.classList.add("vditor-reset--anchor"), (0, f.O)(le, ge.hljs), (0, b.s)(ge.hljs, le, ge.cdn), (0, x.H)(le, {
                            cdn: ge.cdn,
                            math: ge.math
                          }), (0, T.i)(le, ge.cdn, ge.mode), (0, E.J)(le, ge.cdn, ge.mode), (0, C.K)(le, ge.cdn), (0, m.P)(le, ge.cdn), (0, y.v)(le, ge.cdn), (0, h.p)(le, ge.cdn, ge.mode), (0, O.P)(le, ge.cdn, ge.mode), (0, F.B)(le, ge.cdn), (0, c.Q)(le, ge.cdn), ge.render.media.enable && (0, M.Y)(le), ge.speech.enable && Oe(le), ge.anchor !== 0 && ie(ge.anchor), ge.after && ge.after(), ge.lazyLoadImage && k(le), le.addEventListener("click", function(Vt) {
                            var Ue = (0, U.lG)(Vt.target, "SPAN");
                            if (Ue && (0, U.fb)(Ue, "vditor-toc")) {
                              var yt = le.querySelector("#" + Ue.getAttribute("data-target-id"));
                              yt && window.scrollTo(window.scrollX, yt.offsetTop);
                              return;
                            }
                          }), [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                }, V = l(190), _t = l(580), at = (
                  /** @class */
                  function() {
                    function le() {
                    }
                    return le.adapterRender = u, le.previewImage = V.E, le.codeRender = f.O, le.graphvizRender = y.v, le.highlightRender = b.s, le.mathRender = x.H, le.mermaidRender = T.i, le.SMILESRender = E.J, le.markmapRender = C.K, le.flowchartRender = m.P, le.chartRender = h.p, le.abcRender = c.Q, le.mindmapRender = O.P, le.plantumlRender = F.B, le.outlineRender = R.k, le.mediaRender = M.Y, le.speechRender = Oe, le.lazyLoadImageRender = k, le.md2html = Re, le.preview = J, le.setCodeTheme = _t.Y, le.setContentTheme = z.Z, le;
                  }()
                );
                const mt = at;
              }
            ),
            /***/
            145: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  H: () => (
                    /* binding */
                    c
                  ),
                  /* harmony export */
                  g: () => (
                    /* binding */
                    u
                  )
                  /* harmony export */
                });
                var c = "3.11.2", u = (
                  /** @class */
                  function() {
                    function h() {
                    }
                    return h.ZWSP = "​", h.DROP_EDITOR = "application/editor", h.MOBILE_WIDTH = 520, h.CLASS_MENU_DISABLED = "vditor-menu--disabled", h.EDIT_TOOLBARS = [
                      "emoji",
                      "headings",
                      "bold",
                      "italic",
                      "strike",
                      "link",
                      "list",
                      "ordered-list",
                      "outdent",
                      "indent",
                      "check",
                      "line",
                      "quote",
                      "code",
                      "inline-code",
                      "insert-after",
                      "insert-before",
                      "upload",
                      "record",
                      "table"
                    ], h.CODE_THEME = [
                      "a11y-dark",
                      "agate",
                      "an-old-hope",
                      "androidstudio",
                      "arta",
                      "atom-one-dark",
                      "atom-one-dark-reasonable",
                      "base16/3024",
                      "base16/apathy",
                      "base16/apprentice",
                      "base16/ashes",
                      "base16/atelier-cave",
                      "base16/atelier-dune",
                      "base16/atelier-estuary",
                      "base16/atelier-forest",
                      "base16/atelier-heath",
                      "base16/atelier-lakeside",
                      "base16/atelier-plateau",
                      "base16/atelier-savanna",
                      "base16/atelier-seaside",
                      "base16/atelier-sulphurpool",
                      "base16/atlas",
                      "base16/bespin",
                      "base16/black-metal",
                      "base16/black-metal-bathory",
                      "base16/black-metal-burzum",
                      "base16/black-metal-dark-funeral",
                      "base16/black-metal-gorgoroth",
                      "base16/black-metal-immortal",
                      "base16/black-metal-khold",
                      "base16/black-metal-marduk",
                      "base16/black-metal-mayhem",
                      "base16/black-metal-nile",
                      "base16/black-metal-venom",
                      "base16/brewer",
                      "base16/bright",
                      "base16/brogrammer",
                      "base16/brush-trees-dark",
                      "base16/chalk",
                      "base16/circus",
                      "base16/classic-dark",
                      "base16/codeschool",
                      "base16/colors",
                      "base16/danqing",
                      "base16/darcula",
                      "base16/dark-violet",
                      "base16/darkmoss",
                      "base16/darktooth",
                      "base16/decaf",
                      "base16/default-dark",
                      "base16/dracula",
                      "base16/edge-dark",
                      "base16/eighties",
                      "base16/embers",
                      "base16/equilibrium-dark",
                      "base16/equilibrium-gray-dark",
                      "base16/espresso",
                      "base16/eva",
                      "base16/eva-dim",
                      "base16/flat",
                      "base16/framer",
                      "base16/gigavolt",
                      "base16/google-dark",
                      "base16/grayscale-dark",
                      "base16/green-screen",
                      "base16/gruvbox-dark-hard",
                      "base16/gruvbox-dark-medium",
                      "base16/gruvbox-dark-pale",
                      "base16/gruvbox-dark-soft",
                      "base16/hardcore",
                      "base16/harmonic16-dark",
                      "base16/heetch-dark",
                      "base16/helios",
                      "base16/hopscotch",
                      "base16/horizon-dark",
                      "base16/humanoid-dark",
                      "base16/ia-dark",
                      "base16/icy-dark",
                      "base16/ir-black",
                      "base16/isotope",
                      "base16/kimber",
                      "base16/london-tube",
                      "base16/macintosh",
                      "base16/marrakesh",
                      "base16/materia",
                      "base16/material",
                      "base16/material-darker",
                      "base16/material-palenight",
                      "base16/material-vivid",
                      "base16/mellow-purple",
                      "base16/mocha",
                      "base16/monokai",
                      "base16/nebula",
                      "base16/nord",
                      "base16/nova",
                      "base16/ocean",
                      "base16/oceanicnext",
                      "base16/onedark",
                      "base16/outrun-dark",
                      "base16/papercolor-dark",
                      "base16/paraiso",
                      "base16/pasque",
                      "base16/phd",
                      "base16/pico",
                      "base16/pop",
                      "base16/porple",
                      "base16/qualia",
                      "base16/railscasts",
                      "base16/rebecca",
                      "base16/ros-pine",
                      "base16/ros-pine-moon",
                      "base16/sandcastle",
                      "base16/seti-ui",
                      "base16/silk-dark",
                      "base16/snazzy",
                      "base16/solar-flare",
                      "base16/solarized-dark",
                      "base16/spacemacs",
                      "base16/summercamp",
                      "base16/summerfruit-dark",
                      "base16/synth-midnight-terminal-dark",
                      "base16/tango",
                      "base16/tender",
                      "base16/tomorrow-night",
                      "base16/twilight",
                      "base16/unikitty-dark",
                      "base16/vulcan",
                      "base16/windows-10",
                      "base16/windows-95",
                      "base16/windows-high-contrast",
                      "base16/windows-nt",
                      "base16/woodland",
                      "base16/xcode-dusk",
                      "base16/zenburn",
                      "codepen-embed",
                      "dark",
                      "devibeans",
                      "far",
                      "felipec",
                      "github-dark",
                      "github-dark-dimmed",
                      "gml",
                      "gradient-dark",
                      "hybrid",
                      "ir-black",
                      "isbl-editor-dark",
                      "kimbie-dark",
                      "lioshi",
                      "monokai",
                      "monokai-sublime",
                      "night-owl",
                      "nnfx-dark",
                      "nord",
                      "obsidian",
                      "panda-syntax-dark",
                      "paraiso-dark",
                      "pojoaque",
                      "qtcreator-dark",
                      "rainbow",
                      "shades-of-purple",
                      "srcery",
                      "stackoverflow-dark",
                      "sunburst",
                      "tomorrow-night-blue",
                      "tomorrow-night-bright",
                      "tokyo-night-dark",
                      "vs2015",
                      "xt256",
                      "ant-design",
                      "a11y-light",
                      "arduino-light",
                      "ascetic",
                      "atom-one-light",
                      "base16/atelier-cave-light",
                      "base16/atelier-dune-light",
                      "base16/atelier-estuary-light",
                      "base16/atelier-forest-light",
                      "base16/atelier-heath-light",
                      "base16/atelier-lakeside-light",
                      "base16/atelier-plateau-light",
                      "base16/atelier-savanna-light",
                      "base16/atelier-seaside-light",
                      "base16/atelier-sulphurpool-light",
                      "base16/brush-trees",
                      "base16/classic-light",
                      "base16/cupcake",
                      "base16/cupertino",
                      "base16/default-light",
                      "base16/dirtysea",
                      "base16/edge-light",
                      "base16/equilibrium-gray-light",
                      "base16/equilibrium-light",
                      "base16/fruit-soda",
                      "base16/github",
                      "base16/google-light",
                      "base16/grayscale-light",
                      "base16/gruvbox-light-hard",
                      "base16/gruvbox-light-medium",
                      "base16/gruvbox-light-soft",
                      "base16/harmonic16-light",
                      "base16/heetch-light",
                      "base16/humanoid-light",
                      "base16/horizon-light",
                      "base16/ia-light",
                      "base16/material-lighter",
                      "base16/mexico-light",
                      "base16/one-light",
                      "base16/papercolor-light",
                      "base16/ros-pine-dawn",
                      "base16/sagelight",
                      "base16/shapeshifter",
                      "base16/silk-light",
                      "base16/solar-flare-light",
                      "base16/solarized-light",
                      "base16/summerfruit-light",
                      "base16/synth-midnight-terminal-light",
                      "base16/tomorrow",
                      "base16/unikitty-light",
                      "base16/windows-10-light",
                      "base16/windows-95-light",
                      "base16/windows-high-contrast-light",
                      "brown-paper",
                      "base16/windows-nt-light",
                      "color-brewer",
                      "docco",
                      "foundation",
                      "github",
                      "googlecode",
                      "gradient-light",
                      "grayscale",
                      "idea",
                      "intellij-light",
                      "isbl-editor-light",
                      "kimbie-light",
                      "lightfair",
                      "magula",
                      "mono-blue",
                      "nnfx-light",
                      "panda-syntax-light",
                      "paraiso-light",
                      "purebasic",
                      "qtcreator-light",
                      "routeros",
                      "school-book",
                      "stackoverflow-light",
                      "tokyo-night-light",
                      "vs",
                      "xcode",
                      "default"
                    ], h.ALIAS_CODE_LANGUAGES = [
                      // 自定义
                      "abc",
                      "plantuml",
                      "mermaid",
                      "flowchart",
                      "echarts",
                      "mindmap",
                      "graphviz",
                      "math",
                      "markmap",
                      "smiles",
                      // 别名
                      "js",
                      "ts",
                      "html",
                      "toml",
                      "c#",
                      "bat"
                    ], h.CDN = "https://unpkg.com/vditor@".concat("3.11.2"), h.MARKDOWN_OPTIONS = {
                      autoSpace: !1,
                      gfmAutoLink: !0,
                      codeBlockPreview: !0,
                      fixTermTypo: !1,
                      footnotes: !0,
                      linkBase: "",
                      linkPrefix: "",
                      listStyle: !1,
                      mark: !1,
                      mathBlockPreview: !0,
                      paragraphBeginningSpace: !1,
                      sanitize: !0,
                      toc: !1
                    }, h.HLJS_OPTIONS = {
                      enable: !0,
                      lineNumber: !1,
                      defaultLang: "",
                      style: "github"
                    }, h.MATH_OPTIONS = {
                      engine: "KaTeX",
                      inlineDigit: !1,
                      macros: {}
                    }, h.THEME_OPTIONS = {
                      current: "light",
                      list: {
                        "ant-design": "Ant Design",
                        dark: "Dark",
                        light: "Light",
                        wechat: "WeChat"
                      },
                      path: "".concat(h.CDN, "/dist/css/content-theme")
                    }, h;
                  }()
                );
              }
            ),
            /***/
            825: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  J: () => (
                    /* binding */
                    m
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = l(494), m = function(y, b, k) {
                  y === void 0 && (y = document), b === void 0 && (b = c.g.CDN);
                  var x = h.SMILESRenderAdapter.getElements(y);
                  x.length > 0 && (0, u.G)("".concat(b, "/dist/js/smiles-drawer/smiles-drawer.min.js?v=2.1.7"), "vditorAbcjsScript").then(function() {
                    var M = new SmiDrawer({}, {});
                    x.forEach(function(T) {
                      var E = h.SMILESRenderAdapter.getCode(T).trim();
                      if (!(T.getAttribute("data-processed") === "true" || E.trim() === "")) {
                        var C = "smiles" + (0, f.Wb)();
                        T.innerHTML = '<svg id="'.concat(C, '"></svg>'), M.draw(E, "#" + C, k === "dark" ? "dark" : void 0), T.setAttribute("data-processed", "true");
                      }
                    });
                  });
                };
              }
            ),
            /***/
            135: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  Q: () => (
                    /* binding */
                    f
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = function(m, y) {
                  m === void 0 && (m = document), y === void 0 && (y = c.g.CDN);
                  var b = h.abcRenderAdapter.getElements(m);
                  b.length > 0 && (0, u.G)("".concat(y, "/dist/js/abcjs/abcjs_basic.min.js"), "vditorAbcjsScript").then(function() {
                    b.forEach(function(k) {
                      k.parentElement.classList.contains("vditor-wysiwyg__pre") || k.parentElement.classList.contains("vditor-ir__marker--pre") || k.getAttribute("data-processed") !== "true" && (ABCJS.renderAbc(k, h.abcRenderAdapter.getCode(k).trim()), k.style.overflowX = "auto", k.setAttribute("data-processed", "true"));
                    });
                  });
                };
              }
            ),
            /***/
            840: (
              /***/
              (o, a, l) => {
                l.r(a), l.d(a, {
                  /* harmony export */
                  mathRenderAdapter: () => (
                    /* binding */
                    c
                  ),
                  /* harmony export */
                  SMILESRenderAdapter: () => (
                    /* binding */
                    u
                  ),
                  /* harmony export */
                  mermaidRenderAdapter: () => (
                    /* binding */
                    h
                  ),
                  /* harmony export */
                  markmapRenderAdapter: () => (
                    /* binding */
                    f
                  ),
                  /* harmony export */
                  mindmapRenderAdapter: () => (
                    /* binding */
                    m
                  ),
                  /* harmony export */
                  chartRenderAdapter: () => (
                    /* binding */
                    y
                  ),
                  /* harmony export */
                  abcRenderAdapter: () => (
                    /* binding */
                    b
                  ),
                  /* harmony export */
                  graphvizRenderAdapter: () => (
                    /* binding */
                    k
                  ),
                  /* harmony export */
                  flowchartRenderAdapter: () => (
                    /* binding */
                    x
                  ),
                  /* harmony export */
                  plantumlRenderAdapter: () => (
                    /* binding */
                    M
                  )
                  /* harmony export */
                });
                var c = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-math");
                  }
                }, u = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-smiles");
                  }
                }, h = {
                  /** 不仅要返回code，并且需要将 code 设置为 el 的 innerHTML */
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-mermaid");
                  }
                }, f = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-markmap");
                  }
                }, m = {
                  getCode: function(T) {
                    return T.getAttribute("data-code");
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-mindmap");
                  }
                }, y = {
                  getCode: function(T) {
                    return T.innerText;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-echarts");
                  }
                }, b = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-abc");
                  }
                }, k = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-graphviz");
                  }
                }, x = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-flowchart");
                  }
                }, M = {
                  getCode: function(T) {
                    return T.textContent;
                  },
                  getElements: function(T) {
                    return T.querySelectorAll(".language-plantuml");
                  }
                };
              }
            ),
            /***/
            775: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  p: () => (
                    /* binding */
                    b
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = l(494), m = function(k, x, M, T) {
                  function E(C) {
                    return C instanceof M ? C : new M(function(O) {
                      O(C);
                    });
                  }
                  return new (M || (M = Promise))(function(C, O) {
                    function R(z) {
                      try {
                        H(T.next(z));
                      } catch (K) {
                        O(K);
                      }
                    }
                    function F(z) {
                      try {
                        H(T.throw(z));
                      } catch (K) {
                        O(K);
                      }
                    }
                    function H(z) {
                      z.done ? C(z.value) : E(z.value).then(R, F);
                    }
                    H((T = T.apply(k, x || [])).next());
                  });
                }, y = function(k, x) {
                  var M = { label: 0, sent: function() {
                    if (C[0] & 1) throw C[1];
                    return C[1];
                  }, trys: [], ops: [] }, T, E, C, O;
                  return O = { next: R(0), throw: R(1), return: R(2) }, typeof Symbol == "function" && (O[Symbol.iterator] = function() {
                    return this;
                  }), O;
                  function R(H) {
                    return function(z) {
                      return F([H, z]);
                    };
                  }
                  function F(H) {
                    if (T) throw new TypeError("Generator is already executing.");
                    for (; O && (O = 0, H[0] && (M = 0)), M; ) try {
                      if (T = 1, E && (C = H[0] & 2 ? E.return : H[0] ? E.throw || ((C = E.return) && C.call(E), 0) : E.next) && !(C = C.call(E, H[1])).done) return C;
                      switch (E = 0, C && (H = [H[0] & 2, C.value]), H[0]) {
                        case 0:
                        case 1:
                          C = H;
                          break;
                        case 4:
                          return M.label++, { value: H[1], done: !1 };
                        case 5:
                          M.label++, E = H[1], H = [0];
                          continue;
                        case 7:
                          H = M.ops.pop(), M.trys.pop();
                          continue;
                        default:
                          if (C = M.trys, !(C = C.length > 0 && C[C.length - 1]) && (H[0] === 6 || H[0] === 2)) {
                            M = 0;
                            continue;
                          }
                          if (H[0] === 3 && (!C || H[1] > C[0] && H[1] < C[3])) {
                            M.label = H[1];
                            break;
                          }
                          if (H[0] === 6 && M.label < C[1]) {
                            M.label = C[1], C = H;
                            break;
                          }
                          if (C && M.label < C[2]) {
                            M.label = C[2], M.ops.push(H);
                            break;
                          }
                          C[2] && M.ops.pop(), M.trys.pop();
                          continue;
                      }
                      H = x.call(k, M);
                    } catch (z) {
                      H = [6, z], E = 0;
                    } finally {
                      T = C = 0;
                    }
                    if (H[0] & 5) throw H[1];
                    return { value: H[0] ? H[1] : void 0, done: !0 };
                  }
                }, b = function(k, x, M) {
                  k === void 0 && (k = document), x === void 0 && (x = c.g.CDN);
                  var T = h.chartRenderAdapter.getElements(k);
                  T.length > 0 && (0, u.G)("".concat(x, "/dist/js/echarts/echarts.min.js?v=5.5.1"), "vditorEchartsScript").then(function() {
                    T.forEach(function(E) {
                      return m(void 0, void 0, void 0, function() {
                        var C, O, R;
                        return y(this, function(F) {
                          switch (F.label) {
                            case 0:
                              if (E.parentElement.classList.contains("vditor-wysiwyg__pre") || E.parentElement.classList.contains("vditor-ir__marker--pre"))
                                return [
                                  2
                                  /*return*/
                                ];
                              if (C = h.chartRenderAdapter.getCode(E).trim(), !C)
                                return [
                                  2
                                  /*return*/
                                ];
                              F.label = 1;
                            case 1:
                              return F.trys.push([1, 3, , 4]), E.getAttribute("data-processed") === "true" ? [
                                2
                                /*return*/
                              ] : [4, (0, f.Qf)(C)];
                            case 2:
                              return O = F.sent(), echarts.init(E, M === "dark" ? "dark" : void 0).setOption(O), E.setAttribute("data-processed", "true"), [3, 4];
                            case 3:
                              return R = F.sent(), E.className = "vditor-reset--error", E.innerHTML = "echarts render error: <br>".concat(R), [3, 4];
                            case 4:
                              return [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    });
                  });
                };
              }
            ),
            /***/
            428: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  O: () => (
                    /* binding */
                    h
                  )
                  /* harmony export */
                });
                var c = l(105), u = l(145), h = function(f, m) {
                  Array.from(f.querySelectorAll("pre > code")).filter(function(y, b) {
                    return !(y.parentElement.classList.contains("vditor-wysiwyg__pre") || y.parentElement.classList.contains("vditor-ir__marker--pre") || y.classList.contains("language-mermaid") || y.classList.contains("language-flowchart") || y.classList.contains("language-echarts") || y.classList.contains("language-mindmap") || y.classList.contains("language-plantuml") || y.classList.contains("language-markmap") || y.classList.contains("language-abc") || y.classList.contains("language-graphviz") || y.classList.contains("language-math") || y.classList.contains("language-smiles") || y.style.maxHeight.indexOf("px") > -1 || f.classList.contains("vditor-preview") && b > 5);
                  }).forEach(function(y) {
                    var b, k, x, M = y.innerText;
                    if (y.classList.contains("highlight-chroma")) {
                      var T = y.cloneNode(!0);
                      T.querySelectorAll(".highlight-ln").forEach(function(R) {
                        R.remove();
                      }), M = T.innerText;
                    } else M.endsWith(`
`) && (M = M.substr(0, M.length - 1));
                    var E = '<svg><use xlink:href="#vditor-icon-copy"></use></svg>';
                    document.getElementById("vditorIconScript") || (E = '<svg viewBox="0 0 32 32"><path d="M22.545-0h-17.455c-1.6 0-2.909 1.309-2.909 2.909v20.364h2.909v-20.364h17.455v-2.909zM26.909 5.818h-16c-1.6 0-2.909 1.309-2.909 2.909v20.364c0 1.6 1.309 2.909 2.909 2.909h16c1.6 0 2.909-1.309 2.909-2.909v-20.364c0-1.6-1.309-2.909-2.909-2.909zM26.909 29.091h-16v-20.364h16v20.364z"></path></svg>');
                    var C = document.createElement("div");
                    C.className = "vditor-copy", C.innerHTML = '<span aria-label="'.concat(((b = window.VditorI18n) === null || b === void 0 ? void 0 : b.copy) || "复制", `"
onmouseover="this.setAttribute('aria-label', '`).concat(((k = window.VditorI18n) === null || k === void 0 ? void 0 : k.copy) || "复制", `')"
class="vditor-tooltipped vditor-tooltipped__w"
onclick="event.stopPropagation();this.previousElementSibling.select();document.execCommand('copy');this.setAttribute('aria-label', '`).concat(((x = window.VditorI18n) === null || x === void 0 ? void 0 : x.copied) || "已复制", `');this.previousElementSibling.blur()">`).concat(E, "</span>");
                    var O = document.createElement("textarea");
                    O.value = (0, c.X)(M), C.insertAdjacentElement("afterbegin", O), m && m.renderMenu && m.renderMenu(y, C), y.before(C), y.style.maxHeight = window.outerHeight - 40 + "px", y.insertAdjacentHTML("afterend", '<span style="position: absolute">'.concat(u.g.ZWSP, "</span>"));
                  });
                };
              }
            ),
            /***/
            325: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  P: () => (
                    /* binding */
                    f
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = function(m, y) {
                  y === void 0 && (y = c.g.CDN);
                  var b = h.flowchartRenderAdapter.getElements(m);
                  b.length !== 0 && (0, u.G)("".concat(y, "/dist/js/flowchart.js/flowchart.min.js"), "vditorFlowchartScript").then(function() {
                    b.forEach(function(k) {
                      if (k.getAttribute("data-processed") !== "true") {
                        var x = flowchart.parse(h.flowchartRenderAdapter.getCode(k));
                        k.innerHTML = "", x.drawSVG(k), k.setAttribute("data-processed", "true");
                      }
                    });
                  });
                };
              }
            ),
            /***/
            483: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  v: () => (
                    /* binding */
                    f
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = function(m, y) {
                  y === void 0 && (y = c.g.CDN);
                  var b = h.graphvizRenderAdapter.getElements(m);
                  b.length !== 0 && (0, u.G)("".concat(y, "/dist/js/graphviz/viz.js"), "vditorGraphVizScript").then(function() {
                    b.forEach(function(k) {
                      var x = h.graphvizRenderAdapter.getCode(k);
                      if (!(k.parentElement.classList.contains("vditor-wysiwyg__pre") || k.parentElement.classList.contains("vditor-ir__marker--pre")) && !(k.getAttribute("data-processed") === "true" || x.trim() === "")) {
                        try {
                          var M = new Blob(["importScripts('".concat(document.getElementById("vditorGraphVizScript").src.replace("viz.js", "full.render.js"), "');")], { type: "application/javascript" }), T = window.URL || window.webkitURL, E = T.createObjectURL(M), C = new Worker(E);
                          new Viz({ worker: C }).renderSVGElement(x).then(function(O) {
                            k.innerHTML = O.outerHTML;
                          }).catch(function(O) {
                            k.innerHTML = "graphviz render error: <br>".concat(O), k.className = "vditor-reset--error";
                          });
                        } catch (O) {
                          console.error("graphviz error", O);
                        }
                        k.setAttribute("data-processed", "true");
                      }
                    });
                  });
                };
              }
            ),
            /***/
            999: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  s: () => (
                    /* binding */
                    f
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(290), f = function(m, y, b) {
                  y === void 0 && (y = document), b === void 0 && (b = c.g.CDN);
                  var k = m.style;
                  c.g.CODE_THEME.includes(k) || (k = "github");
                  var x = document.getElementById("vditorHljsStyle"), M = "".concat(b, "/dist/js/highlight.js/styles/").concat(k, ".min.css");
                  if (x && x.getAttribute("href") !== M && x.remove(), (0, h.c)("".concat(b, "/dist/js/highlight.js/styles/").concat(k, ".min.css"), "vditorHljsStyle"), m.enable !== !1) {
                    var T = y.querySelectorAll("pre > code");
                    T.length !== 0 && (0, u.G)("".concat(b, "/dist/js/highlight.js/highlight.min.js?v=11.7.0"), "vditorHljsScript").then(function() {
                      (0, u.G)("".concat(b, "/dist/js/highlight.js/third-languages.js?v=1.0.1"), "vditorHljsThirdScript").then(function() {
                        y.querySelectorAll("pre > code").forEach(function(E) {
                          if (!(E.parentElement.classList.contains("vditor-ir__marker--pre") || E.parentElement.classList.contains("vditor-wysiwyg__pre")) && !(E.classList.contains("language-mermaid") || E.classList.contains("language-flowchart") || E.classList.contains("language-echarts") || E.classList.contains("language-mindmap") || E.classList.contains("language-plantuml") || E.classList.contains("language-smiles") || E.classList.contains("language-abc") || E.classList.contains("language-graphviz") || E.classList.contains("language-math"))) {
                            m.defaultLang !== "" && E.className.indexOf("language-") === -1 && E.classList.add("language-" + m.defaultLang);
                            var C = E.className.replace("language-", "");
                            if (window.hljs.getLanguage(C) || (C = "plaintext"), E.innerHTML = window.hljs.highlight(E.textContent, {
                              language: C,
                              ignoreIllegals: !0
                            }).value, E.classList.add("hljs"), !!m.lineNumber) {
                              E.classList.add("vditor-linenumber");
                              var O = E.querySelector(".vditor-linenumber__temp");
                              O || (O = document.createElement("div"), O.className = "vditor-linenumber__temp", E.insertAdjacentElement("beforeend", O));
                              var R = getComputedStyle(E).whiteSpace, F = !1;
                              (R === "pre-wrap" || R === "pre-line") && (F = !0);
                              var H = "", z = E.textContent.split(/\r\n|\r|\n/g);
                              z.pop(), z.map(function(K) {
                                var U = "";
                                F && (O.textContent = K || `
`, U = ' style="height:'.concat(O.getBoundingClientRect().height, 'px"')), H += "<span".concat(U, "></span>");
                              }), O.style.display = "none", H = '<span class="vditor-linenumber__rows">'.concat(H, "</span>"), E.insertAdjacentHTML("beforeend", H);
                            }
                          }
                        });
                      });
                    });
                  }
                };
              }
            ),
            /***/
            11: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  K: () => (
                    /* binding */
                    b
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = {}, m = function(k, x) {
                  var M = k.transform(x), T = Object.keys(M.features).filter(function(F) {
                    return !f[F];
                  });
                  T.forEach(function(F) {
                    f[F] = !0;
                  });
                  var E = k.getAssets(T), C = E.styles, O = E.scripts, R = window.markmap;
                  return C && R.loadCSS(C), O && R.loadJS(O), M;
                }, y = function(k, x) {
                  var M = window.markmap, T = M.Transformer, E = M.Markmap, C = M.deriveOptions;
                  M.globalCSS;
                  var O = new T();
                  k.innerHTML = '<svg style="width:100%"></svg>';
                  var R = k.firstChild, F = E.create(R, null), H = m(O, x), z = H.root, K = H.frontmatter, U = K == null ? void 0 : K.markmap, ae = C(U);
                  F.setData(z, ae), F.fit();
                }, b = function(k, x) {
                  k === void 0 && (k = document), x === void 0 && (x = c.g.CDN);
                  var M = h.markmapRenderAdapter.getElements(k);
                  M.length !== 0 && (0, u.G)("".concat(x, "/dist/js/markmap/markmap.min.js"), "vditorMarkerScript").then(function() {
                    M.forEach(function(T) {
                      var E = h.markmapRenderAdapter.getCode(T);
                      if (!(T.getAttribute("data-processed") === "true" || E.trim() === "")) {
                        var C = document.createElement("div");
                        C.className = "language-markmap", T.parentNode.appendChild(C), y(C, E), T.parentNode.childNodes[0].nodeName == "CODE" && T.parentNode.removeChild(T.parentNode.childNodes[0]);
                      }
                    });
                  });
                };
              }
            ),
            /***/
            472: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  H: () => (
                    /* binding */
                    y
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(290), f = l(105), m = l(840), y = function(b, k) {
                  b === void 0 && (b = document);
                  var x = m.mathRenderAdapter.getElements(b);
                  if (x.length !== 0) {
                    var M = {
                      cdn: c.g.CDN,
                      math: {
                        engine: "KaTeX",
                        inlineDigit: !1,
                        macros: {}
                      }
                    };
                    if (k && k.math && (k.math = Object.assign({}, M.math, k.math)), k = Object.assign({}, M, k), k.math.engine === "KaTeX")
                      (0, h.c)("".concat(k.cdn, "/dist/js/katex/katex.min.css?v=0.16.9"), "vditorKatexStyle"), (0, u.G)("".concat(k.cdn, "/dist/js/katex/katex.min.js?v=0.16.9"), "vditorKatexScript").then(function() {
                        (0, u.G)("".concat(k.cdn, "/dist/js/katex/mhchem.min.js?v=0.16.9"), "vditorKatexChemScript").then(function() {
                          x.forEach(function(C) {
                            if (!(C.parentElement.classList.contains("vditor-wysiwyg__pre") || C.parentElement.classList.contains("vditor-ir__marker--pre")) && !C.getAttribute("data-math")) {
                              var O = (0, f.X)(m.mathRenderAdapter.getCode(C));
                              C.setAttribute("data-math", O);
                              try {
                                C.innerHTML = katex.renderToString(O, {
                                  displayMode: C.tagName === "DIV",
                                  output: "html",
                                  macros: k.math.macros
                                });
                              } catch (R) {
                                C.innerHTML = R.message, C.className = "language-math vditor-reset--error";
                              }
                              C.addEventListener("copy", function(R) {
                                R.stopPropagation(), R.preventDefault();
                                var F = R.currentTarget.closest(".language-math");
                                R.clipboardData.setData("text/html", F.innerHTML), R.clipboardData.setData("text/plain", F.getAttribute("data-math"));
                              });
                            }
                          });
                        });
                      });
                    else if (k.math.engine === "MathJax") {
                      var T = function(C) {
                        if (C.length !== 0) {
                          var O = 0, R = C[C.length - 1], F = function() {
                            var H = C[O++];
                            H === R ? H() : H(F);
                          };
                          F();
                        }
                      };
                      window.MathJax || (window.MathJax = {
                        loader: {
                          paths: { mathjax: "".concat(k.cdn, "/dist/js/mathjax") }
                        },
                        startup: {
                          typeset: !1
                        },
                        tex: {
                          macros: k.math.macros
                        }
                      }, Object.assign(window.MathJax, k.math.mathJaxOptions)), (0, u.J)("".concat(k.cdn, "/dist/js/mathjax/tex-svg-full.js"), "protyleMathJaxScript");
                      var E = function(C, O) {
                        var R = (0, f.X)(C.textContent).trim(), F = window.MathJax.getMetricsFor(C);
                        F.display = C.tagName === "DIV", window.MathJax.tex2svgPromise(R, F).then(function(H) {
                          C.innerHTML = "", C.setAttribute("data-math", R), C.append(H), window.MathJax.startup.document.clear(), window.MathJax.startup.document.updateDocument();
                          var z = H.querySelector('[data-mml-node="merror"]');
                          z && z.textContent.trim() !== "" && (C.innerHTML = z.textContent.trim(), C.className = "vditor-reset--error"), O && O();
                        });
                      };
                      window.MathJax.startup.promise.then(function() {
                        for (var C = [], O = function(F) {
                          var H = x[F];
                          !H.parentElement.classList.contains("vditor-wysiwyg__pre") && !H.parentElement.classList.contains("vditor-ir__marker--pre") && !H.getAttribute("data-math") && (0, f.X)(H.textContent).trim() && C.push(function(z) {
                            F === x.length - 1 ? E(H) : E(H, z);
                          });
                        }, R = 0; R < x.length; R++)
                          O(R);
                        T(C);
                      });
                    }
                  }
                };
              }
            ),
            /***/
            280: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  Y: () => (
                    /* binding */
                    m
                  )
                  /* harmony export */
                });
                var c = l(494), u = function(y, b) {
                  y.insertAdjacentHTML("afterend", '<video controls="controls" src="'.concat(b, '"></video>')), y.remove();
                }, h = function(y, b) {
                  y.insertAdjacentHTML("afterend", '<audio controls="controls" src="'.concat(b, '"></audio>')), y.remove();
                }, f = function(y, b) {
                  var k = b.match(/\/\/(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))([\w|-]{11})(?:(?:[\?&]t=)(\S+))?/), x = b.match(/\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/), M = b.match(/\/\/v\.qq\.com\/x\/cover\/.*\/([^\/]+)\.html\??.*/), T = b.match(/(?:www\.|\/\/)coub\.com\/view\/(\w+)/), E = b.match(/(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/), C = b.match(/.+dailymotion.com\/(video|hub)\/(\w+)\?/), O = b.match(/(?:www\.|\/\/)bilibili\.com\/video\/(\w+)/), R = b.match(/(?:www\.|\/\/)ted\.com\/talks\/(\w+)/);
                  if (k && k[1].length === 11)
                    y.insertAdjacentHTML("afterend", '<iframe class="iframe__video" src="//www.youtube.com/embed/'.concat(k[1] + (k[2] ? "?start=" + k[2] : ""), '"></iframe>')), y.remove();
                  else if (x && x[1])
                    y.insertAdjacentHTML("afterend", '<iframe class="iframe__video" src="//player.youku.com/embed/'.concat(x[1], '"></iframe>')), y.remove();
                  else if (M && M[1])
                    y.insertAdjacentHTML("afterend", '<iframe class="iframe__video" src="https://v.qq.com/txp/iframe/player.html?vid='.concat(M[1], '"></iframe>')), y.remove();
                  else if (T && T[1])
                    y.insertAdjacentHTML("afterend", `<iframe class="iframe__video"
 src="//coub.com/embed/`.concat(T[1], '?muted=false&autostart=false&originalSize=true&startWithHD=true"></iframe>')), y.remove();
                  else if (E && E[0])
                    y.insertAdjacentHTML("afterend", `<iframe class="iframe__video"
 src="https://www.facebook.com/plugins/video.php?href=`.concat(encodeURIComponent(E[0]), '"></iframe>')), y.remove();
                  else if (C && C[2])
                    y.insertAdjacentHTML("afterend", `<iframe class="iframe__video"
 src="https://www.dailymotion.com/embed/video/`.concat(C[2], '"></iframe>')), y.remove();
                  else if (b.indexOf("bilibili.com") > -1 && (b.indexOf("bvid=") > -1 || O && O[1])) {
                    var F = {
                      bvid: (0, c.on)("bvid", b) || O && O[1],
                      page: "1",
                      high_quality: "1",
                      as_wide: "1",
                      allowfullscreen: "true",
                      autoplay: "0"
                    };
                    new URL(b.startsWith("http") ? b : "https:" + b).search.split("&").forEach(function(K, U) {
                      if (K) {
                        U === 0 && (K = K.substr(1));
                        var ae = K.split("=");
                        F[ae[0]] = ae[1];
                      }
                    });
                    var H = "https://player.bilibili.com/player.html?", z = Object.keys(F);
                    z.forEach(function(K, U) {
                      H += "".concat(K, "=").concat(F[K]), U < z.length - 1 && (H += "&");
                    }), y.insertAdjacentHTML("afterend", '<iframe class="iframe__video" src="'.concat(H, '"></iframe>')), y.remove();
                  } else R && R[1] && (y.insertAdjacentHTML("afterend", '<iframe class="iframe__video" src="//embed.ted.com/talks/'.concat(R[1], '"></iframe>')), y.remove());
                }, m = function(y) {
                  y && y.querySelectorAll("a").forEach(function(b) {
                    var k = b.getAttribute("href");
                    k && (k.match(/^.+.(mp4|m4v|ogg|ogv|webm)$/) ? u(b, k) : k.match(/^.+.(mp3|wav|flac)$/) ? h(b, k) : f(b, k));
                  });
                };
              }
            ),
            /***/
            637: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  i: () => (
                    /* binding */
                    b
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = l(494), m = function(k, x, M, T) {
                  function E(C) {
                    return C instanceof M ? C : new M(function(O) {
                      O(C);
                    });
                  }
                  return new (M || (M = Promise))(function(C, O) {
                    function R(z) {
                      try {
                        H(T.next(z));
                      } catch (K) {
                        O(K);
                      }
                    }
                    function F(z) {
                      try {
                        H(T.throw(z));
                      } catch (K) {
                        O(K);
                      }
                    }
                    function H(z) {
                      z.done ? C(z.value) : E(z.value).then(R, F);
                    }
                    H((T = T.apply(k, x || [])).next());
                  });
                }, y = function(k, x) {
                  var M = { label: 0, sent: function() {
                    if (C[0] & 1) throw C[1];
                    return C[1];
                  }, trys: [], ops: [] }, T, E, C, O;
                  return O = { next: R(0), throw: R(1), return: R(2) }, typeof Symbol == "function" && (O[Symbol.iterator] = function() {
                    return this;
                  }), O;
                  function R(H) {
                    return function(z) {
                      return F([H, z]);
                    };
                  }
                  function F(H) {
                    if (T) throw new TypeError("Generator is already executing.");
                    for (; O && (O = 0, H[0] && (M = 0)), M; ) try {
                      if (T = 1, E && (C = H[0] & 2 ? E.return : H[0] ? E.throw || ((C = E.return) && C.call(E), 0) : E.next) && !(C = C.call(E, H[1])).done) return C;
                      switch (E = 0, C && (H = [H[0] & 2, C.value]), H[0]) {
                        case 0:
                        case 1:
                          C = H;
                          break;
                        case 4:
                          return M.label++, { value: H[1], done: !1 };
                        case 5:
                          M.label++, E = H[1], H = [0];
                          continue;
                        case 7:
                          H = M.ops.pop(), M.trys.pop();
                          continue;
                        default:
                          if (C = M.trys, !(C = C.length > 0 && C[C.length - 1]) && (H[0] === 6 || H[0] === 2)) {
                            M = 0;
                            continue;
                          }
                          if (H[0] === 3 && (!C || H[1] > C[0] && H[1] < C[3])) {
                            M.label = H[1];
                            break;
                          }
                          if (H[0] === 6 && M.label < C[1]) {
                            M.label = C[1], C = H;
                            break;
                          }
                          if (C && M.label < C[2]) {
                            M.label = C[2], M.ops.push(H);
                            break;
                          }
                          C[2] && M.ops.pop(), M.trys.pop();
                          continue;
                      }
                      H = x.call(k, M);
                    } catch (z) {
                      H = [6, z], E = 0;
                    } finally {
                      T = C = 0;
                    }
                    if (H[0] & 5) throw H[1];
                    return { value: H[0] ? H[1] : void 0, done: !0 };
                  }
                }, b = function(k, x, M) {
                  k === void 0 && (k = document), x === void 0 && (x = c.g.CDN);
                  var T = h.mermaidRenderAdapter.getElements(k);
                  T.length !== 0 && (0, u.G)("".concat(x, "/dist/js/mermaid/mermaid.min.js?v=11.6.0"), "vditorMermaidScript").then(function() {
                    var E = {
                      securityLevel: "loose",
                      altFontFamily: "sans-serif",
                      fontFamily: "sans-serif",
                      startOnLoad: !1,
                      flowchart: {
                        htmlLabels: !0,
                        useMaxWidth: !0
                      },
                      sequence: {
                        useMaxWidth: !0,
                        diagramMarginX: 8,
                        diagramMarginY: 8,
                        boxMargin: 8,
                        showSequenceNumbers: !0
                        // Mermaid 时序图增加序号 https://github.com/siyuan-note/siyuan/pull/6992 https://mermaid.js.org/syntax/sequenceDiagram.html#sequencenumbers
                      },
                      gantt: {
                        leftPadding: 75,
                        rightPadding: 20
                      }
                    };
                    M === "dark" && (E.theme = "dark"), mermaid.initialize(E), T.forEach(function(C) {
                      return m(void 0, void 0, void 0, function() {
                        var O, R, F, H, z;
                        return y(this, function(K) {
                          switch (K.label) {
                            case 0:
                              if (O = h.mermaidRenderAdapter.getCode(C), C.getAttribute("data-processed") === "true" || O.trim() === "")
                                return [
                                  2
                                  /*return*/
                                ];
                              R = "mermaid" + (0, f.Wb)(), K.label = 1;
                            case 1:
                              return K.trys.push([1, 3, , 4]), [4, mermaid.render(R, C.textContent)];
                            case 2:
                              return F = K.sent(), C.innerHTML = F.svg, [3, 4];
                            case 3:
                              return H = K.sent(), z = document.querySelector("#" + R), C.innerHTML = "".concat(z.outerHTML, `<br>
<div style="text-align: left"><small>`).concat(H.message.replace(/\n/, "<br>"), "</small></div>"), z.parentElement.remove(), [3, 4];
                            case 4:
                              return C.setAttribute("data-processed", "true"), [
                                2
                                /*return*/
                              ];
                          }
                        });
                      });
                    });
                  });
                };
              }
            ),
            /***/
            194: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  P: () => (
                    /* binding */
                    f
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = function(m, y, b) {
                  m === void 0 && (m = document), y === void 0 && (y = c.g.CDN);
                  var k = h.mindmapRenderAdapter.getElements(m);
                  k.length > 0 && (0, u.G)("".concat(y, "/dist/js/echarts/echarts.min.js?v=5.5.1"), "vditorEchartsScript").then(function() {
                    k.forEach(function(x) {
                      if (!(x.parentElement.classList.contains("vditor-wysiwyg__pre") || x.parentElement.classList.contains("vditor-ir__marker--pre"))) {
                        var M = h.mindmapRenderAdapter.getCode(x);
                        if (M)
                          try {
                            if (x.getAttribute("data-processed") === "true")
                              return;
                            echarts.init(x, b === "dark" ? "dark" : void 0).setOption({
                              series: [
                                {
                                  data: [JSON.parse(decodeURIComponent(M))],
                                  initialTreeDepth: -1,
                                  itemStyle: {
                                    borderWidth: 0,
                                    color: "#4285f4"
                                  },
                                  label: {
                                    backgroundColor: "#f6f8fa",
                                    borderColor: "#d1d5da",
                                    borderRadius: 5,
                                    borderWidth: 0.5,
                                    color: "#586069",
                                    lineHeight: 20,
                                    offset: [-5, 0],
                                    padding: [0, 5],
                                    position: "insideRight"
                                  },
                                  lineStyle: {
                                    color: "#d1d5da",
                                    width: 1
                                  },
                                  roam: !0,
                                  symbol: function(T, E) {
                                    var C;
                                    return !((C = E == null ? void 0 : E.data) === null || C === void 0) && C.children ? "circle" : "path://";
                                  },
                                  type: "tree"
                                }
                              ],
                              tooltip: {
                                trigger: "item",
                                triggerOn: "mousemove"
                              }
                            }), x.setAttribute("data-processed", "true");
                          } catch (T) {
                            x.className = "vditor-reset--error", x.innerHTML = "mindmap render error: <br>".concat(T);
                          }
                      }
                    });
                  });
                };
              }
            ),
            /***/
            436: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  k: () => (
                    /* binding */
                    h
                  )
                  /* harmony export */
                });
                var c = l(771), u = l(472), h = function(f, m, y) {
                  var b = "", k = [];
                  if (Array.from(f.children).forEach(function(E, C) {
                    if ((0, c.W)(E)) {
                      if (y) {
                        var O = E.id.lastIndexOf("_");
                        E.id = E.id.substring(0, O === -1 ? void 0 : O) + "_" + C;
                      }
                      k.push(E.id), b += E.outerHTML.replace("<wbr>", "");
                    }
                  }), b === "")
                    return m.innerHTML = "", "";
                  var x = document.createElement("div");
                  if (y)
                    y.lute.SetToC(!0), y.currentMode === "wysiwyg" && !y.preview.element.contains(f) ? x.innerHTML = y.lute.SpinVditorDOM("<p>[ToC]</p>" + b) : y.currentMode === "ir" && !y.preview.element.contains(f) ? x.innerHTML = y.lute.SpinVditorIRDOM("<p>[ToC]</p>" + b) : x.innerHTML = y.lute.HTML2VditorDOM("<p>[ToC]</p>" + b), y.lute.SetToC(y.options.preview.markdown.toc);
                  else {
                    m.classList.add("vditor-outline");
                    var M = Lute.New();
                    M.SetToC(!0), x.innerHTML = M.HTML2VditorDOM("<p>[ToC]</p>" + b);
                  }
                  var T = x.firstElementChild.querySelectorAll("li > span[data-target-id]");
                  return T.forEach(function(E, C) {
                    if (E.nextElementSibling && E.nextElementSibling.tagName === "UL") {
                      var O = "<svg class='vditor-outline__action'><use xlink:href='#vditor-icon-down'></use></svg>";
                      document.getElementById("vditorIconScript") || (O = '<svg class="vditor-outline__action" viewBox="0 0 32 32"><path d="M3.76 6.12l12.24 12.213 12.24-12.213 3.76 3.76-16 16-16-16 3.76-3.76z"></path></svg>'), E.innerHTML = "".concat(O, "<span>").concat(E.innerHTML, "</span>");
                    } else
                      E.innerHTML = "<svg></svg><span>".concat(E.innerHTML, "</span>");
                    E.setAttribute("data-target-id", k[C]);
                  }), b = x.firstElementChild.innerHTML, T.length === 0 ? (m.innerHTML = "", b) : (m.innerHTML = b, y && (0, u.H)(m, {
                    cdn: y.options.cdn,
                    math: y.options.preview.math
                  }), m.firstElementChild.addEventListener("click", function(E) {
                    for (var C = E.target; C && !C.isEqualNode(m); ) {
                      if (C.classList.contains("vditor-outline__action")) {
                        C.classList.contains("vditor-outline__action--close") ? (C.classList.remove("vditor-outline__action--close"), C.parentElement.nextElementSibling.setAttribute("style", "display:block")) : (C.classList.add("vditor-outline__action--close"), C.parentElement.nextElementSibling.setAttribute("style", "display:none")), E.preventDefault(), E.stopPropagation();
                        break;
                      } else if (C.getAttribute("data-target-id")) {
                        E.preventDefault(), E.stopPropagation();
                        var O = document.getElementById(C.getAttribute("data-target-id"));
                        if (!O)
                          return;
                        if (y)
                          if (y.options.height === "auto") {
                            var R = O.offsetTop + y.element.offsetTop;
                            y.options.toolbarConfig.pin || (R += y.toolbar.element.offsetHeight), window.scrollTo(window.scrollX, R);
                          } else
                            y.element.offsetTop < window.scrollY && window.scrollTo(window.scrollX, y.element.offsetTop), y.preview.element.contains(f) ? f.parentElement.scrollTop = O.offsetTop : f.scrollTop = O.offsetTop;
                        else
                          window.scrollTo(window.scrollX, O.offsetTop);
                        break;
                      }
                      C = C.parentElement;
                    }
                  }), b);
                };
              }
            ),
            /***/
            229: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  B: () => (
                    /* binding */
                    f
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(413), h = l(840), f = function(m, y) {
                  m === void 0 && (m = document), y === void 0 && (y = c.g.CDN);
                  var b = h.plantumlRenderAdapter.getElements(m);
                  b.length !== 0 && (0, u.G)("".concat(y, "/dist/js/plantuml/plantuml-encoder.min.js"), "vditorPlantumlScript").then(function() {
                    b.forEach(function(k) {
                      if (!(k.parentElement.classList.contains("vditor-wysiwyg__pre") || k.parentElement.classList.contains("vditor-ir__marker--pre"))) {
                        var x = h.plantumlRenderAdapter.getCode(k).trim();
                        if (x)
                          try {
                            k.innerHTML = '<object type="image/svg+xml" data="https://www.plantuml.com/plantuml/svg/~1'.concat(plantumlEncoder.encode(x), '"/>');
                          } catch (M) {
                            k.className = "vditor-reset--error", k.innerHTML = "plantuml render error: <br>".concat(M);
                          }
                      }
                    });
                  });
                };
              }
            ),
            /***/
            214: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  X: () => (
                    /* binding */
                    c
                  )
                  /* harmony export */
                });
                var c = function(u) {
                  var h = Lute.New();
                  return h.PutEmojis(u.emojis), h.SetEmojiSite(u.emojiSite), h.SetHeadingAnchor(u.headingAnchor), h.SetInlineMathAllowDigitAfterOpenMarker(u.inlineMathDigit), h.SetAutoSpace(u.autoSpace), h.SetToC(u.toc), h.SetFootnotes(u.footnotes), h.SetFixTermTypo(u.fixTermTypo), h.SetVditorCodeBlockPreview(u.codeBlockPreview), h.SetVditorMathBlockPreview(u.mathBlockPreview), h.SetSanitize(u.sanitize), h.SetChineseParagraphBeginningSpace(u.paragraphBeginningSpace), h.SetRenderListStyle(u.listStyle), h.SetLinkBase(u.linkBase), h.SetLinkPrefix(u.linkPrefix), h.SetMark(u.mark), h.SetGFMAutoLink(u.gfmAutoLink), u.lazyLoadImage && h.SetImageLazyLoading(u.lazyLoadImage), h;
                };
              }
            ),
            /***/
            190: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  E: () => (
                    /* binding */
                    c
                  )
                  /* harmony export */
                });
                var c = function(u, h, f) {
                  f === void 0 && (f = "classic");
                  var m = u.getBoundingClientRect(), y = 36;
                  document.body.insertAdjacentHTML("beforeend", '<div class="vditor vditor-img'.concat(f === "dark" ? " vditor--dark" : "", `">
    <div class="vditor-img__bar">
      <span class="vditor-img__btn" data-deg="0">
        <svg><use xlink:href="#vditor-icon-redo"></use></svg>
        `).concat(window.VditorI18n.spin, `
      </span>
      <span class="vditor-img__btn"  onclick="this.parentElement.parentElement.outerHTML = '';document.body.style.overflow = ''">
        X &nbsp;`).concat(window.VditorI18n.close, `
      </span>
    </div>
    <div class="vditor-img__img" onclick="this.parentElement.outerHTML = '';document.body.style.overflow = ''">
      <img style="width: `).concat(u.width, "px;height:").concat(u.height, "px;transform: translate3d(").concat(m.left, "px, ").concat(m.top - y, 'px, 0)" src="').concat(u.getAttribute("src"), `">
    </div>
</div>`)), document.body.style.overflow = "hidden";
                  var b = document.querySelector(".vditor-img img"), k = "translate3d(".concat(Math.max(0, window.innerWidth - u.naturalWidth) / 2, "px, ").concat(Math.max(0, window.innerHeight - y - u.naturalHeight) / 2, "px, 0)");
                  setTimeout(function() {
                    b.setAttribute("style", "transition: transform .3s ease-in-out;transform: ".concat(k)), setTimeout(function() {
                      b.parentElement.scrollTo((b.parentElement.scrollWidth - b.parentElement.clientWidth) / 2, (b.parentElement.scrollHeight - b.parentElement.clientHeight) / 2);
                    }, 400);
                  });
                  var x = document.querySelector(".vditor-img__btn");
                  x.addEventListener("click", function() {
                    var M = parseInt(x.getAttribute("data-deg"), 10) + 90;
                    M / 90 % 2 === 1 && u.naturalWidth > b.parentElement.clientHeight ? b.style.transform = "translate3d(".concat(Math.max(0, window.innerWidth - u.naturalWidth) / 2, "px, ").concat(u.naturalWidth / 2 - u.naturalHeight / 2, "px, 0) rotateZ(").concat(M, "deg)") : b.style.transform = "".concat(k, " rotateZ(").concat(M, "deg)"), x.setAttribute("data-deg", M.toString()), setTimeout(function() {
                      b.parentElement.scrollTo((b.parentElement.scrollWidth - b.parentElement.clientWidth) / 2, (b.parentElement.scrollHeight - b.parentElement.clientHeight) / 2);
                    }, 400);
                  });
                };
              }
            ),
            /***/
            580: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  Y: () => (
                    /* binding */
                    h
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(290), h = function(f, m) {
                  m === void 0 && (m = c.g.CDN), c.g.CODE_THEME.includes(f) || (f = "github");
                  var y = document.getElementById("vditorHljsStyle"), b = "".concat(m, "/dist/js/highlight.js/styles/").concat(f, ".min.css");
                  y ? y.getAttribute("href") !== b && (y.remove(), (0, u.c)(b, "vditorHljsStyle")) : (0, u.c)(b, "vditorHljsStyle");
                };
              }
            ),
            /***/
            538: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  Z: () => (
                    /* binding */
                    u
                  )
                  /* harmony export */
                });
                var c = l(290), u = function(h, f) {
                  if (!(!h || !f)) {
                    var m = document.getElementById("vditorContentTheme"), y = "".concat(f, "/").concat(h, ".css");
                    m ? m.getAttribute("href") !== y && (m.remove(), (0, c.c)(y, "vditorContentTheme")) : (0, c.c)(y, "vditorContentTheme");
                  }
                };
              }
            ),
            /***/
            413: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  J: () => (
                    /* binding */
                    c
                  ),
                  /* harmony export */
                  G: () => (
                    /* binding */
                    u
                  )
                  /* harmony export */
                });
                var c = function(h, f) {
                  if (document.getElementById(f))
                    return !1;
                  var m = new XMLHttpRequest();
                  m.open("GET", h, !1), m.setRequestHeader("Accept", "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01"), m.send("");
                  var y = document.createElement("script");
                  y.type = "text/javascript", y.text = m.responseText, y.id = f, document.head.appendChild(y);
                }, u = function(h, f) {
                  return new Promise(function(m, y) {
                    if (document.getElementById(f))
                      return m(!0), !1;
                    var b = document.createElement("script");
                    b.src = h, b.async = !0, document.head.appendChild(b), b.onerror = function(k) {
                      y(k);
                    }, b.onload = function() {
                      if (document.getElementById(f))
                        return b.remove(), m(!0), !1;
                      b.id = f, m(!0);
                    };
                  });
                };
              }
            ),
            /***/
            290: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  c: () => (
                    /* binding */
                    c
                  )
                  /* harmony export */
                });
                var c = function(u, h) {
                  if (!document.getElementById(h)) {
                    var f = document.createElement("link");
                    f.id = h, f.rel = "stylesheet", f.type = "text/css", f.href = u, document.getElementsByTagName("head")[0].appendChild(f);
                  }
                };
              }
            ),
            /***/
            105: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  X: () => (
                    /* binding */
                    c
                  )
                  /* harmony export */
                });
                var c = function(u) {
                  return u.replace(/\u00a0/g, " ");
                };
              }
            ),
            /***/
            410: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  G6: () => (
                    /* binding */
                    c
                  ),
                  /* harmony export */
                  vU: () => (
                    /* binding */
                    u
                  ),
                  /* harmony export */
                  pK: () => (
                    /* binding */
                    h
                  ),
                  /* harmony export */
                  Le: () => (
                    /* binding */
                    f
                  ),
                  /* harmony export */
                  yl: () => (
                    /* binding */
                    m
                  ),
                  /* harmony export */
                  ns: () => (
                    /* binding */
                    y
                  ),
                  /* harmony export */
                  i7: () => (
                    /* binding */
                    b
                  )
                  /* harmony export */
                });
                var c = function() {
                  return navigator.userAgent.indexOf("Safari") > -1 && navigator.userAgent.indexOf("Chrome") === -1;
                }, u = function() {
                  return navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
                }, h = function() {
                  try {
                    return typeof localStorage < "u";
                  } catch {
                    return !1;
                  }
                }, f = function() {
                  return navigator.userAgent.indexOf("iPhone") > -1 ? "touchstart" : "click";
                }, m = function(k) {
                  return navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? !!(k.metaKey && !k.ctrlKey) : !!(!k.metaKey && k.ctrlKey);
                }, y = function(k) {
                  return /Mac/.test(navigator.platform) || navigator.platform === "iPhone" ? k.indexOf("⇧") > -1 && u() && (k = k.replace(";", ":").replace("=", "+").replace("-", "_")) : (k.startsWith("⌘") ? k = k.replace("⌘", "⌘+") : k.startsWith("⌥") && k.substr(1, 1) !== "⌘" ? k = k.replace("⌥", "⌥+") : k = k.replace("⇧⌘", "⌘+⇧+").replace("⌥⌘", "⌥+⌘+"), k = k.replace("⌘", "Ctrl").replace("⇧", "Shift").replace("⌥", "Alt"), k.indexOf("Shift") > -1 && (k = k.replace(";", ":").replace("=", "+").replace("-", "_"))), k;
                }, b = function() {
                  return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
                };
              }
            ),
            /***/
            494: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  Wb: () => (
                    /* binding */
                    c
                  ),
                  /* harmony export */
                  on: () => (
                    /* binding */
                    u
                  ),
                  /* harmony export */
                  Qf: () => (
                    /* binding */
                    h
                  )
                  /* harmony export */
                });
                var c = function() {
                  return ([1e7].toString() + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function(f) {
                    return (parseInt(f, 10) ^ window.crypto.getRandomValues(new Uint32Array(1))[0] & 15 >> parseInt(f, 10) / 4).toString(16);
                  });
                }, u = function(f, m) {
                  m === void 0 && (m = window.location.search);
                  var y = m.substring(m.indexOf("?")), b = y.indexOf("#"), k = new URLSearchParams(y.substring(0, b >= 0 ? b : void 0));
                  return k.get(f);
                }, h = function(f) {
                  return Function('"use strict";return ('.concat(f, ")"))();
                };
              }
            ),
            /***/
            106: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  JQ: () => (
                    /* binding */
                    u
                  ),
                  /* harmony export */
                  E2: () => (
                    /* binding */
                    h
                  ),
                  /* harmony export */
                  O9: () => (
                    /* binding */
                    f
                  ),
                  /* harmony export */
                  a1: () => (
                    /* binding */
                    m
                  ),
                  /* harmony export */
                  F9: () => (
                    /* binding */
                    y
                  ),
                  /* harmony export */
                  lG: () => (
                    /* binding */
                    b
                  ),
                  /* harmony export */
                  fb: () => (
                    /* binding */
                    k
                  ),
                  /* harmony export */
                  DX: () => (
                    /* binding */
                    x
                  )
                  /* harmony export */
                });
                var c = l(771), u = function(M, T) {
                  for (var E = k(M, T), C = !1, O = !1; E && !E.classList.contains("vditor-reset") && !O; )
                    C = k(E.parentElement, T), C ? E = C : O = !0;
                  return E || !1;
                }, h = function(M, T) {
                  for (var E = (0, c.S)(M, T), C = !1, O = !1; E && !E.classList.contains("vditor-reset") && !O; )
                    C = (0, c.S)(E.parentElement, T), C ? E = C : O = !0;
                  return E || !1;
                }, f = function(M) {
                  var T = h(M, "UL"), E = h(M, "OL"), C = T;
                  return E && (!T || T && E.contains(T)) && (C = E), C;
                }, m = function(M, T, E) {
                  if (!M)
                    return !1;
                  M.nodeType === 3 && (M = M.parentElement);
                  for (var C = M, O = !1; C && !O && !C.classList.contains("vditor-reset"); )
                    C.getAttribute(T) === E ? O = !0 : C = C.parentElement;
                  return O && C;
                }, y = function(M) {
                  if (!M)
                    return !1;
                  M.nodeType === 3 && (M = M.parentElement);
                  var T = M, E = !1, C = m(M, "data-block", "0");
                  if (C)
                    return C;
                  for (; T && !E && !T.classList.contains("vditor-reset"); )
                    T.tagName === "H1" || T.tagName === "H2" || T.tagName === "H3" || T.tagName === "H4" || T.tagName === "H5" || T.tagName === "H6" || T.tagName === "P" || T.tagName === "BLOCKQUOTE" || T.tagName === "OL" || T.tagName === "UL" ? E = !0 : T = T.parentElement;
                  return E && T;
                }, b = function(M, T) {
                  if (!M)
                    return !1;
                  M.nodeType === 3 && (M = M.parentElement);
                  for (var E = M, C = !1; E && !C && !E.classList.contains("vditor-reset"); )
                    E.nodeName === T ? C = !0 : E = E.parentElement;
                  return C && E;
                }, k = function(M, T) {
                  if (!M)
                    return !1;
                  M.nodeType === 3 && (M = M.parentElement);
                  for (var E = M, C = !1; E && !C && !E.classList.contains("vditor-reset"); )
                    E.classList.contains(T) ? C = !0 : E = E.parentElement;
                  return C && E;
                }, x = function(M) {
                  for (; M && M.lastChild; )
                    M = M.lastChild;
                  return M;
                };
              }
            ),
            /***/
            771: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  S: () => (
                    /* binding */
                    c
                  ),
                  /* harmony export */
                  W: () => (
                    /* binding */
                    u
                  )
                  /* harmony export */
                });
                var c = function(h, f) {
                  if (!h)
                    return !1;
                  h.nodeType === 3 && (h = h.parentElement);
                  for (var m = h, y = !1; m && !y && !m.classList.contains("vditor-reset"); )
                    m.nodeName.indexOf(f) === 0 ? y = !0 : m = m.parentElement;
                  return y && m;
                }, u = function(h) {
                  var f = c(h, "H");
                  return f && f.tagName.length === 2 && f.tagName !== "HR" ? f : !1;
                };
              }
            ),
            /***/
            673: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  T: () => (
                    /* binding */
                    c
                  )
                  /* harmony export */
                });
                var c = function() {
                  for (var u = [], h = 0; h < arguments.length; h++)
                    u[h] = arguments[h];
                  for (var f = {}, m = function(b) {
                    for (var k in b)
                      b.hasOwnProperty(k) && (Object.prototype.toString.call(b[k]) === "[object Object]" ? f[k] = c(f[k], b[k]) : f[k] = b[k]);
                  }, y = 0; y < u.length; y++)
                    m(u[y]);
                  return f;
                };
              }
            ),
            /***/
            810: (
              /***/
              (o, a, l) => {
                l.d(a, {
                  /* harmony export */
                  zh: () => (
                    /* binding */
                    f
                  ),
                  /* harmony export */
                  Ny: () => (
                    /* binding */
                    m
                  ),
                  /* harmony export */
                  Gb: () => (
                    /* binding */
                    y
                  ),
                  /* harmony export */
                  Hc: () => (
                    /* binding */
                    b
                  ),
                  /* harmony export */
                  im: () => (
                    /* binding */
                    k
                  ),
                  /* harmony export */
                  $j: () => (
                    /* binding */
                    x
                  ),
                  /* harmony export */
                  ib: () => (
                    /* binding */
                    M
                  ),
                  /* harmony export */
                  oC: () => (
                    /* binding */
                    T
                  )
                  /* harmony export */
                });
                var c = l(145), u = l(410), h = l(106), f = function(E) {
                  var C, O = E[E.currentMode].element;
                  return getSelection().rangeCount > 0 && (C = getSelection().getRangeAt(0), O.isEqualNode(C.startContainer) || O.contains(C.startContainer)) ? C : E[E.currentMode].range ? E[E.currentMode].range : (O.focus(), C = O.ownerDocument.createRange(), C.setStart(O, 0), C.collapse(!0), C);
                }, m = function(E) {
                  var C = window.getSelection().getRangeAt(0);
                  if (!E.contains(C.startContainer) && !(0, h.fb)(C.startContainer, "vditor-panel--none"))
                    return {
                      left: 0,
                      top: 0
                    };
                  var O = E.parentElement.getBoundingClientRect(), R;
                  if (C.getClientRects().length === 0)
                    if (C.startContainer.nodeType === 3) {
                      var F = C.startContainer.parentElement;
                      if (F && F.getClientRects().length > 0)
                        R = F.getClientRects()[0];
                      else
                        return {
                          left: 0,
                          top: 0
                        };
                    } else {
                      var H = C.startContainer.children;
                      if (H[C.startOffset] && H[C.startOffset].getClientRects().length > 0)
                        R = H[C.startOffset].getClientRects()[0];
                      else if (C.startContainer.childNodes.length > 0) {
                        var z = C.cloneRange();
                        C.selectNode(C.startContainer.childNodes[Math.max(0, C.startOffset - 1)]), R = C.getClientRects()[0], C.setEnd(z.endContainer, z.endOffset), C.setStart(z.startContainer, z.startOffset);
                      } else
                        R = C.startContainer.getClientRects()[0];
                      if (!R) {
                        for (var K = C.startContainer.childNodes[C.startOffset]; !K.getClientRects || K.getClientRects && K.getClientRects().length === 0; )
                          K = K.parentElement;
                        R = K.getClientRects()[0];
                      }
                    }
                  else
                    R = C.getClientRects()[0];
                  return {
                    left: R.left - O.left,
                    top: R.top - O.top
                  };
                }, y = function(E, C) {
                  if (!C) {
                    if (getSelection().rangeCount === 0)
                      return !1;
                    C = getSelection().getRangeAt(0);
                  }
                  var O = C.commonAncestorContainer;
                  return E.isEqualNode(O) || E.contains(O);
                }, b = function(E) {
                  var C = window.getSelection();
                  C.removeAllRanges(), C.addRange(E);
                }, k = function(E, C, O) {
                  var R = {
                    end: 0,
                    start: 0
                  };
                  if (!O) {
                    if (getSelection().rangeCount === 0)
                      return R;
                    O = window.getSelection().getRangeAt(0);
                  }
                  if (y(C, O)) {
                    var F = O.cloneRange();
                    E.childNodes[0] && E.childNodes[0].childNodes[0] ? F.setStart(E.childNodes[0].childNodes[0], 0) : F.selectNodeContents(E), F.setEnd(O.startContainer, O.startOffset), R.start = F.toString().length, R.end = R.start + O.toString().length;
                  }
                  return R;
                }, x = function(E, C, O) {
                  var R = 0, F = 0, H = O.childNodes[F], z = !1, K = !1;
                  E = Math.max(0, E), C = Math.max(0, C);
                  var U = O.ownerDocument.createRange();
                  for (U.setStart(H || O, 0), U.collapse(!0); !K && H; ) {
                    var ae = R + H.textContent.length;
                    if (!z && E >= R && E <= ae && (E === 0 ? U.setStart(H, 0) : H.childNodes[0].nodeType === 3 ? U.setStart(H.childNodes[0], E - R) : H.nextSibling ? U.setStartBefore(H.nextSibling) : U.setStartAfter(H), z = !0, E === C)) {
                      K = !0;
                      break;
                    }
                    z && C >= R && C <= ae && (C === 0 ? U.setEnd(H, 0) : H.childNodes[0].nodeType === 3 ? U.setEnd(H.childNodes[0], C - R) : H.nextSibling ? U.setEndBefore(H.nextSibling) : U.setEndAfter(H), K = !0), R = ae, H = O.childNodes[++F];
                  }
                  return !K && O.childNodes[F - 1] && U.setStartBefore(O.childNodes[F - 1]), b(U), U;
                }, M = function(E, C) {
                  var O = E.querySelector("wbr");
                  if (O) {
                    if (!O.previousElementSibling)
                      O.previousSibling ? C.setStart(O.previousSibling, O.previousSibling.textContent.length) : O.nextSibling ? O.nextSibling.nodeType === 3 ? C.setStart(O.nextSibling, 0) : C.setStartBefore(O.nextSibling) : C.setStart(O.parentElement, 0);
                    else if (O.previousElementSibling.isSameNode(O.previousSibling))
                      if (O.previousElementSibling.lastChild) {
                        C.setStartBefore(O), C.collapse(!0), b(C), (0, u.i7)() && (O.previousElementSibling.tagName === "EM" || O.previousElementSibling.tagName === "STRONG" || O.previousElementSibling.tagName === "S") && (C.insertNode(document.createTextNode(c.g.ZWSP)), C.collapse(!1)), O.remove();
                        return;
                      } else
                        C.setStartAfter(O.previousElementSibling);
                    else
                      C.setStart(O.previousSibling, O.previousSibling.textContent.length);
                    C.collapse(!0), O.remove(), b(C);
                  }
                }, T = function(E, C) {
                  var O = document.createElement("div");
                  O.innerHTML = E;
                  var R = O.querySelectorAll("p");
                  R.length === 1 && !R[0].previousSibling && !R[0].nextSibling && C[C.currentMode].element.children.length > 0 && O.firstElementChild.tagName === "P" && (E = R[0].innerHTML.trim());
                  var F = document.createElement("div");
                  F.innerHTML = E;
                  var H = f(C);
                  if (H.toString() !== "" && (C[C.currentMode].preventInput = !0, document.execCommand("delete", !1, "")), F.firstElementChild && F.firstElementChild.getAttribute("data-block") === "0") {
                    F.lastElementChild.insertAdjacentHTML("beforeend", "<wbr>");
                    var z = (0, h.F9)(H.startContainer);
                    if (!z)
                      C[C.currentMode].element.insertAdjacentHTML("beforeend", F.innerHTML);
                    else {
                      var K = (0, h.lG)(H.startContainer, "LI");
                      K && F.firstElementChild.tagName === "UL" ? K.insertAdjacentHTML("afterend", F.firstElementChild.innerHTML) : z.insertAdjacentHTML("afterend", F.innerHTML);
                    }
                    M(C[C.currentMode].element, H);
                  } else {
                    var U = document.createElement("template");
                    U.innerHTML = E, H.insertNode(U.content.cloneNode(!0)), H.collapse(!1), b(H);
                  }
                };
              }
            )
            /******/
          }, r = {};
          function i(o) {
            var a = r[o];
            if (a !== void 0)
              return a.exports;
            var l = r[o] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return t[o](l, l.exports, i), l.exports;
          }
          i.d = (o, a) => {
            for (var l in a)
              i.o(a, l) && !i.o(o, l) && Object.defineProperty(o, l, { enumerable: !0, get: a[l] });
          }, i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a), i.r = (o) => {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(o, "__esModule", { value: !0 });
          };
          var s = {};
          return (() => {
            i.d(s, {
              default: () => (
                /* binding */
                $_
              )
            });
            var o = i(408), a = i(145), l = i(105), c = function(d) {
              return d.currentMode === "sv" ? (0, l.X)("".concat(d.sv.element.textContent, `
`).replace(/\n\n$/, `
`)) : d.currentMode === "wysiwyg" ? d.lute.VditorDOM2Md(d.wysiwyg.element.innerHTML) : d.currentMode === "ir" ? d.lute.VditorIRDOM2Md(d.ir.element.innerHTML) : "";
            }, u = i(413), h = (
              /** @class */
              function() {
                function d() {
                  this.element = document.createElement("div"), this.element.className = "vditor-devtools", this.element.innerHTML = '<div class="vditor-reset--error"></div><div style="height: 100%;"></div>';
                }
                return d.prototype.renderEchart = function(p) {
                  var g = this;
                  p.devtools.element.style.display === "block" && (0, u.G)("".concat(p.options.cdn, "/dist/js/echarts/echarts.min.js?v=5.5.1"), "vditorEchartsScript").then(function() {
                    g.ASTChart || (g.ASTChart = echarts.init(p.devtools.element.lastElementChild));
                    try {
                      g.element.lastElementChild.style.display = "block", g.element.firstElementChild.innerHTML = "", g.ASTChart.setOption({
                        series: [
                          {
                            data: JSON.parse(p.lute.RenderEChartsJSON(c(p))),
                            initialTreeDepth: -1,
                            label: {
                              align: "left",
                              backgroundColor: "rgba(68, 77, 86, .68)",
                              borderRadius: 3,
                              color: "#d1d5da",
                              fontSize: 12,
                              lineHeight: 12,
                              offset: [9, 12],
                              padding: [2, 4, 2, 4],
                              position: "top",
                              verticalAlign: "middle"
                            },
                            lineStyle: {
                              color: "#4285f4",
                              type: "curve",
                              width: 1
                            },
                            orient: "vertical",
                            roam: !0,
                            type: "tree"
                          }
                        ],
                        toolbox: {
                          bottom: 25,
                          emphasis: {
                            iconStyle: {
                              color: "#4285f4"
                            }
                          },
                          feature: {
                            restore: {
                              show: !0
                            },
                            saveAsImage: {
                              show: !0
                            }
                          },
                          right: 15,
                          show: !0
                        }
                      }), g.ASTChart.resize();
                    } catch (v) {
                      g.element.lastElementChild.style.display = "none", g.element.firstElementChild.innerHTML = v;
                    }
                  });
                }, d;
              }()
            ), f = i(410), m = function(d, p) {
              p.forEach(function(g) {
                if (d[g]) {
                  var v = d[g].children[0];
                  v && v.classList.contains("vditor-menu--current") && v.classList.remove("vditor-menu--current");
                }
              });
            }, y = function(d, p) {
              p.forEach(function(g) {
                if (d[g]) {
                  var v = d[g].children[0];
                  v && !v.classList.contains("vditor-menu--current") && v.classList.add("vditor-menu--current");
                }
              });
            }, b = function(d, p) {
              p.forEach(function(g) {
                if (d[g]) {
                  var v = d[g].children[0];
                  v && v.classList.contains(a.g.CLASS_MENU_DISABLED) && v.classList.remove(a.g.CLASS_MENU_DISABLED);
                }
              });
            }, k = function(d, p) {
              p.forEach(function(g) {
                if (d[g]) {
                  var v = d[g].children[0];
                  v && !v.classList.contains(a.g.CLASS_MENU_DISABLED) && v.classList.add(a.g.CLASS_MENU_DISABLED);
                }
              });
            }, x = function(d, p) {
              p.forEach(function(g) {
                d[g] && d[g] && (d[g].style.display = "none");
              });
            }, M = function(d, p) {
              p.forEach(function(g) {
                d[g] && d[g] && (d[g].style.display = "block");
              });
            }, T = function(d, p, g) {
              p.includes("subToolbar") && (d.toolbar.element.querySelectorAll(".vditor-hint").forEach(function(v) {
                g && v.isEqualNode(g) || (v.style.display = "none");
              }), d.toolbar.elements.emoji && (d.toolbar.elements.emoji.lastElementChild.style.display = "none")), p.includes("hint") && (d.hint.element.style.display = "none"), d.wysiwyg.popover && p.includes("popover") && (d.wysiwyg.popover.style.display = "none");
            }, E = function(d, p, g, v) {
              g.addEventListener((0, f.Le)(), function(w) {
                w.preventDefault(), w.stopPropagation(), !g.classList.contains(a.g.CLASS_MENU_DISABLED) && (d.toolbar.element.querySelectorAll(".vditor-hint--current").forEach(function(S) {
                  S.classList.remove("vditor-hint--current");
                }), p.style.display === "block" ? p.style.display = "none" : (T(d, ["subToolbar", "hint", "popover"], g.parentElement.parentElement), g.classList.contains("vditor-tooltipped") || g.classList.add("vditor-hint--current"), p.style.display = "block", d.toolbar.element.getBoundingClientRect().right - g.getBoundingClientRect().right < 250 ? p.classList.add("vditor-panel--left") : p.classList.remove("vditor-panel--left")));
              });
            }, C = i(106), O = i(771), R = function(d, p, g, v) {
              v && console.log("".concat(d, " - ").concat(g, ": ").concat(p));
            }, F = i(135), H = i(775), z = i(428), K = i(325), U = i(483), ae = i(999), ie = i(472), he = i(637), Ie = i(11), Oe = i(194), Ne = i(229), We = i(825), q = function(d, p, g) {
              g === void 0 && (g = "sv");
              var v = document.createElement("div");
              v.innerHTML = d;
              var w = !1;
              v.childElementCount === 1 && v.lastElementChild.style.fontFamily.indexOf("monospace") > -1 && (w = !0);
              var S = v.querySelectorAll("pre");
              if (v.childElementCount === 1 && S.length === 1 && S[0].className !== "vditor-wysiwyg" && S[0].className !== "vditor-sv" && (w = !0), d.indexOf(`
<p class="p1">`) === 0 && (w = !0), v.childElementCount === 1 && v.firstElementChild.tagName === "TABLE" && v.querySelector(".line-number") && v.querySelector(".line-content") && (w = !0), w) {
                var D = p || d;
                return /\n/.test(D) || S.length === 1 ? g === "wysiwyg" ? '<div class="vditor-wysiwyg__block" data-block="0" data-type="code-block"><pre><code>'.concat(D.replace(/&/g, "&amp;").replace(/</g, "&lt;"), "<wbr></code></pre></div>") : "\n```\n" + D.replace(/&/g, "&amp;").replace(/</g, "&lt;") + "\n```" : g === "wysiwyg" ? "<code>".concat(D.replace(/&/g, "&amp;").replace(/</g, "&lt;"), "</code><wbr>") : "`".concat(D, "`");
              }
              return !1;
            }, Re = function(d, p) {
              if (d) {
                if (d.parentElement.getAttribute("data-type") === "html-block") {
                  d.setAttribute("data-render", "1");
                  return;
                }
                var g = d.firstElementChild.className.replace("language-", "");
                if (g === "abc")
                  (0, F.Q)(d, p.options.cdn);
                else if (g === "mermaid")
                  (0, he.i)(d, p.options.cdn, p.options.theme);
                else if (g === "smiles")
                  (0, We.J)(d, p.options.cdn, p.options.theme);
                else if (g === "markmap")
                  (0, Ie.K)(d, p.options.cdn);
                else if (g === "flowchart")
                  (0, K.P)(d, p.options.cdn);
                else if (g === "echarts")
                  (0, H.p)(d, p.options.cdn, p.options.theme);
                else if (g === "mindmap")
                  (0, Oe.P)(d, p.options.cdn, p.options.theme);
                else if (g === "plantuml")
                  (0, Ne.B)(d, p.options.cdn);
                else if (g === "graphviz")
                  (0, U.v)(d, p.options.cdn);
                else if (g === "math")
                  (0, ie.H)(d, { cdn: p.options.cdn, math: p.options.preview.math });
                else {
                  var v = p.options.customRenders.find(function(w) {
                    if (w.language === g)
                      return w.render(d, p), !0;
                  });
                  v || ((0, ae.s)(Object.assign({}, p.options.preview.hljs), d, p.options.cdn), (0, z.O)(d, p.options.preview.hljs));
                }
                d.setAttribute("data-render", "1");
              }
            }, J = i(810), V = function(d) {
              if (d.currentMode !== "sv") {
                var p = d[d.currentMode].element, g = d.outline.render(d);
                g === "" && (g = "[ToC]"), p.querySelectorAll('[data-type="toc-block"]').forEach(function(v) {
                  v.innerHTML = g, (0, ie.H)(v, {
                    cdn: d.options.cdn,
                    math: d.options.preview.math
                  });
                });
              }
            }, _t = function(d, p) {
              var g = (0, C.lG)(d.target, "SPAN");
              if (g && (0, C.fb)(g, "vditor-toc")) {
                var v = p[p.currentMode].element.querySelector("#" + g.getAttribute("data-target-id"));
                if (v)
                  if (p.options.height === "auto") {
                    var w = v.offsetTop + p.element.offsetTop;
                    p.options.toolbarConfig.pin || (w += p.toolbar.element.offsetHeight), window.scrollTo(window.scrollX, w);
                  } else
                    p.element.offsetTop < window.scrollY && window.scrollTo(window.scrollX, p.element.offsetTop), p[p.currentMode].element.scrollTop = v.offsetTop;
                return;
              }
            }, at = function(d, p, g, v) {
              if (d.previousElementSibling && d.previousElementSibling.classList.contains("vditor-toc")) {
                if (g.key === "Backspace" && (0, J.im)(d, p[p.currentMode].element, v).start === 0)
                  return d.previousElementSibling.remove(), xt(p), !0;
                if (Ge(p, g, v, d, d.previousElementSibling))
                  return !0;
              }
              if (d.nextElementSibling && d.nextElementSibling.classList.contains("vditor-toc")) {
                if (g.key === "Delete" && (0, J.im)(d, p[p.currentMode].element, v).start >= d.textContent.trimRight().length)
                  return d.nextElementSibling.remove(), xt(p), !0;
                if (Nt(p, g, v, d, d.nextElementSibling))
                  return !0;
              }
              if (g.key === "Backspace" || g.key === "Delete") {
                var w = (0, C.fb)(v.startContainer, "vditor-toc");
                if (w)
                  return w.remove(), xt(p), !0;
              }
            }, mt = function(d, p, g, v) {
              g === void 0 && (g = !1);
              var w = (0, C.F9)(p.startContainer);
              if (w && !g && w.getAttribute("data-type") !== "code-block") {
                if (qy(w.innerHTML) && w.previousElementSibling || $y(w.innerHTML))
                  return;
                for (
                  var S = (0, J.im)(w, d.ir.element, p).start, D = !0, I = S - 1;
                  // 软换行后有空格
                  I > w.textContent.substr(0, S).lastIndexOf(`
`);
                  I--
                )
                  if (w.textContent.charAt(I) !== " " && // 多个 tab 前删除不形成代码块 https://github.com/Vanessa219/vditor/issues/162 1
                  w.textContent.charAt(I) !== "	") {
                    D = !1;
                    break;
                  }
                S === 0 && (D = !1);
                for (var B = !0, I = S - 1; I < w.textContent.length; I++)
                  if (w.textContent.charAt(I) !== " " && w.textContent.charAt(I) !== `
`) {
                    B = !1;
                    break;
                  }
                if (D) {
                  typeof d.options.input == "function" && d.options.input(c(d));
                  return;
                }
                if (B && /^#{1,6} $/.test(w.textContent) && (B = !1), B) {
                  var _ = (0, C.fb)(p.startContainer, "vditor-ir__marker");
                  if (!_) {
                    var W = p.startContainer.previousSibling;
                    W && W.nodeType !== 3 && W.classList.contains("vditor-ir__node--expand") && W.classList.remove("vditor-ir__node--expand"), typeof d.options.input == "function" && d.options.input(c(d));
                    return;
                  }
                }
              }
              if (d.ir.element.querySelectorAll(".vditor-ir__node--expand").forEach(function(bt) {
                bt.classList.remove("vditor-ir__node--expand");
              }), w || (w = d.ir.element), !w.querySelector("wbr")) {
                var Z = (0, C.fb)(p.startContainer, "vditor-ir__preview");
                Z ? Z.previousElementSibling.insertAdjacentHTML("beforeend", "<wbr>") : p.insertNode(document.createElement("wbr"));
              }
              w.querySelectorAll("[style]").forEach(function(bt) {
                bt.removeAttribute("style");
              }), w.getAttribute("data-type") === "link-ref-defs-block" && (w = d.ir.element);
              var ye = w.isEqualNode(d.ir.element), ve = (0, C.a1)(w, "data-type", "footnotes-block"), fe = "";
              if (ye)
                fe = w.innerHTML;
              else {
                var Ae = (0, O.S)(p.startContainer, "BLOCKQUOTE"), Me = (0, C.O9)(p.startContainer);
                if (Me && (w = Me), Ae && (!Me || Me && !Ae.contains(Me)) && (w = Ae), ve && (w = ve), fe = w.outerHTML, w.tagName === "UL" || w.tagName === "OL") {
                  var de = w.previousElementSibling, Je = w.nextElementSibling;
                  de && (de.tagName === "UL" || de.tagName === "OL") && (fe = de.outerHTML + fe, de.remove()), Je && (Je.tagName === "UL" || Je.tagName === "OL") && (fe = fe + Je.outerHTML, Je.remove()), fe = fe.replace("<div><wbr><br></div>", "<li><p><wbr><br></p></li>");
                } else w.previousElementSibling && w.previousElementSibling.textContent.replace(a.g.ZWSP, "") !== "" && v && v.inputType === "insertParagraph" && (fe = w.previousElementSibling.outerHTML + fe, w.previousElementSibling.remove());
                w.innerText.startsWith("```") || (d.ir.element.querySelectorAll("[data-type='link-ref-defs-block']").forEach(function(bt) {
                  bt && !w.isEqualNode(bt) && (fe += bt.outerHTML, bt.remove());
                }), d.ir.element.querySelectorAll("[data-type='footnotes-block']").forEach(function(bt) {
                  bt && !w.isEqualNode(bt) && (fe += bt.outerHTML, bt.remove());
                }));
              }
              if (R("SpinVditorIRDOM", fe, "argument", d.options.debugger), fe = d.lute.SpinVditorIRDOM(fe), R("SpinVditorIRDOM", fe, "result", d.options.debugger), ye)
                w.innerHTML = fe;
              else if (w.outerHTML = fe, ve) {
                var De = (0, C.a1)(d.ir.element.querySelector("wbr"), "data-type", "footnotes-def");
                if (De) {
                  var nt = De.textContent, Yt = nt.substring(1, nt.indexOf("]:")), jt = d.ir.element.querySelector('sup[data-type="footnotes-ref"][data-footnotes-label="'.concat(Yt, '"]'));
                  jt && jt.setAttribute("aria-label", nt.substr(Yt.length + 3).trim().substr(0, 24));
                }
              }
              var sn, qr = d.ir.element.querySelectorAll("[data-type='link-ref-defs-block']");
              qr.forEach(function(bt, Hn) {
                Hn === 0 ? sn = bt : (sn.insertAdjacentHTML("beforeend", bt.innerHTML), bt.remove());
              }), qr.length > 0 && d.ir.element.insertAdjacentElement("beforeend", qr[0]);
              var sr, $r = d.ir.element.querySelectorAll("[data-type='footnotes-block']");
              $r.forEach(function(bt, Hn) {
                Hn === 0 ? sr = bt : (sr.insertAdjacentHTML("beforeend", bt.innerHTML), bt.remove());
              }), $r.length > 0 && d.ir.element.insertAdjacentElement("beforeend", $r[0]), (0, J.ib)(d.ir.element, p), d.ir.element.querySelectorAll(".vditor-ir__preview[data-render='2']").forEach(function(bt) {
                Re(bt, d);
              }), V(d), Mo(d, {
                enableAddUndoStack: !0,
                enableHint: !0,
                enableInput: !0
              });
            }, le = function(d, p) {
              if (d === "")
                return !1;
              if (d.indexOf("⇧") === -1 && d.indexOf("⌘") === -1 && d.indexOf("⌥") === -1)
                return !(0, f.yl)(p) && !p.altKey && !p.shiftKey && p.code === d;
              if (d === "⇧Tab")
                return !!(!(0, f.yl)(p) && !p.altKey && p.shiftKey && p.code === "Tab");
              var g = d.split("");
              if (d.startsWith("⌥")) {
                var v = g.length === 3 ? g[2] : g[1];
                return !!((g.length === 3 ? (0, f.yl)(p) : !(0, f.yl)(p)) && p.altKey && !p.shiftKey && p.code === (/^[0-9]$/.test(v) ? "Digit" : "Key") + v);
              }
              d === "⌘Enter" && (g = ["⌘", "Enter"]);
              var w = g.length > 2 && g[0] === "⇧", S = w ? g[2] : g[1];
              return w && ((0, f.vU)() || !/Mac/.test(navigator.platform)) && (S === "-" ? S = "_" : S === "=" && (S = "+")), !!((0, f.yl)(p) && p.key.toLowerCase() === S.toLowerCase() && !p.altKey && (!w && !p.shiftKey || w && p.shiftKey));
            }, tt = function(d) {
              var p = d.startContainer;
              if (p.nodeType === 3 && p.nodeValue.length !== d.startOffset)
                return !1;
              for (var g = p.nextSibling; g && g.textContent === ""; )
                g = g.nextSibling;
              if (g) {
                if (g && g.nodeType !== 3 && g.classList.contains("vditor-ir__node") && !g.getAttribute("data-block"))
                  return g;
              } else {
                var v = (0, C.fb)(p, "vditor-ir__marker");
                if (v && !v.nextSibling) {
                  var w = p.parentElement.parentElement.nextSibling;
                  if (w && w.nodeType !== 3 && w.classList.contains("vditor-ir__node"))
                    return w;
                }
                return !1;
              }
              return !1;
            }, xe = function(d) {
              var p = d.startContainer, g = p.previousSibling;
              return p.nodeType === 3 && d.startOffset === 0 && g && g.nodeType !== 3 && // *em*|text
              g.classList.contains("vditor-ir__node") && !g.getAttribute("data-block") ? g : !1;
            }, ge = function(d, p) {
              p.ir.element.querySelectorAll(".vditor-ir__node--expand").forEach(function(D) {
                D.classList.remove("vditor-ir__node--expand");
              });
              var g = (0, C.JQ)(d.startContainer, "vditor-ir__node"), v = !d.collapsed && (0, C.JQ)(d.endContainer, "vditor-ir__node");
              if (!(!d.collapsed && (!g || g !== v))) {
                g && (g.classList.add("vditor-ir__node--expand"), g.classList.remove("vditor-ir__node--hidden"), (0, J.Hc)(d));
                var w = tt(d);
                if (w) {
                  w.classList.add("vditor-ir__node--expand"), w.classList.remove("vditor-ir__node--hidden");
                  return;
                }
                var S = xe(d);
                if (S) {
                  S.classList.add("vditor-ir__node--expand"), S.classList.remove("vditor-ir__node--hidden");
                  return;
                }
              }
            }, Ot = function(d, p) {
              if (d.ir.composingLock = p.isComposing, p.isComposing)
                return !1;
              p.key.indexOf("Arrow") === -1 && p.key !== "Meta" && p.key !== "Control" && p.key !== "Alt" && p.key !== "Shift" && p.key !== "CapsLock" && p.key !== "Escape" && !/^F\d{1,2}$/.test(p.key) && d.undo.recordFirstPosition(d, p);
              var g = (0, J.zh)(d), v = g.startContainer;
              if (!Co(p, d, v) || (gp(g, d, p), $6(g), p.key !== "Enter" && p.key !== "Tab" && p.key !== "Backspace" && p.key.indexOf("Arrow") === -1 && !(0, f.yl)(p) && p.key !== "Escape" && p.key !== "Delete"))
                return !1;
              var w = (0, C.a1)(v, "data-newline", "1");
              if (!(0, f.yl)(p) && !p.altKey && !p.shiftKey && p.key === "Enter" && w && g.startOffset < w.textContent.length) {
                var S = w.previousElementSibling;
                S && (g.insertNode(document.createTextNode(S.textContent)), g.collapse(!1));
                var D = w.nextSibling;
                D && (g.insertNode(document.createTextNode(D.textContent)), g.collapse(!0));
              }
              var I = (0, C.lG)(v, "P");
              if (I6(p, d, I, g) || N6(g, d, I, p) || F6(d, g, p, I))
                return !0;
              var B = (0, C.fb)(v, "vditor-ir__marker--pre");
              if (B && B.tagName === "PRE") {
                var _ = B.firstChild;
                if (z6(d, p, B, g) || (_.getAttribute("data-type") === "math-block" || _.getAttribute("data-type") === "html-block") && Ge(d, p, g, _, B.parentElement) || Nt(d, p, g, _, B.parentElement))
                  return !0;
              }
              var W = (0, C.a1)(v, "data-type", "code-block-info");
              if (W) {
                if (p.key === "Enter" || p.key === "Tab")
                  return g.selectNodeContents(W.nextElementSibling.firstChild), g.collapse(!0), p.preventDefault(), T(d, ["hint"]), !0;
                if (p.key === "Backspace") {
                  var Z = (0, J.im)(W, d.ir.element).start;
                  Z === 1 && g.setStart(v, 0), Z === 2 && (d.hint.recentLanguage = "");
                }
                if (Ge(d, p, g, W, W.parentElement))
                  return T(d, ["hint"]), !0;
              }
              var ye = (0, C.lG)(v, "TD") || (0, C.lG)(v, "TH");
              if (p.key.indexOf("Arrow") > -1 && ye) {
                var ve = Al(ye);
                if (ve && Ge(d, p, g, ye, ve))
                  return !0;
                var fe = El(ye);
                if (fe && Nt(d, p, g, ye, fe))
                  return !0;
              }
              if (H6(d, p, g) || V6(d, g, p) || jy(d, g, p))
                return !0;
              var Ae = (0, O.W)(v);
              if (Ae) {
                if (le("⌘=", p)) {
                  var Me = Ae.querySelector(".vditor-ir__marker--heading");
                  return Me && Me.textContent.trim().length > 1 && Gh(d, Me.textContent.substr(1)), p.preventDefault(), !0;
                }
                if (le("⌘-", p)) {
                  var Me = Ae.querySelector(".vditor-ir__marker--heading");
                  return Me && Me.textContent.trim().length < 6 && Gh(d, Me.textContent.trim() + "# "), p.preventDefault(), !0;
                }
              }
              var de = (0, C.F9)(v);
              if (p.key === "Backspace" && !(0, f.yl)(p) && !p.shiftKey && !p.altKey && g.toString() === "") {
                if (q6(d, g, p, I))
                  return !0;
                if (de && de.previousElementSibling && de.tagName !== "UL" && de.tagName !== "OL" && (de.previousElementSibling.getAttribute("data-type") === "code-block" || de.previousElementSibling.getAttribute("data-type") === "math-block")) {
                  var Je = (0, J.im)(de, d.ir.element, g).start;
                  if (Je === 0 || Je === 1 && de.innerText.startsWith(a.g.ZWSP))
                    return g.selectNodeContents(de.previousElementSibling.querySelector(".vditor-ir__marker--pre code")), g.collapse(!1), ge(g, d), de.textContent.trim().replace(a.g.ZWSP, "") === "" && (de.remove(), Mo(d)), p.preventDefault(), !0;
                }
                if (Ae) {
                  var De = Ae.firstElementChild.textContent.length;
                  (0, J.im)(Ae, d.ir.element).start === De && De !== 0 && (g.setStart(Ae.firstElementChild.firstChild, De - 1), g.collapse(!0), (0, J.Hc)(g));
                }
              }
              return (p.key === "ArrowUp" || p.key === "ArrowDown") && de && (de.querySelectorAll(".vditor-ir__node").forEach(function(nt) {
                nt.contains(v) || nt.classList.add("vditor-ir__node--hidden");
              }), j6(p, de, g)) ? !0 : (yp(g, p.key), de && at(de, d, p, g) ? (p.preventDefault(), !0) : !1);
            }, Ee = i(190), Ft = function(d, p) {
              d.querySelectorAll("[data-type=footnotes-link]").forEach(function(g) {
                for (var v = g.parentElement, w = v.nextSibling; w && w.textContent.startsWith("    "); ) {
                  var S = w;
                  S.childNodes.forEach(function(D) {
                    v.append(D.cloneNode(!0));
                  }), w = w.nextSibling, S.remove();
                }
                p && p(v);
              });
            }, ft = function(d, p) {
              var g, v = getSelection().getRangeAt(0).cloneRange(), w = v.startContainer;
              v.startContainer.nodeType !== 3 && v.startContainer.tagName === "DIV" && (w = v.startContainer.childNodes[v.startOffset - 1]);
              var S = (0, C.a1)(w, "data-block", "0");
              if (S && p && (p.inputType === "deleteContentBackward" || p.data === " ")) {
                for (
                  var D = (0, J.im)(S, d.sv.element, v).start, I = !0, B = D - 1;
                  // 软换行后有空格
                  B > S.textContent.substr(0, D).lastIndexOf(`
`);
                  B--
                )
                  if (S.textContent.charAt(B) !== " " && // 多个 tab 前删除不形成代码块 https://github.com/Vanessa219/vditor/issues/162 1
                  S.textContent.charAt(B) !== "	") {
                    I = !1;
                    break;
                  }
                if (D === 0 && (I = !1), I) {
                  gt(d);
                  return;
                }
                if (p.inputType === "deleteContentBackward") {
                  var _ = (0, C.a1)(w, "data-type", "code-block-open-marker") || (0, C.a1)(w, "data-type", "code-block-close-marker");
                  if (_) {
                    if (_.getAttribute("data-type") === "code-block-close-marker") {
                      var W = Ve(w, "code-block-open-marker");
                      if (W) {
                        W.textContent = _.textContent, gt(d);
                        return;
                      }
                    }
                    if (_.getAttribute("data-type") === "code-block-open-marker") {
                      var W = Ve(w, "code-block-close-marker", !1);
                      if (W) {
                        W.textContent = _.textContent, gt(d);
                        return;
                      }
                    }
                  }
                  var Z = (0, C.a1)(w, "data-type", "math-block-open-marker");
                  if (Z) {
                    var ye = Z.nextElementSibling.nextElementSibling;
                    ye && ye.getAttribute("data-type") === "math-block-close-marker" && (ye.remove(), gt(d));
                    return;
                  }
                  S.querySelectorAll('[data-type="code-block-open-marker"]').forEach(function(de) {
                    de.textContent.length === 1 && de.remove();
                  }), S.querySelectorAll('[data-type="code-block-close-marker"]').forEach(function(de) {
                    de.textContent.length === 1 && de.remove();
                  });
                  var ve = (0, C.a1)(w, "data-type", "heading-marker");
                  if (ve && ve.textContent.indexOf("#") === -1) {
                    gt(d);
                    return;
                  }
                }
                if ((p.data === " " || p.inputType === "deleteContentBackward") && ((0, C.a1)(w, "data-type", "padding") || (0, C.a1)(w, "data-type", "li-marker") || (0, C.a1)(w, "data-type", "task-marker") || (0, C.a1)(w, "data-type", "blockquote-marker"))) {
                  gt(d);
                  return;
                }
              }
              if (S && S.textContent.trimRight() === "$$") {
                gt(d);
                return;
              }
              S || (S = d.sv.element), ((g = S.firstElementChild) === null || g === void 0 ? void 0 : g.getAttribute("data-type")) === "link-ref-defs-block" && (S = d.sv.element), (0, C.a1)(w, "data-type", "footnotes-link") && (S = d.sv.element), S.textContent.indexOf(Lute.Caret) === -1 && v.insertNode(document.createTextNode(Lute.Caret)), S.querySelectorAll("[style]").forEach(function(de) {
                de.removeAttribute("style");
              }), S.querySelectorAll("font").forEach(function(de) {
                de.outerHTML = de.innerHTML;
              });
              var fe = S.textContent, Ae = S.isEqualNode(d.sv.element);
              if (Ae)
                fe = S.textContent;
              else {
                S.previousElementSibling && (fe = S.previousElementSibling.textContent + fe, S.previousElementSibling.remove()), S.previousElementSibling && fe.indexOf(`---
`) === 0 && (fe = S.previousElementSibling.textContent + fe, S.previousElementSibling.remove());
                var Me = "";
                d.sv.element.querySelectorAll("[data-type='link-ref-defs-block']").forEach(function(de, Je) {
                  de && !S.isEqualNode(de.parentElement) && (Me += de.parentElement.textContent + `
`, de.parentElement.remove());
                }), d.sv.element.querySelectorAll("[data-type='footnotes-link']").forEach(function(de, Je) {
                  de && !S.isEqualNode(de.parentElement) && (Me += de.parentElement.textContent + `
`, de.parentElement.remove());
                }), fe = Me + fe;
              }
              fe = qt(fe, d), Ae ? S.innerHTML = fe : S.outerHTML = fe, d.sv.element.querySelectorAll("[data-type='link-ref-defs-block']").forEach(function(de) {
                d.sv.element.insertAdjacentElement("beforeend", de.parentElement);
              }), Ft(d.sv.element, function(de) {
                d.sv.element.insertAdjacentElement("beforeend", de);
              }), (0, J.ib)(d.sv.element, v), un(d), gt(d, {
                enableAddUndoStack: !0,
                enableHint: !0,
                enableInput: !0
              });
            }, Vt = function(d, p) {
              var g, v, w, S, D;
              if (d.sv.composingLock = p.isComposing, p.isComposing || (p.key.indexOf("Arrow") === -1 && p.key !== "Meta" && p.key !== "Control" && p.key !== "Alt" && p.key !== "Shift" && p.key !== "CapsLock" && p.key !== "Escape" && !/^F\d{1,2}$/.test(p.key) && d.undo.recordFirstPosition(d, p), p.key !== "Enter" && p.key !== "Tab" && p.key !== "Backspace" && p.key.indexOf("Arrow") === -1 && !(0, f.yl)(p) && p.key !== "Escape"))
                return !1;
              var I = (0, J.zh)(d), B = I.startContainer;
              I.startContainer.nodeType !== 3 && I.startContainer.tagName === "DIV" && (B = I.startContainer.childNodes[I.startOffset - 1]);
              var _ = (0, C.a1)(B, "data-type", "text"), W = (0, C.a1)(B, "data-type", "blockquote-marker");
              if (!W && I.startOffset === 0 && _ && _.previousElementSibling && _.previousElementSibling.getAttribute("data-type") === "blockquote-marker" && (W = _.previousElementSibling), W && p.key === "Enter" && !(0, f.yl)(p) && !p.altKey && W.nextElementSibling.textContent.trim() === "" && (0, J.im)(W, d.sv.element, I).start === W.textContent.length)
                return ((g = W.previousElementSibling) === null || g === void 0 ? void 0 : g.getAttribute("data-type")) === "padding" && W.previousElementSibling.setAttribute("data-action", "enter-remove"), W.remove(), gt(d), p.preventDefault(), !0;
              var Z = (0, C.a1)(B, "data-type", "li-marker"), ye = (0, C.a1)(B, "data-type", "task-marker"), ve = Z;
              if (ve || ye && ye.nextElementSibling.getAttribute("data-type") !== "task-marker" && (ve = ye), !ve && I.startOffset === 0 && _ && _.previousElementSibling && (_.previousElementSibling.getAttribute("data-type") === "li-marker" || _.previousElementSibling.getAttribute("data-type") === "task-marker") && (ve = _.previousElementSibling), ve) {
                var fe = (0, J.im)(ve, d.sv.element, I).start, Ae = ve.getAttribute("data-type") === "task-marker", Me = ve;
                if (Ae && (Me = ve.previousElementSibling.previousElementSibling.previousElementSibling), fe === ve.textContent.length) {
                  if (p.key === "Enter" && !(0, f.yl)(p) && !p.altKey && !p.shiftKey && ve.nextElementSibling.textContent.trim() === "")
                    return ((v = Me.previousElementSibling) === null || v === void 0 ? void 0 : v.getAttribute("data-type")) === "padding" ? (Me.previousElementSibling.remove(), ft(d)) : (Ae && (Me.remove(), ve.previousElementSibling.previousElementSibling.remove(), ve.previousElementSibling.remove()), ve.nextElementSibling.remove(), ve.remove(), gt(d)), p.preventDefault(), !0;
                  if (p.key === "Tab")
                    return p.shiftKey ? Me.previousElementSibling.getAttribute("data-type") === "padding" && Me.previousElementSibling.remove() : Me.insertAdjacentHTML("beforebegin", '<span data-type="padding">'.concat(Me.textContent.replace(/\S/g, " "), "</span>")), /^\d/.test(Me.textContent) && (Me.textContent = Me.textContent.replace(/^\d{1,}/, "1"), I.selectNodeContents(ve.firstChild), I.collapse(!1)), ft(d), p.preventDefault(), !0;
                }
              }
              if (jy(d, I, p))
                return !0;
              var de = (0, C.a1)(B, "data-block", "0"), Je = (0, O.S)(B, "SPAN");
              if (p.key === "Enter" && !(0, f.yl)(p) && !p.altKey && !p.shiftKey && de) {
                var De = !1, nt = de.textContent.match(/^\n+/);
                (0, J.im)(de, d.sv.element).start <= (nt ? nt[0].length : 0) && (De = !0);
                var Yt = `
`;
                if (Je) {
                  if (((w = Je.previousElementSibling) === null || w === void 0 ? void 0 : w.getAttribute("data-action")) === "enter-remove")
                    return Je.previousElementSibling.remove(), gt(d), p.preventDefault(), !0;
                  Yt += Nn(Je);
                }
                return I.insertNode(document.createTextNode(Yt)), I.collapse(!1), de && de.textContent.trim() !== "" && !De ? ft(d) : gt(d), p.preventDefault(), !0;
              }
              if (p.key === "Backspace" && !(0, f.yl)(p) && !p.altKey && !p.shiftKey) {
                if (Je && ((S = Je.previousElementSibling) === null || S === void 0 ? void 0 : S.getAttribute("data-type")) === "newline" && (0, J.im)(Je, d.sv.element, I).start === 1 && // 飘号的处理需在 inputEvent 中，否则上下飘号对不齐
                Je.getAttribute("data-type").indexOf("code-block-") === -1)
                  return I.setStart(Je, 0), I.extractContents(), Je.textContent.trim() !== "" ? ft(d) : gt(d), p.preventDefault(), !0;
                if (de && (0, J.im)(de, d.sv.element, I).start === 0 && de.previousElementSibling) {
                  I.extractContents();
                  var jt = de.previousElementSibling.lastElementChild;
                  return jt.getAttribute("data-type") === "newline" && (jt.remove(), jt = de.previousElementSibling.lastElementChild), jt.getAttribute("data-type") !== "newline" && (jt.insertAdjacentHTML("afterend", de.innerHTML), de.remove()), de.textContent.trim() !== "" && !(!((D = de.previousElementSibling) === null || D === void 0) && D.querySelector('[data-type="code-block-open-marker"]')) ? ft(d) : (jt.getAttribute("data-type") !== "newline" && (I.selectNodeContents(jt.lastChild), I.collapse(!1)), gt(d)), p.preventDefault(), !0;
                }
              }
              return !1;
            }, Ue = i(538), yt = function(d) {
              d.options.theme === "dark" ? d.element.classList.add("vditor--dark") : d.element.classList.remove("vditor--dark");
            }, Ut = function(d) {
              d.element.innerHTML = "", d.element.classList.add("vditor"), d.options.rtl && d.element.setAttribute("dir", "rtl"), yt(d), (0, Ue.Z)(d.options.preview.theme.current, d.options.preview.theme.path), typeof d.options.height == "number" ? d.element.style.height = d.options.height + "px" : d.element.style.height = d.options.height, typeof d.options.minHeight == "number" && (d.element.style.minHeight = d.options.minHeight + "px"), typeof d.options.width == "number" ? d.element.style.width = d.options.width + "px" : d.element.style.width = d.options.width, d.element.appendChild(d.toolbar.element);
              var p = document.createElement("div");
              if (p.className = "vditor-content", d.options.outline.position === "left" && p.appendChild(d.outline.element), p.appendChild(d.wysiwyg.element.parentElement), p.appendChild(d.sv.element), p.appendChild(d.ir.element.parentElement), p.appendChild(d.preview.element), d.toolbar.elements.devtools && p.appendChild(d.devtools.element), d.options.outline.position === "right" && (d.outline.element.classList.add("vditor-outline--right"), p.appendChild(d.outline.element)), d.upload && p.appendChild(d.upload.element), d.options.resize.enable && p.appendChild(d.resize.element), p.appendChild(d.hint.element), p.appendChild(d.tip.element), d.element.appendChild(p), p.addEventListener("click", function() {
                T(d, ["subToolbar"]);
              }), d.toolbar.elements.export && d.element.insertAdjacentHTML("beforeend", '<iframe id="vditorExportIframe" style="width: 100%;height: 0;border: 0"></iframe>'), hi(d, d.options.mode, Ns(d)), document.execCommand("DefaultParagraphSeparator", !1, "p"), navigator.userAgent.indexOf("iPhone") > -1 && typeof window.visualViewport < "u") {
                var g = !1, v = function(w) {
                  g || (g = !0, requestAnimationFrame(function() {
                    g = !1;
                    var S = d.toolbar.element;
                    S.style.transform = "none", S.getBoundingClientRect().top < 0 && (S.style.transform = "translate(0, ".concat(-S.getBoundingClientRect().top, "px)"));
                  }));
                };
                window.visualViewport.addEventListener("scroll", v), window.visualViewport.addEventListener("resize", v);
              }
            }, Kt = function(d) {
              var p = window.innerWidth <= a.g.MOBILE_WIDTH ? 10 : 35;
              if (d.wysiwyg.element.parentElement.style.display !== "none") {
                var g = (d.wysiwyg.element.parentElement.clientWidth - d.options.preview.maxWidth) / 2;
                d.wysiwyg.element.style.padding = "10px ".concat(Math.max(p, g), "px");
              }
              if (d.ir.element.parentElement.style.display !== "none") {
                var g = (d.ir.element.parentElement.clientWidth - d.options.preview.maxWidth) / 2;
                d.ir.element.style.padding = "10px ".concat(Math.max(p, g), "px");
              }
              d.preview.element.style.display !== "block" ? d.toolbar.element.style.paddingLeft = Math.max(5, parseInt(d[d.currentMode].element.style.paddingLeft || "0", 10) + (d.options.outline.position === "left" ? d.outline.element.offsetWidth : 0)) + "px" : d.toolbar.element.style.paddingLeft = 5 + (d.options.outline.position === "left" ? d.outline.element.offsetWidth : 0) + "px";
            }, ci = function(d) {
              if (d.options.typewriterMode) {
                var p = window.innerHeight;
                typeof d.options.height == "number" ? (p = d.options.height, typeof d.options.minHeight == "number" && (p = Math.max(p, d.options.minHeight)), p = Math.min(window.innerHeight, p)) : p = d.element.clientHeight, d.element.classList.contains("vditor--fullscreen") && (p = window.innerHeight), d[d.currentMode].element.style.setProperty("--editor-bottom", (p - d.toolbar.element.offsetHeight) / 2 + "px");
              }
            }, Ds;
            function yo() {
              window.removeEventListener("resize", Ds);
            }
            var Ns = function(d) {
              ci(d), yo(), window.addEventListener("resize", Ds = function() {
                Kt(d), ci(d);
              });
              var p = (0, f.pK)() && localStorage.getItem(d.options.cache.id);
              return (!d.options.cache.enable || !p) && (d.options.value ? p = d.options.value : d.originalInnerHTML ? p = d.lute.HTML2Md(d.originalInnerHTML) : d.options.cache.enable || (p = "")), p || "";
            }, mr = function(d) {
              clearTimeout(d[d.currentMode].hlToolbarTimeoutId), d[d.currentMode].hlToolbarTimeoutId = window.setTimeout(function() {
                if (d[d.currentMode].element.getAttribute("contenteditable") !== "false" && (0, J.Gb)(d[d.currentMode].element)) {
                  m(d.toolbar.elements, a.g.EDIT_TOOLBARS), b(d.toolbar.elements, a.g.EDIT_TOOLBARS);
                  var p = (0, J.zh)(d), g = p.startContainer;
                  p.startContainer.nodeType === 3 && (g = p.startContainer.parentElement), g.classList.contains("vditor-reset") && (g = g.childNodes[p.startOffset]);
                  var v = d.currentMode === "sv" ? (0, C.a1)(g, "data-type", "heading") : (0, O.W)(g);
                  v && y(d.toolbar.elements, ["headings"]);
                  var w = d.currentMode === "sv" ? (0, C.a1)(g, "data-type", "blockquote") : (0, C.lG)(g, "BLOCKQUOTE");
                  w && y(d.toolbar.elements, ["quote"]);
                  var S = (0, C.a1)(g, "data-type", "strong");
                  S && y(d.toolbar.elements, ["bold"]);
                  var D = (0, C.a1)(g, "data-type", "em");
                  D && y(d.toolbar.elements, ["italic"]);
                  var I = (0, C.a1)(g, "data-type", "s");
                  I && y(d.toolbar.elements, ["strike"]);
                  var B = (0, C.a1)(g, "data-type", "a");
                  B && y(d.toolbar.elements, ["link"]);
                  var _ = (0, C.lG)(g, "LI");
                  _ ? (_.classList.contains("vditor-task") ? y(d.toolbar.elements, ["check"]) : _.parentElement.tagName === "OL" ? y(d.toolbar.elements, ["ordered-list"]) : _.parentElement.tagName === "UL" && y(d.toolbar.elements, ["list"]), b(d.toolbar.elements, ["outdent", "indent"])) : k(d.toolbar.elements, ["outdent", "indent"]);
                  var W = (0, C.a1)(g, "data-type", "code-block");
                  W && (k(d.toolbar.elements, [
                    "headings",
                    "bold",
                    "italic",
                    "strike",
                    "line",
                    "quote",
                    "list",
                    "ordered-list",
                    "check",
                    "code",
                    "inline-code",
                    "upload",
                    "link",
                    "table",
                    "record"
                  ]), y(d.toolbar.elements, ["code"]));
                  var Z = (0, C.a1)(g, "data-type", "code");
                  Z && (k(d.toolbar.elements, [
                    "headings",
                    "bold",
                    "italic",
                    "strike",
                    "line",
                    "quote",
                    "list",
                    "ordered-list",
                    "check",
                    "code",
                    "upload",
                    "link",
                    "table",
                    "record"
                  ]), y(d.toolbar.elements, ["inline-code"]));
                  var ye = (0, C.a1)(g, "data-type", "table");
                  ye && k(d.toolbar.elements, [
                    "headings",
                    "list",
                    "ordered-list",
                    "check",
                    "line",
                    "quote",
                    "code",
                    "table"
                  ]);
                }
              }, 200);
            }, kt = function(d, p) {
              p === void 0 && (p = {
                enableAddUndoStack: !0,
                enableHint: !1,
                enableInput: !0
              }), p.enableHint && d.hint.render(d), clearTimeout(d.wysiwyg.afterRenderTimeoutId), d.wysiwyg.afterRenderTimeoutId = window.setTimeout(function() {
                if (!d.wysiwyg.composingLock) {
                  var g = c(d);
                  typeof d.options.input == "function" && p.enableInput && d.options.input(g), d.options.counter.enable && d.counter.render(d, g), d.options.cache.enable && (0, f.pK)() && (localStorage.setItem(d.options.cache.id, g), d.options.cache.after && d.options.cache.after(g)), d.devtools && d.devtools.renderEchart(d), p.enableAddUndoStack && d.undo.addToUndoStack(d);
                }
              }, d.options.undoDelay);
            }, ne = function(d) {
              for (var p = d.previousSibling; p; ) {
                if (p.nodeType !== 3 && p.tagName === "A" && !p.previousSibling && p.innerHTML.replace(a.g.ZWSP, "") === "" && p.nextSibling)
                  return p;
                p = p.previousSibling;
              }
              return !1;
            }, Ce = function(d) {
              for (var p = d.startContainer.nextSibling; p && p.textContent === ""; )
                p = p.nextSibling;
              return !!(p && p.nodeType !== 3 && (p.tagName === "CODE" || p.getAttribute("data-type") === "math-inline" || p.getAttribute("data-type") === "html-entity" || p.getAttribute("data-type") === "html-inline"));
            }, it = function(d) {
              for (var p = "", g = d.nextSibling; g; )
                g.nodeType === 3 ? p += g.textContent : p += g.outerHTML, g = g.nextSibling;
              return p;
            }, dt = function(d) {
              for (var p = "", g = d.previousSibling; g; )
                g.nodeType === 3 ? p = g.textContent + p : p = g.outerHTML + p, g = g.previousSibling;
              return p;
            }, Dt = function(d) {
              for (var p = d; p && !p.nextSibling; )
                p = p.parentElement;
              return p.nextSibling;
            }, Un = function(d) {
              var p = dt(d.startContainer), g = it(d.startContainer), v = d.startContainer.textContent, w = d.startOffset, S = "", D = "";
              return (v.substr(0, w) !== "" && v.substr(0, w) !== a.g.ZWSP || p) && (S = "".concat(p).concat(v.substr(0, w))), (v.substr(w) !== "" && v.substr(w) !== a.g.ZWSP || g) && (D = "".concat(v.substr(w)).concat(g)), {
                afterHTML: D,
                beforeHTML: S
              };
            }, Kn = function(d, p) {
              Array.from(d.wysiwyg.element.childNodes).find(function(g) {
                if (g.nodeType === 3) {
                  var v = document.createElement("p");
                  v.setAttribute("data-block", "0"), v.textContent = g.textContent;
                  var w = p.startContainer.nodeType === 3 ? p.startOffset : g.textContent.length;
                  return g.parentNode.insertBefore(v, g), g.remove(), p.setStart(v.firstChild, Math.min(v.firstChild.textContent.length, w)), p.collapse(!0), (0, J.Hc)(p), !0;
                } else if (!g.getAttribute("data-block"))
                  return g.tagName === "P" ? g.remove() : (g.tagName === "DIV" ? (p.insertNode(document.createElement("wbr")), g.outerHTML = '<p data-block="0">'.concat(g.innerHTML, "</p>")) : g.tagName === "BR" ? g.outerHTML = '<p data-block="0">'.concat(g.outerHTML, "<wbr></p>") : (p.insertNode(document.createElement("wbr")), g.outerHTML = '<p data-block="0">'.concat(g.outerHTML, "</p>")), (0, J.ib)(d.wysiwyg.element, p), p = getSelection().getRangeAt(0)), !0;
              });
            }, Cn = function(d, p) {
              var g = (0, J.zh)(d), v = (0, C.F9)(g.startContainer);
              v || (v = g.startContainer.childNodes[g.startOffset]), !v && d.wysiwyg.element.children.length === 0 && (v = d.wysiwyg.element), v && !v.classList.contains("vditor-wysiwyg__block") && (g.insertNode(document.createElement("wbr")), v.innerHTML.trim() === "<wbr>" && (v.innerHTML = "<wbr><br>"), v.tagName === "BLOCKQUOTE" || v.classList.contains("vditor-reset") ? v.innerHTML = "<".concat(p, ' data-block="0">').concat(v.innerHTML.trim(), "</").concat(p, ">") : v.outerHTML = "<".concat(p, ' data-block="0">').concat(v.innerHTML.trim(), "</").concat(p, ">"), (0, J.ib)(d.wysiwyg.element, g), V(d));
            }, Mn = function(d) {
              var p = getSelection().getRangeAt(0), g = (0, C.F9)(p.startContainer);
              g || (g = p.startContainer.childNodes[p.startOffset]), g && (p.insertNode(document.createElement("wbr")), g.outerHTML = '<p data-block="0">'.concat(g.innerHTML, "</p>"), (0, J.ib)(d.wysiwyg.element, p)), d.wysiwyg.popover.style.display = "none";
            }, Dn = function(d, p, g) {
              g === void 0 && (g = !0);
              var v = d.previousElementSibling, w = v.ownerDocument.createRange();
              v.tagName === "CODE" ? (v.style.display = "inline-block", g ? w.setStart(v.firstChild, 1) : w.selectNodeContents(v)) : (v.style.display = "block", v.firstChild.firstChild || v.firstChild.appendChild(document.createTextNode("")), w.selectNodeContents(v.firstChild)), g ? w.collapse(!0) : w.collapse(!1), (0, J.Hc)(w), !d.firstElementChild.classList.contains("language-mindmap") && un(p);
            }, Tn = function(d, p) {
              if (d.wysiwyg.composingLock = p.isComposing, p.isComposing)
                return !1;
              p.key.indexOf("Arrow") === -1 && p.key !== "Meta" && p.key !== "Control" && p.key !== "Alt" && p.key !== "Shift" && p.key !== "CapsLock" && p.key !== "Escape" && !/^F\d{1,2}$/.test(p.key) && d.undo.recordFirstPosition(d, p);
              var g = (0, J.zh)(d), v = g.startContainer;
              if (!Co(p, d, v) || (gp(g, d, p), $6(g), p.key !== "Enter" && p.key !== "Tab" && p.key !== "Backspace" && p.key.indexOf("Arrow") === -1 && !(0, f.yl)(p) && p.key !== "Escape" && p.key !== "Delete"))
                return !1;
              var w = (0, C.F9)(v), S = (0, C.lG)(v, "P");
              if (I6(p, d, S, g) || N6(g, d, S, p) || H6(d, p, g))
                return !0;
              var D = (0, C.fb)(v, "vditor-wysiwyg__block");
              if (D) {
                if (p.key === "Escape" && D.children.length === 2)
                  return d.wysiwyg.popover.style.display = "none", D.firstElementChild.style.display = "none", d.wysiwyg.element.blur(), p.preventDefault(), !0;
                if (!(0, f.yl)(p) && !p.shiftKey && p.altKey && p.key === "Enter" && D.getAttribute("data-type") === "code-block") {
                  var I = d.wysiwyg.popover.querySelector(".vditor-input");
                  return I.focus(), I.select(), p.preventDefault(), !0;
                }
                if (D.getAttribute("data-block") === "0" && (z6(d, p, D.firstElementChild, g) || Nt(d, p, g, D.firstElementChild, D) || D.getAttribute("data-type") !== "yaml-front-matter" && Ge(d, p, g, D.firstElementChild, D)))
                  return !0;
              }
              if (F6(d, g, p, S))
                return !0;
              var B = (0, C.E2)(v, "BLOCKQUOTE");
              if (B && !p.shiftKey && p.altKey && p.key === "Enter") {
                (0, f.yl)(p) ? g.setStartBefore(B) : g.setStartAfter(B), (0, J.Hc)(g);
                var _ = document.createElement("p");
                return _.setAttribute("data-block", "0"), _.innerHTML = `
`, g.insertNode(_), g.collapse(!0), (0, J.Hc)(g), kt(d), un(d), p.preventDefault(), !0;
              }
              var W = (0, O.W)(v);
              if (W) {
                if (W.tagName === "H6" && v.textContent.length === g.startOffset && !(0, f.yl)(p) && !p.shiftKey && !p.altKey && p.key === "Enter") {
                  var Z = document.createElement("p");
                  return Z.textContent = `
`, Z.setAttribute("data-block", "0"), v.parentElement.insertAdjacentElement("afterend", Z), g.setStart(Z, 0), (0, J.Hc)(g), kt(d), un(d), p.preventDefault(), !0;
                }
                if (le("⌘=", p)) {
                  var ye = parseInt(W.tagName.substr(1), 10) - 1;
                  return ye > 0 && (Cn(d, "h".concat(ye)), kt(d)), p.preventDefault(), !0;
                }
                if (le("⌘-", p)) {
                  var ye = parseInt(W.tagName.substr(1), 10) + 1;
                  return ye < 7 && (Cn(d, "h".concat(ye)), kt(d)), p.preventDefault(), !0;
                }
                p.key === "Backspace" && !(0, f.yl)(p) && !p.shiftKey && !p.altKey && W.textContent.length === 1 && Mn(d);
              }
              if (V6(d, g, p))
                return !0;
              if (p.altKey && p.key === "Enter" && !(0, f.yl)(p) && !p.shiftKey) {
                var ve = (0, C.lG)(v, "A"), fe = (0, C.a1)(v, "data-type", "link-ref"), Ae = (0, C.a1)(v, "data-type", "footnotes-ref");
                if (ve || fe || Ae || W && W.tagName.length === 2) {
                  var Me = d.wysiwyg.popover.querySelector("input");
                  Me.focus(), Me.select();
                }
              }
              if (Gt(d, p))
                return !0;
              if (le("⇧⌘U", p)) {
                var de = d.wysiwyg.popover.querySelector('[data-type="up"]');
                if (de)
                  return de.click(), p.preventDefault(), !0;
              }
              if (le("⇧⌘D", p)) {
                var de = d.wysiwyg.popover.querySelector('[data-type="down"]');
                if (de)
                  return de.click(), p.preventDefault(), !0;
              }
              if (jy(d, g, p))
                return !0;
              if (!(0, f.yl)(p) && p.shiftKey && !p.altKey && p.key === "Enter" && v.parentElement.tagName !== "LI" && v.parentElement.tagName !== "P")
                return ["STRONG", "STRIKE", "S", "I", "EM", "B"].includes(v.parentElement.tagName) ? g.insertNode(document.createTextNode(`
` + a.g.ZWSP)) : g.insertNode(document.createTextNode(`
`)), g.collapse(!1), (0, J.Hc)(g), kt(d), un(d), p.preventDefault(), !0;
              if (p.key === "Backspace" && !(0, f.yl)(p) && !p.shiftKey && !p.altKey && g.toString() === "") {
                if (q6(d, g, p, S))
                  return !0;
                if (w) {
                  if (w.previousElementSibling && w.previousElementSibling.classList.contains("vditor-wysiwyg__block") && w.previousElementSibling.getAttribute("data-block") === "0" && w.tagName !== "UL" && w.tagName !== "OL") {
                    var Je = (0, J.im)(w, d.wysiwyg.element, g).start;
                    if (Je === 0 && g.startOffset === 0 || // https://github.com/Vanessa219/vditor/issues/894
                    Je === 1 && w.innerText.startsWith(a.g.ZWSP))
                      return Dn(w.previousElementSibling.lastElementChild, d, !1), w.innerHTML.trim().replace(a.g.ZWSP, "") === "" && (w.remove(), kt(d)), p.preventDefault(), !0;
                  }
                  var De = g.startOffset;
                  if (g.toString() === "" && v.nodeType === 3 && v.textContent.charAt(De - 2) === `
` && v.textContent.charAt(De - 1) !== a.g.ZWSP && ["STRONG", "STRIKE", "S", "I", "EM", "B"].includes(v.parentElement.tagName))
                    return v.textContent = v.textContent.substring(0, De - 1) + a.g.ZWSP, g.setStart(v, De), g.collapse(!0), kt(d), p.preventDefault(), !0;
                  v.textContent === a.g.ZWSP && g.startOffset === 1 && !v.previousSibling && Ce(g) && (v.textContent = ""), w.querySelectorAll("span.vditor-wysiwyg__block[data-type='math-inline']").forEach(function(Yt) {
                    Yt.firstElementChild.style.display = "inline", Yt.lastElementChild.style.display = "none";
                  }), w.querySelectorAll("span.vditor-wysiwyg__block[data-type='html-entity']").forEach(function(Yt) {
                    Yt.firstElementChild.style.display = "inline", Yt.lastElementChild.style.display = "none";
                  });
                }
              }
              if ((0, f.vU)() && g.startOffset === 1 && v.textContent.indexOf(a.g.ZWSP) > -1 && v.previousSibling && v.previousSibling.nodeType !== 3 && v.previousSibling.tagName === "CODE" && (p.key === "Backspace" || p.key === "ArrowLeft"))
                return g.selectNodeContents(v.previousSibling), g.collapse(!1), p.preventDefault(), !0;
              if (j6(p, w, g))
                return p.preventDefault(), !0;
              if (yp(g, p.key), p.key === "ArrowDown") {
                var nt = v.nextSibling;
                nt && nt.nodeType !== 3 && nt.getAttribute("data-type") === "math-inline" && g.setStartAfter(nt);
              }
              return w && at(w, d, p, g) ? (p.preventDefault(), !0) : !1;
            }, Gt = function(d, p) {
              if (le("⇧⌘X", p)) {
                var g = d.wysiwyg.popover.querySelector('[data-type="remove"]');
                return g && g.click(), p.preventDefault(), !0;
              }
            }, An = function(d) {
              clearTimeout(d.wysiwyg.hlToolbarTimeoutId), d.wysiwyg.hlToolbarTimeoutId = window.setTimeout(function() {
                if (d.wysiwyg.element.getAttribute("contenteditable") !== "false" && (0, J.Gb)(d.wysiwyg.element)) {
                  m(d.toolbar.elements, a.g.EDIT_TOOLBARS), b(d.toolbar.elements, a.g.EDIT_TOOLBARS);
                  var p = getSelection().getRangeAt(0), g = p.startContainer;
                  p.startContainer.nodeType === 3 ? g = p.startContainer.parentElement : g = g.childNodes[p.startOffset >= g.childNodes.length ? g.childNodes.length - 1 : p.startOffset];
                  var v = (0, C.a1)(g, "data-type", "footnotes-block");
                  if (v) {
                    d.wysiwyg.popover.innerHTML = "", ir(v, d), Gn(d, "footnotes-block"), Pn(d, v);
                    return;
                  }
                  var w = (0, C.lG)(g, "LI");
                  w ? (w.classList.contains("vditor-task") ? y(d.toolbar.elements, ["check"]) : w.parentElement.tagName === "OL" ? y(d.toolbar.elements, ["ordered-list"]) : w.parentElement.tagName === "UL" && y(d.toolbar.elements, ["list"]), b(d.toolbar.elements, ["outdent", "indent"])) : k(d.toolbar.elements, ["outdent", "indent"]), (0, C.lG)(g, "BLOCKQUOTE") && y(d.toolbar.elements, ["quote"]), ((0, C.lG)(g, "B") || (0, C.lG)(g, "STRONG")) && y(d.toolbar.elements, ["bold"]), ((0, C.lG)(g, "I") || (0, C.lG)(g, "EM")) && y(d.toolbar.elements, ["italic"]), ((0, C.lG)(g, "STRIKE") || (0, C.lG)(g, "S")) && y(d.toolbar.elements, ["strike"]), d.wysiwyg.element.querySelectorAll(".vditor-comment--focus").forEach(function(qe) {
                    qe.classList.remove("vditor-comment--focus");
                  });
                  var S = (0, C.fb)(g, "vditor-comment");
                  if (S) {
                    var D = S.getAttribute("data-cmtids").split(" ");
                    if (D.length > 1 && S.nextSibling.isSameNode(S.nextElementSibling)) {
                      var I = S.nextElementSibling.getAttribute("data-cmtids").split(" ");
                      D.find(function(qe) {
                        if (I.includes(qe))
                          return D = [qe], !0;
                      });
                    }
                    d.wysiwyg.element.querySelectorAll(".vditor-comment").forEach(function(qe) {
                      qe.getAttribute("data-cmtids").indexOf(D[0]) > -1 && qe.classList.add("vditor-comment--focus");
                    });
                  }
                  var B = (0, C.lG)(g, "A");
                  B && y(d.toolbar.elements, ["link"]);
                  var _ = (0, C.lG)(g, "TABLE"), W = (0, O.W)(g);
                  (0, C.lG)(g, "CODE") ? (0, C.lG)(g, "PRE") ? (k(d.toolbar.elements, [
                    "headings",
                    "bold",
                    "italic",
                    "strike",
                    "line",
                    "quote",
                    "list",
                    "ordered-list",
                    "check",
                    "code",
                    "inline-code",
                    "upload",
                    "link",
                    "table",
                    "record"
                  ]), y(d.toolbar.elements, ["code"])) : (k(d.toolbar.elements, [
                    "headings",
                    "bold",
                    "italic",
                    "strike",
                    "line",
                    "quote",
                    "list",
                    "ordered-list",
                    "check",
                    "code",
                    "upload",
                    "link",
                    "table",
                    "record"
                  ]), y(d.toolbar.elements, ["inline-code"])) : W ? (k(d.toolbar.elements, ["bold"]), y(d.toolbar.elements, ["headings"])) : _ && k(d.toolbar.elements, ["table"]);
                  var Z = (0, C.fb)(g, "vditor-toc");
                  if (Z) {
                    d.wysiwyg.popover.innerHTML = "", ir(Z, d), Gn(d, "vditor-toc"), Pn(d, Z);
                    return;
                  }
                  var ye = (0, O.S)(g, "BLOCKQUOTE");
                  if (ye && (d.wysiwyg.popover.innerHTML = "", ss(p, ye, d), Mr(p, ye, d), ir(ye, d), Gn(d, "blockquote"), Pn(d, ye)), w && (d.wysiwyg.popover.innerHTML = "", ss(p, w, d), Mr(p, w, d), ir(w, d), Gn(d, "li"), Pn(d, w)), _) {
                    d.options.lang, d.options, d.wysiwyg.popover.innerHTML = "";
                    var ve = function() {
                      var qe = _.rows.length, At = _.rows[0].cells.length, wa = parseInt(Hn.value, 10) || qe, ka = parseInt(fi.value, 10) || At;
                      if (!(wa === qe && At === ka)) {
                        if (At !== ka)
                          for (var Yh = ka - At, Rs = 0; Rs < _.rows.length; Rs++)
                            if (Yh > 0)
                              for (var ek = 0; ek < Yh; ek++)
                                Rs === 0 ? _.rows[Rs].lastElementChild.insertAdjacentHTML("afterend", "<th> </th>") : _.rows[Rs].lastElementChild.insertAdjacentHTML("afterend", "<td> </td>");
                            else
                              for (var Gy = At - 1; Gy >= ka; Gy--)
                                _.rows[Rs].cells[Gy].remove();
                        if (qe !== wa) {
                          var tk = wa - qe;
                          if (tk > 0) {
                            for (var Jy = "<tr>", Jc = 0; Jc < ka; Jc++)
                              Jy += "<td> </td>";
                            for (var nk = 0; nk < tk; nk++)
                              _.querySelector("tbody") ? _.querySelector("tbody").insertAdjacentHTML("beforeend", Jy) : _.querySelector("thead").insertAdjacentHTML("afterend", Jy + "</tr>");
                          } else
                            for (var Jc = qe - 1; Jc >= wa; Jc--)
                              _.rows[Jc].remove(), _.rows.length === 1 && _.querySelector("tbody").remove();
                        }
                        typeof d.options.input == "function" && d.options.input(c(d));
                      }
                    }, fe = function(qe) {
                      bp(_, qe), qe === "right" ? (Je.classList.remove("vditor-icon--current"), De.classList.remove("vditor-icon--current"), nt.classList.add("vditor-icon--current")) : qe === "center" ? (Je.classList.remove("vditor-icon--current"), nt.classList.remove("vditor-icon--current"), De.classList.add("vditor-icon--current")) : (De.classList.remove("vditor-icon--current"), nt.classList.remove("vditor-icon--current"), Je.classList.add("vditor-icon--current")), (0, J.Hc)(p), kt(d);
                    }, Ae = (0, C.lG)(g, "TD"), Me = (0, C.lG)(g, "TH"), de = "left";
                    Ae ? de = Ae.getAttribute("align") || "left" : Me && (de = Me.getAttribute("align") || "center");
                    var Je = document.createElement("button");
                    Je.setAttribute("type", "button"), Je.setAttribute("aria-label", window.VditorI18n.alignLeft + "<" + (0, f.ns)("⇧⌘L") + ">"), Je.setAttribute("data-type", "left"), Je.innerHTML = '<svg><use xlink:href="#vditor-icon-align-left"></use></svg>', Je.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n" + (de === "left" ? " vditor-icon--current" : ""), Je.onclick = function() {
                      fe("left");
                    };
                    var De = document.createElement("button");
                    De.setAttribute("type", "button"), De.setAttribute("aria-label", window.VditorI18n.alignCenter + "<" + (0, f.ns)("⇧⌘C") + ">"), De.setAttribute("data-type", "center"), De.innerHTML = '<svg><use xlink:href="#vditor-icon-align-center"></use></svg>', De.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n" + (de === "center" ? " vditor-icon--current" : ""), De.onclick = function() {
                      fe("center");
                    };
                    var nt = document.createElement("button");
                    nt.setAttribute("type", "button"), nt.setAttribute("aria-label", window.VditorI18n.alignRight + "<" + (0, f.ns)("⇧⌘R") + ">"), nt.setAttribute("data-type", "right"), nt.innerHTML = '<svg><use xlink:href="#vditor-icon-align-right"></use></svg>', nt.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n" + (de === "right" ? " vditor-icon--current" : ""), nt.onclick = function() {
                      fe("right");
                    };
                    var Yt = document.createElement("button");
                    Yt.setAttribute("type", "button"), Yt.setAttribute("aria-label", window.VditorI18n.insertRowBelow + "<" + (0, f.ns)("⌘=") + ">"), Yt.setAttribute("data-type", "insertRow"), Yt.innerHTML = '<svg><use xlink:href="#vditor-icon-insert-row"></use></svg>', Yt.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", Yt.onclick = function() {
                      var qe = getSelection().getRangeAt(0).startContainer, At = (0, C.lG)(qe, "TD") || (0, C.lG)(qe, "TH");
                      At && _6(d, p, At);
                    };
                    var jt = document.createElement("button");
                    jt.setAttribute("type", "button"), jt.setAttribute("aria-label", window.VditorI18n.insertRowAbove + "<" + (0, f.ns)("⇧⌘F") + ">"), jt.setAttribute("data-type", "insertRow"), jt.innerHTML = '<svg><use xlink:href="#vditor-icon-insert-rowb"></use></svg>', jt.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", jt.onclick = function() {
                      var qe = getSelection().getRangeAt(0).startContainer, At = (0, C.lG)(qe, "TD") || (0, C.lG)(qe, "TH");
                      At && R6(d, p, At);
                    };
                    var sn = document.createElement("button");
                    sn.setAttribute("type", "button"), sn.setAttribute("aria-label", window.VditorI18n.insertColumnRight + "<" + (0, f.ns)("⇧⌘=") + ">"), sn.setAttribute("data-type", "insertColumn"), sn.innerHTML = '<svg><use xlink:href="#vditor-icon-insert-column"></use></svg>', sn.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", sn.onclick = function() {
                      var qe = getSelection().getRangeAt(0).startContainer, At = (0, C.lG)(qe, "TD") || (0, C.lG)(qe, "TH");
                      At && vp(d, _, At);
                    };
                    var qr = document.createElement("button");
                    qr.setAttribute("type", "button"), qr.setAttribute("aria-label", window.VditorI18n.insertColumnLeft + "<" + (0, f.ns)("⇧⌘G") + ">"), qr.setAttribute("data-type", "insertColumn"), qr.innerHTML = '<svg><use xlink:href="#vditor-icon-insert-columnb"></use></svg>', qr.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", qr.onclick = function() {
                      var qe = getSelection().getRangeAt(0).startContainer, At = (0, C.lG)(qe, "TD") || (0, C.lG)(qe, "TH");
                      At && vp(d, _, At, "beforebegin");
                    };
                    var sr = document.createElement("button");
                    sr.setAttribute("type", "button"), sr.setAttribute("aria-label", window.VditorI18n["delete-row"] + "<" + (0, f.ns)("⌘-") + ">"), sr.setAttribute("data-type", "deleteRow"), sr.innerHTML = '<svg><use xlink:href="#vditor-icon-delete-row"></use></svg>', sr.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", sr.onclick = function() {
                      var qe = getSelection().getRangeAt(0).startContainer, At = (0, C.lG)(qe, "TD") || (0, C.lG)(qe, "TH");
                      At && P6(d, p, At);
                    };
                    var $r = document.createElement("button");
                    $r.setAttribute("type", "button"), $r.setAttribute("aria-label", window.VditorI18n["delete-column"] + "<" + (0, f.ns)("⇧⌘-") + ">"), $r.setAttribute("data-type", "deleteColumn"), $r.innerHTML = '<svg><use xlink:href="#vditor-icon-delete-column"></use></svg>', $r.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", $r.onclick = function() {
                      var qe = getSelection().getRangeAt(0).startContainer, At = (0, C.lG)(qe, "TD") || (0, C.lG)(qe, "TH");
                      At && B6(d, p, _, At);
                    };
                    var bt = document.createElement("span");
                    bt.setAttribute("aria-label", window.VditorI18n.row), bt.className = "vditor-tooltipped vditor-tooltipped__n";
                    var Hn = document.createElement("input");
                    bt.appendChild(Hn), Hn.type = "number", Hn.min = "1", Hn.className = "vditor-input", Hn.style.width = "42px", Hn.style.textAlign = "center", Hn.setAttribute("placeholder", window.VditorI18n.row), Hn.value = _.rows.length.toString(), Hn.oninput = function() {
                      ve();
                    }, Hn.onkeydown = function(qe) {
                      if (!qe.isComposing) {
                        if (qe.key === "Tab") {
                          fi.focus(), fi.select(), qe.preventDefault();
                          return;
                        }
                        Gt(d, qe) || Tr(qe, p);
                      }
                    };
                    var xp = document.createElement("span");
                    xp.setAttribute("aria-label", window.VditorI18n.column), xp.className = "vditor-tooltipped vditor-tooltipped__n";
                    var fi = document.createElement("input");
                    xp.appendChild(fi), fi.type = "number", fi.min = "1", fi.className = "vditor-input", fi.style.width = "42px", fi.style.textAlign = "center", fi.setAttribute("placeholder", window.VditorI18n.column), fi.value = _.rows[0].cells.length.toString(), fi.oninput = function() {
                      ve();
                    }, fi.onkeydown = function(qe) {
                      if (!qe.isComposing) {
                        if (qe.key === "Tab") {
                          Hn.focus(), Hn.select(), qe.preventDefault();
                          return;
                        }
                        Gt(d, qe) || Tr(qe, p);
                      }
                    }, ss(p, _, d), Mr(p, _, d), ir(_, d), d.wysiwyg.popover.insertAdjacentElement("beforeend", Je), d.wysiwyg.popover.insertAdjacentElement("beforeend", De), d.wysiwyg.popover.insertAdjacentElement("beforeend", nt), d.wysiwyg.popover.insertAdjacentElement("beforeend", jt), d.wysiwyg.popover.insertAdjacentElement("beforeend", Yt), d.wysiwyg.popover.insertAdjacentElement("beforeend", qr), d.wysiwyg.popover.insertAdjacentElement("beforeend", sn), d.wysiwyg.popover.insertAdjacentElement("beforeend", sr), d.wysiwyg.popover.insertAdjacentElement("beforeend", $r), d.wysiwyg.popover.insertAdjacentElement("beforeend", bt), d.wysiwyg.popover.insertAdjacentHTML("beforeend", " x "), d.wysiwyg.popover.insertAdjacentElement("beforeend", xp), Gn(d, "table"), Pn(d, _);
                  }
                  var Ky = (0, C.a1)(g, "data-type", "link-ref");
                  Ky && Is(d, Ky, p);
                  var Kc = (0, C.a1)(g, "data-type", "footnotes-ref");
                  if (Kc) {
                    d.options.lang, d.options, d.wysiwyg.popover.innerHTML = "";
                    var bt = document.createElement("span");
                    bt.setAttribute("aria-label", window.VditorI18n.footnoteRef + "<" + (0, f.ns)("⌥Enter") + ">"), bt.className = "vditor-tooltipped vditor-tooltipped__n";
                    var To = document.createElement("input");
                    bt.appendChild(To), To.className = "vditor-input", To.setAttribute("placeholder", window.VditorI18n.footnoteRef + "<" + (0, f.ns)("⌥Enter") + ">"), To.style.width = "120px", To.value = Kc.getAttribute("data-footnotes-label"), To.oninput = function() {
                      To.value.trim() !== "" && Kc.setAttribute("data-footnotes-label", To.value), typeof d.options.input == "function" && d.options.input(c(d));
                    }, To.onkeydown = function(At) {
                      At.isComposing || Gt(d, At) || Tr(At, p);
                    }, ir(Kc, d), d.wysiwyg.popover.insertAdjacentElement("beforeend", bt), Gn(d, "footnotes-ref"), Pn(d, Kc);
                  }
                  var Zn = (0, C.fb)(g, "vditor-wysiwyg__block"), Z6 = Zn ? Zn.getAttribute("data-type").indexOf("block") > -1 : !1;
                  if (d.wysiwyg.element.querySelectorAll(".vditor-wysiwyg__preview").forEach(function(qe) {
                    if (!Zn || Zn && Z6 && !Zn.contains(qe)) {
                      var At = qe.previousElementSibling;
                      At.style.display = "none";
                    }
                  }), Zn && Z6) {
                    if (d.wysiwyg.popover.innerHTML = "", ss(p, Zn, d), Mr(p, Zn, d), ir(Zn, d), Zn.getAttribute("data-type") === "code-block") {
                      var Sp = document.createElement("span");
                      Sp.setAttribute("aria-label", window.VditorI18n.language + "<" + (0, f.ns)("⌥Enter") + ">"), Sp.className = "vditor-tooltipped vditor-tooltipped__n";
                      var ls = document.createElement("input");
                      Sp.appendChild(ls);
                      var Jh = Zn.firstElementChild.firstElementChild;
                      ls.className = "vditor-input", ls.setAttribute("placeholder", window.VditorI18n.language + "<" + (0, f.ns)("⌥Enter") + ">"), ls.value = Jh.className.indexOf("language-") > -1 ? Jh.className.split("-")[1].split(" ")[0] : "", ls.oninput = function(qe) {
                        ls.value.trim() !== "" ? Jh.className = "language-".concat(ls.value) : (Jh.className = "", d.hint.recentLanguage = ""), Zn.lastElementChild.classList.contains("vditor-wysiwyg__preview") && (Zn.lastElementChild.innerHTML = Zn.firstElementChild.innerHTML, Re(Zn.lastElementChild, d)), kt(d), qe.detail === 1 && (p.setStart(Jh.firstChild, 0), p.collapse(!0), (0, J.Hc)(p));
                      }, ls.onkeydown = function(qe) {
                        if (!qe.isComposing && !Gt(d, qe)) {
                          if (qe.key === "Escape" && d.hint.element.style.display === "block") {
                            d.hint.element.style.display = "none", qe.preventDefault();
                            return;
                          }
                          d.hint.select(qe, d), Tr(qe, p);
                        }
                      }, ls.onkeyup = function(qe) {
                        var At, wa;
                        if (!(qe.isComposing || qe.key === "Enter" || qe.key === "ArrowUp" || qe.key === "Escape" || qe.key === "ArrowDown")) {
                          var ka = [], Yh = ls.value.substring(0, ls.selectionStart);
                          (d.options.preview.hljs.langs || a.g.ALIAS_CODE_LANGUAGES.concat(((wa = (At = window.hljs) === null || At === void 0 ? void 0 : At.listLanguages()) !== null && wa !== void 0 ? wa : []).sort())).forEach(function(Rs) {
                            Rs.indexOf(Yh.toLowerCase()) > -1 && ka.push({
                              html: Rs,
                              value: Rs
                            });
                          }), d.hint.genHTML(ka, Yh, d), qe.preventDefault();
                        }
                      }, d.wysiwyg.popover.insertAdjacentElement("beforeend", Sp), Gn(d, "code-block");
                    } else
                      Gn(d, "block");
                    Pn(d, Zn);
                  } else
                    Zn = void 0;
                  if (W) {
                    d.wysiwyg.popover.innerHTML = "";
                    var bt = document.createElement("span");
                    bt.setAttribute("aria-label", "ID<" + (0, f.ns)("⌥Enter") + ">"), bt.className = "vditor-tooltipped vditor-tooltipped__n";
                    var va = document.createElement("input");
                    bt.appendChild(va), va.className = "vditor-input", va.setAttribute("placeholder", "ID<" + (0, f.ns)("⌥Enter") + ">"), va.style.width = "120px", va.value = W.getAttribute("data-id") || "", va.oninput = function() {
                      W.setAttribute("data-id", va.value), typeof d.options.input == "function" && d.options.input(c(d));
                    }, va.onkeydown = function(At) {
                      At.isComposing || Gt(d, At) || Tr(At, p);
                    }, ss(p, W, d), Mr(p, W, d), ir(W, d), d.wysiwyg.popover.insertAdjacentElement("beforeend", bt), Gn(d, "heading"), Pn(d, W);
                  }
                  if (B && cn(d, B, p), !ye && !w && !_ && !Zn && !B && !Ky && !Kc && !W && !Z) {
                    var Gc = (0, C.a1)(g, "data-block", "0");
                    Gc && Gc.parentElement.isEqualNode(d.wysiwyg.element) ? (d.wysiwyg.popover.innerHTML = "", ss(p, Gc, d), Mr(p, Gc, d), ir(Gc, d), Gn(d, "block"), Pn(d, Gc)) : d.wysiwyg.popover.style.display = "none";
                  }
                  d.wysiwyg.element.querySelectorAll('span[data-type="backslash"] > span').forEach(function(qe) {
                    qe.style.display = "none";
                  });
                  var Q6 = (0, C.a1)(p.startContainer, "data-type", "backslash");
                  Q6 && (Q6.querySelector("span").style.display = "inline");
                }
              }, 200);
            }, Pn = function(d, p) {
              var g = p, v = (0, C.lG)(p, "TABLE");
              v && (g = v), d.wysiwyg.popover.style.left = "0", d.wysiwyg.popover.style.display = "block", d.wysiwyg.popover.style.top = Math.max(-8, g.offsetTop - 21 - d.wysiwyg.element.scrollTop) + "px", d.wysiwyg.popover.style.left = Math.min(g.offsetLeft, d.wysiwyg.element.clientWidth - d.wysiwyg.popover.clientWidth) + "px", d.wysiwyg.popover.setAttribute("data-top", (g.offsetTop - 21).toString());
            }, Is = function(d, p, g) {
              g === void 0 && (g = getSelection().getRangeAt(0)), d.wysiwyg.popover.innerHTML = "";
              var v = function() {
                S.value.trim() !== "" && (p.tagName === "IMG" ? p.setAttribute("alt", S.value) : p.textContent = S.value), I.value.trim() !== "" && p.setAttribute("data-link-label", I.value), typeof d.options.input == "function" && d.options.input(c(d));
              }, w = document.createElement("span");
              w.setAttribute("aria-label", window.VditorI18n.textIsNotEmpty), w.className = "vditor-tooltipped vditor-tooltipped__n";
              var S = document.createElement("input");
              w.appendChild(S), S.className = "vditor-input", S.setAttribute("placeholder", window.VditorI18n.textIsNotEmpty), S.style.width = "120px", S.value = p.getAttribute("alt") || p.textContent, S.oninput = function() {
                v();
              }, S.onkeydown = function(B) {
                Gt(d, B) || Tr(B, g) || _s(d, p, B, I);
              };
              var D = document.createElement("span");
              D.setAttribute("aria-label", window.VditorI18n.linkRef), D.className = "vditor-tooltipped vditor-tooltipped__n";
              var I = document.createElement("input");
              D.appendChild(I), I.className = "vditor-input", I.setAttribute("placeholder", window.VditorI18n.linkRef), I.value = p.getAttribute("data-link-label"), I.oninput = function() {
                v();
              }, I.onkeydown = function(B) {
                Gt(d, B) || Tr(B, g) || _s(d, p, B, S);
              }, ir(p, d), d.wysiwyg.popover.insertAdjacentElement("beforeend", w), d.wysiwyg.popover.insertAdjacentElement("beforeend", D), Gn(d, "link-ref"), Pn(d, p);
            }, ss = function(d, p, g) {
              var v = p.previousElementSibling;
              if (!(!v || !p.parentElement.isEqualNode(g.wysiwyg.element) && p.tagName !== "LI")) {
                var w = document.createElement("button");
                w.setAttribute("type", "button"), w.setAttribute("data-type", "up"), w.setAttribute("aria-label", window.VditorI18n.up + "<" + (0, f.ns)("⇧⌘U") + ">"), w.innerHTML = '<svg><use xlink:href="#vditor-icon-up"></use></svg>', w.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", w.onclick = function() {
                  d.insertNode(document.createElement("wbr")), v.insertAdjacentElement("beforebegin", p), (0, J.ib)(g.wysiwyg.element, d), kt(g), An(g), un(g);
                }, g.wysiwyg.popover.insertAdjacentElement("beforeend", w);
              }
            }, Mr = function(d, p, g) {
              var v = p.nextElementSibling;
              if (!(!v || !p.parentElement.isEqualNode(g.wysiwyg.element) && p.tagName !== "LI")) {
                var w = document.createElement("button");
                w.setAttribute("type", "button"), w.setAttribute("data-type", "down"), w.setAttribute("aria-label", window.VditorI18n.down + "<" + (0, f.ns)("⇧⌘D") + ">"), w.innerHTML = '<svg><use xlink:href="#vditor-icon-down"></use></svg>', w.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", w.onclick = function() {
                  d.insertNode(document.createElement("wbr")), v.insertAdjacentElement("afterend", p), (0, J.ib)(g.wysiwyg.element, d), kt(g), An(g), un(g);
                }, g.wysiwyg.popover.insertAdjacentElement("beforeend", w);
              }
            }, ir = function(d, p) {
              var g = document.createElement("button");
              g.setAttribute("type", "button"), g.setAttribute("data-type", "remove"), g.setAttribute("aria-label", window.VditorI18n.remove + "<" + (0, f.ns)("⇧⌘X") + ">"), g.innerHTML = '<svg><use xlink:href="#vditor-icon-trashcan"></use></svg>', g.className = "vditor-icon vditor-tooltipped vditor-tooltipped__n", g.onclick = function() {
                var v = (0, J.zh)(p);
                v.setStartAfter(d), (0, J.Hc)(v), d.remove(), kt(p), An(p), ["H1", "H2", "H3", "H4", "H5", "H6"].includes(d.tagName) && V(p);
              }, p.wysiwyg.popover.insertAdjacentElement("beforeend", g);
            }, _s = function(d, p, g, v) {
              if (!g.isComposing) {
                if (g.key === "Tab") {
                  v.focus(), v.select(), g.preventDefault();
                  return;
                }
                if (!(0, f.yl)(g) && !g.shiftKey && g.altKey && g.key === "Enter") {
                  var w = (0, J.zh)(d);
                  p.insertAdjacentHTML("afterend", a.g.ZWSP), w.setStartAfter(p.nextSibling), w.collapse(!0), (0, J.Hc)(w), g.preventDefault();
                }
              }
            }, cn = function(d, p, g) {
              d.wysiwyg.popover.innerHTML = "";
              var v = function() {
                S.value.trim() !== "" && (p.innerHTML = S.value), p.setAttribute("href", I.value), p.setAttribute("title", _.value), kt(d);
              };
              p.querySelectorAll("[data-marker]").forEach(function(W) {
                W.removeAttribute("data-marker");
              });
              var w = document.createElement("span");
              w.setAttribute("aria-label", window.VditorI18n.textIsNotEmpty), w.className = "vditor-tooltipped vditor-tooltipped__n";
              var S = document.createElement("input");
              w.appendChild(S), S.className = "vditor-input", S.setAttribute("placeholder", window.VditorI18n.textIsNotEmpty), S.style.width = "120px", S.value = p.innerHTML || "", S.oninput = function() {
                v();
              }, S.onkeydown = function(W) {
                Gt(d, W) || Tr(W, g) || _s(d, p, W, I);
              };
              var D = document.createElement("span");
              D.setAttribute("aria-label", window.VditorI18n.link), D.className = "vditor-tooltipped vditor-tooltipped__n";
              var I = document.createElement("input");
              D.appendChild(I), I.className = "vditor-input", I.setAttribute("placeholder", window.VditorI18n.link), I.value = p.getAttribute("href") || "", I.oninput = function() {
                v();
              }, I.onkeydown = function(W) {
                Gt(d, W) || Tr(W, g) || _s(d, p, W, _);
              };
              var B = document.createElement("span");
              B.setAttribute("aria-label", window.VditorI18n.tooltipText), B.className = "vditor-tooltipped vditor-tooltipped__n";
              var _ = document.createElement("input");
              B.appendChild(_), _.className = "vditor-input", _.setAttribute("placeholder", window.VditorI18n.tooltipText), _.style.width = "60px", _.value = p.getAttribute("title") || "", _.oninput = function() {
                v();
              }, _.onkeydown = function(W) {
                Gt(d, W) || Tr(W, g) || _s(d, p, W, S);
              }, ir(p, d), d.wysiwyg.popover.insertAdjacentElement("beforeend", w), d.wysiwyg.popover.insertAdjacentElement("beforeend", D), d.wysiwyg.popover.insertAdjacentElement("beforeend", B), Gn(d, "a"), Pn(d, p);
            }, as = function(d, p) {
              var g = d.target;
              p.wysiwyg.popover.innerHTML = "";
              var v = function() {
                g.setAttribute("src", S.value), g.setAttribute("alt", I.value), g.setAttribute("title", _.value), typeof p.options.input == "function" && p.options.input(c(p));
              }, w = document.createElement("span");
              w.setAttribute("aria-label", window.VditorI18n.imageURL), w.className = "vditor-tooltipped vditor-tooltipped__n";
              var S = document.createElement("input");
              w.appendChild(S), S.className = "vditor-input", S.setAttribute("placeholder", window.VditorI18n.imageURL), S.value = g.getAttribute("src") || "", S.oninput = function() {
                v();
              }, S.onkeydown = function(W) {
                Gt(p, W);
              };
              var D = document.createElement("span");
              D.setAttribute("aria-label", window.VditorI18n.alternateText), D.className = "vditor-tooltipped vditor-tooltipped__n";
              var I = document.createElement("input");
              D.appendChild(I), I.className = "vditor-input", I.setAttribute("placeholder", window.VditorI18n.alternateText), I.style.width = "52px", I.value = g.getAttribute("alt") || "", I.oninput = function() {
                v();
              }, I.onkeydown = function(W) {
                Gt(p, W);
              };
              var B = document.createElement("span");
              B.setAttribute("aria-label", window.VditorI18n.title), B.className = "vditor-tooltipped vditor-tooltipped__n";
              var _ = document.createElement("input");
              B.appendChild(_), _.className = "vditor-input", _.setAttribute("placeholder", window.VditorI18n.title), _.value = g.getAttribute("title") || "", _.oninput = function() {
                v();
              }, _.onkeydown = function(W) {
                Gt(p, W);
              }, ir(g, p), p.wysiwyg.popover.insertAdjacentElement("beforeend", w), p.wysiwyg.popover.insertAdjacentElement("beforeend", D), p.wysiwyg.popover.insertAdjacentElement("beforeend", B), Gn(p, "image"), Pn(p, g);
            }, Tr = function(d, p) {
              if (!(0, f.yl)(d) && !d.shiftKey && d.key === "Enter" || d.key === "Escape")
                return p && (0, J.Hc)(p), d.preventDefault(), d.stopPropagation(), !0;
            }, Gn = function(d, p) {
              d.options.customWysiwygToolbar(p, d.wysiwyg.popover);
            }, ui = function(d) {
              d.currentMode === "wysiwyg" ? An(d) : d.currentMode === "ir" && mr(d);
            }, ba = function(d, p, g) {
              g === void 0 && (g = {
                enableAddUndoStack: !0,
                enableHint: !1,
                enableInput: !0
              });
              var v = d.wysiwyg.element;
              v.innerHTML = d.lute.Md2VditorDOM(p), v.querySelectorAll(".vditor-wysiwyg__preview[data-render='2']").forEach(function(w) {
                Re(w, d), w.previousElementSibling.setAttribute("style", "display:none");
              }), kt(d, g);
            }, kl = function(d, p, g) {
              for (var v = d.startContainer.parentElement, w = !1, S = "", D = "", I = Un(d), B = I.beforeHTML, _ = I.afterHTML; v && !w; ) {
                var W = v.tagName;
                if (W === "STRIKE" && (W = "S"), W === "I" && (W = "EM"), W === "B" && (W = "STRONG"), W === "S" || W === "STRONG" || W === "EM") {
                  var Z = "", ye = "", ve = "";
                  v.parentElement.getAttribute("data-block") !== "0" && (ye = dt(v), ve = it(v)), (B || ye) && (Z = "".concat(ye, "<").concat(W, ">").concat(B, "</").concat(W, ">"), B = Z), (g === "bold" && W === "STRONG" || g === "italic" && W === "EM" || g === "strikeThrough" && W === "S") && (Z += "".concat(S).concat(a.g.ZWSP, "<wbr>").concat(D), w = !0), (_ || ve) && (_ = "<".concat(W, ">").concat(_, "</").concat(W, ">").concat(ve), Z += _), v.parentElement.getAttribute("data-block") !== "0" ? (v = v.parentElement, v.innerHTML = Z) : (v.outerHTML = Z, v = v.parentElement), S = "<".concat(W, ">") + S, D = "</".concat(W, ">") + D;
                } else
                  w = !0;
              }
              (0, J.ib)(p.wysiwyg.element, d);
            }, Wc = function(d, p, g) {
              if (!(d.wysiwyg.composingLock && g instanceof CustomEvent)) {
                var v = !0, w = !0;
                d.wysiwyg.element.querySelector("wbr") && d.wysiwyg.element.querySelector("wbr").remove();
                var S = (0, J.zh)(d), D = p.getAttribute("data-type");
                if (p.classList.contains("vditor-menu--current"))
                  if (D === "strike" && (D = "strikeThrough"), D === "quote") {
                    var I = (0, C.lG)(S.startContainer, "BLOCKQUOTE");
                    I || (I = S.startContainer.childNodes[S.startOffset]), I && (v = !1, p.classList.remove("vditor-menu--current"), S.insertNode(document.createElement("wbr")), I.outerHTML = I.innerHTML.trim() === "" ? '<p data-block="0">'.concat(I.innerHTML, "</p>") : I.innerHTML, (0, J.ib)(d.wysiwyg.element, S));
                  } else if (D === "inline-code") {
                    var B = (0, C.lG)(S.startContainer, "CODE");
                    B || (B = S.startContainer.childNodes[S.startOffset]), B && (B.outerHTML = B.innerHTML.replace(a.g.ZWSP, "") + "<wbr>", (0, J.ib)(d.wysiwyg.element, S));
                  } else D === "link" ? (S.collapsed && S.selectNode(S.startContainer.parentElement), document.execCommand("unlink", !1, "")) : D === "check" || D === "list" || D === "ordered-list" ? (Ze(d, S, D), (0, J.ib)(d.wysiwyg.element, S), v = !1, p.classList.remove("vditor-menu--current")) : (v = !1, p.classList.remove("vditor-menu--current"), S.toString() === "" ? kl(S, d, D) : document.execCommand(D, !1, ""));
                else {
                  d.wysiwyg.element.childNodes.length === 0 && (d.wysiwyg.element.innerHTML = '<p data-block="0"><wbr></p>', (0, J.ib)(d.wysiwyg.element, S));
                  var _ = (0, C.F9)(S.startContainer);
                  if (D === "quote") {
                    if (_ || (_ = S.startContainer.childNodes[S.startOffset]), _) {
                      v = !1, p.classList.add("vditor-menu--current"), S.insertNode(document.createElement("wbr"));
                      var W = (0, C.lG)(S.startContainer, "LI");
                      W && _.contains(W) ? W.innerHTML = '<blockquote data-block="0">'.concat(W.innerHTML, "</blockquote>") : _.outerHTML = '<blockquote data-block="0">'.concat(_.outerHTML, "</blockquote>"), (0, J.ib)(d.wysiwyg.element, S);
                    }
                  } else if (D === "check" || D === "list" || D === "ordered-list")
                    Ze(d, S, D, !1), (0, J.ib)(d.wysiwyg.element, S), v = !1, m(d.toolbar.elements, ["check", "list", "ordered-list"]), p.classList.add("vditor-menu--current");
                  else if (D === "inline-code") {
                    if (S.toString() === "") {
                      var Z = document.createElement("code");
                      Z.textContent = a.g.ZWSP, S.insertNode(Z), S.setStart(Z.firstChild, 1), S.collapse(!0), (0, J.Hc)(S);
                    } else if (S.startContainer.nodeType === 3) {
                      var Z = document.createElement("code");
                      S.surroundContents(Z), S.insertNode(Z), (0, J.Hc)(S);
                    }
                    p.classList.add("vditor-menu--current");
                  } else if (D === "code") {
                    var Z = document.createElement("div");
                    Z.className = "vditor-wysiwyg__block", Z.setAttribute("data-type", "code-block"), Z.setAttribute("data-block", "0"), Z.setAttribute("data-marker", "```"), S.toString() === "" ? Z.innerHTML = `<pre><code><wbr>
</code></pre>` : (Z.innerHTML = "<pre><code>".concat(S.toString(), "<wbr></code></pre>"), S.deleteContents()), S.insertNode(Z), _ && (_.outerHTML = d.lute.SpinVditorDOM(_.outerHTML)), (0, J.ib)(d.wysiwyg.element, S), d.wysiwyg.element.querySelectorAll(".vditor-wysiwyg__preview[data-render='2']").forEach(function(Yt) {
                      Re(Yt, d);
                    }), p.classList.add("vditor-menu--disabled");
                  } else if (D === "link") {
                    if (S.toString() === "") {
                      var ye = document.createElement("a");
                      ye.innerText = a.g.ZWSP, S.insertNode(ye), S.setStart(ye.firstChild, 1), S.collapse(!0), cn(d, ye, S);
                      var ve = d.wysiwyg.popover.querySelector("input");
                      ve.value = "", ve.focus(), w = !1;
                    } else {
                      var Z = document.createElement("a");
                      Z.setAttribute("href", ""), Z.innerHTML = S.toString(), S.surroundContents(Z), S.insertNode(Z), (0, J.Hc)(S), cn(d, Z, S);
                      var fe = d.wysiwyg.popover.querySelectorAll("input");
                      fe[0].value = Z.innerText, fe[1].focus();
                    }
                    v = !1, p.classList.add("vditor-menu--current");
                  } else if (D === "table") {
                    var Ae = '<table data-block="0"><thead><tr><th>col1<wbr></th><th>col2</th><th>col3</th></tr></thead><tbody><tr><td> </td><td> </td><td> </td></tr><tr><td> </td><td> </td><td> </td></tr></tbody></table>';
                    if (S.toString().trim() === "")
                      _ && _.innerHTML.trim().replace(a.g.ZWSP, "") === "" ? _.outerHTML = Ae : document.execCommand("insertHTML", !1, Ae), S.selectNode(d.wysiwyg.element.querySelector("wbr").previousSibling), d.wysiwyg.element.querySelector("wbr").remove(), (0, J.Hc)(S);
                    else {
                      Ae = '<table data-block="0"><thead><tr>';
                      var Me = S.toString().split(`
`), de = Me[0].split(",").length > Me[0].split("	").length ? "," : "	";
                      Me.forEach(function(nt, Yt) {
                        Yt === 0 ? (nt.split(de).forEach(function(jt, sn) {
                          sn === 0 ? Ae += "<th>".concat(jt, "<wbr></th>") : Ae += "<th>".concat(jt, "</th>");
                        }), Ae += "</tr></thead>") : (Yt === 1 ? Ae += "<tbody><tr>" : Ae += "<tr>", nt.split(de).forEach(function(jt) {
                          Ae += "<td>".concat(jt, "</td>");
                        }), Ae += "</tr>");
                      }), Ae += "</tbody></table>", document.execCommand("insertHTML", !1, Ae), (0, J.ib)(d.wysiwyg.element, S);
                    }
                    v = !1, p.classList.add("vditor-menu--disabled");
                  } else if (D === "line") {
                    if (_) {
                      var Je = `<hr data-block="0"><p data-block="0"><wbr>
</p>`;
                      _.innerHTML.trim() === "" ? _.outerHTML = Je : _.insertAdjacentHTML("afterend", Je), (0, J.ib)(d.wysiwyg.element, S);
                    }
                  } else if (v = !1, p.classList.add("vditor-menu--current"), D === "strike" && (D = "strikeThrough"), S.toString() === "" && (D === "bold" || D === "italic" || D === "strikeThrough")) {
                    var De = "strong";
                    D === "italic" ? De = "em" : D === "strikeThrough" && (De = "s");
                    var Z = document.createElement(De);
                    Z.textContent = a.g.ZWSP, S.insertNode(Z), Z.previousSibling && Z.previousSibling.textContent === a.g.ZWSP && (Z.previousSibling.textContent = ""), S.setStart(Z.firstChild, 1), S.collapse(!0), (0, J.Hc)(S);
                  } else
                    document.execCommand(D, !1, "");
                }
                v && An(d), w && kt(d);
              }
            }, Tt = (
              /** @class */
              /* @__PURE__ */ function() {
                function d(p, g) {
                  var v, w = this;
                  this.element = document.createElement("div"), g.className && (v = this.element.classList).add.apply(v, g.className.split(" "));
                  var S = g.hotkey ? " <".concat((0, f.ns)(g.hotkey), ">") : "";
                  g.level === 2 && (S = g.hotkey ? " &lt;".concat((0, f.ns)(g.hotkey), "&gt;") : "");
                  var D = g.tip ? g.tip + S : "".concat(window.VditorI18n[g.name]).concat(S), I = g.name === "upload" ? "div" : "button";
                  if (g.level === 2)
                    this.element.innerHTML = "<".concat(I, ' data-type="').concat(g.name, '">').concat(D, "</").concat(I, ">");
                  else {
                    this.element.classList.add("vditor-toolbar__item");
                    var B = document.createElement(I);
                    B.setAttribute("data-type", g.name), B.className = "vditor-tooltipped vditor-tooltipped__".concat(g.tipPosition), B.setAttribute("aria-label", D), B.innerHTML = g.icon, this.element.appendChild(B);
                  }
                  g.prefix && this.element.children[0].addEventListener((0, f.Le)(), function(_) {
                    _.preventDefault(), !w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) && (p.currentMode === "wysiwyg" ? Wc(p, w.element.children[0], _) : p.currentMode === "ir" ? LI(p, w.element.children[0], g.prefix || "", g.suffix || "") : Vr(p, w.element.children[0], g.prefix || "", g.suffix || ""));
                  });
                }
                return d;
              }()
            ), Ii = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), hi = function(d, p, g) {
              var v;
              if (typeof g != "string" ? (T(d, ["subToolbar", "hint"]), g.preventDefault(), v = c(d)) : v = g, !(d.currentMode === p && typeof g != "string")) {
                if (d.devtools && d.devtools.renderEchart(d), d.options.preview.mode === "both" && p === "sv" ? d.preview.element.style.display = "block" : d.preview.element.style.display = "none", b(d.toolbar.elements, a.g.EDIT_TOOLBARS), m(d.toolbar.elements, a.g.EDIT_TOOLBARS), k(d.toolbar.elements, ["outdent", "indent"]), p === "ir")
                  x(d.toolbar.elements, ["both"]), M(d.toolbar.elements, ["outdent", "indent", "outline", "insert-before", "insert-after"]), d.sv.element.style.display = "none", d.wysiwyg.element.parentElement.style.display = "none", d.ir.element.parentElement.style.display = "block", d.lute.SetVditorIR(!0), d.lute.SetVditorWYSIWYG(!1), d.lute.SetVditorSV(!1), d.currentMode = "ir", d.ir.element.innerHTML = d.lute.Md2VditorIRDOM(v), Mo(d, {
                    enableAddUndoStack: !0,
                    enableHint: !1,
                    enableInput: !1
                  }), Kt(d), d.ir.element.querySelectorAll(".vditor-ir__preview[data-render='2']").forEach(function(S) {
                    Re(S, d);
                  }), d.ir.element.querySelectorAll(".vditor-toc").forEach(function(S) {
                    (0, ie.H)(S, {
                      cdn: d.options.cdn,
                      math: d.options.preview.math
                    });
                  });
                else if (p === "wysiwyg")
                  x(d.toolbar.elements, ["both"]), M(d.toolbar.elements, ["outdent", "indent", "outline", "insert-before", "insert-after"]), d.sv.element.style.display = "none", d.wysiwyg.element.parentElement.style.display = "block", d.ir.element.parentElement.style.display = "none", d.lute.SetVditorIR(!1), d.lute.SetVditorWYSIWYG(!0), d.lute.SetVditorSV(!1), d.currentMode = "wysiwyg", Kt(d), ba(d, v, {
                    enableAddUndoStack: !0,
                    enableHint: !1,
                    enableInput: !1
                  }), d.wysiwyg.element.querySelectorAll(".vditor-toc").forEach(function(S) {
                    (0, ie.H)(S, {
                      cdn: d.options.cdn,
                      math: d.options.preview.math
                    });
                  }), d.wysiwyg.popover.style.display = "none";
                else if (p === "sv") {
                  M(d.toolbar.elements, ["both"]), x(d.toolbar.elements, ["outdent", "indent", "outline", "insert-before", "insert-after"]), d.wysiwyg.element.parentElement.style.display = "none", d.ir.element.parentElement.style.display = "none", (d.options.preview.mode === "both" || d.options.preview.mode === "editor") && (d.sv.element.style.display = "block"), d.lute.SetVditorIR(!1), d.lute.SetVditorWYSIWYG(!1), d.lute.SetVditorSV(!0), d.currentMode = "sv";
                  var w = qt(v, d);
                  w === "<div data-block='0'></div>" && (w = ""), d.sv.element.innerHTML = w, Ft(d.sv.element), gt(d, {
                    enableAddUndoStack: !0,
                    enableHint: !1,
                    enableInput: !1
                  }), Kt(d);
                }
                d.undo.resetIcon(d), typeof g != "string" && (d[d.currentMode].element.focus(), ui(d)), V(d), ci(d), d.toolbar.elements["edit-mode"] && (d.toolbar.elements["edit-mode"].querySelectorAll("button").forEach(function(S) {
                  S.classList.remove("vditor-menu--current");
                }), d.toolbar.elements["edit-mode"].querySelector('button[data-mode="'.concat(d.currentMode, '"]')).classList.add("vditor-menu--current")), d.outline.toggle(d, d.currentMode !== "sv" && d.options.outline.enable, typeof g != "string");
              }
            }, xl = (
              /** @class */
              function(d) {
                Ii(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = document.createElement("div");
                  return S.className = "vditor-hint".concat(v.level === 2 ? "" : " vditor-panel--arrow"), S.innerHTML = '<button data-mode="wysiwyg">'.concat(window.VditorI18n.wysiwyg, " &lt;").concat((0, f.ns)("⌥⌘7"), `></button>
<button data-mode="ir">`).concat(window.VditorI18n.instantRendering, " &lt;").concat((0, f.ns)("⌥⌘8"), `></button>
<button data-mode="sv">`).concat(window.VditorI18n.splitView, " &lt;").concat((0, f.ns)("⌥⌘9"), "></button>"), w.element.appendChild(S), w._bindEvent(g, S, v), w;
                }
                return p.prototype._bindEvent = function(g, v, w) {
                  var S = this.element.children[0];
                  E(g, v, S, w.level), v.children.item(0).addEventListener((0, f.Le)(), function(D) {
                    hi(g, "wysiwyg", D), D.preventDefault(), D.stopPropagation();
                  }), v.children.item(1).addEventListener((0, f.Le)(), function(D) {
                    hi(g, "ir", D), D.preventDefault(), D.stopPropagation();
                  }), v.children.item(2).addEventListener((0, f.Le)(), function(D) {
                    hi(g, "sv", D), D.preventDefault(), D.stopPropagation();
                  });
                }, p;
              }(Tt)
            ), _i = function(d, p) {
              return (0, J.Gb)(d, p) ? getSelection().toString() : "";
            }, bo = function(d, p) {
              p.addEventListener("focus", function() {
                d.options.focus && d.options.focus(c(d)), T(d, ["subToolbar", "hint"]);
              });
            }, Ar = function(d, p) {
              p.addEventListener("dblclick", function(g) {
                g.target.tagName === "IMG" && (d.options.image.preview ? d.options.image.preview(g.target) : d.options.image.isPreview && (0, Ee.E)(g.target, d.options.lang, d.options.theme));
              });
            }, vo = function(d, p) {
              p.addEventListener("blur", function(g) {
                if (d.currentMode === "ir") {
                  var v = d.ir.element.querySelector(".vditor-ir__node--expand");
                  v && v.classList.remove("vditor-ir__node--expand");
                } else d.currentMode === "wysiwyg" && !d.wysiwyg.selectPopover.contains(g.relatedTarget) && d.wysiwyg.hideComment();
                d[d.currentMode].range = (0, J.zh)(d), d.options.blur && d.options.blur(c(d));
              });
            }, wo = function(d, p) {
              p.addEventListener("dragstart", function(g) {
                g.dataTransfer.setData(a.g.DROP_EDITOR, a.g.DROP_EDITOR);
              }), p.addEventListener("drop", function(g) {
                g.dataTransfer.getData(a.g.DROP_EDITOR) ? xt(d) : (g.dataTransfer.types.includes("Files") || g.dataTransfer.types.includes("text/html")) && wp(d, g, {
                  pasteCode: function(v) {
                    document.execCommand("insertHTML", !1, v);
                  }
                });
              });
            }, ko = function(d, p, g) {
              p.addEventListener("copy", function(v) {
                return g(v, d);
              });
            }, xo = function(d, p, g) {
              p.addEventListener("cut", function(v) {
                g(v, d), d.options.comment.enable && d.currentMode === "wysiwyg" && d.wysiwyg.getComments(d), document.execCommand("delete");
              });
            }, un = function(d) {
              if (d.currentMode === "wysiwyg" && d.options.comment.enable && d.options.comment.adjustTop(d.wysiwyg.getComments(d, !0)), !!d.options.typewriterMode) {
                var p = d[d.currentMode].element, g = (0, J.Ny)(p).top;
                d.options.height === "auto" && !d.element.classList.contains("vditor--fullscreen") && window.scrollTo(window.scrollX, g + d.element.offsetTop + d.toolbar.element.offsetHeight - window.innerHeight / 2 + 10), (d.options.height !== "auto" || d.element.classList.contains("vditor--fullscreen")) && (p.scrollTop = g + p.scrollTop - p.clientHeight / 2 + 10);
              }
            }, Ke = function(d, p) {
              p.addEventListener("keydown", function(g) {
                if (!g.isComposing && d.options.keydown && d.options.keydown(g), !((d.options.hint.extend.length > 1 || d.toolbar.elements.emoji) && d.hint.select(g, d))) {
                  if (d.options.comment.enable && d.currentMode === "wysiwyg" && (g.key === "Backspace" || le("⌘X", g)) && d.wysiwyg.getComments(d), d.currentMode === "sv") {
                    if (Vt(d, g))
                      return;
                  } else if (d.currentMode === "wysiwyg") {
                    if (Tn(d, g))
                      return;
                  } else if (d.currentMode === "ir" && Ot(d, g))
                    return;
                  if (d.options.ctrlEnter && le("⌘Enter", g)) {
                    d.options.ctrlEnter(c(d)), g.preventDefault();
                    return;
                  }
                  if (le("⌘Z", g) && !d.toolbar.elements.undo) {
                    d.undo.undo(d), g.preventDefault();
                    return;
                  }
                  if (le("⌘Y", g) && !d.toolbar.elements.redo) {
                    d.undo.redo(d), g.preventDefault();
                    return;
                  }
                  if (g.key === "Escape") {
                    d.hint.element.style.display === "block" ? d.hint.element.style.display = "none" : d.options.esc && !g.isComposing && d.options.esc(c(d)), g.preventDefault();
                    return;
                  }
                  if ((0, f.yl)(g) && g.altKey && !g.shiftKey && /^Digit[1-6]$/.test(g.code)) {
                    if (d.currentMode === "wysiwyg") {
                      var v = g.code.replace("Digit", "H");
                      (0, C.lG)(getSelection().getRangeAt(0).startContainer, v) ? Mn(d) : Cn(d, v), kt(d);
                    } else d.currentMode === "sv" ? Bn(d, "#".repeat(parseInt(g.code.replace("Digit", ""), 10)) + " ") : d.currentMode === "ir" && Gh(d, "#".repeat(parseInt(g.code.replace("Digit", ""), 10)) + " ");
                    return g.preventDefault(), !0;
                  }
                  if ((0, f.yl)(g) && g.altKey && !g.shiftKey && /^Digit[7-9]$/.test(g.code))
                    return g.code === "Digit7" ? hi(d, "wysiwyg", g) : g.code === "Digit8" ? hi(d, "ir", g) : g.code === "Digit9" && hi(d, "sv", g), !0;
                  d.options.toolbar.find(function(w) {
                    if (!w.hotkey || w.toolbar) {
                      if (w.toolbar) {
                        var S = w.toolbar.find(function(D) {
                          if (!D.hotkey)
                            return !1;
                          if (le(D.hotkey, g))
                            return d.toolbar.elements[D.name].children[0].dispatchEvent(new CustomEvent((0, f.Le)())), g.preventDefault(), !0;
                        });
                        return !!S;
                      }
                      return !1;
                    }
                    if (le(w.hotkey, g))
                      return d.toolbar.elements[w.name].children[0].dispatchEvent(new CustomEvent((0, f.Le)())), g.preventDefault(), !0;
                  });
                }
              });
            }, Y = function(d, p) {
              p.addEventListener("selectstart", function(g) {
                p.onmouseup = function() {
                  setTimeout(function() {
                    var v = _i(d[d.currentMode].element);
                    v.trim() ? (d.currentMode === "wysiwyg" && d.options.comment.enable && (!(0, C.a1)(g.target, "data-type", "footnotes-block") && !(0, C.a1)(g.target, "data-type", "link-ref-defs-block") ? d.wysiwyg.showComment() : d.wysiwyg.hideComment()), d.options.select && d.options.select(v)) : (d.currentMode === "wysiwyg" && d.options.comment.enable && d.wysiwyg.hideComment(), typeof d.options.unSelect == "function" && d.options.unSelect());
                  });
                };
              });
            }, be = function(d, p) {
              var g = (0, J.zh)(d);
              g.extractContents(), g.insertNode(document.createTextNode(Lute.Caret)), g.insertNode(document.createTextNode(p));
              var v = (0, C.a1)(g.startContainer, "data-block", "0");
              v || (v = d.sv.element);
              var w = d.lute.SpinVditorSVDOM(v.textContent);
              w = "<div data-block='0'>" + w.replace(/<span data-type="newline"><br \/><span style="display: none">\n<\/span><\/span><span data-type="newline"><br \/><span style="display: none">\n<\/span><\/span></g, `<span data-type="newline"><br /><span style="display: none">
</span></span><span data-type="newline"><br /><span style="display: none">
</span></span></div><div data-block="0"><`) + "</div>", v.isEqualNode(d.sv.element) ? v.innerHTML = w : v.outerHTML = w, Ft(d.sv.element), (0, J.ib)(d.sv.element, g), un(d);
            }, Ve = function(d, p, g) {
              g === void 0 && (g = !0);
              var v = d;
              for (v.nodeType === 3 && (v = v.parentElement); v; ) {
                if (v.getAttribute("data-type") === p)
                  return v;
                g ? v = v.previousElementSibling : v = v.nextElementSibling;
              }
              return !1;
            }, qt = function(d, p) {
              R("SpinVditorSVDOM", d, "argument", p.options.debugger);
              var g = p.lute.SpinVditorSVDOM(d);
              return d = "<div data-block='0'>" + g.replace(/<span data-type="newline"><br \/><span style="display: none">\n<\/span><\/span><span data-type="newline"><br \/><span style="display: none">\n<\/span><\/span></g, `<span data-type="newline"><br /><span style="display: none">
</span></span><span data-type="newline"><br /><span style="display: none">
</span></span></div><div data-block="0"><`) + "</div>", R("SpinVditorSVDOM", d, "result", p.options.debugger), d;
            }, Nn = function(d) {
              var p = d.getAttribute("data-type"), g = d.previousElementSibling, v = p && p !== "text" && p !== "table" && p !== "heading-marker" && p !== "newline" && p !== "yaml-front-matter-open-marker" && p !== "yaml-front-matter-close-marker" && p !== "code-block-info" && p !== "code-block-close-marker" && p !== "code-block-open-marker" ? d.textContent : "", w = !1;
              for (p === "newline" && (w = !0); g && !w; ) {
                var S = g.getAttribute("data-type");
                if (S === "li-marker" || S === "blockquote-marker" || S === "task-marker" || S === "padding") {
                  var D = g.textContent;
                  if (S === "li-marker" && (p === "code-block-open-marker" || p === "code-block-info"))
                    v = D.replace(/\S/g, " ") + v;
                  else if (p === "code-block-close-marker" && g.nextElementSibling.isSameNode(d)) {
                    var I = Ve(d, "code-block-open-marker");
                    I && I.previousElementSibling && (g = I.previousElementSibling, v = D + v);
                  } else
                    v = D + v;
                } else S === "newline" && (w = !0);
                g = g.previousElementSibling;
              }
              return v;
            }, gt = function(d, p) {
              p === void 0 && (p = {
                enableAddUndoStack: !0,
                enableHint: !1,
                enableInput: !0
              }), p.enableHint && d.hint.render(d), d.preview.render(d);
              var g = c(d);
              typeof d.options.input == "function" && p.enableInput && d.options.input(g), d.options.counter.enable && d.counter.render(d, g), d.options.cache.enable && (0, f.pK)() && (localStorage.setItem(d.options.cache.id, g), d.options.cache.after && d.options.cache.after(g)), d.devtools && d.devtools.renderEchart(d), clearTimeout(d.sv.processTimeoutId), d.sv.processTimeoutId = window.setTimeout(function() {
                p.enableAddUndoStack && !d.sv.composingLock && d.undo.addToUndoStack(d);
              }, d.options.undoDelay);
            }, Bn = function(d, p) {
              var g = (0, J.zh)(d), v = (0, O.S)(g.startContainer, "SPAN");
              v && v.textContent.trim() !== "" && (p = `
` + p), g.collapse(!0), document.execCommand("insertHTML", !1, p);
            }, Vr = function(d, p, g, v) {
              var w = (0, J.zh)(d), S = p.getAttribute("data-type");
              d.sv.element.childNodes.length === 0 && (d.sv.element.innerHTML = `<span data-type="p" data-block="0"><span data-type="text"><wbr></span></span><span data-type="newline"><br><span style="display: none">
</span></span>`, (0, J.ib)(d.sv.element, w));
              var D = (0, C.F9)(w.startContainer), I = (0, O.S)(w.startContainer, "SPAN");
              if (D) {
                if (S === "link") {
                  var B = void 0;
                  w.toString() === "" ? B = "".concat(g).concat(Lute.Caret).concat(v) : B = "".concat(g).concat(w.toString()).concat(v.replace(")", Lute.Caret + ")")), document.execCommand("insertHTML", !1, B);
                  return;
                } else if (S === "italic" || S === "bold" || S === "strike" || S === "inline-code" || S === "code" || S === "table" || S === "line") {
                  var B = void 0;
                  w.toString() === "" ? B = "".concat(g).concat(Lute.Caret).concat(S === "code" ? "" : v) : B = "".concat(g).concat(w.toString()).concat(Lute.Caret).concat(S === "code" ? "" : v), S === "table" || S === "code" && I && I.textContent !== "" ? B = `

` + B : S === "line" && (B = `

`.concat(g, `
`).concat(Lute.Caret)), document.execCommand("insertHTML", !1, B);
                  return;
                } else if ((S === "check" || S === "list" || S === "ordered-list" || S === "quote") && I) {
                  var _ = "* ";
                  S === "check" ? _ = "* [ ] " : S === "ordered-list" ? _ = "1. " : S === "quote" && (_ = "> ");
                  var W = Ve(I, "newline");
                  W ? W.insertAdjacentText("afterend", _) : D.insertAdjacentText("afterbegin", _), ft(d);
                  return;
                }
                (0, J.ib)(d.sv.element, w), gt(d);
              }
            }, Ri = function(d) {
              switch (d.currentMode) {
                case "ir":
                  return d.ir.element;
                case "wysiwyg":
                  return d.wysiwyg.element;
                case "sv":
                  return d.sv.element;
              }
            }, So = function(d, p) {
              d.options.upload.setHeaders && (d.options.upload.headers = d.options.upload.setHeaders()), d.options.upload.headers && Object.keys(d.options.upload.headers).forEach(function(g) {
                p.setRequestHeader(g, d.options.upload.headers[g]);
              });
            }, En = function(d, p, g, v) {
              function w(S) {
                return S instanceof g ? S : new g(function(D) {
                  D(S);
                });
              }
              return new (g || (g = Promise))(function(S, D) {
                function I(W) {
                  try {
                    _(v.next(W));
                  } catch (Z) {
                    D(Z);
                  }
                }
                function B(W) {
                  try {
                    _(v.throw(W));
                  } catch (Z) {
                    D(Z);
                  }
                }
                function _(W) {
                  W.done ? S(W.value) : w(W.value).then(I, B);
                }
                _((v = v.apply(d, p || [])).next());
              });
            }, Sl = function(d, p) {
              var g = { label: 0, sent: function() {
                if (S[0] & 1) throw S[1];
                return S[1];
              }, trys: [], ops: [] }, v, w, S, D;
              return D = { next: I(0), throw: I(1), return: I(2) }, typeof Symbol == "function" && (D[Symbol.iterator] = function() {
                return this;
              }), D;
              function I(_) {
                return function(W) {
                  return B([_, W]);
                };
              }
              function B(_) {
                if (v) throw new TypeError("Generator is already executing.");
                for (; D && (D = 0, _[0] && (g = 0)), g; ) try {
                  if (v = 1, w && (S = _[0] & 2 ? w.return : _[0] ? w.throw || ((S = w.return) && S.call(w), 0) : w.next) && !(S = S.call(w, _[1])).done) return S;
                  switch (w = 0, S && (_ = [_[0] & 2, S.value]), _[0]) {
                    case 0:
                    case 1:
                      S = _;
                      break;
                    case 4:
                      return g.label++, { value: _[1], done: !1 };
                    case 5:
                      g.label++, w = _[1], _ = [0];
                      continue;
                    case 7:
                      _ = g.ops.pop(), g.trys.pop();
                      continue;
                    default:
                      if (S = g.trys, !(S = S.length > 0 && S[S.length - 1]) && (_[0] === 6 || _[0] === 2)) {
                        g = 0;
                        continue;
                      }
                      if (_[0] === 3 && (!S || _[1] > S[0] && _[1] < S[3])) {
                        g.label = _[1];
                        break;
                      }
                      if (_[0] === 6 && g.label < S[1]) {
                        g.label = S[1], S = _;
                        break;
                      }
                      if (S && g.label < S[2]) {
                        g.label = S[2], g.ops.push(_);
                        break;
                      }
                      S[2] && g.ops.pop(), g.trys.pop();
                      continue;
                  }
                  _ = p.call(d, g);
                } catch (W) {
                  _ = [6, W], w = 0;
                } finally {
                  v = S = 0;
                }
                if (_[0] & 5) throw _[1];
                return { value: _[0] ? _[1] : void 0, done: !0 };
              }
            }, Cl = (
              /** @class */
              /* @__PURE__ */ function() {
                function d() {
                  this.isUploading = !1, this.element = document.createElement("div"), this.element.className = "vditor-upload";
                }
                return d;
              }()
            ), dp = function(d, p) {
              d.tip.hide();
              var g = [], v = "", w = "";
              d.options.lang, d.options;
              for (var S = function(_, W) {
                var Z = p[W], ye = !0;
                Z.name || (v += "<li>".concat(window.VditorI18n.nameEmpty, "</li>"), ye = !1), Z.size > d.options.upload.max && (v += "<li>".concat(Z.name, " ").concat(window.VditorI18n.over, " ").concat(d.options.upload.max / 1024 / 1024, "M</li>"), ye = !1);
                var ve = Z.name.lastIndexOf("."), fe = Z.name.substr(ve), Ae = d.options.upload.filename(Z.name.substr(0, ve)) + fe;
                if (d.options.upload.accept) {
                  var Me = d.options.upload.accept.split(",").some(function(de) {
                    var Je = de.trim();
                    if (Je.indexOf(".") === 0) {
                      if (fe.toLowerCase() === Je.toLowerCase())
                        return !0;
                    } else if (Z.type.split("/")[0] === Je.split("/")[0])
                      return !0;
                    return !1;
                  });
                  Me || (v += "<li>".concat(Z.name, " ").concat(window.VditorI18n.fileTypeError, "</li>"), ye = !1);
                }
                ye && (g.push(Z), w += "<li>".concat(Ae, " ").concat(window.VditorI18n.uploading, ' <a class="vditorCancelUpload" href="javascript:void(0)">').concat(window.VditorI18n.cancelUpload, "</a></li>"));
              }, D = p.length, I = 0; I < D; I++)
                S(D, I);
              if (d.tip.show("<ul>".concat(v).concat(w, "</ul>")), d.options.upload.cancel) {
                var B = d.tip.element.querySelector(".vditorCancelUpload");
                B && B.addEventListener("click", function() {
                  d.options.upload.cancel(g), d.tip.hide(), d.upload.isUploading = !1;
                });
              }
              return g;
            }, pp = function(d, p) {
              var g = Ri(p);
              g.focus();
              var v = JSON.parse(d), w = "";
              v.code === 1 && (w = "".concat(v.msg)), v.data.errFiles && v.data.errFiles.length > 0 && (w = "<ul><li>".concat(w, "</li>"), v.data.errFiles.forEach(function(D) {
                var I = D.lastIndexOf("."), B = p.options.upload.filename(D.substr(0, I)) + D.substr(I);
                w += "<li>".concat(B, " ").concat(window.VditorI18n.uploadError, "</li>");
              }), w += "</ul>"), w ? p.tip.show(w) : p.tip.hide();
              var S = "";
              Object.keys(v.data.succMap).forEach(function(D) {
                var I = v.data.succMap[D], B = D.lastIndexOf("."), _ = D.substr(B), W = p.options.upload.filename(D.substr(0, B)) + _;
                _ = _.toLowerCase(), _.indexOf(".wav") === 0 || _.indexOf(".mp3") === 0 || _.indexOf(".ogg") === 0 ? p.currentMode === "wysiwyg" ? S += `<div class="vditor-wysiwyg__block" data-type="html-block"
 data-block="0"><pre><code>&lt;audio controls="controls" src="`.concat(I, '"&gt;&lt;/audio&gt;</code></pre><pre class="vditor-wysiwyg__preview" data-render="1"><audio controls="controls" src="').concat(I, `"></audio></pre></div>
`) : p.currentMode === "ir" ? S += '<audio controls="controls" src="'.concat(I, `"></audio>
`) : S += "[".concat(W, "](").concat(I, `)
`) : _.indexOf(".apng") === 0 || _.indexOf(".bmp") === 0 || _.indexOf(".gif") === 0 || _.indexOf(".ico") === 0 || _.indexOf(".cur") === 0 || _.indexOf(".jpg") === 0 || _.indexOf(".jpeg") === 0 || _.indexOf(".jfif") === 0 || _.indexOf(".pjp") === 0 || _.indexOf(".pjpeg") === 0 || _.indexOf(".png") === 0 || _.indexOf(".svg") === 0 || _.indexOf(".webp") === 0 ? p.currentMode === "wysiwyg" ? S += '<img alt="'.concat(W, '" src="').concat(I, `">
`) : S += "![".concat(W, "](").concat(I, `)
`) : p.currentMode === "wysiwyg" ? S += '<a href="'.concat(I, '">').concat(W, `</a>
`) : S += "[".concat(W, "](").concat(I, `)
`);
              }), (0, J.Hc)(p.upload.range), document.execCommand("insertHTML", !1, S), p.upload.range = getSelection().getRangeAt(0).cloneRange();
            }, Uc = function(d, p, g) {
              return En(void 0, void 0, void 0, function() {
                var v, w, fe, S, D, D, I, B, _, W, Z, ye, ve, fe, Ae, Me;
                return Sl(this, function(de) {
                  switch (de.label) {
                    case 0:
                      for (v = [], w = d.options.upload.multiple === !0 ? p.length : 1, fe = 0; fe < w; fe++)
                        S = p[fe], S instanceof DataTransferItem && (S = S.getAsFile()), v.push(S);
                      return d.options.upload.handler ? [4, d.options.upload.handler(v)] : [3, 2];
                    case 1:
                      return D = de.sent(), g && (g.value = ""), typeof D == "string" ? (d.tip.show(D), [
                        2
                        /*return*/
                      ]) : [
                        2
                        /*return*/
                      ];
                    case 2:
                      return !d.options.upload.url || !d.upload ? (g && (g.value = ""), d.tip.show("please config: options.upload.url"), [
                        2
                        /*return*/
                      ]) : d.options.upload.file ? [4, d.options.upload.file(v)] : [3, 4];
                    case 3:
                      v = de.sent(), de.label = 4;
                    case 4:
                      if (d.options.upload.validate && (D = d.options.upload.validate(v), typeof D == "string"))
                        return d.tip.show(D), [
                          2
                          /*return*/
                        ];
                      if (I = Ri(d), d.upload.range = (0, J.zh)(d), B = dp(d, v), B.length === 0)
                        return g && (g.value = ""), [
                          2
                          /*return*/
                        ];
                      for (_ = new FormData(), W = d.options.upload.extraData, Z = 0, ye = Object.keys(W); Z < ye.length; Z++)
                        ve = ye[Z], _.append(ve, W[ve]);
                      for (fe = 0, Ae = B.length; fe < Ae; fe++)
                        _.append(d.options.upload.fieldName, B[fe]);
                      return Me = new XMLHttpRequest(), d.upload.xhr = Me, Me.open("POST", d.options.upload.url), d.options.upload.token && Me.setRequestHeader("X-Upload-Token", d.options.upload.token), d.options.upload.withCredentials && (Me.withCredentials = !0), So(d, Me), d.upload.isUploading = !0, I.setAttribute("contenteditable", "false"), Me.onreadystatechange = function() {
                        if (Me.readyState === XMLHttpRequest.DONE) {
                          if (d.upload.isUploading = !1, I.setAttribute("contenteditable", "true"), Me.status >= 200 && Me.status < 300)
                            if (d.options.upload.success)
                              d.options.upload.success(I, Me.responseText);
                            else {
                              var Je = Me.responseText;
                              d.options.upload.format && (Je = d.options.upload.format(p, Me.responseText)), pp(Je, d);
                            }
                          else
                            d.options.upload.error ? d.options.upload.error(Me.responseText) : d.tip.show(Me.responseText);
                          g && (g.value = ""), d.upload.element.style.display = "none", d.upload.xhr = void 0;
                        }
                      }, Me.upload.onprogress = function(Je) {
                        if (Je.lengthComputable) {
                          var De = Je.loaded / Je.total * 100;
                          d.upload.element.style.display = "block";
                          var nt = d.upload.element;
                          nt.style.width = De + "%";
                        }
                      }, Me.send(_), [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }, Ml = function(d, p, g) {
              var v, w = (0, C.F9)(p.startContainer);
              if (w || (w = d.wysiwyg.element), g && g.inputType !== "formatItalic" && g.inputType !== "deleteByDrag" && g.inputType !== "insertFromDrop" && g.inputType !== "formatBold" && g.inputType !== "formatRemove" && g.inputType !== "formatStrikeThrough" && g.inputType !== "insertUnorderedList" && g.inputType !== "insertOrderedList" && g.inputType !== "formatOutdent" && g.inputType !== "formatIndent" && g.inputType !== "" || !g) {
                var S = ne(p.startContainer);
                S && S.remove(), d.wysiwyg.element.querySelectorAll("wbr").forEach(function(De) {
                  De.remove();
                }), p.insertNode(document.createElement("wbr")), w.querySelectorAll("[style]").forEach(function(De) {
                  De.removeAttribute("style");
                }), w.querySelectorAll(".vditor-comment").forEach(function(De) {
                  De.textContent.trim() === "" && (De.classList.remove("vditor-comment", "vditor-comment--focus"), De.removeAttribute("data-cmtids"));
                }), (v = w.previousElementSibling) === null || v === void 0 || v.querySelectorAll(".vditor-comment").forEach(function(De) {
                  De.textContent.trim() === "" && (De.classList.remove("vditor-comment", "vditor-comment--focus"), De.removeAttribute("data-cmtids"));
                });
                var D = "";
                w.getAttribute("data-type") === "link-ref-defs-block" && (w = d.wysiwyg.element);
                var I = w.isEqualNode(d.wysiwyg.element), B = (0, C.a1)(w, "data-type", "footnotes-block");
                if (I)
                  D = w.innerHTML;
                else {
                  var _ = (0, C.O9)(p.startContainer);
                  if (_ && !B) {
                    var W = (0, O.S)(p.startContainer, "BLOCKQUOTE");
                    W ? w = (0, C.F9)(p.startContainer) || w : w = _;
                  }
                  if (B && (w = B), D = w.outerHTML, w.tagName === "UL" || w.tagName === "OL") {
                    var Z = w.previousElementSibling, ye = w.nextElementSibling;
                    Z && (Z.tagName === "UL" || Z.tagName === "OL") && (D = Z.outerHTML + D, Z.remove()), ye && (ye.tagName === "UL" || ye.tagName === "OL") && (D = D + ye.outerHTML, ye.remove()), D = D.replace("<div><wbr><br></div>", "<li><p><wbr><br></p></li>");
                  }
                  w.innerText.startsWith("```") || (d.wysiwyg.element.querySelectorAll("[data-type='link-ref-defs-block']").forEach(function(De) {
                    De && !w.isEqualNode(De) && (D += De.outerHTML, De.remove());
                  }), d.wysiwyg.element.querySelectorAll("[data-type='footnotes-block']").forEach(function(De) {
                    De && !w.isEqualNode(De) && (D += De.outerHTML, De.remove());
                  }));
                }
                if (D = D.replace(/<\/(strong|b)><strong data-marker="\W{2}">/g, "").replace(/<\/(em|i)><em data-marker="\W{1}">/g, "").replace(/<\/(s|strike)><s data-marker="~{1,2}">/g, ""), D === '<p data-block="0">```<wbr></p>' && d.hint.recentLanguage && (D = '<p data-block="0">```<wbr></p>'.replace("```", "```" + d.hint.recentLanguage)), R("SpinVditorDOM", D, "argument", d.options.debugger), D = d.lute.SpinVditorDOM(D), R("SpinVditorDOM", D, "result", d.options.debugger), I)
                  w.innerHTML = D;
                else if (w.outerHTML = D, B) {
                  var ve = (0, C.E2)(d.wysiwyg.element.querySelector("wbr"), "LI");
                  if (ve) {
                    var fe = d.wysiwyg.element.querySelector('sup[data-type="footnotes-ref"][data-footnotes-label="'.concat(ve.getAttribute("data-marker"), '"]'));
                    fe && fe.setAttribute("aria-label", ve.textContent.trim().substr(0, 24));
                  }
                }
                var Ae, Me = d.wysiwyg.element.querySelectorAll("[data-type='link-ref-defs-block']");
                Me.forEach(function(De, nt) {
                  nt === 0 ? Ae = De : (Ae.insertAdjacentHTML("beforeend", De.innerHTML), De.remove());
                }), Me.length > 0 && d.wysiwyg.element.insertAdjacentElement("beforeend", Me[0]);
                var de, Je = d.wysiwyg.element.querySelectorAll("[data-type='footnotes-block']");
                Je.forEach(function(De, nt) {
                  nt === 0 ? de = De : (de.insertAdjacentHTML("beforeend", De.innerHTML), De.remove());
                }), Je.length > 0 && d.wysiwyg.element.insertAdjacentElement("beforeend", Je[0]), (0, J.ib)(d.wysiwyg.element, p), d.wysiwyg.element.querySelectorAll(".vditor-wysiwyg__preview[data-render='2']").forEach(function(De) {
                  Re(De, d);
                }), g && (g.inputType === "deleteContentBackward" || g.inputType === "deleteContentForward") && d.options.comment.enable && (d.wysiwyg.triggerRemoveComment(d), d.options.comment.adjustTop(d.wysiwyg.getComments(d, !0)));
              }
              V(d), kt(d, {
                enableAddUndoStack: !0,
                enableHint: !0,
                enableInput: !0
              });
            }, mp = function(d, p) {
              return Object.defineProperty ? Object.defineProperty(d, "raw", { value: p }) : d.raw = p, d;
            }, jh = function(d, p, g, v) {
              function w(S) {
                return S instanceof g ? S : new g(function(D) {
                  D(S);
                });
              }
              return new (g || (g = Promise))(function(S, D) {
                function I(W) {
                  try {
                    _(v.next(W));
                  } catch (Z) {
                    D(Z);
                  }
                }
                function B(W) {
                  try {
                    _(v.throw(W));
                  } catch (Z) {
                    D(Z);
                  }
                }
                function _(W) {
                  W.done ? S(W.value) : w(W.value).then(I, B);
                }
                _((v = v.apply(d, p || [])).next());
              });
            }, Wh = function(d, p) {
              var g = { label: 0, sent: function() {
                if (S[0] & 1) throw S[1];
                return S[1];
              }, trys: [], ops: [] }, v, w, S, D;
              return D = { next: I(0), throw: I(1), return: I(2) }, typeof Symbol == "function" && (D[Symbol.iterator] = function() {
                return this;
              }), D;
              function I(_) {
                return function(W) {
                  return B([_, W]);
                };
              }
              function B(_) {
                if (v) throw new TypeError("Generator is already executing.");
                for (; D && (D = 0, _[0] && (g = 0)), g; ) try {
                  if (v = 1, w && (S = _[0] & 2 ? w.return : _[0] ? w.throw || ((S = w.return) && S.call(w), 0) : w.next) && !(S = S.call(w, _[1])).done) return S;
                  switch (w = 0, S && (_ = [_[0] & 2, S.value]), _[0]) {
                    case 0:
                    case 1:
                      S = _;
                      break;
                    case 4:
                      return g.label++, { value: _[1], done: !1 };
                    case 5:
                      g.label++, w = _[1], _ = [0];
                      continue;
                    case 7:
                      _ = g.ops.pop(), g.trys.pop();
                      continue;
                    default:
                      if (S = g.trys, !(S = S.length > 0 && S[S.length - 1]) && (_[0] === 6 || _[0] === 2)) {
                        g = 0;
                        continue;
                      }
                      if (_[0] === 3 && (!S || _[1] > S[0] && _[1] < S[3])) {
                        g.label = _[1];
                        break;
                      }
                      if (_[0] === 6 && g.label < S[1]) {
                        g.label = S[1], S = _;
                        break;
                      }
                      if (S && g.label < S[2]) {
                        g.label = S[2], g.ops.push(_);
                        break;
                      }
                      S[2] && g.ops.pop(), g.trys.pop();
                      continue;
                  }
                  _ = p.call(d, g);
                } catch (W) {
                  _ = [6, W], w = 0;
                } finally {
                  v = S = 0;
                }
                if (_[0] & 5) throw _[1];
                return { value: _[0] ? _[1] : void 0, done: !0 };
              }
            }, Co = function(d, p, g) {
              if (d.keyCode === 229 && d.code === "" && d.key === "Unidentified" && p.currentMode !== "sv") {
                var v = (0, C.F9)(g);
                if (v && v.textContent.trim() === "")
                  return p[p.currentMode].composingLock = !0, !1;
              }
              return !0;
            }, gp = function(d, p, g) {
              if (!(g.key === "Enter" || g.key === "Tab" || g.key === "Backspace" || g.key.indexOf("Arrow") > -1 || (0, f.yl)(g) || g.key === "Escape" || g.shiftKey || g.altKey)) {
                var v = (0, C.lG)(d.startContainer, "P") || (0, C.lG)(d.startContainer, "LI");
                if (v && (0, J.im)(v, p[p.currentMode].element, d).start === 0) {
                  v.nodeValue && (v.nodeValue = v.nodeValue.replace(/\u2006/g, ""));
                  var w = document.createTextNode(a.g.ZWSP);
                  d.insertNode(w), d.setStartAfter(w);
                }
              }
            }, yp = function(d, p) {
              if (p === "ArrowDown" || p === "ArrowUp") {
                var g = (0, C.a1)(d.startContainer, "data-type", "math-inline") || (0, C.a1)(d.startContainer, "data-type", "html-entity") || (0, C.a1)(d.startContainer, "data-type", "html-inline");
                g && (p === "ArrowDown" && d.setStartAfter(g.parentElement), p === "ArrowUp" && d.setStartBefore(g.parentElement));
              }
            }, Tl = function(d, p) {
              var g = (0, J.zh)(d), v = (0, C.F9)(g.startContainer);
              v && (v.insertAdjacentHTML(p, '<p data-block="0">'.concat(a.g.ZWSP, `<wbr>
</p>`)), (0, J.ib)(d[d.currentMode].element, g), ui(d), xt(d));
            }, Al = function(d) {
              var p = (0, C.lG)(d, "TABLE");
              return p && p.rows[0].cells[0].isSameNode(d) ? p : !1;
            }, El = function(d) {
              var p = (0, C.lG)(d, "TABLE");
              return p && p.lastElementChild.lastElementChild.lastElementChild.isSameNode(d) ? p : !1;
            }, Uh = function(d, p, g) {
              g === void 0 && (g = !0);
              var v = d.previousElementSibling;
              return v || (d.parentElement.previousElementSibling ? v = d.parentElement.previousElementSibling.lastElementChild : d.parentElement.parentElement.tagName === "TBODY" && d.parentElement.parentElement.previousElementSibling ? v = d.parentElement.parentElement.previousElementSibling.lastElementChild.lastElementChild : v = null), v && (p.selectNodeContents(v), g || p.collapse(!1), (0, J.Hc)(p)), v;
            }, Nt = function(d, p, g, v, w) {
              var S = (0, J.im)(v, d[d.currentMode].element, g);
              if (p.key === "ArrowDown" && v.textContent.trimRight().substr(S.start).indexOf(`
`) === -1 || p.key === "ArrowRight" && S.start >= v.textContent.trimRight().length) {
                var D = w.nextElementSibling;
                return !D || D && (D.tagName === "TABLE" || D.getAttribute("data-type")) ? (w.insertAdjacentHTML("afterend", '<p data-block="0">'.concat(a.g.ZWSP, "<wbr></p>")), (0, J.ib)(d[d.currentMode].element, g)) : (g.selectNodeContents(D), g.collapse(!0), (0, J.Hc)(g)), p.preventDefault(), !0;
              }
              return !1;
            }, Ge = function(d, p, g, v, w) {
              var S = (0, J.im)(v, d[d.currentMode].element, g);
              if (p.key === "ArrowUp" && v.textContent.substr(0, S.start).indexOf(`
`) === -1 || (p.key === "ArrowLeft" || p.key === "Backspace" && g.toString() === "") && S.start === 0) {
                var D = w.previousElementSibling;
                return !D || D && (D.tagName === "TABLE" || D.getAttribute("data-type")) ? (w.insertAdjacentHTML("beforebegin", '<p data-block="0">'.concat(a.g.ZWSP, "<wbr></p>")), (0, J.ib)(d[d.currentMode].element, g)) : (g.selectNodeContents(D), g.collapse(!1), (0, J.Hc)(g)), p.preventDefault(), !0;
              }
              return !1;
            }, Ze = function(d, p, g, v) {
              v === void 0 && (v = !0);
              var w = (0, C.lG)(p.startContainer, "LI");
              if (d[d.currentMode].element.querySelectorAll("wbr").forEach(function(W) {
                W.remove();
              }), p.insertNode(document.createElement("wbr")), v && w) {
                for (var S = "", D = 0; D < w.parentElement.childElementCount; D++) {
                  var I = w.parentElement.children[D].querySelector("input");
                  I && I.remove(), S += '<p data-block="0">'.concat(w.parentElement.children[D].innerHTML.trimLeft(), "</p>");
                }
                w.parentElement.insertAdjacentHTML("beforebegin", S), w.parentElement.remove();
              } else if (w)
                if (g === "check")
                  w.parentElement.querySelectorAll("li").forEach(function(W) {
                    W.insertAdjacentHTML("afterbegin", '<input type="checkbox" />'.concat(W.textContent.indexOf(" ") === 0 ? "" : " ")), W.classList.add("vditor-task");
                  });
                else {
                  w.querySelector("input") && w.parentElement.querySelectorAll("li").forEach(function(W) {
                    W.querySelector("input").remove(), W.classList.remove("vditor-task");
                  });
                  var _ = void 0;
                  g === "list" ? (_ = document.createElement("ul"), _.setAttribute("data-marker", "*")) : (_ = document.createElement("ol"), _.setAttribute("data-marker", "1.")), _.setAttribute("data-block", "0"), _.setAttribute("data-tight", w.parentElement.getAttribute("data-tight")), _.innerHTML = w.parentElement.innerHTML, w.parentElement.parentNode.replaceChild(_, w.parentElement);
                }
              else {
                var B = (0, C.a1)(p.startContainer, "data-block", "0");
                B || (d[d.currentMode].element.querySelector("wbr").remove(), B = d[d.currentMode].element.querySelector("p"), B.innerHTML = "<wbr>"), g === "check" ? (B.insertAdjacentHTML("beforebegin", '<ul data-block="0"><li class="vditor-task"><input type="checkbox" /> '.concat(B.innerHTML, "</li></ul>")), B.remove()) : g === "list" ? (B.insertAdjacentHTML("beforebegin", '<ul data-block="0"><li>'.concat(B.innerHTML, "</li></ul>")), B.remove()) : g === "ordered-list" && (B.insertAdjacentHTML("beforebegin", '<ol data-block="0"><li>'.concat(B.innerHTML, "</li></ol>")), B.remove());
              }
            }, Rt = function(d, p, g) {
              var v = p.previousElementSibling;
              if (p && v) {
                var w = [p];
                Array.from(g.cloneContents().children).forEach(function(B, _) {
                  B.nodeType !== 3 && p && B.textContent.trim() !== "" && p.getAttribute("data-node-id") === B.getAttribute("data-node-id") && (_ !== 0 && w.push(p), p = p.nextElementSibling);
                }), d[d.currentMode].element.querySelectorAll("wbr").forEach(function(B) {
                  B.remove();
                }), g.insertNode(document.createElement("wbr"));
                var S = v.parentElement, D = "";
                w.forEach(function(B) {
                  var _ = B.getAttribute("data-marker");
                  _.length !== 1 && (_ = "1".concat(_.slice(-1))), D += '<li data-node-id="'.concat(B.getAttribute("data-node-id"), '" data-marker="').concat(_, '">').concat(B.innerHTML, "</li>"), B.remove();
                }), v.insertAdjacentHTML("beforeend", "<".concat(S.tagName, ' data-block="0">').concat(D, "</").concat(S.tagName, ">")), d.currentMode === "wysiwyg" ? S.outerHTML = d.lute.SpinVditorDOM(S.outerHTML) : S.outerHTML = d.lute.SpinVditorIRDOM(S.outerHTML), (0, J.ib)(d[d.currentMode].element, g);
                var I = (0, C.O9)(g.startContainer);
                I && I.querySelectorAll(".vditor-".concat(d.currentMode, "__preview[data-render='2']")).forEach(function(B) {
                  Re(B, d), d.currentMode === "wysiwyg" && B.previousElementSibling.setAttribute("style", "display:none");
                }), xt(d), ui(d);
              } else
                d[d.currentMode].element.focus();
            }, Kh = function(d, p, g, v) {
              var w = (0, C.lG)(p.parentElement, "LI");
              if (w) {
                d[d.currentMode].element.querySelectorAll("wbr").forEach(function(Z) {
                  Z.remove();
                }), g.insertNode(document.createElement("wbr"));
                var S = p.parentElement, D = S.cloneNode(), I = [p];
                Array.from(g.cloneContents().children).forEach(function(Z, ye) {
                  Z.nodeType !== 3 && p && Z.textContent.trim() !== "" && p.getAttribute("data-node-id") === Z.getAttribute("data-node-id") && (ye !== 0 && I.push(p), p = p.nextElementSibling);
                });
                var B = !1, _ = "";
                S.querySelectorAll("li").forEach(function(Z) {
                  B && (_ += Z.outerHTML, !Z.nextElementSibling && !Z.previousElementSibling ? Z.parentElement.remove() : Z.remove()), Z.isSameNode(I[I.length - 1]) && (B = !0);
                }), I.reverse().forEach(function(Z) {
                  w.insertAdjacentElement("afterend", Z);
                }), _ && (D.innerHTML = _, I[0].insertAdjacentElement("beforeend", D)), d.currentMode === "wysiwyg" ? v.outerHTML = d.lute.SpinVditorDOM(v.outerHTML) : v.outerHTML = d.lute.SpinVditorIRDOM(v.outerHTML), (0, J.ib)(d[d.currentMode].element, g);
                var W = (0, C.O9)(g.startContainer);
                W && W.querySelectorAll(".vditor-".concat(d.currentMode, "__preview[data-render='2']")).forEach(function(Z) {
                  Re(Z, d), d.currentMode === "wysiwyg" && Z.previousElementSibling.setAttribute("style", "display:none");
                }), xt(d), ui(d);
              } else
                d[d.currentMode].element.focus();
            }, bp = function(d, p) {
              for (var g = getSelection().getRangeAt(0).startContainer.parentElement, v = d.rows[0].cells.length, w = d.rows.length, S = 0, D = 0; D < w; D++)
                for (var I = 0; I < v; I++)
                  if (d.rows[D].cells[I].isSameNode(g)) {
                    S = I;
                    break;
                  }
              for (var B = 0; B < w; B++)
                d.rows[B].cells[S].setAttribute("align", p);
            }, qy = function(d) {
              var p = d.trimRight().split(`
`).pop();
              return p === "" ? !1 : (p.replace(/ |-/g, "") === "" || p.replace(/ |_/g, "") === "" || p.replace(/ |\*/g, "") === "") && p.replace(/ /g, "").length > 2 ? !(p.indexOf("-") > -1 && p.trimLeft().indexOf(" ") === -1 && d.trimRight().split(`
`).length > 1 || p.indexOf("    ") === 0 || p.indexOf("	") === 0) : !1;
            }, $y = function(d) {
              var p = d.trimRight().split(`
`);
              return d = p.pop(), d.indexOf("    ") === 0 || d.indexOf("	") === 0 || (d = d.trimLeft(), d === "" || p.length === 0) ? !1 : d.replace(/-/g, "") === "" || d.replace(/=/g, "") === "";
            }, xt = function(d, p) {
              p === void 0 && (p = {
                enableAddUndoStack: !0,
                enableHint: !1,
                enableInput: !0
              }), d.currentMode === "wysiwyg" ? kt(d, p) : d.currentMode === "ir" ? Mo(d, p) : d.currentMode === "sv" && gt(d, p);
            }, N6 = function(d, p, g, v) {
              var w, S = d.startContainer, D = (0, C.lG)(S, "LI");
              if (D) {
                if (!(0, f.yl)(v) && !v.altKey && v.key === "Enter" && // fix li 中有多个 P 时，在第一个 P 中换行会在下方生成新的 li
                !v.shiftKey && g && D.contains(g) && g.nextElementSibling)
                  return D && !D.textContent.endsWith(`
`) && D.insertAdjacentText("beforeend", `
`), d.insertNode(document.createTextNode(`

`)), d.collapse(!1), xt(p), v.preventDefault(), !0;
                if (!(0, f.yl)(v) && !v.shiftKey && !v.altKey && v.key === "Backspace" && !D.previousElementSibling && d.toString() === "" && (0, J.im)(D, p[p.currentMode].element, d).start === 0)
                  return D.nextElementSibling ? (D.parentElement.insertAdjacentHTML("beforebegin", '<p data-block="0"><wbr>'.concat(D.innerHTML, "</p>")), D.remove()) : D.parentElement.outerHTML = '<p data-block="0"><wbr>'.concat(D.innerHTML, "</p>"), (0, J.ib)(p[p.currentMode].element, d), xt(p), v.preventDefault(), !0;
                if (!(0, f.yl)(v) && !v.shiftKey && !v.altKey && v.key === "Backspace" && D.textContent.trim().replace(a.g.ZWSP, "") === "" && d.toString() === "" && ((w = D.previousElementSibling) === null || w === void 0 ? void 0 : w.tagName) === "LI")
                  return D.previousElementSibling.insertAdjacentText("beforeend", `

`), d.selectNodeContents(D.previousElementSibling), d.collapse(!1), D.remove(), (0, J.ib)(p[p.currentMode].element, d), xt(p), v.preventDefault(), !0;
                if (!(0, f.yl)(v) && !v.altKey && v.key === "Tab") {
                  var I = !1;
                  if ((d.startOffset === 0 && (S.nodeType === 3 && !S.previousSibling || S.nodeType !== 3 && S.nodeName === "LI") || D.classList.contains("vditor-task") && d.startOffset === 1 && S.previousSibling.nodeType !== 3 && S.previousSibling.tagName === "INPUT") && (I = !0), I || d.toString() !== "")
                    return v.shiftKey ? Kh(p, D, d, D.parentElement) : Rt(p, D, d), v.preventDefault(), !0;
                }
              }
              return !1;
            }, jy = function(d, p, g) {
              if (d.options.tab && g.key === "Tab")
                return g.shiftKey || (p.toString() === "" ? (p.insertNode(document.createTextNode(d.options.tab)), p.collapse(!1)) : (p.extractContents(), p.insertNode(document.createTextNode(d.options.tab)), p.collapse(!1))), (0, J.Hc)(p), xt(d), g.preventDefault(), !0;
            }, I6 = function(d, p, g, v) {
              if (g) {
                if (!(0, f.yl)(d) && !d.altKey && d.key === "Enter") {
                  var w = String.raw(W6 || (W6 = mp(["", ""], ["", ""])), g.textContent).replace(/\\\|/g, "").trim(), S = w.split("|");
                  if (w.startsWith("|") && w.endsWith("|") && S.length > 3) {
                    var D = S.map(function() {
                      return "---";
                    }).join("|");
                    return D = g.textContent + `
` + D.substring(3, D.length - 3) + `
|<wbr>`, g.outerHTML = p.lute.SpinVditorDOM(D), (0, J.ib)(p[p.currentMode].element, v), xt(p), un(p), d.preventDefault(), !0;
                  }
                  if (qy(g.innerHTML) && g.previousElementSibling) {
                    var I = "", B = g.innerHTML.trimRight().split(`
`);
                    return B.length > 1 && (B.pop(), I = '<p data-block="0">'.concat(B.join(`
`), "</p>")), g.insertAdjacentHTML("afterend", "".concat(I, `<hr data-block="0"><p data-block="0"><wbr>
</p>`)), g.remove(), (0, J.ib)(p[p.currentMode].element, v), xt(p), un(p), d.preventDefault(), !0;
                  }
                  if ($y(g.innerHTML))
                    return p.currentMode === "wysiwyg" ? g.outerHTML = p.lute.SpinVditorDOM(g.innerHTML + `<p data-block="0"><wbr>
</p>`) : g.outerHTML = p.lute.SpinVditorIRDOM(g.innerHTML + `<p data-block="0"><wbr>
</p>`), (0, J.ib)(p[p.currentMode].element, v), xt(p), un(p), d.preventDefault(), !0;
                }
                if (v.collapsed && g.previousElementSibling && d.key === "Backspace" && !(0, f.yl)(d) && !d.altKey && !d.shiftKey && g.textContent.trimRight().split(`
`).length > 1 && (0, J.im)(g, p[p.currentMode].element, v).start === 0) {
                  var _ = (0, C.DX)(g.previousElementSibling);
                  return _.textContent.endsWith(`
`) || (_.textContent = _.textContent + `
`), _.parentElement.insertAdjacentHTML("beforeend", "<wbr>".concat(g.innerHTML)), g.remove(), (0, J.ib)(p[p.currentMode].element, v), !1;
                }
                return !1;
              }
            }, _6 = function(d, p, g) {
              for (var v = "", w = 0; w < g.parentElement.childElementCount; w++)
                v += '<td align="'.concat(g.parentElement.children[w].getAttribute("align"), '"> </td>');
              g.tagName === "TH" ? g.parentElement.parentElement.insertAdjacentHTML("afterend", "<tbody><tr>".concat(v, "</tr></tbody>")) : g.parentElement.insertAdjacentHTML("afterend", "<tr>".concat(v, "</tr>")), xt(d);
            }, R6 = function(d, p, g) {
              for (var v = "", w = 0; w < g.parentElement.childElementCount; w++)
                g.tagName === "TH" ? v += '<th align="'.concat(g.parentElement.children[w].getAttribute("align"), '"> </th>') : v += '<td align="'.concat(g.parentElement.children[w].getAttribute("align"), '"> </td>');
              if (g.tagName === "TH") {
                g.parentElement.parentElement.insertAdjacentHTML("beforebegin", "<thead><tr>".concat(v, "</tr></thead>")), p.insertNode(document.createElement("wbr"));
                var S = g.parentElement.innerHTML.replace(/<th>/g, "<td>").replace(/<\/th>/g, "</td>");
                g.parentElement.parentElement.nextElementSibling.insertAdjacentHTML("afterbegin", S), g.parentElement.parentElement.remove(), (0, J.ib)(d.ir.element, p);
              } else
                g.parentElement.insertAdjacentHTML("beforebegin", "<tr>".concat(v, "</tr>"));
              xt(d);
            }, vp = function(d, p, g, v) {
              v === void 0 && (v = "afterend");
              for (var w = 0, S = g.previousElementSibling; S; )
                w++, S = S.previousElementSibling;
              for (var D = 0; D < p.rows.length; D++)
                D === 0 ? p.rows[D].cells[w].insertAdjacentHTML(v, "<th> </th>") : p.rows[D].cells[w].insertAdjacentHTML(v, "<td> </td>");
              xt(d);
            }, P6 = function(d, p, g) {
              if (g.tagName === "TD") {
                var v = g.parentElement.parentElement;
                g.parentElement.previousElementSibling ? p.selectNodeContents(g.parentElement.previousElementSibling.lastElementChild) : p.selectNodeContents(v.previousElementSibling.lastElementChild.lastElementChild), v.childElementCount === 1 ? v.remove() : g.parentElement.remove(), p.collapse(!1), (0, J.Hc)(p), xt(d);
              }
            }, B6 = function(d, p, g, v) {
              for (var w = 0, S = v.previousElementSibling; S; )
                w++, S = S.previousElementSibling;
              (v.previousElementSibling || v.nextElementSibling) && (p.selectNodeContents(v.previousElementSibling || v.nextElementSibling), p.collapse(!0));
              for (var D = 0; D < g.rows.length; D++) {
                var I = g.rows[D].cells;
                if (I.length === 1) {
                  g.remove(), ui(d);
                  break;
                }
                I[w].remove();
              }
              (0, J.Hc)(p), xt(d);
            }, H6 = function(d, p, g) {
              var v = g.startContainer, w = (0, C.lG)(v, "TD") || (0, C.lG)(v, "TH");
              if (w) {
                if (!(0, f.yl)(p) && !p.altKey && p.key === "Enter") {
                  (!w.lastElementChild || w.lastElementChild && (!w.lastElementChild.isSameNode(w.lastChild) || w.lastElementChild.tagName !== "BR")) && w.insertAdjacentHTML("beforeend", "<br>");
                  var S = document.createElement("br");
                  return g.insertNode(S), g.setStartAfter(S), xt(d), un(d), p.preventDefault(), !0;
                }
                if (p.key === "Tab") {
                  if (p.shiftKey)
                    return Uh(w, g), p.preventDefault(), !0;
                  var D = w.nextElementSibling;
                  return D || (w.parentElement.nextElementSibling ? D = w.parentElement.nextElementSibling.firstElementChild : w.parentElement.parentElement.tagName === "THEAD" && w.parentElement.parentElement.nextElementSibling ? D = w.parentElement.parentElement.nextElementSibling.firstElementChild.firstElementChild : D = null), D && (g.selectNodeContents(D), (0, J.Hc)(g)), p.preventDefault(), !0;
                }
                var I = w.parentElement.parentElement.parentElement;
                if (p.key === "ArrowUp") {
                  if (p.preventDefault(), w.tagName === "TH")
                    return I.previousElementSibling ? (g.selectNodeContents(I.previousElementSibling), g.collapse(!1), (0, J.Hc)(g)) : Tl(d, "beforebegin"), !0;
                  for (var B = 0, _ = w.parentElement; B < _.cells.length && !_.cells[B].isSameNode(w); B++)
                    ;
                  var W = _.previousElementSibling;
                  return W || (W = _.parentElement.previousElementSibling.firstChild), g.selectNodeContents(W.cells[B]), g.collapse(!1), (0, J.Hc)(g), !0;
                }
                if (p.key === "ArrowDown") {
                  p.preventDefault();
                  var _ = w.parentElement;
                  if (!_.nextElementSibling && w.tagName === "TD")
                    return I.nextElementSibling ? (g.selectNodeContents(I.nextElementSibling), g.collapse(!0), (0, J.Hc)(g)) : Tl(d, "afterend"), !0;
                  for (var B = 0; B < _.cells.length && !_.cells[B].isSameNode(w); B++)
                    ;
                  var D = _.nextElementSibling;
                  return D || (D = _.parentElement.nextElementSibling.firstChild), g.selectNodeContents(D.cells[B]), g.collapse(!0), (0, J.Hc)(g), !0;
                }
                if (d.currentMode === "wysiwyg" && !(0, f.yl)(p) && p.key === "Enter" && !p.shiftKey && p.altKey) {
                  var Z = d.wysiwyg.popover.querySelector(".vditor-input");
                  return Z.focus(), Z.select(), p.preventDefault(), !0;
                }
                if (!(0, f.yl)(p) && !p.shiftKey && !p.altKey && p.key === "Backspace" && g.startOffset === 0 && g.toString() === "") {
                  var ye = Uh(w, g, !1);
                  return !ye && I && (I.textContent.trim() === "" ? (I.outerHTML = `<p data-block="0"><wbr>
</p>`, (0, J.ib)(d[d.currentMode].element, g)) : (g.setStartBefore(I), g.collapse(!0)), xt(d)), p.preventDefault(), !0;
                }
                if (le("⇧⌘F", p))
                  return R6(d, g, w), p.preventDefault(), !0;
                if (le("⌘=", p))
                  return _6(d, g, w), p.preventDefault(), !0;
                if (le("⇧⌘G", p))
                  return vp(d, I, w, "beforebegin"), p.preventDefault(), !0;
                if (le("⇧⌘=", p))
                  return vp(d, I, w), p.preventDefault(), !0;
                if (le("⌘-", p))
                  return P6(d, g, w), p.preventDefault(), !0;
                if (le("⇧⌘-", p))
                  return B6(d, g, I, w), p.preventDefault(), !0;
                if (le("⇧⌘L", p)) {
                  if (d.currentMode === "ir")
                    return bp(I, "left"), xt(d), p.preventDefault(), !0;
                  var ve = d.wysiwyg.popover.querySelector('[data-type="left"]');
                  if (ve)
                    return ve.click(), p.preventDefault(), !0;
                }
                if (le("⇧⌘C", p)) {
                  if (d.currentMode === "ir")
                    return bp(I, "center"), xt(d), p.preventDefault(), !0;
                  var ve = d.wysiwyg.popover.querySelector('[data-type="center"]');
                  if (ve)
                    return ve.click(), p.preventDefault(), !0;
                }
                if (le("⇧⌘R", p)) {
                  if (d.currentMode === "ir")
                    return bp(I, "right"), xt(d), p.preventDefault(), !0;
                  var ve = d.wysiwyg.popover.querySelector('[data-type="right"]');
                  if (ve)
                    return ve.click(), p.preventDefault(), !0;
                }
              }
              return !1;
            }, z6 = function(d, p, g, v) {
              if (g.tagName === "PRE" && le("⌘A", p))
                return v.selectNodeContents(g.firstElementChild), p.preventDefault(), !0;
              if (d.options.tab && p.key === "Tab" && !p.shiftKey && v.toString() === "")
                return v.insertNode(document.createTextNode(d.options.tab)), v.collapse(!1), xt(d), p.preventDefault(), !0;
              if (p.key === "Backspace" && !(0, f.yl)(p) && !p.shiftKey && !p.altKey) {
                var w = (0, J.im)(g, d[d.currentMode].element, v);
                if ((w.start === 0 || w.start === 1 && g.innerText === `
`) && v.toString() === "")
                  return g.parentElement.outerHTML = '<p data-block="0"><wbr>'.concat(g.firstElementChild.innerHTML, "</p>"), (0, J.ib)(d[d.currentMode].element, v), xt(d), p.preventDefault(), !0;
              }
              return !(0, f.yl)(p) && !p.altKey && p.key === "Enter" ? (g.firstElementChild.textContent.endsWith(`
`) || g.firstElementChild.insertAdjacentText("beforeend", `
`), v.extractContents(), v.insertNode(document.createTextNode(`
`)), v.collapse(!1), (0, J.Hc)(v), (0, f.vU)() || (d.currentMode === "wysiwyg" ? Ml(d, v) : mt(d, v)), un(d), p.preventDefault(), !0) : !1;
            }, F6 = function(d, p, g, v) {
              var w = p.startContainer, S = (0, C.lG)(w, "BLOCKQUOTE");
              if (S && p.toString() === "") {
                if (g.key === "Backspace" && !(0, f.yl)(g) && !g.shiftKey && !g.altKey && (0, J.im)(S, d[d.currentMode].element, p).start === 0)
                  return p.insertNode(document.createElement("wbr")), S.outerHTML = S.innerHTML, (0, J.ib)(d[d.currentMode].element, p), xt(d), g.preventDefault(), !0;
                if (v && g.key === "Enter" && !(0, f.yl)(g) && !g.shiftKey && !g.altKey && v.parentElement.tagName === "BLOCKQUOTE") {
                  var D = !1;
                  if (v.innerHTML.replace(a.g.ZWSP, "") === `
` || v.innerHTML.replace(a.g.ZWSP, "") === "" ? (D = !0, v.remove()) : v.innerHTML.endsWith(`

`) && (0, J.im)(v, d[d.currentMode].element, p).start === v.textContent.length - 1 && (v.innerHTML = v.innerHTML.substr(0, v.innerHTML.length - 2), D = !0), D)
                    return S.insertAdjacentHTML("afterend", '<p data-block="0">'.concat(a.g.ZWSP, `<wbr>
</p>`)), (0, J.ib)(d[d.currentMode].element, p), xt(d), g.preventDefault(), !0;
                }
                var I = (0, C.F9)(w);
                if (d.currentMode === "wysiwyg" && I && le("⇧⌘;", g))
                  return p.insertNode(document.createElement("wbr")), I.outerHTML = '<blockquote data-block="0">'.concat(I.outerHTML, "</blockquote>"), (0, J.ib)(d.wysiwyg.element, p), kt(d), g.preventDefault(), !0;
                if (Nt(d, g, p, S, S) || Ge(d, g, p, S, S))
                  return !0;
              }
              return !1;
            }, V6 = function(d, p, g) {
              var v = p.startContainer, w = (0, C.lG)(v, "LI");
              if (w && w.classList.contains("vditor-task")) {
                if (le("⇧⌘J", g)) {
                  var S = w.firstElementChild;
                  return S.checked ? S.removeAttribute("checked") : S.setAttribute("checked", "checked"), xt(d), g.preventDefault(), !0;
                }
                if (g.key === "Backspace" && !(0, f.yl)(g) && !g.shiftKey && !g.altKey && p.toString() === "" && p.startOffset === 1 && (v.nodeType === 3 && v.previousSibling && v.previousSibling.tagName === "INPUT" || v.nodeType !== 3)) {
                  var D = w.previousElementSibling;
                  if (w.querySelector("input").remove(), D) {
                    var I = (0, C.DX)(D);
                    I.parentElement.insertAdjacentHTML("beforeend", "<wbr>" + w.innerHTML.trim()), w.remove();
                  } else
                    w.parentElement.insertAdjacentHTML("beforebegin", '<p data-block="0"><wbr>'.concat(w.innerHTML.trim() || `
`, "</p>")), w.nextElementSibling ? w.remove() : w.parentElement.remove();
                  return (0, J.ib)(d[d.currentMode].element, p), xt(d), g.preventDefault(), !0;
                }
                if (g.key === "Enter" && !(0, f.yl)(g) && !g.shiftKey && !g.altKey) {
                  if (w.textContent.trim() === "")
                    if ((0, C.fb)(w.parentElement, "vditor-task")) {
                      var B = (0, C.O9)(v);
                      B && Kh(d, w, p, B);
                    } else if (w.nextElementSibling) {
                      var _ = "", W = "", Z = !1;
                      Array.from(w.parentElement.children).forEach(function(Ae) {
                        w.isSameNode(Ae) ? Z = !0 : Z ? _ += Ae.outerHTML : W += Ae.outerHTML;
                      });
                      var ye = w.parentElement.tagName, ve = w.parentElement.tagName === "OL" ? "" : ' data-marker="'.concat(w.parentElement.getAttribute("data-marker"), '"'), fe = "";
                      W && (fe = w.parentElement.tagName === "UL" ? "" : ' start="1"', W = "<".concat(ye, ' data-tight="true"').concat(ve, ' data-block="0">').concat(W, "</").concat(ye, ">")), w.parentElement.outerHTML = "".concat(W, `<p data-block="0"><wbr>
</p><`).concat(ye, `
 data-tight="true"`).concat(ve, ' data-block="0"').concat(fe, ">").concat(_, "</").concat(ye, ">");
                    } else
                      w.parentElement.insertAdjacentHTML("afterend", `<p data-block="0"><wbr>
</p>`), w.parentElement.querySelectorAll("li").length === 1 ? w.parentElement.remove() : w.remove();
                  else v.nodeType !== 3 && p.startOffset === 0 && v.firstChild.tagName === "INPUT" ? p.setStart(v.childNodes[1], 1) : (p.setEndAfter(w.lastChild), w.insertAdjacentHTML("afterend", '<li class="vditor-task" data-marker="'.concat(w.getAttribute("data-marker"), '"><input type="checkbox"> <wbr></li>')), document.querySelector("wbr").after(p.extractContents()));
                  return (0, J.ib)(d[d.currentMode].element, p), xt(d), un(d), g.preventDefault(), !0;
                }
              }
              return !1;
            }, q6 = function(d, p, g, v) {
              if (p.startContainer.nodeType !== 3) {
                var w = p.startContainer.children[p.startOffset];
                if (w && w.tagName === "HR")
                  return p.selectNodeContents(w.previousElementSibling), p.collapse(!1), g.preventDefault(), !0;
              }
              if (v) {
                var S = v.previousElementSibling;
                if (S && (0, J.im)(v, d[d.currentMode].element, p).start === 0 && ((0, f.vU)() && S.tagName === "HR" || S.tagName === "TABLE")) {
                  if (S.tagName === "TABLE") {
                    var D = S.lastElementChild.lastElementChild.lastElementChild;
                    D.innerHTML = D.innerHTML.trimLeft() + "<wbr>" + v.textContent.trim(), v.remove();
                  } else
                    S.remove();
                  return (0, J.ib)(d[d.currentMode].element, p), xt(d), g.preventDefault(), !0;
                }
              }
              return !1;
            }, $6 = function(d) {
              (0, f.vU)() && d.startContainer.nodeType !== 3 && d.startContainer.tagName === "HR" && d.setStartBefore(d.startContainer);
            }, j6 = function(d, p, g) {
              var v, w;
              if (!(0, f.vU)())
                return !1;
              if (d.key === "ArrowUp" && p && ((v = p.previousElementSibling) === null || v === void 0 ? void 0 : v.tagName) === "TABLE") {
                var S = p.previousElementSibling;
                return g.selectNodeContents(S.rows[S.rows.length - 1].lastElementChild), g.collapse(!1), d.preventDefault(), !0;
              }
              return d.key === "ArrowDown" && p && ((w = p.nextElementSibling) === null || w === void 0 ? void 0 : w.tagName) === "TABLE" ? (g.selectNodeContents(p.nextElementSibling.rows[0].cells[0]), g.collapse(!0), d.preventDefault(), !0) : !1;
            }, wp = function(d, p, g) {
              return jh(void 0, void 0, void 0, function() {
                var v, w, S, D, I, B, _, W, Z, ye, ve, fe, Ae, de, Me, de, Je;
                return Wh(this, function(De) {
                  switch (De.label) {
                    case 0:
                      return d[d.currentMode].element.getAttribute("contenteditable") !== "true" ? [
                        2
                        /*return*/
                      ] : (p.stopPropagation(), p.preventDefault(), "clipboardData" in p ? (v = p.clipboardData.getData("text/html"), w = p.clipboardData.getData("text/plain"), S = p.clipboardData.files) : (v = p.dataTransfer.getData("text/html"), w = p.dataTransfer.getData("text/plain"), p.dataTransfer.types.includes("Files") && (S = p.dataTransfer.items)), D = {}, I = function(nt, Yt) {
                        if (!Yt)
                          return ["", Lute.WalkContinue];
                        if (d.options.upload.renderLinkDest)
                          return d.options.upload.renderLinkDest(d, nt, Yt);
                        var jt = nt.TokensStr();
                        if (nt.__internal_object__.Parent.Type === 34 && jt && jt.indexOf("file://") === -1 && d.options.upload.linkToImgUrl) {
                          var sn = new XMLHttpRequest();
                          sn.open("POST", d.options.upload.linkToImgUrl), d.options.upload.token && sn.setRequestHeader("X-Upload-Token", d.options.upload.token), d.options.upload.withCredentials && (sn.withCredentials = !0), So(d, sn), sn.setRequestHeader("Content-Type", "application/json; charset=utf-8"), sn.onreadystatechange = function() {
                            if (sn.readyState === XMLHttpRequest.DONE) {
                              if (sn.status === 200) {
                                var qr = sn.responseText;
                                d.options.upload.linkToImgFormat && (qr = d.options.upload.linkToImgFormat(sn.responseText));
                                var sr = JSON.parse(qr);
                                if (sr.code !== 0) {
                                  d.tip.show(sr.msg);
                                  return;
                                }
                                var $r = sr.data.originalURL;
                                if (d.currentMode === "sv")
                                  d.sv.element.querySelectorAll(".vditor-sv__marker--link").forEach(function(Hn) {
                                    Hn.textContent === $r && (Hn.textContent = sr.data.url);
                                  });
                                else {
                                  var bt = d[d.currentMode].element.querySelector('img[src="'.concat($r, '"]'));
                                  bt.src = sr.data.url, d.currentMode === "ir" && (bt.previousElementSibling.previousElementSibling.innerHTML = sr.data.url);
                                }
                                xt(d);
                              } else
                                d.tip.show(sn.responseText);
                              d.options.upload.linkToImgCallback && d.options.upload.linkToImgCallback(sn.responseText);
                            }
                          }, sn.send(JSON.stringify({ url: jt }));
                        }
                        return d.currentMode === "ir" ? ['<span class="vditor-ir__marker vditor-ir__marker--link">'.concat(Lute.EscapeHTMLStr(jt), "</span>"), Lute.WalkContinue] : d.currentMode === "wysiwyg" ? ["", Lute.WalkContinue] : ['<span class="vditor-sv__marker--link">'.concat(Lute.EscapeHTMLStr(jt), "</span>"), Lute.WalkContinue];
                      }, (v.replace(/&amp;/g, "&").replace(/<(|\/)(html|body|meta)[^>]*?>/ig, "").trim() === '<a href="'.concat(w, '">').concat(w, "</a>") || v.replace(/&amp;/g, "&").replace(/<(|\/)(html|body|meta)[^>]*?>/ig, "").trim() === '<!--StartFragment--><a href="'.concat(w, '">').concat(w, "</a><!--EndFragment-->")) && (v = ""), B = new DOMParser().parseFromString(v, "text/html"), B.body && (v = B.body.innerHTML), v = Lute.Sanitize(v), d.wysiwyg.getComments(d), _ = d[d.currentMode].element.scrollHeight, W = q(v, w, d.currentMode), Z = d.currentMode === "sv" ? (0, C.a1)(p.target, "data-type", "code-block") : (0, C.lG)(p.target, "CODE"), Z ? (d.currentMode === "sv" ? document.execCommand("insertHTML", !1, w.replace(/&/g, "&amp;").replace(/</g, "&lt;")) : (ye = (0, J.im)(p.target, d[d.currentMode].element), Z.parentElement.tagName !== "PRE" && (w += a.g.ZWSP), Z.textContent = Z.textContent.substring(0, ye.start) + w + Z.textContent.substring(ye.end), (0, J.$j)(ye.start + w.length, ye.start + w.length, Z.parentElement), !((Je = Z.parentElement) === null || Je === void 0) && Je.nextElementSibling.classList.contains("vditor-".concat(d.currentMode, "__preview")) && (Z.parentElement.nextElementSibling.innerHTML = Z.outerHTML, Re(Z.parentElement.nextElementSibling, d))), [3, 10]) : [3, 1]);
                    case 1:
                      return W ? (g.pasteCode(W), [3, 10]) : [3, 2];
                    case 2:
                      return v.trim() === "" ? [3, 5] : (ve = document.createElement("div"), ve.innerHTML = v, d.options.upload.base64ToLink ? [3, 4] : [4, EI(d, ve, ("clipboardData" in p ? p.clipboardData : p.dataTransfer).getData("text/rtf"))]);
                    case 3:
                      De.sent(), De.label = 4;
                    case 4:
                      return ve.querySelectorAll("[style]").forEach(function(nt) {
                        nt.removeAttribute("style");
                      }), ve.querySelectorAll(".vditor-copy").forEach(function(nt) {
                        nt.remove();
                      }), d.currentMode === "ir" ? (D.HTML2VditorIRDOM = { renderLinkDest: I }, d.lute.SetJSRenderers({ renderers: D }), (0, J.oC)(d.lute.HTML2VditorIRDOM(ve.innerHTML), d)) : d.currentMode === "wysiwyg" ? (D.HTML2VditorDOM = { renderLinkDest: I }, d.lute.SetJSRenderers({ renderers: D }), (0, J.oC)(d.lute.HTML2VditorDOM(ve.innerHTML), d)) : (D.Md2VditorSVDOM = { renderLinkDest: I }, d.lute.SetJSRenderers({ renderers: D }), be(d, d.lute.HTML2Md(ve.innerHTML).trimRight())), d.outline.render(d), [3, 10];
                    case 5:
                      return S.length > 0 ? d.options.upload.url || d.options.upload.handler ? [4, Uc(d, S)] : [3, 7] : [3, 9];
                    case 6:
                      return De.sent(), [3, 8];
                    case 7:
                      fe = new FileReader(), "clipboardData" in p ? (S = p.clipboardData.files, Ae = S[0]) : p.dataTransfer.types.includes("Files") && (S = p.dataTransfer.items, Ae = S[0].getAsFile()), Ae && Ae.type.startsWith("image") && (fe.readAsDataURL(Ae), fe.onload = function() {
                        var nt = "";
                        d.currentMode === "wysiwyg" ? nt += '<img alt="'.concat(Ae.name, '" src="').concat(fe.result.toString(), `">
`) : nt += "![".concat(Ae.name, "](").concat(fe.result.toString(), `)
`), document.execCommand("insertHTML", !1, nt);
                      }), De.label = 8;
                    case 8:
                      return [3, 10];
                    case 9:
                      w.trim() !== "" && S.length === 0 && (de = (0, J.zh)(d), de.toString() !== "" && d.lute.IsValidLinkDest(w) && (w = "[".concat(de.toString(), "](").concat(w, ")")), d.currentMode === "ir" ? (D.Md2VditorIRDOM = { renderLinkDest: I }, d.lute.SetJSRenderers({ renderers: D }), (0, J.oC)(Lute.Sanitize(d.lute.Md2VditorIRDOM(w)), d)) : d.currentMode === "wysiwyg" ? (D.Md2VditorDOM = { renderLinkDest: I }, d.lute.SetJSRenderers({ renderers: D }), (0, J.oC)(Lute.Sanitize(d.lute.Md2VditorDOM(w)), d)) : (D.Md2VditorSVDOM = { renderLinkDest: I }, d.lute.SetJSRenderers({ renderers: D }), be(d, w)), d.outline.render(d)), De.label = 10;
                    case 10:
                      return d.currentMode !== "sv" && (Me = (0, C.F9)((0, J.zh)(d).startContainer), Me && (de = (0, J.zh)(d), d[d.currentMode].element.querySelectorAll("wbr").forEach(function(nt) {
                        nt.remove();
                      }), de.insertNode(document.createElement("wbr")), d.currentMode === "wysiwyg" ? Me.outerHTML = d.lute.SpinVditorDOM(Me.outerHTML) : Me.outerHTML = d.lute.SpinVditorIRDOM(Me.outerHTML), (0, J.ib)(d[d.currentMode].element, de)), d[d.currentMode].element.querySelectorAll(".vditor-".concat(d.currentMode, "__preview[data-render='2']")).forEach(function(nt) {
                        Re(nt, d);
                      })), d.wysiwyg.triggerRemoveComment(d), xt(d), d[d.currentMode].element.scrollHeight - _ > Math.min(d[d.currentMode].element.clientHeight, window.innerHeight) / 2 && un(d), [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }, EI = function(d, p, g) {
              return jh(void 0, void 0, void 0, function() {
                var v, w, S, D, I, B, _, W, Z, Ae, ye, ve, fe, Ae, Me, de;
                return Wh(this, function(Je) {
                  switch (Je.label) {
                    case 0:
                      if (!g)
                        return [
                          2
                          /*return*/
                        ];
                      if (v = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, w = new RegExp("(?:(" + v.source + "))([\\da-fA-F\\s]+)\\}", "g"), S = g.match(w), D = [], S)
                        for (I = 0, B = S; I < B.length; I++)
                          _ = B[I], W = void 0, _.includes("\\pngblip") ? W = "image/png" : _.includes("\\jpegblip") && (W = "image/jpeg"), W && D.push({
                            hex: _.replace(v, "").replace(/[^\da-fA-F]/g, ""),
                            type: W
                          });
                      for (Z = [], Wy(p, function(De) {
                        if (De.tagName === "V:SHAPE")
                          return Wy(De, function(nt) {
                            nt.tagName === "V:IMAGEDATA" && Z.push({ shape: De, img: nt });
                          }), !1;
                      }), Ae = 0; Ae < Z.length; Ae++)
                        ye = document.createElement("img"), ve = "data:" + D[Ae].type + ";base64," + btoa((D[Ae].hex.match(/\w{2}/g) || []).map(function(De) {
                          return String.fromCharCode(parseInt(De, 16));
                        }).join("")), ye.src = ve, ye.title = Z[Ae].img.getAttribute("title"), Z[Ae].shape.parentNode.replaceChild(ye, Z[Ae].shape);
                      fe = p.querySelectorAll("img"), Ae = 0, Je.label = 1;
                    case 1:
                      return Ae < fe.length ? (Me = fe[Ae].src || "", Me ? (de = fe[Ae], [4, d.options.upload.base64ToLink(Me)]) : [3, 3]) : [3, 4];
                    case 2:
                      de.src = Je.sent(), Je.label = 3;
                    case 3:
                      return Ae++, [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }, Wy = function(d, p) {
              var g = p(d);
              if (g !== !1)
                for (var v = 0; v < d.children.length; v++)
                  Wy(d.children[v], p);
            }, W6, U6 = function(d) {
              var p, g;
              d.hint.render(d);
              var v = (0, J.zh)(d).startContainer, w = (0, C.a1)(v, "data-type", "code-block-info");
              if (w)
                if (w.textContent.replace(a.g.ZWSP, "") === "" && d.hint.recentLanguage) {
                  w.textContent = a.g.ZWSP + d.hint.recentLanguage;
                  var S = (0, J.zh)(d);
                  S.selectNodeContents(w);
                } else {
                  var D = [], I = w.textContent.substring(0, (0, J.im)(w, d.ir.element).start).replace(a.g.ZWSP, "");
                  (d.options.preview.hljs.langs || a.g.ALIAS_CODE_LANGUAGES.concat(((g = (p = window.hljs) === null || p === void 0 ? void 0 : p.listLanguages()) !== null && g !== void 0 ? g : []).sort())).forEach(function(B) {
                    B.indexOf(I.toLowerCase()) > -1 && D.push({
                      html: B,
                      value: B
                    });
                  }), d.hint.genHTML(D, I, d);
                }
            }, Mo = function(d, p) {
              p === void 0 && (p = {
                enableAddUndoStack: !0,
                enableHint: !1,
                enableInput: !0
              }), p.enableHint && U6(d), clearTimeout(d.ir.processTimeoutId), d.ir.processTimeoutId = window.setTimeout(function() {
                if (!d.ir.composingLock) {
                  var g = c(d);
                  typeof d.options.input == "function" && p.enableInput && d.options.input(g), d.options.counter.enable && d.counter.render(d, g), d.options.cache.enable && (0, f.pK)() && (localStorage.setItem(d.options.cache.id, g), d.options.cache.after && d.options.cache.after(g)), d.devtools && d.devtools.renderEchart(d), p.enableAddUndoStack && d.undo.addToUndoStack(d);
                }
              }, d.options.undoDelay);
            }, Gh = function(d, p) {
              var g = (0, J.zh)(d), v = (0, C.F9)(g.startContainer) || g.startContainer;
              if (v) {
                var w = v.querySelector(".vditor-ir__marker--heading");
                w ? w.innerHTML = p : (v.insertAdjacentText("afterbegin", p), g.selectNodeContents(v), g.collapse(!1)), mt(d, g.cloneRange()), mr(d);
              }
            }, kp = function(d, p, g) {
              var v = (0, C.a1)(d.startContainer, "data-type", g);
              if (v) {
                v.firstElementChild.remove(), v.lastElementChild.remove(), d.insertNode(document.createElement("wbr"));
                var w = document.createElement("div");
                w.innerHTML = p.lute.SpinVditorIRDOM(v.outerHTML), v.outerHTML = w.firstElementChild.innerHTML.trim();
              }
            }, LI = function(d, p, g, v) {
              var w = (0, J.zh)(d), S = p.getAttribute("data-type"), D = w.startContainer;
              D.nodeType === 3 && (D = D.parentElement);
              var I = !0;
              if (p.classList.contains("vditor-menu--current"))
                if (S === "quote") {
                  var B = (0, C.lG)(D, "BLOCKQUOTE");
                  B && (w.insertNode(document.createElement("wbr")), B.outerHTML = B.innerHTML.trim() === "" ? '<p data-block="0">'.concat(B.innerHTML, "</p>") : B.innerHTML);
                } else if (S === "link") {
                  var _ = (0, C.a1)(w.startContainer, "data-type", "a");
                  if (_) {
                    var W = (0, C.fb)(w.startContainer, "vditor-ir__link");
                    W ? (w.insertNode(document.createElement("wbr")), _.outerHTML = W.innerHTML) : _.outerHTML = _.querySelector(".vditor-ir__link").innerHTML + "<wbr>";
                  }
                } else S === "italic" ? kp(w, d, "em") : S === "bold" ? kp(w, d, "strong") : S === "strike" ? kp(w, d, "s") : S === "inline-code" ? kp(w, d, "code") : (S === "check" || S === "list" || S === "ordered-list") && (Ze(d, w, S), I = !1, p.classList.remove("vditor-menu--current"));
              else {
                d.ir.element.childNodes.length === 0 && (d.ir.element.innerHTML = '<p data-block="0"><wbr></p>', (0, J.ib)(d.ir.element, w));
                var Z = (0, C.F9)(w.startContainer);
                if (S === "line") {
                  if (Z) {
                    var ye = `<hr data-block="0"><p data-block="0"><wbr>
</p>`;
                    Z.innerHTML.trim() === "" ? Z.outerHTML = ye : Z.insertAdjacentHTML("afterend", ye);
                  }
                } else if (S === "quote")
                  Z && (w.insertNode(document.createElement("wbr")), Z.outerHTML = '<blockquote data-block="0">'.concat(Z.outerHTML, "</blockquote>"), I = !1, p.classList.add("vditor-menu--current"));
                else if (S === "link") {
                  var ve = void 0;
                  w.toString() === "" ? ve = "".concat(g, "<wbr>").concat(v) : ve = "".concat(g).concat(w.toString()).concat(v.replace(")", "<wbr>)")), document.execCommand("insertHTML", !1, ve), I = !1, p.classList.add("vditor-menu--current");
                } else if (S === "italic" || S === "bold" || S === "strike" || S === "inline-code" || S === "code" || S === "table") {
                  var ve = void 0;
                  w.toString() === "" ? ve = "".concat(g, "<wbr>").concat(v) : (S === "code" ? ve = "".concat(g, `
`).concat(w.toString(), "<wbr>").concat(v) : S === "table" ? ve = "".concat(g).concat(w.toString(), "<wbr>").concat(v) : ve = "".concat(g).concat(w.toString()).concat(v, "<wbr>"), w.deleteContents()), (S === "table" || S === "code") && (ve = `
` + ve + `

`);
                  var fe = document.createElement("span");
                  fe.innerHTML = ve, w.insertNode(fe), mt(d, w), S === "table" && (w.selectNodeContents(getSelection().getRangeAt(0).startContainer.parentElement), (0, J.Hc)(w));
                } else (S === "check" || S === "list" || S === "ordered-list") && (Ze(d, w, S, !1), I = !1, m(d.toolbar.elements, ["check", "list", "ordered-list"]), p.classList.add("vditor-menu--current"));
              }
              (0, J.ib)(d.ir.element, w), Mo(d), I && mr(d);
            }, OI = function(d, p, g, v) {
              function w(S) {
                return S instanceof g ? S : new g(function(D) {
                  D(S);
                });
              }
              return new (g || (g = Promise))(function(S, D) {
                function I(W) {
                  try {
                    _(v.next(W));
                  } catch (Z) {
                    D(Z);
                  }
                }
                function B(W) {
                  try {
                    _(v.throw(W));
                  } catch (Z) {
                    D(Z);
                  }
                }
                function _(W) {
                  W.done ? S(W.value) : w(W.value).then(I, B);
                }
                _((v = v.apply(d, p || [])).next());
              });
            }, DI = function(d, p) {
              var g = { label: 0, sent: function() {
                if (S[0] & 1) throw S[1];
                return S[1];
              }, trys: [], ops: [] }, v, w, S, D;
              return D = { next: I(0), throw: I(1), return: I(2) }, typeof Symbol == "function" && (D[Symbol.iterator] = function() {
                return this;
              }), D;
              function I(_) {
                return function(W) {
                  return B([_, W]);
                };
              }
              function B(_) {
                if (v) throw new TypeError("Generator is already executing.");
                for (; D && (D = 0, _[0] && (g = 0)), g; ) try {
                  if (v = 1, w && (S = _[0] & 2 ? w.return : _[0] ? w.throw || ((S = w.return) && S.call(w), 0) : w.next) && !(S = S.call(w, _[1])).done) return S;
                  switch (w = 0, S && (_ = [_[0] & 2, S.value]), _[0]) {
                    case 0:
                    case 1:
                      S = _;
                      break;
                    case 4:
                      return g.label++, { value: _[1], done: !1 };
                    case 5:
                      g.label++, w = _[1], _ = [0];
                      continue;
                    case 7:
                      _ = g.ops.pop(), g.trys.pop();
                      continue;
                    default:
                      if (S = g.trys, !(S = S.length > 0 && S[S.length - 1]) && (_[0] === 6 || _[0] === 2)) {
                        g = 0;
                        continue;
                      }
                      if (_[0] === 3 && (!S || _[1] > S[0] && _[1] < S[3])) {
                        g.label = _[1];
                        break;
                      }
                      if (_[0] === 6 && g.label < S[1]) {
                        g.label = S[1], S = _;
                        break;
                      }
                      if (S && g.label < S[2]) {
                        g.label = S[2], g.ops.push(_);
                        break;
                      }
                      S[2] && g.ops.pop(), g.trys.pop();
                      continue;
                  }
                  _ = p.call(d, g);
                } catch (W) {
                  _ = [6, W], w = 0;
                } finally {
                  v = S = 0;
                }
                if (_[0] & 5) throw _[1];
                return { value: _[0] ? _[1] : void 0, done: !0 };
              }
            }, NI = (
              /** @class */
              function() {
                function d(p) {
                  var g = this;
                  this.splitChar = "", this.lastIndex = -1, this.fillEmoji = function(v, w) {
                    g.element.style.display = "none";
                    var S = decodeURIComponent(v.getAttribute("data-value")), D = window.getSelection().getRangeAt(0);
                    if (w.currentMode === "ir") {
                      var I = (0, C.a1)(D.startContainer, "data-type", "code-block-info");
                      if (I) {
                        I.textContent = a.g.ZWSP + S.trimRight(), D.selectNodeContents(I), D.collapse(!1), Mo(w), I.parentElement.querySelectorAll("code").forEach(function(Z) {
                          Z.className = "language-" + S.trimRight();
                        }), Re(I.parentElement.querySelector(".vditor-ir__preview"), w), g.recentLanguage = S.trimRight();
                        return;
                      }
                    }
                    if (w.currentMode === "wysiwyg" && D.startContainer.nodeType !== 3) {
                      var B = D.startContainer, _ = void 0;
                      if (B.classList.contains("vditor-input") ? _ = B : _ = B.firstElementChild, _ && _.classList.contains("vditor-input")) {
                        _.value = S.trimRight(), D.selectNodeContents(_), D.collapse(!1), _.dispatchEvent(new CustomEvent("input", { detail: 1 })), g.recentLanguage = S.trimRight();
                        return;
                      }
                    }
                    if (D.setStart(D.startContainer, g.lastIndex), D.deleteContents(), w.options.hint.parse ? w.currentMode === "sv" ? (0, J.oC)(w.lute.SpinVditorSVDOM(S), w) : w.currentMode === "wysiwyg" ? (0, J.oC)(w.lute.SpinVditorDOM(S), w) : (0, J.oC)(w.lute.SpinVditorIRDOM(S), w) : (0, J.oC)(S, w), g.splitChar === ":" && S.indexOf(":") > -1 && w.currentMode !== "sv" && D.insertNode(document.createTextNode(" ")), D.collapse(!1), (0, J.Hc)(D), w.currentMode === "wysiwyg") {
                      var W = (0, C.fb)(D.startContainer, "vditor-wysiwyg__block");
                      W && W.lastElementChild.classList.contains("vditor-wysiwyg__preview") && (W.lastElementChild.innerHTML = W.firstElementChild.innerHTML, Re(W.lastElementChild, w));
                    } else if (w.currentMode === "ir") {
                      var W = (0, C.fb)(D.startContainer, "vditor-ir__marker--pre");
                      W && W.nextElementSibling.classList.contains("vditor-ir__preview") && (W.nextElementSibling.innerHTML = W.innerHTML, Re(W.nextElementSibling, w));
                    }
                    xt(w);
                  }, this.timeId = -1, this.element = document.createElement("div"), this.element.className = "vditor-hint", this.recentLanguage = "", p.push({ key: ":" });
                }
                return d.prototype.render = function(p) {
                  var g = this;
                  if (window.getSelection().focusNode) {
                    var v, w = getSelection().getRangeAt(0);
                    v = w.startContainer.textContent.substring(0, w.startOffset) || "";
                    var S = this.getKey(v, p.options.hint.extend);
                    if (typeof S > "u")
                      this.element.style.display = "none", clearTimeout(this.timeId);
                    else if (this.splitChar === ":") {
                      var D = S === "" ? p.options.hint.emoji : p.lute.GetEmojis(), I = [];
                      Object.keys(D).forEach(function(B) {
                        B.indexOf(S.toLowerCase()) === 0 && (D[B].indexOf(".") > -1 ? I.push({
                          html: '<img src="'.concat(D[B], '" title=":').concat(B, ':"/> :').concat(B, ":"),
                          value: ":".concat(B, ":")
                        }) : I.push({
                          html: '<span class="vditor-hint__emoji">'.concat(D[B], "</span>").concat(B),
                          value: D[B]
                        }));
                      }), this.genHTML(I, S, p);
                    } else
                      p.options.hint.extend.forEach(function(B) {
                        B.key === g.splitChar && (clearTimeout(g.timeId), g.timeId = window.setTimeout(function() {
                          return OI(g, void 0, void 0, function() {
                            var _;
                            return DI(this, function(W) {
                              switch (W.label) {
                                case 0:
                                  return _ = this.genHTML, [4, B.hint(S)];
                                case 1:
                                  return _.apply(this, [W.sent(), S, p]), [
                                    2
                                    /*return*/
                                  ];
                              }
                            });
                          });
                        }, p.options.hint.delay));
                      });
                  }
                }, d.prototype.genHTML = function(p, g, v) {
                  var w = this;
                  if (p.length === 0) {
                    this.element.style.display = "none";
                    return;
                  }
                  var S = v[v.currentMode].element, D = (0, J.Ny)(S), I = D.left + (v.options.outline.position === "left" ? v.outline.element.offsetWidth : 0), B = D.top, _ = "";
                  p.forEach(function(Z, ye) {
                    if (!(ye > 7)) {
                      var ve = Z.html;
                      if (g !== "") {
                        var fe = ve.lastIndexOf(">") + 1, Ae = ve.substr(fe), Me = Ae.toLowerCase().indexOf(g.toLowerCase());
                        Me > -1 && (Ae = Ae.substring(0, Me) + "<b>" + Ae.substring(Me, Me + g.length) + "</b>" + Ae.substring(Me + g.length), ve = ve.substr(0, fe) + Ae);
                      }
                      _ += '<button type="button" data-value="'.concat(encodeURIComponent(Z.value), ` "
`).concat(ye === 0 ? "class='vditor-hint--current'" : "", "> ").concat(ve, "</button>");
                    }
                  }), this.element.innerHTML = _;
                  var W = parseInt(document.defaultView.getComputedStyle(S, null).getPropertyValue("line-height"), 10);
                  this.element.style.top = "".concat(B + (W || 22), "px"), this.element.style.left = "".concat(I, "px"), this.element.style.display = "block", this.element.style.right = "auto", this.element.querySelectorAll("button").forEach(function(Z) {
                    Z.addEventListener("click", function(ye) {
                      w.fillEmoji(Z, v), ye.preventDefault();
                    });
                  }), this.element.getBoundingClientRect().bottom > window.innerHeight && (this.element.style.top = "".concat(B - this.element.offsetHeight, "px")), this.element.getBoundingClientRect().right > window.innerWidth && (this.element.style.left = "auto", this.element.style.right = "0");
                }, d.prototype.select = function(p, g) {
                  if (this.element.querySelectorAll("button").length === 0 || this.element.style.display === "none")
                    return !1;
                  var v = this.element.querySelector(".vditor-hint--current");
                  if (p.key === "ArrowDown")
                    return p.preventDefault(), p.stopPropagation(), v.removeAttribute("class"), v.nextElementSibling ? v.nextElementSibling.className = "vditor-hint--current" : this.element.children[0].className = "vditor-hint--current", !0;
                  if (p.key === "ArrowUp") {
                    if (p.preventDefault(), p.stopPropagation(), v.removeAttribute("class"), v.previousElementSibling)
                      v.previousElementSibling.className = "vditor-hint--current";
                    else {
                      var w = this.element.children.length;
                      this.element.children[w - 1].className = "vditor-hint--current";
                    }
                    return !0;
                  } else if (!(0, f.yl)(p) && !p.shiftKey && !p.altKey && p.key === "Enter" && !p.isComposing)
                    return p.preventDefault(), p.stopPropagation(), this.fillEmoji(v, g), !0;
                  return !1;
                }, d.prototype.getKey = function(p, g) {
                  var v = this;
                  this.lastIndex = -1, this.splitChar = "", g.forEach(function(_) {
                    var W = p.lastIndexOf(_.key);
                    v.lastIndex < W && (v.splitChar = _.key, v.lastIndex = W);
                  });
                  var w;
                  if (this.lastIndex === -1)
                    return w;
                  var S = p.split(this.splitChar), D = S[S.length - 1], I = 32;
                  if (S.length > 1 && D.trim() === D)
                    if (S.length === 2 && S[0] === "" && S[1].length < I)
                      w = S[1];
                    else {
                      var B = S[S.length - 2].slice(-1);
                      (0, l.X)(B) === " " && D.length < I && (w = D);
                    }
                  return w;
                }, d;
              }()
            ), II = (
              /** @class */
              function() {
                function d(p) {
                  this.composingLock = !1;
                  var g = document.createElement("div");
                  g.className = "vditor-ir", g.innerHTML = '<pre class="vditor-reset" placeholder="'.concat(p.options.placeholder, `"
 contenteditable="true" spellcheck="false"></pre>`), this.element = g.firstElementChild, this.bindEvent(p), bo(p, this.element), Ar(p, this.element), vo(p, this.element), Ke(p, this.element), Y(p, this.element), wo(p, this.element), ko(p, this.element, this.copy), xo(p, this.element, this.copy);
                }
                return d.prototype.copy = function(p, g) {
                  var v = getSelection().getRangeAt(0);
                  if (v.toString() !== "") {
                    p.stopPropagation(), p.preventDefault();
                    var w = document.createElement("div");
                    w.appendChild(v.cloneContents()), p.clipboardData.setData("text/plain", g.lute.VditorIRDOM2Md(w.innerHTML).trim()), p.clipboardData.setData("text/html", "");
                  }
                }, d.prototype.bindEvent = function(p) {
                  var g = this;
                  this.element.addEventListener("paste", function(v) {
                    wp(p, v, {
                      pasteCode: function(w) {
                        document.execCommand("insertHTML", !1, w);
                      }
                    });
                  }), this.element.addEventListener("scroll", function() {
                    T(p, ["hint"]);
                  }), this.element.addEventListener("compositionstart", function(v) {
                    g.composingLock = !0;
                  }), this.element.addEventListener("compositionend", function(v) {
                    (0, f.vU)() || mt(p, getSelection().getRangeAt(0).cloneRange()), g.composingLock = !1;
                  }), this.element.addEventListener("input", function(v) {
                    if (!(v.inputType === "deleteByDrag" || v.inputType === "insertFromDrop")) {
                      if (g.preventInput) {
                        g.preventInput = !1, Mo(p, {
                          enableAddUndoStack: !0,
                          enableHint: !0,
                          enableInput: !0
                        });
                        return;
                      }
                      g.composingLock || v.data === "‘" || v.data === "“" || v.data === "《" || mt(p, getSelection().getRangeAt(0).cloneRange(), !1, v);
                    }
                  }), this.element.addEventListener("click", function(v) {
                    if (v.target.tagName === "INPUT") {
                      v.target.checked ? v.target.setAttribute("checked", "checked") : v.target.removeAttribute("checked"), g.preventInput = !0, Mo(p);
                      return;
                    }
                    var w = (0, J.zh)(p), S = (0, C.fb)(v.target, "vditor-ir__preview");
                    if (S || (S = (0, C.fb)(w.startContainer, "vditor-ir__preview")), S && (S.previousElementSibling.firstElementChild ? w.selectNodeContents(S.previousElementSibling.firstElementChild) : w.selectNodeContents(S.previousElementSibling), w.collapse(!0), (0, J.Hc)(w), un(p)), v.target.tagName === "IMG") {
                      var D = v.target.parentElement.querySelector(".vditor-ir__marker--link");
                      D && (w.selectNode(D), (0, J.Hc)(w));
                    }
                    var I = (0, C.a1)(v.target, "data-type", "a");
                    if (I && !I.classList.contains("vditor-ir__node--expand")) {
                      p.options.link.click ? p.options.link.click(I.querySelector(":scope > .vditor-ir__marker--link")) : p.options.link.isOpen && window.open(I.querySelector(":scope > .vditor-ir__marker--link").textContent);
                      return;
                    }
                    if (v.target.isEqualNode(g.element) && g.element.lastElementChild && w.collapsed) {
                      var B = g.element.lastElementChild.getBoundingClientRect();
                      v.y > B.top + B.height && (g.element.lastElementChild.tagName === "P" && g.element.lastElementChild.textContent.trim().replace(a.g.ZWSP, "") === "" ? (w.selectNodeContents(g.element.lastElementChild), w.collapse(!1)) : (g.element.insertAdjacentHTML("beforeend", '<p data-block="0">'.concat(a.g.ZWSP, "<wbr></p>")), (0, J.ib)(g.element, w)));
                    }
                    w.toString() === "" ? ge(w, p) : setTimeout(function() {
                      ge((0, J.zh)(p), p);
                    }), _t(v, p), mr(p);
                  }), this.element.addEventListener("keyup", function(v) {
                    if (!(v.isComposing || (0, f.yl)(v))) {
                      if (v.key === "Enter" && un(p), mr(p), (v.key === "Backspace" || v.key === "Delete") && p.ir.element.innerHTML !== "" && p.ir.element.childNodes.length === 1 && p.ir.element.firstElementChild && p.ir.element.firstElementChild.tagName === "P" && p.ir.element.firstElementChild.childElementCount === 0 && (p.ir.element.textContent === "" || p.ir.element.textContent === `
`)) {
                        p.ir.element.innerHTML = "";
                        return;
                      }
                      var w = (0, J.zh)(p);
                      v.key === "Backspace" ? ((0, f.vU)() && w.startContainer.textContent === `
` && w.startOffset === 1 && (w.startContainer.textContent = "", ge(w, p)), g.element.querySelectorAll(".language-math").forEach(function(D) {
                        var I = D.querySelector("br");
                        I && I.remove();
                      })) : v.key.indexOf("Arrow") > -1 ? ((v.key === "ArrowLeft" || v.key === "ArrowRight") && U6(p), ge(w, p)) : v.keyCode === 229 && v.code === "" && v.key === "Unidentified" && ge(w, p);
                      var S = (0, C.fb)(w.startContainer, "vditor-ir__preview");
                      if (S) {
                        if (v.key === "ArrowUp" || v.key === "ArrowLeft")
                          return S.previousElementSibling.firstElementChild ? w.selectNodeContents(S.previousElementSibling.firstElementChild) : w.selectNodeContents(S.previousElementSibling), w.collapse(!1), v.preventDefault(), !0;
                        if (S.tagName === "SPAN" && (v.key === "ArrowDown" || v.key === "ArrowRight"))
                          return S.parentElement.getAttribute("data-type") === "html-entity" ? (S.parentElement.insertAdjacentText("afterend", a.g.ZWSP), w.setStart(S.parentElement.nextSibling, 1)) : w.selectNodeContents(S.parentElement.lastElementChild), w.collapse(!1), v.preventDefault(), !0;
                      }
                    }
                  });
                }, d;
              }()
            ), K6 = function(d) {
              if (d.currentMode === "sv")
                return d.lute.Md2HTML(c(d));
              if (d.currentMode === "wysiwyg")
                return d.lute.VditorDOM2HTML(d.wysiwyg.element.innerHTML);
              if (d.currentMode === "ir")
                return d.lute.VditorIRDOM2HTML(d.ir.element.innerHTML);
            }, _I = i(214), G6 = i(436), RI = (
              /** @class */
              function() {
                function d(p) {
                  this.element = document.createElement("div"), this.element.className = "vditor-outline", this.element.innerHTML = '<div class="vditor-outline__title">'.concat(p, `</div>
<div class="vditor-outline__content"></div>`);
                }
                return d.prototype.render = function(p) {
                  var g = "";
                  return p.preview.element.style.display === "block" ? g = (0, G6.k)(p.preview.previewElement, this.element.lastElementChild, p) : g = (0, G6.k)(p[p.currentMode].element, this.element.lastElementChild, p), g;
                }, d.prototype.toggle = function(p, g, v) {
                  var w;
                  g === void 0 && (g = !0), v === void 0 && (v = !0);
                  var S = (w = p.toolbar.elements.outline) === null || w === void 0 ? void 0 : w.firstElementChild;
                  if (g && window.innerWidth >= a.g.MOBILE_WIDTH ? (this.element.style.display = "block", this.render(p), S == null || S.classList.add("vditor-menu--current")) : (this.element.style.display = "none", S == null || S.classList.remove("vditor-menu--current")), v && getSelection().rangeCount > 0) {
                    var D = getSelection().getRangeAt(0);
                    p[p.currentMode].element.contains(D.startContainer) && (0, J.Hc)(D);
                  }
                  Kt(p);
                }, d;
              }()
            ), PI = i(280), BI = (
              /** @class */
              function() {
                function d(p) {
                  var g = this;
                  this.element = document.createElement("div"), this.element.className = "vditor-preview", this.previewElement = document.createElement("div"), this.previewElement.className = "vditor-reset", p.options.classes.preview && this.previewElement.classList.add(p.options.classes.preview), this.previewElement.style.maxWidth = p.options.preview.maxWidth + "px", this.previewElement.addEventListener("copy", function(B) {
                    if (B.target.tagName !== "TEXTAREA") {
                      var _ = document.createElement("div");
                      _.className = "vditor-reset", _.appendChild(getSelection().getRangeAt(0).cloneContents()), g.copyToX(p, _, "default"), B.preventDefault();
                    }
                  }), this.previewElement.addEventListener("click", function(B) {
                    var _ = (0, C.lG)(B.target, "SPAN");
                    if (_ && (0, C.fb)(_, "vditor-toc")) {
                      var W = g.previewElement.querySelector("#" + _.getAttribute("data-target-id"));
                      W && (g.element.scrollTop = W.offsetTop);
                      return;
                    }
                    if (B.target.tagName === "A") {
                      p.options.link.click ? p.options.link.click(B.target) : p.options.link.isOpen && window.open(B.target.getAttribute("href")), B.preventDefault();
                      return;
                    }
                    B.target.tagName === "IMG" && (p.options.image.preview ? p.options.image.preview(B.target) : p.options.image.isPreview && (0, Ee.E)(B.target, p.options.lang, p.options.theme));
                  }), this.element.appendChild(this.previewElement);
                  var v = p.options.preview.actions;
                  if (v.length !== 0) {
                    var w = document.createElement("div");
                    w.className = "vditor-preview__action";
                    for (var S = [], D = 0; D < v.length; D++) {
                      var I = v[D];
                      if (typeof I == "object") {
                        S.push('<button type="button" data-type="'.concat(I.key, '" class="').concat(I.className, '"').concat(I.tooltip ? ' aria-label="'.concat(I.tooltip, '"') : "", '">').concat(I.text, "</button>"));
                        continue;
                      }
                      switch (I) {
                        case "desktop":
                          S.push('<button type="button" class="vditor-preview__action--current" data-type="desktop">Desktop</button>');
                          break;
                        case "tablet":
                          S.push('<button type="button" data-type="tablet">Tablet</button>');
                          break;
                        case "mobile":
                          S.push('<button type="button" data-type="mobile">Mobile/Wechat</button>');
                          break;
                        case "mp-wechat":
                          S.push('<button type="button" data-type="mp-wechat" class="vditor-tooltipped vditor-tooltipped__w" aria-label="复制到公众号"><svg><use xlink:href="#vditor-icon-mp-wechat"></use></svg></button>');
                          break;
                        case "zhihu":
                          S.push('<button type="button" data-type="zhihu" class="vditor-tooltipped vditor-tooltipped__w" aria-label="复制到知乎"><svg><use xlink:href="#vditor-icon-zhihu"></use></svg></button>');
                          break;
                      }
                    }
                    w.innerHTML = S.join(""), w.addEventListener((0, f.Le)(), function(B) {
                      var _ = (0, O.S)(B.target, "BUTTON");
                      if (_) {
                        var W = _.getAttribute("data-type"), Z = v.find(function(ye) {
                          return (ye == null ? void 0 : ye.key) === W;
                        });
                        if (Z) {
                          Z.click(W);
                          return;
                        }
                        if (W === "mp-wechat" || W === "zhihu") {
                          g.copyToX(p, g.previewElement.cloneNode(!0), W);
                          return;
                        }
                        W === "desktop" ? g.previewElement.style.width = "auto" : W === "tablet" ? g.previewElement.style.width = "780px" : g.previewElement.style.width = "360px", g.previewElement.scrollWidth > g.previewElement.parentElement.clientWidth && (g.previewElement.style.width = "auto"), g.render(p), w.querySelectorAll("button").forEach(function(ye) {
                          ye.classList.remove("vditor-preview__action--current");
                        }), _.classList.add("vditor-preview__action--current");
                      }
                    }), this.element.insertBefore(w, this.previewElement);
                  }
                }
                return d.prototype.render = function(p, g) {
                  var v = this;
                  if (clearTimeout(this.mdTimeoutId), this.element.style.display === "none") {
                    this.element.getAttribute("data-type") === "renderPerformance" && p.tip.hide();
                    return;
                  }
                  if (g) {
                    this.previewElement.innerHTML = g;
                    return;
                  }
                  if (c(p).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") === "") {
                    this.previewElement.innerHTML = "";
                    return;
                  }
                  var w = (/* @__PURE__ */ new Date()).getTime(), S = c(p);
                  this.mdTimeoutId = window.setTimeout(function() {
                    if (p.options.preview.url) {
                      var D = new XMLHttpRequest();
                      D.open("POST", p.options.preview.url), D.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), D.onreadystatechange = function() {
                        if (D.readyState === XMLHttpRequest.DONE)
                          if (D.status === 200) {
                            var B = JSON.parse(D.responseText);
                            if (B.code !== 0) {
                              p.tip.show(B.msg);
                              return;
                            }
                            p.options.preview.transform && (B.data = p.options.preview.transform(B.data)), v.previewElement.innerHTML = B.data, v.afterRender(p, w);
                          } else {
                            var _ = p.lute.Md2HTML(S);
                            p.options.preview.transform && (_ = p.options.preview.transform(_)), v.previewElement.innerHTML = _, v.afterRender(p, w);
                          }
                      }, D.send(JSON.stringify({ markdownText: S }));
                    } else {
                      var I = p.lute.Md2HTML(S);
                      p.options.preview.transform && (I = p.options.preview.transform(I)), v.previewElement.innerHTML = I, v.afterRender(p, w);
                    }
                  }, p.options.preview.delay);
                }, d.prototype.afterRender = function(p, g) {
                  p.options.preview.parse && p.options.preview.parse(this.element);
                  var v = (/* @__PURE__ */ new Date()).getTime() - g;
                  (/* @__PURE__ */ new Date()).getTime() - g > 2600 ? (p.tip.show(window.VditorI18n.performanceTip.replace("${x}", v.toString())), p.preview.element.setAttribute("data-type", "renderPerformance")) : p.preview.element.getAttribute("data-type") === "renderPerformance" && (p.tip.hide(), p.preview.element.removeAttribute("data-type"));
                  var w = p.preview.element.querySelector(".vditor-comment--focus");
                  w && w.classList.remove("vditor-comment--focus"), (0, z.O)(p.preview.previewElement, p.options.preview.hljs), (0, ae.s)(p.options.preview.hljs, p.preview.previewElement, p.options.cdn), (0, he.i)(p.preview.previewElement, p.options.cdn, p.options.theme), (0, Ie.K)(p.preview.previewElement, p.options.cdn), (0, We.J)(p.preview.previewElement, p.options.cdn, p.options.theme), (0, K.P)(p.preview.previewElement, p.options.cdn), (0, U.v)(p.preview.previewElement, p.options.cdn), (0, H.p)(p.preview.previewElement, p.options.cdn, p.options.theme), (0, Oe.P)(p.preview.previewElement, p.options.cdn, p.options.theme), (0, Ne.B)(p.preview.previewElement, p.options.cdn), (0, F.Q)(p.preview.previewElement, p.options.cdn), p.options.preview.render.media.enable && (0, PI.Y)(p.preview.previewElement), p.options.customRenders.forEach(function(I) {
                    I.render(p.preview.previewElement, p);
                  });
                  var S = p.preview.element, D = p.outline.render(p);
                  D === "" && (D = "[ToC]"), S.querySelectorAll('[data-type="toc-block"]').forEach(function(I) {
                    I.innerHTML = D, (0, ie.H)(I, {
                      cdn: p.options.cdn,
                      math: p.options.preview.math
                    });
                  }), (0, ie.H)(p.preview.previewElement, {
                    cdn: p.options.cdn,
                    math: p.options.preview.math
                  });
                }, d.prototype.copyToX = function(p, g, v) {
                  v === void 0 && (v = "mp-wechat"), v !== "zhihu" ? g.querySelectorAll(".katex-html .base").forEach(function(S) {
                    S.style.display = "initial";
                  }) : g.querySelectorAll(".language-math").forEach(function(S) {
                    S.outerHTML = '<img class="Formula-image" data-eeimg="true" src="//www.zhihu.com/equation?tex=" alt="'.concat(S.getAttribute("data-math"), '\\" style="display: block; margin: 0 auto; max-width: 100%;">');
                  }), g.style.backgroundColor = "#fff", g.querySelectorAll("code").forEach(function(S) {
                    S.style.backgroundImage = "none";
                  }), this.element.append(g);
                  var w = g.ownerDocument.createRange();
                  w.selectNode(g), (0, J.Hc)(w), document.execCommand("copy"), g.remove(), p.tip.show(["zhihu", "mp-wechat"].includes(v) ? "已复制，可到".concat(v === "zhihu" ? "知乎" : "微信公众号平台", "进行粘贴") : "已复制到剪切板");
                }, d;
              }()
            ), HI = (
              /** @class */
              function() {
                function d(p) {
                  this.element = document.createElement("div"), this.element.className = "vditor-resize vditor-resize--".concat(p.options.resize.position), this.element.innerHTML = '<div><svg><use xlink:href="#vditor-icon-resize"></use></svg></div>', this.bindEvent(p);
                }
                return d.prototype.bindEvent = function(p) {
                  var g = this;
                  this.element.addEventListener("mousedown", function(v) {
                    var w = document, S = v.clientY, D = p.element.offsetHeight, I = 63 + p.element.querySelector(".vditor-toolbar").clientHeight;
                    w.ondragstart = function() {
                      return !1;
                    }, window.captureEvents && window.captureEvents(), g.element.classList.add("vditor-resize--selected"), w.onmousemove = function(B) {
                      p.options.resize.position === "top" ? p.element.style.height = Math.max(I, D + (S - B.clientY)) + "px" : p.element.style.height = Math.max(I, D + (B.clientY - S)) + "px", p.options.typewriterMode && (p.sv.element.style.paddingBottom = p.sv.element.parentElement.offsetHeight / 2 + "px");
                    }, w.onmouseup = function() {
                      p.options.resize.after && p.options.resize.after(p.element.offsetHeight - D), window.captureEvents && window.captureEvents(), w.onmousemove = null, w.onmouseup = null, w.ondragstart = null, w.onselectstart = null, w.onselect = null, g.element.classList.remove("vditor-resize--selected");
                    };
                  });
                }, d;
              }()
            ), zI = (
              /** @class */
              function() {
                function d(p) {
                  this.composingLock = !1, this.element = document.createElement("pre"), this.element.className = "vditor-sv vditor-reset", this.element.setAttribute("placeholder", p.options.placeholder), this.element.setAttribute("contenteditable", "true"), this.element.setAttribute("spellcheck", "false"), this.bindEvent(p), bo(p, this.element), vo(p, this.element), Ke(p, this.element), Y(p, this.element), wo(p, this.element), ko(p, this.element, this.copy), xo(p, this.element, this.copy);
                }
                return d.prototype.copy = function(p, g) {
                  p.stopPropagation(), p.preventDefault(), p.clipboardData.setData("text/plain", _i(g[g.currentMode].element));
                }, d.prototype.bindEvent = function(p) {
                  var g = this;
                  this.element.addEventListener("paste", function(v) {
                    wp(p, v, {
                      pasteCode: function(w) {
                        document.execCommand("insertHTML", !1, w);
                      }
                    });
                  }), this.element.addEventListener("scroll", function() {
                    if (p.preview.element.style.display === "block") {
                      var v = g.element.scrollTop, w = g.element.clientHeight, S = g.element.scrollHeight - parseFloat(g.element.style.paddingBottom || "0"), D = p.preview.element;
                      v / w > 0.5 ? D.scrollTop = (v + w) * D.scrollHeight / S - w : D.scrollTop = v * D.scrollHeight / S;
                    }
                  }), this.element.addEventListener("compositionstart", function(v) {
                    g.composingLock = !0;
                  }), this.element.addEventListener("compositionend", function(v) {
                    (0, f.vU)() || ft(p, v), g.composingLock = !1;
                  }), this.element.addEventListener("input", function(v) {
                    if (!(v.inputType === "deleteByDrag" || v.inputType === "insertFromDrop") && !(g.composingLock || v.data === "‘" || v.data === "“" || v.data === "《")) {
                      if (g.preventInput) {
                        g.preventInput = !1, gt(p, {
                          enableAddUndoStack: !0,
                          enableHint: !0,
                          enableInput: !0
                        });
                        return;
                      }
                      ft(p, v);
                    }
                  }), this.element.addEventListener("keyup", function(v) {
                    if (!(v.isComposing || (0, f.yl)(v))) {
                      if ((v.key === "Backspace" || v.key === "Delete") && p.sv.element.innerHTML !== "" && p.sv.element.childNodes.length === 1 && p.sv.element.firstElementChild && p.sv.element.firstElementChild.tagName === "DIV" && p.sv.element.firstElementChild.childElementCount === 2 && (p.sv.element.firstElementChild.textContent === "" || p.sv.element.textContent === `
`)) {
                        p.sv.element.innerHTML = "";
                        return;
                      }
                      v.key === "Enter" && un(p);
                    }
                  });
                }, d;
              }()
            ), J6 = (
              /** @class */
              function() {
                function d() {
                  this.element = document.createElement("div"), this.element.className = "vditor-tip";
                }
                return d.prototype.show = function(p, g) {
                  var v = this;
                  g === void 0 && (g = 6e3), this.element.className = "vditor-tip vditor-tip--show", g === 0 ? (this.element.innerHTML = '<div class="vditor-tip__content">'.concat(p, `
<div class="vditor-tip__close">X</div></div>`), this.element.querySelector(".vditor-tip__close").addEventListener("click", function() {
                    v.hide();
                  })) : (this.element.innerHTML = '<div class="vditor-tip__content">'.concat(p, "</div>"), setTimeout(function() {
                    v.hide();
                  }, g)), this.element.removeAttribute("style"), setTimeout(function() {
                    var w = v.element.getBoundingClientRect();
                    w.top < 46 && (v.element.style.position = "fixed", v.element.style.top = "46px");
                  }, 150);
                }, d.prototype.hide = function() {
                  this.element.className = "vditor-messageElementtip", this.element.innerHTML = "";
                }, d;
              }()
            ), Uy = function(d, p) {
              if (p.options.preview.mode !== d) {
                switch (p.options.preview.mode = d, d) {
                  case "both":
                    p.sv.element.style.display = "block", p.preview.element.style.display = "block", p.preview.render(p), y(p.toolbar.elements, ["both"]);
                    break;
                  case "editor":
                    p.sv.element.style.display = "block", p.preview.element.style.display = "none", m(p.toolbar.elements, ["both"]);
                    break;
                }
                p.devtools && p.devtools.renderEchart(p);
              }
            }, FI = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), VI = (
              /** @class */
              function(d) {
                FI(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return g.options.preview.mode === "both" && w.element.children[0].classList.add("vditor-menu--current"), w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    var D = w.element.firstElementChild;
                    D.classList.contains(a.g.CLASS_MENU_DISABLED) || (S.preventDefault(), g.currentMode === "sv" && (g.options.preview.mode === "both" ? Uy("editor", g) : Uy("both", g)));
                  }), w;
                }
                return p;
              }(Tt)
            ), qI = (
              /** @class */
              /* @__PURE__ */ function() {
                function d() {
                  this.element = document.createElement("div"), this.element.className = "vditor-toolbar__br";
                }
                return d;
              }()
            ), Y6 = i(580), $I = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), jI = (
              /** @class */
              function(d) {
                $I(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = w.element.children[0], D = document.createElement("div");
                  D.className = "vditor-hint".concat(v.level === 2 ? "" : " vditor-panel--arrow");
                  var I = "";
                  return a.g.CODE_THEME.forEach(function(B) {
                    I += "<button>".concat(B, "</button>");
                  }), D.innerHTML = '<div style="overflow: auto;max-height:'.concat(window.innerHeight / 2, 'px">').concat(I, "</div>"), D.addEventListener((0, f.Le)(), function(B) {
                    B.target.tagName === "BUTTON" && (T(g, ["subToolbar"]), g.options.preview.hljs.style = B.target.textContent, (0, Y6.Y)(B.target.textContent, g.options.cdn), B.preventDefault(), B.stopPropagation());
                  }), w.element.appendChild(D), E(g, D, S, v.level), w;
                }
                return p;
              }(Tt)
            ), WI = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), UI = (
              /** @class */
              function(d) {
                WI(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = w.element.children[0], D = document.createElement("div");
                  D.className = "vditor-hint".concat(v.level === 2 ? "" : " vditor-panel--arrow");
                  var I = "";
                  return Object.keys(g.options.preview.theme.list).forEach(function(B) {
                    I += '<button data-type="'.concat(B, '">').concat(g.options.preview.theme.list[B], "</button>");
                  }), D.innerHTML = '<div style="overflow: auto;max-height:'.concat(window.innerHeight / 2, 'px">').concat(I, "</div>"), D.addEventListener((0, f.Le)(), function(B) {
                    B.target.tagName === "BUTTON" && (T(g, ["subToolbar"]), g.options.preview.theme.current = B.target.getAttribute("data-type"), (0, Ue.Z)(g.options.preview.theme.current, g.options.preview.theme.path), B.preventDefault(), B.stopPropagation());
                  }), w.element.appendChild(D), E(g, D, S, v.level), w;
                }
                return p;
              }(Tt)
            ), KI = (
              /** @class */
              function() {
                function d(p) {
                  this.element = document.createElement("span"), this.element.className = "vditor-counter vditor-tooltipped vditor-tooltipped__nw", this.render(p, "");
                }
                return d.prototype.render = function(p, g) {
                  var v = g.endsWith(`
`) ? g.length - 1 : g.length;
                  if (p.options.counter.type === "text" && p[p.currentMode]) {
                    var w = p[p.currentMode].element.cloneNode(!0);
                    w.querySelectorAll(".vditor-wysiwyg__preview").forEach(function(S) {
                      S.remove();
                    }), v = w.textContent.length;
                  }
                  typeof p.options.counter.max == "number" ? (v > p.options.counter.max ? this.element.className = "vditor-counter vditor-counter--error" : this.element.className = "vditor-counter", this.element.innerHTML = "".concat(v, "/").concat(p.options.counter.max)) : this.element.innerHTML = "".concat(v), this.element.setAttribute("aria-label", p.options.counter.type), p.options.counter.after && p.options.counter.after(v, {
                    enable: p.options.counter.enable,
                    max: p.options.counter.max,
                    type: p.options.counter.type
                  });
                }, d;
              }()
            ), GI = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), JI = (
              /** @class */
              function(d) {
                GI(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].innerHTML = v.icon, w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), !S.currentTarget.classList.contains(a.g.CLASS_MENU_DISABLED) && v.click(S, g);
                  }), w;
                }
                return p;
              }(Tt)
            ), YI = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), XI = (
              /** @class */
              function(d) {
                YI(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.firstElementChild.addEventListener((0, f.Le)(), function(S) {
                    var D = w.element.firstElementChild;
                    D.classList.contains(a.g.CLASS_MENU_DISABLED) || (S.preventDefault(), D.classList.contains("vditor-menu--current") ? (D.classList.remove("vditor-menu--current"), g.devtools.element.style.display = "none", Kt(g)) : (D.classList.add("vditor-menu--current"), g.devtools.element.style.display = "block", Kt(g), g.devtools.renderEchart(g)));
                  }), w;
                }
                return p;
              }(Tt)
            ), ZI = (
              /** @class */
              /* @__PURE__ */ function() {
                function d() {
                  this.element = document.createElement("div"), this.element.className = "vditor-toolbar__divider";
                }
                return d;
              }()
            ), QI = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), e_ = (
              /** @class */
              function(d) {
                QI(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = document.createElement("div");
                  S.className = "vditor-panel vditor-panel--arrow";
                  var D = "";
                  return Object.keys(g.options.hint.emoji).forEach(function(I) {
                    var B = g.options.hint.emoji[I];
                    B.indexOf(".") > -1 ? D += '<button data-value=":'.concat(I, ': " data-key=":').concat(I, `:"><img
data-value=":`).concat(I, ': " data-key=":').concat(I, ':" class="vditor-emojis__icon" src="').concat(B, '"/></button>') : D += '<button data-value="'.concat(B, ` "
 data-key="`).concat(I, '"><span class="vditor-emojis__icon">').concat(B, "</span></button>");
                  }), S.innerHTML = '<div class="vditor-emojis" style="max-height: '.concat(g.options.height === "auto" ? "auto" : g.options.height - 80, 'px">').concat(D, `</div><div class="vditor-emojis__tail">
    <span class="vditor-emojis__tip"></span><span>`).concat(g.options.hint.emojiTail || "", `</span>
</div>`), w.element.appendChild(S), E(g, S, w.element.firstElementChild, v.level), w.bindEvent(g), w;
                }
                return p.prototype.bindEvent = function(g) {
                  var v = this;
                  this.element.lastElementChild.addEventListener((0, f.Le)(), function(w) {
                    var S = (0, O.S)(w.target, "BUTTON");
                    if (S) {
                      w.preventDefault();
                      var D = S.getAttribute("data-value"), I = (0, J.zh)(g), B = D;
                      if (g.currentMode === "wysiwyg" ? B = g.lute.SpinVditorDOM(D) : g.currentMode === "ir" && (B = g.lute.SpinVditorIRDOM(D)), D.indexOf(":") > -1 && g.currentMode !== "sv") {
                        var _ = document.createElement("div");
                        _.innerHTML = B, B = _.firstElementChild.firstElementChild.outerHTML + " ", (0, J.oC)(B, g);
                      } else
                        I.extractContents(), I.insertNode(document.createTextNode(D)), (0, C.F9)(I.startContainer) || Kn(g, I);
                      I.collapse(!1), (0, J.Hc)(I), v.element.lastElementChild.style.display = "none", xt(g);
                    }
                  }), this.element.lastElementChild.addEventListener("mouseover", function(w) {
                    var S = (0, O.S)(w.target, "BUTTON");
                    S && (v.element.querySelector(".vditor-emojis__tip").innerHTML = S.getAttribute("data-key"));
                  });
                }, p;
              }(Tt)
            ), X6 = function(d, p, g) {
              var v = document.createElement("a");
              "download" in v ? (v.download = g, v.style.display = "none", v.href = URL.createObjectURL(new Blob([p])), document.body.appendChild(v), v.click(), v.remove()) : d.tip.show(window.VditorI18n.downloadTip, 0);
            }, t_ = function(d) {
              var p = c(d);
              X6(d, p, p.substr(0, 10) + ".md");
            }, n_ = function(d) {
              d.tip.show(window.VditorI18n.generate, 3800);
              var p = document.querySelector("#vditorExportIframe");
              p.contentDocument.open(), p.contentDocument.write('<link rel="stylesheet" href="'.concat(d.options.cdn, `/dist/index.css"/>
<script src="`).concat(d.options.cdn, `/dist/method.min.js"><\/script>
<div id="preview" style="width: 800px"></div>
<script>
window.addEventListener("message", (e) => {
  if(!e.data) {
    return;
  }
  Vditor.preview(document.getElementById('preview'), e.data, {
    cdn: "`).concat(d.options.cdn, `",
    markdown: {
      theme: `).concat(JSON.stringify(d.options.preview.theme), `
    },
    hljs: {
      style: "`).concat(d.options.preview.hljs.style, `"
    }
  });
  setTimeout(() => {
        window.print();
    }, 3600);
}, false);
<\/script>`)), p.contentDocument.close(), setTimeout(function() {
                p.contentWindow.postMessage(c(d), "*");
              }, 200);
            }, r_ = function(d) {
              var p = K6(d), g = '<html><head><link rel="stylesheet" type="text/css" href="'.concat(d.options.cdn, `/dist/index.css"/>
<script src="`).concat(d.options.cdn, "/dist/js/i18n/").concat(d.options.lang, `.js"><\/script>
<script src="`).concat(d.options.cdn, `/dist/method.min.js"><\/script></head>
<body><div class="vditor-reset" id="preview">`).concat(p, `</div>
<script>
    const previewElement = document.getElementById('preview')
    Vditor.setContentTheme('`).concat(d.options.preview.theme.current, "', '").concat(d.options.preview.theme.path, `');
    Vditor.codeRender(previewElement);
    Vditor.highlightRender(`).concat(JSON.stringify(d.options.preview.hljs), ", previewElement, '").concat(d.options.cdn, `');
    Vditor.mathRender(previewElement, {
        cdn: '`).concat(d.options.cdn, `',
        math: `).concat(JSON.stringify(d.options.preview.math), `,
    });
    Vditor.mermaidRender(previewElement, '`).concat(d.options.cdn, "', '").concat(d.options.theme, `');
    Vditor.SMILESRender(previewElement, '`).concat(d.options.cdn, "', '").concat(d.options.theme, `');
    Vditor.markmapRender(previewElement, '`).concat(d.options.cdn, `');
    Vditor.flowchartRender(previewElement, '`).concat(d.options.cdn, `');
    Vditor.graphvizRender(previewElement, '`).concat(d.options.cdn, `');
    Vditor.chartRender(previewElement, '`).concat(d.options.cdn, "', '").concat(d.options.theme, `');
    Vditor.mindmapRender(previewElement, '`).concat(d.options.cdn, "', '").concat(d.options.theme, `');
    Vditor.abcRender(previewElement, '`).concat(d.options.cdn, `');
    `).concat(d.options.preview.render.media.enable ? "Vditor.mediaRender(previewElement);" : "", `
    Vditor.speechRender(previewElement);
<\/script>
<script src="`).concat(d.options.cdn, "/dist/js/icons/").concat(d.options.icon, '.js"><\/script></body></html>');
              X6(d, g, p.substr(0, 10) + ".html");
            }, i_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), s_ = (
              /** @class */
              function(d) {
                i_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = w.element.children[0], D = document.createElement("div");
                  return D.className = "vditor-hint".concat(v.level === 2 ? "" : " vditor-panel--arrow"), D.innerHTML = `<button data-type="markdown">Markdown</button>
<button data-type="pdf">PDF</button>
<button data-type="html">HTML</button>`, D.addEventListener((0, f.Le)(), function(I) {
                    var B = I.target;
                    if (B.tagName === "BUTTON") {
                      switch (B.getAttribute("data-type")) {
                        case "markdown":
                          t_(g);
                          break;
                        case "pdf":
                          n_(g);
                          break;
                        case "html":
                          r_(g);
                          break;
                      }
                      T(g, ["subToolbar"]), I.preventDefault(), I.stopPropagation();
                    }
                  }), w.element.appendChild(D), E(g, D, S, v.level), w;
                }
                return p;
              }(Tt)
            ), o_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), a_ = (
              /** @class */
              function(d) {
                o_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w._bindEvent(g, v), w;
                }
                return p.prototype._bindEvent = function(g, v) {
                  this.element.children[0].addEventListener((0, f.Le)(), function(w) {
                    w.preventDefault(), g.element.className.includes("vditor--fullscreen") ? (v.level || (this.innerHTML = v.icon), g.element.style.zIndex = "", document.body.style.overflow = "", g.element.classList.remove("vditor--fullscreen"), Object.keys(g.toolbar.elements).forEach(function(S) {
                      var D = g.toolbar.elements[S].firstChild;
                      D && (D.className = D.className.replace("__s", "__n"), g.options.toolbar.forEach(function(I) {
                        typeof I != "string" && I.tipPosition && I.name === D.dataset.type && (D.className = "vditor-tooltipped vditor-tooltipped__".concat(I.tipPosition));
                      }));
                    }), g.counter && (g.counter.element.className = g.counter.element.className.replace("__s", "__n"))) : (v.level || (this.innerHTML = '<svg><use xlink:href="#vditor-icon-contract"></use></svg>'), g.element.style.zIndex = g.options.fullscreen.index.toString(), document.body.style.overflow = "hidden", g.element.classList.add("vditor--fullscreen"), Object.keys(g.toolbar.elements).forEach(function(S) {
                      var D = g.toolbar.elements[S].firstChild;
                      D && (D.className = D.className.replace("__n", "__s"));
                    }), g.counter && (g.counter.element.className = g.counter.element.className.replace("__n", "__s"))), g.devtools && g.devtools.renderEchart(g), v.click && v.click(w, g), Kt(g), ci(g);
                  });
                }, p;
              }(Tt)
            ), l_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), c_ = (
              /** @class */
              function(d) {
                l_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = document.createElement("div");
                  return S.className = "vditor-hint vditor-panel--arrow", S.innerHTML = '<button data-tag="h1" data-value="# ">'.concat(window.VditorI18n.heading1, " ").concat((0, f.ns)("&lt;⌥⌘1>"), `</button>
<button data-tag="h2" data-value="## ">`).concat(window.VditorI18n.heading2, " &lt;").concat((0, f.ns)("⌥⌘2"), `></button>
<button data-tag="h3" data-value="### ">`).concat(window.VditorI18n.heading3, " &lt;").concat((0, f.ns)("⌥⌘3"), `></button>
<button data-tag="h4" data-value="#### ">`).concat(window.VditorI18n.heading4, " &lt;").concat((0, f.ns)("⌥⌘4"), `></button>
<button data-tag="h5" data-value="##### ">`).concat(window.VditorI18n.heading5, " &lt;").concat((0, f.ns)("⌥⌘5"), `></button>
<button data-tag="h6" data-value="###### ">`).concat(window.VditorI18n.heading6, " &lt;").concat((0, f.ns)("⌥⌘6"), "></button>"), w.element.appendChild(S), w._bindEvent(g, S), w;
                }
                return p.prototype._bindEvent = function(g, v) {
                  var w = this.element.children[0];
                  w.addEventListener((0, f.Le)(), function(D) {
                    D.preventDefault(), clearTimeout(g.wysiwyg.afterRenderTimeoutId), clearTimeout(g.ir.processTimeoutId), clearTimeout(g.sv.processTimeoutId), !w.classList.contains(a.g.CLASS_MENU_DISABLED) && (w.blur(), w.classList.contains("vditor-menu--current") ? (g.currentMode === "wysiwyg" ? (Mn(g), kt(g)) : g.currentMode === "ir" && Gh(g, ""), w.classList.remove("vditor-menu--current")) : (T(g, ["subToolbar"]), v.style.display = "block"));
                  });
                  for (var S = 0; S < 6; S++)
                    v.children.item(S).addEventListener((0, f.Le)(), function(D) {
                      D.preventDefault(), g.currentMode === "wysiwyg" ? (Cn(g, D.target.getAttribute("data-tag")), kt(g), w.classList.add("vditor-menu--current")) : g.currentMode === "ir" ? (Gh(g, D.target.getAttribute("data-value")), w.classList.add("vditor-menu--current")) : Bn(g, D.target.getAttribute("data-value")), v.style.display = "none";
                    });
                }, p;
              }(Tt)
            ), u_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), h_ = (
              /** @class */
              function(d) {
                u_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), g.tip.show(`<div style="margin-bottom:14px;font-size: 14px;line-height: 22px;min-width:300px;max-width: 360px;display: flex;">
<div style="margin-top: 14px;flex: 1">
    <div>Markdown 使用指南</div>
    <ul style="list-style: none">
        <li><a href="https://ld246.com/article/1583308420519" target="_blank">语法速查手册</a></li>
        <li><a href="https://ld246.com/article/1583129520165" target="_blank">基础语法</a></li>
        <li><a href="https://ld246.com/article/1583305480675" target="_blank">扩展语法</a></li>
        <li><a href="https://ld246.com/article/1582778815353" target="_blank">键盘快捷键</a></li>
    </ul>
</div>
<div style="margin-top: 14px;flex: 1">
    <div>Vditor 支持</div>
    <ul style="list-style: none">
        <li><a href="https://github.com/Vanessa219/vditor/issues" target="_blank">Issues</a></li>
        <li><a href="https://ld246.com/tag/vditor" target="_blank">官方讨论区</a></li>
        <li><a href="https://ld246.com/article/1549638745630" target="_blank">开发手册</a></li>
        <li><a href="https://ld246.com/guide/markdown" target="_blank">演示地址</a></li>
    </ul>
</div></div>`, 0);
                  }), w;
                }
                return p;
              }(Tt)
            ), f_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), d_ = (
              /** @class */
              function(d) {
                f_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    if (S.preventDefault(), !(w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) || g.currentMode === "sv")) {
                      var D = (0, J.zh)(g), I = (0, C.lG)(D.startContainer, "LI");
                      I && Rt(g, I, D);
                    }
                  }), w;
                }
                return p;
              }(Tt)
            ), p_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), m_ = (
              /** @class */
              function(d) {
                p_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), g.tip.show(`<div style="max-width: 520px; font-size: 14px;line-height: 22px;margin-bottom: 14px;">
<p style="text-align: center;margin: 14px 0">
    <em>下一代的 Markdown 编辑器，为未来而构建</em>
</p>
<div style="display: flex;margin-bottom: 14px;flex-wrap: wrap;align-items: center">
    <img src="https://unpkg.com/vditor/dist/images/logo.png" style="margin: 0 auto;height: 68px"/>
    <div>&nbsp;&nbsp;</div>
    <div style="flex: 1;min-width: 250px">
        Vditor 是一款浏览器端的 Markdown 编辑器，支持所见即所得、即时渲染（类似 Typora）和分屏预览模式。
        它使用 TypeScript 实现，支持原生 JavaScript 以及 Vue、React、Angular 和 Svelte 等框架。
    </div>
</div>
<div style="display: flex;flex-wrap: wrap;">
    <ul style="list-style: none;flex: 1;min-width:148px">
        <li>
        项目地址：<a href="https://b3log.org/vditor" target="_blank">b3log.org/vditor</a>
        </li>
        <li>
        开源协议：MIT
        </li>
    </ul>
    <ul style="list-style: none;margin-right: 18px">
        <li>
        组件版本：Vditor v`.concat(a.H, " / Lute v").concat(Lute.Version, `
        </li>
        <li>
        赞助捐赠：<a href="https://ld246.com/sponsor" target="_blank">https://ld246.com/sponsor</a>
        </li>
    </ul>
</div>
</div>`), 0);
                  }), w;
                }
                return p;
              }(Tt)
            ), g_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), y_ = (
              /** @class */
              function(d) {
                g_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), !(w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) || g.currentMode === "sv") && Tl(g, "afterend");
                  }), w;
                }
                return p;
              }(Tt)
            ), b_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), v_ = (
              /** @class */
              function(d) {
                b_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), !(w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) || g.currentMode === "sv") && Tl(g, "beforebegin");
                  }), w;
                }
                return p;
              }(Tt)
            ), w_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), k_ = (
              /** @class */
              function(d) {
                w_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    if (S.preventDefault(), !(w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) || g.currentMode === "sv")) {
                      var D = (0, J.zh)(g), I = (0, C.lG)(D.startContainer, "LI");
                      I && Kh(g, I, D, I.parentElement);
                    }
                  }), w;
                }
                return p;
              }(Tt)
            ), x_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), S_ = (
              /** @class */
              function(d) {
                x_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return g.options.outline && w.element.firstElementChild.classList.add("vditor-menu--current"), w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault();
                    var D = g.toolbar.elements.outline.firstElementChild;
                    D.classList.contains(a.g.CLASS_MENU_DISABLED) || (g.options.outline.enable = !w.element.firstElementChild.classList.contains("vditor-menu--current"), g.outline.toggle(g, g.options.outline.enable));
                  }), w;
                }
                return p;
              }(Tt)
            ), C_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), M_ = (
              /** @class */
              function(d) {
                C_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w._bindEvent(g), w;
                }
                return p.prototype._bindEvent = function(g) {
                  var v = this;
                  this.element.children[0].addEventListener((0, f.Le)(), function(w) {
                    w.preventDefault();
                    var S = v.element.firstElementChild;
                    if (!S.classList.contains(a.g.CLASS_MENU_DISABLED)) {
                      var D = a.g.EDIT_TOOLBARS.concat(["both", "edit-mode", "devtools"]);
                      S.classList.contains("vditor-menu--current") ? (S.classList.remove("vditor-menu--current"), g.currentMode === "sv" ? (g.sv.element.style.display = "block", g.options.preview.mode === "both" ? g.preview.element.style.display = "block" : g.preview.element.style.display = "none") : (g[g.currentMode].element.parentElement.style.display = "block", g.preview.element.style.display = "none"), b(g.toolbar.elements, D), g.outline.render(g)) : (k(g.toolbar.elements, D), g.preview.element.style.display = "block", g.currentMode === "sv" ? g.sv.element.style.display = "none" : g[g.currentMode].element.parentElement.style.display = "none", g.preview.render(g), S.classList.add("vditor-menu--current"), T(g, ["subToolbar", "hint", "popover"]), setTimeout(function() {
                        g.outline.render(g);
                      }, g.options.preview.delay + 10)), Kt(g);
                    }
                  });
                }, p;
              }(Tt)
            ), T_ = (
              /** @class */
              function() {
                function d(p) {
                  this.SAMPLE_RATE = 5e3, this.isRecording = !1, this.readyFlag = !1, this.leftChannel = [], this.rightChannel = [], this.recordingLength = 0;
                  var g;
                  if (typeof AudioContext < "u")
                    g = new AudioContext();
                  else if (webkitAudioContext)
                    g = new webkitAudioContext();
                  else
                    return;
                  this.DEFAULT_SAMPLE_RATE = g.sampleRate;
                  var v = g.createGain(), w = g.createMediaStreamSource(p);
                  w.connect(v), this.recorder = g.createScriptProcessor(2048, 2, 1), this.recorder.onaudioprocess = null, v.connect(this.recorder), this.recorder.connect(g.destination), this.readyFlag = !0;
                }
                return d.prototype.cloneChannelData = function(p, g) {
                  this.leftChannel.push(new Float32Array(p)), this.rightChannel.push(new Float32Array(g)), this.recordingLength += 2048;
                }, d.prototype.startRecordingNewWavFile = function() {
                  this.readyFlag && (this.isRecording = !0, this.leftChannel.length = this.rightChannel.length = 0, this.recordingLength = 0);
                }, d.prototype.stopRecording = function() {
                  this.isRecording = !1;
                }, d.prototype.buildWavFileBlob = function() {
                  for (var p = this.mergeBuffers(this.leftChannel), g = this.mergeBuffers(this.rightChannel), v = new Float32Array(p.length), w = 0; w < p.length; ++w)
                    v[w] = 0.5 * (p[w] + g[w]);
                  this.DEFAULT_SAMPLE_RATE > this.SAMPLE_RATE && (v = this.downSampleBuffer(v, this.SAMPLE_RATE));
                  var S = 44 + v.length * 2, D = new ArrayBuffer(S), I = new DataView(D);
                  this.writeUTFBytes(I, 0, "RIFF"), I.setUint32(4, S, !0), this.writeUTFBytes(I, 8, "WAVE"), this.writeUTFBytes(I, 12, "fmt "), I.setUint32(16, 16, !0), I.setUint16(20, 1, !0), I.setUint16(22, 1, !0), I.setUint32(24, this.SAMPLE_RATE, !0), I.setUint32(28, this.SAMPLE_RATE * 2, !0), I.setUint16(32, 2, !0), I.setUint16(34, 16, !0);
                  var B = v.length * 2;
                  this.writeUTFBytes(I, 36, "data"), I.setUint32(40, B, !0);
                  for (var _ = v.length, W = 44, Z = 1, ye = 0; ye < _; ye++)
                    I.setInt16(W, v[ye] * (32767 * Z), !0), W += 2;
                  return new Blob([I], { type: "audio/wav" });
                }, d.prototype.downSampleBuffer = function(p, g) {
                  if (g === this.DEFAULT_SAMPLE_RATE || g > this.DEFAULT_SAMPLE_RATE)
                    return p;
                  for (var v = this.DEFAULT_SAMPLE_RATE / g, w = Math.round(p.length / v), S = new Float32Array(w), D = 0, I = 0; D < S.length; ) {
                    for (var B = Math.round((D + 1) * v), _ = 0, W = 0, Z = I; Z < B && Z < p.length; Z++)
                      _ += p[Z], W++;
                    S[D] = _ / W, D++, I = B;
                  }
                  return S;
                }, d.prototype.mergeBuffers = function(p) {
                  for (var g = new Float32Array(this.recordingLength), v = 0, w = p.length, S = 0; S < w; ++S) {
                    var D = p[S];
                    g.set(D, v), v += D.length;
                  }
                  return g;
                }, d.prototype.writeUTFBytes = function(p, g, v) {
                  for (var w = v.length, S = 0; S < w; S++)
                    p.setUint8(g + S, v.charCodeAt(S));
                }, d;
              }()
            ), A_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), E_ = (
              /** @class */
              function(d) {
                A_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return w._bindEvent(g), w;
                }
                return p.prototype._bindEvent = function(g) {
                  var v = this, w;
                  this.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    if (S.preventDefault(), !v.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED)) {
                      var D = g[g.currentMode].element;
                      if (!w) {
                        navigator.mediaDevices.getUserMedia({ audio: !0 }).then(function(B) {
                          w = new T_(B), w.recorder.onaudioprocess = function(_) {
                            if (w.isRecording) {
                              var W = _.inputBuffer.getChannelData(0), Z = _.inputBuffer.getChannelData(1);
                              w.cloneChannelData(W, Z);
                            }
                          }, w.startRecordingNewWavFile(), g.tip.show(window.VditorI18n.recording), D.setAttribute("contenteditable", "false"), v.element.children[0].classList.add("vditor-menu--current");
                        }).catch(function() {
                          g.tip.show(window.VditorI18n["record-tip"]);
                        });
                        return;
                      }
                      if (w.isRecording) {
                        w.stopRecording(), g.tip.hide();
                        var I = new File([w.buildWavFileBlob()], "record".concat((/* @__PURE__ */ new Date()).getTime(), ".wav"), { type: "video/webm" });
                        Uc(g, [I]), v.element.children[0].classList.remove("vditor-menu--current");
                      } else
                        g.tip.show(window.VditorI18n.recording), D.setAttribute("contenteditable", "false"), w.startRecordingNewWavFile(), v.element.children[0].classList.add("vditor-menu--current");
                    }
                  });
                }, p;
              }(Tt)
            ), L_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), O_ = (
              /** @class */
              function(d) {
                L_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return k({ redo: w.element }, ["redo"]), w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), !w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) && g.undo.redo(g);
                  }), w;
                }
                return p;
              }(Tt)
            ), D_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), N_ = (
              /** @class */
              function(d) {
                D_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this;
                  return k({ undo: w.element }, ["undo"]), w.element.children[0].addEventListener((0, f.Le)(), function(S) {
                    S.preventDefault(), !w.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED) && g.undo.undo(g);
                  }), w;
                }
                return p;
              }(Tt)
            ), I_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), __ = (
              /** @class */
              function(d) {
                I_(p, d);
                function p(g, v) {
                  var w = d.call(this, g, v) || this, S = '<input type="file"';
                  return g.options.upload.multiple && (S += ' multiple="multiple"'), g.options.upload.accept && (S += ' accept="'.concat(g.options.upload.accept, '"')), w.element.children[0].innerHTML = "".concat(v.icon || '<svg><use xlink:href="#vditor-icon-upload"></use></svg>').concat(S, ">"), w._bindEvent(g), w;
                }
                return p.prototype._bindEvent = function(g) {
                  var v = this;
                  this.element.children[0].addEventListener((0, f.Le)(), function(w) {
                    if (v.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED)) {
                      w.stopPropagation(), w.preventDefault();
                      return;
                    }
                  }), this.element.querySelector("input").addEventListener("change", function(w) {
                    if (v.element.firstElementChild.classList.contains(a.g.CLASS_MENU_DISABLED)) {
                      w.stopPropagation(), w.preventDefault();
                      return;
                    }
                    w.target.files.length !== 0 && Uc(g, w.target.files, w.target);
                  });
                }, p;
              }(Tt)
            ), R_ = (
              /** @class */
              function() {
                function d(p) {
                  var g = this, v = p.options;
                  this.elements = {}, this.element = document.createElement("div"), this.element.className = "vditor-toolbar", v.toolbar.forEach(function(w, S) {
                    var D = g.genItem(p, w, S);
                    if (g.element.appendChild(D), w.toolbar) {
                      var I = document.createElement("div");
                      I.className = "vditor-hint vditor-panel--arrow", I.addEventListener((0, f.Le)(), function(B) {
                        I.style.display = "none";
                      }), w.toolbar.forEach(function(B, _) {
                        B.level = 2, I.appendChild(g.genItem(p, B, S + _));
                      }), D.appendChild(I), E(p, I, D.children[0]);
                    }
                  }), p.options.toolbarConfig.hide && this.element.classList.add("vditor-toolbar--hide"), p.options.toolbarConfig.pin && this.element.classList.add("vditor-toolbar--pin"), p.options.counter.enable && (p.counter = new KI(p), this.element.appendChild(p.counter.element));
                }
                return d.prototype.updateConfig = function(p, g) {
                  p.options.toolbarConfig = Object.assign({
                    hide: !1,
                    pin: !1
                  }, g), p.options.toolbarConfig.hide ? this.element.classList.add("vditor-toolbar--hide") : this.element.classList.remove("vditor-toolbar--hide"), p.options.toolbarConfig.pin ? this.element.classList.add("vditor-toolbar--pin") : this.element.classList.remove("vditor-toolbar--pin");
                }, d.prototype.genItem = function(p, g, v) {
                  var w;
                  switch (g.name) {
                    case "bold":
                    case "italic":
                    case "more":
                    case "strike":
                    case "line":
                    case "quote":
                    case "list":
                    case "ordered-list":
                    case "check":
                    case "code":
                    case "inline-code":
                    case "link":
                    case "table":
                      w = new Tt(p, g);
                      break;
                    case "emoji":
                      w = new e_(p, g);
                      break;
                    case "headings":
                      w = new c_(p, g);
                      break;
                    case "|":
                      w = new ZI();
                      break;
                    case "br":
                      w = new qI();
                      break;
                    case "undo":
                      w = new N_(p, g);
                      break;
                    case "redo":
                      w = new O_(p, g);
                      break;
                    case "help":
                      w = new h_(p, g);
                      break;
                    case "both":
                      w = new VI(p, g);
                      break;
                    case "preview":
                      w = new M_(p, g);
                      break;
                    case "fullscreen":
                      w = new a_(p, g);
                      break;
                    case "upload":
                      w = new __(p, g);
                      break;
                    case "record":
                      w = new E_(p, g);
                      break;
                    case "info":
                      w = new m_(p, g);
                      break;
                    case "edit-mode":
                      w = new xl(p, g);
                      break;
                    case "devtools":
                      w = new XI(p, g);
                      break;
                    case "outdent":
                      w = new k_(p, g);
                      break;
                    case "indent":
                      w = new d_(p, g);
                      break;
                    case "outline":
                      w = new S_(p, g);
                      break;
                    case "insert-after":
                      w = new y_(p, g);
                      break;
                    case "insert-before":
                      w = new v_(p, g);
                      break;
                    case "code-theme":
                      w = new jI(p, g);
                      break;
                    case "content-theme":
                      w = new UI(p, g);
                      break;
                    case "export":
                      w = new s_(p, g);
                      break;
                    default:
                      w = new JI(p, g);
                      break;
                  }
                  if (w) {
                    var S = g.name;
                    return (S === "br" || S === "|") && (S = S + v), this.elements[S] = w.element, w.element;
                  }
                }, d;
              }()
            ), P_ = i(173), B_ = (
              /** @class */
              function() {
                function d() {
                  this.stackSize = 50, this.resetStack(), this.dmp = new P_();
                }
                return d.prototype.clearStack = function(p) {
                  this.resetStack(), this.resetIcon(p);
                }, d.prototype.resetIcon = function(p) {
                  p.toolbar && (this[p.currentMode].undoStack.length > 1 ? b(p.toolbar.elements, ["undo"]) : k(p.toolbar.elements, ["undo"]), this[p.currentMode].redoStack.length !== 0 ? b(p.toolbar.elements, ["redo"]) : k(p.toolbar.elements, ["redo"]));
                }, d.prototype.undo = function(p) {
                  if (p[p.currentMode].element.getAttribute("contenteditable") !== "false" && !(this[p.currentMode].undoStack.length < 2)) {
                    var g = this[p.currentMode].undoStack.pop();
                    g && (this[p.currentMode].redoStack.push(g), this.renderDiff(g, p), this[p.currentMode].hasUndo = !0, T(p, ["hint"]));
                  }
                }, d.prototype.redo = function(p) {
                  if (p[p.currentMode].element.getAttribute("contenteditable") !== "false") {
                    var g = this[p.currentMode].redoStack.pop();
                    g && (this[p.currentMode].undoStack.push(g), this.renderDiff(g, p, !0));
                  }
                }, d.prototype.recordFirstPosition = function(p, g) {
                  if (getSelection().rangeCount !== 0 && !(this[p.currentMode].undoStack.length !== 1 || this[p.currentMode].undoStack[0].length === 0 || this[p.currentMode].redoStack.length > 0) && !((0, f.vU)() && g.key === "Backspace") && !(0, f.G6)()) {
                    var v = this.addCaret(p);
                    v.replace("<wbr>", "").replace(" vditor-ir__node--expand", "") === this[p.currentMode].undoStack[0][0].diffs[0][1].replace("<wbr>", "") && (this[p.currentMode].undoStack[0][0].diffs[0][1] = v, this[p.currentMode].lastText = v);
                  }
                }, d.prototype.addToUndoStack = function(p) {
                  var g = this.addCaret(p, !0), v = this.dmp.diff_main(g, this[p.currentMode].lastText, !0), w = this.dmp.patch_make(g, this[p.currentMode].lastText, v);
                  w.length === 0 && this[p.currentMode].undoStack.length > 0 || (this[p.currentMode].lastText = g, this[p.currentMode].undoStack.push(w), this[p.currentMode].undoStack.length > this.stackSize && this[p.currentMode].undoStack.shift(), this[p.currentMode].hasUndo && (this[p.currentMode].redoStack = [], this[p.currentMode].hasUndo = !1, k(p.toolbar.elements, ["redo"])), this[p.currentMode].undoStack.length > 1 && b(p.toolbar.elements, ["undo"]));
                }, d.prototype.renderDiff = function(p, g, v) {
                  v === void 0 && (v = !1);
                  var w;
                  if (v) {
                    var S = this.dmp.patch_deepCopy(p).reverse();
                    S.forEach(function(I) {
                      I.diffs.forEach(function(B) {
                        B[0] = -B[0];
                      });
                    }), w = this.dmp.patch_apply(S, this[g.currentMode].lastText)[0];
                  } else
                    w = this.dmp.patch_apply(p, this[g.currentMode].lastText)[0];
                  if (this[g.currentMode].lastText = w, g[g.currentMode].element.innerHTML = w, g.currentMode !== "sv" && (g[g.currentMode].element.querySelectorAll(".vditor-".concat(g.currentMode, "__preview")).forEach(function(I) {
                    I.parentElement.querySelector(".language-echarts") && (g.currentMode === "ir" ? I.parentElement.outerHTML = g.lute.SpinVditorIRDOM(I.parentElement.outerHTML) : I.parentElement.outerHTML = g.lute.SpinVditorDOM(I.parentElement.outerHTML));
                  }), g[g.currentMode].element.querySelectorAll(".vditor-".concat(g.currentMode, "__preview[data-render='2']")).forEach(function(I) {
                    Re(I, g);
                  })), g[g.currentMode].element.querySelector("wbr"))
                    (0, J.ib)(g[g.currentMode].element, g[g.currentMode].element.ownerDocument.createRange()), un(g);
                  else {
                    var D = getSelection().getRangeAt(0);
                    D.setEndBefore(g[g.currentMode].element), D.collapse(!1);
                  }
                  V(g), xt(g, {
                    enableAddUndoStack: !1,
                    enableHint: !1,
                    enableInput: !0
                  }), ui(g), g[g.currentMode].element.querySelectorAll(".vditor-".concat(g.currentMode, "__preview[data-render='2']")).forEach(function(I) {
                    Re(I, g);
                  }), this[g.currentMode].undoStack.length > 1 ? b(g.toolbar.elements, ["undo"]) : k(g.toolbar.elements, ["undo"]), this[g.currentMode].redoStack.length !== 0 ? b(g.toolbar.elements, ["redo"]) : k(g.toolbar.elements, ["redo"]);
                }, d.prototype.resetStack = function() {
                  this.ir = {
                    hasUndo: !1,
                    lastText: "",
                    redoStack: [],
                    undoStack: []
                  }, this.sv = {
                    hasUndo: !1,
                    lastText: "",
                    redoStack: [],
                    undoStack: []
                  }, this.wysiwyg = {
                    hasUndo: !1,
                    lastText: "",
                    redoStack: [],
                    undoStack: []
                  };
                }, d.prototype.addCaret = function(p, g) {
                  g === void 0 && (g = !1);
                  var v;
                  if (getSelection().rangeCount !== 0 && !p[p.currentMode].element.querySelector("wbr")) {
                    var w = getSelection().getRangeAt(0);
                    if (p[p.currentMode].element.contains(w.startContainer)) {
                      v = w.cloneRange();
                      var S = document.createElement("span");
                      S.className = "vditor-wbr", w.insertNode(S);
                    }
                  }
                  var D = p[p.currentMode].element.cloneNode(!0);
                  D.querySelectorAll(".vditor-".concat(p.currentMode, "__preview[data-render='1']")).forEach(function(B) {
                    B.firstElementChild && (B.firstElementChild.classList.contains("language-echarts") || B.firstElementChild.classList.contains("language-plantuml") || B.firstElementChild.classList.contains("language-mindmap") ? (B.firstElementChild.removeAttribute("_echarts_instance_"), B.firstElementChild.removeAttribute("data-processed"), B.firstElementChild.innerHTML = B.previousElementSibling.firstElementChild.innerHTML, B.setAttribute("data-render", "2")) : B.firstElementChild.classList.contains("language-math") && (B.setAttribute("data-render", "2"), B.firstElementChild.textContent = B.firstElementChild.getAttribute("data-math"), B.firstElementChild.removeAttribute("data-math")));
                  });
                  var I = D.innerHTML;
                  return p[p.currentMode].element.querySelectorAll(".vditor-wbr").forEach(function(B) {
                    B.remove();
                  }), g && v && (0, J.Hc)(v), I.replace('<span class="vditor-wbr"></span>', "<wbr>");
                }, d;
              }()
            ), H_ = i(673), z_ = (
              /** @class */
              function() {
                function d(p) {
                  this.defaultOptions = {
                    rtl: !1,
                    after: void 0,
                    cache: {
                      enable: !0
                    },
                    cdn: a.g.CDN,
                    classes: {
                      preview: ""
                    },
                    comment: {
                      enable: !1
                    },
                    counter: {
                      enable: !1,
                      type: "markdown"
                    },
                    customRenders: [],
                    debugger: !1,
                    fullscreen: {
                      index: 90
                    },
                    height: "auto",
                    hint: {
                      delay: 200,
                      emoji: {
                        "+1": "👍",
                        "-1": "👎",
                        confused: "😕",
                        eyes: "👀️",
                        heart: "❤️",
                        rocket: "🚀️",
                        smile: "😄",
                        tada: "🎉️"
                      },
                      emojiPath: "".concat(a.g.CDN, "/dist/images/emoji"),
                      extend: [],
                      parse: !0
                    },
                    icon: "ant",
                    lang: "zh_CN",
                    mode: "ir",
                    outline: {
                      enable: !1,
                      position: "left"
                    },
                    placeholder: "",
                    preview: {
                      actions: ["desktop", "tablet", "mobile", "mp-wechat", "zhihu"],
                      delay: 1e3,
                      hljs: a.g.HLJS_OPTIONS,
                      markdown: a.g.MARKDOWN_OPTIONS,
                      math: a.g.MATH_OPTIONS,
                      maxWidth: 800,
                      mode: "both",
                      theme: a.g.THEME_OPTIONS,
                      render: {
                        media: {
                          enable: !0
                        }
                      }
                    },
                    link: {
                      isOpen: !0
                    },
                    image: {
                      isPreview: !0
                    },
                    resize: {
                      enable: !1,
                      position: "bottom"
                    },
                    theme: "classic",
                    toolbar: [
                      "emoji",
                      "headings",
                      "bold",
                      "italic",
                      "strike",
                      "link",
                      "|",
                      "list",
                      "ordered-list",
                      "check",
                      "outdent",
                      "indent",
                      "|",
                      "quote",
                      "line",
                      "code",
                      "inline-code",
                      "insert-before",
                      "insert-after",
                      "|",
                      "upload",
                      "record",
                      "table",
                      "|",
                      "undo",
                      "redo",
                      "|",
                      "fullscreen",
                      "edit-mode",
                      {
                        name: "more",
                        toolbar: [
                          "both",
                          "code-theme",
                          "content-theme",
                          "export",
                          "outline",
                          "preview",
                          "devtools",
                          "info",
                          "help"
                        ]
                      }
                    ],
                    toolbarConfig: {
                      hide: !1,
                      pin: !1
                    },
                    typewriterMode: !1,
                    undoDelay: 800,
                    upload: {
                      extraData: {},
                      fieldName: "file[]",
                      filename: function(g) {
                        return g.replace(/\W/g, "");
                      },
                      linkToImgUrl: "",
                      max: 10 * 1024 * 1024,
                      multiple: !0,
                      url: "",
                      withCredentials: !1
                    },
                    value: "",
                    width: "auto"
                  }, this.options = p;
                }
                return d.prototype.merge = function() {
                  var p, g, v, w, S, D, I, B, _;
                  this.options && (this.options.toolbar ? this.options.toolbar = this.mergeToolbar(this.options.toolbar) : this.options.toolbar = this.mergeToolbar(this.defaultOptions.toolbar), !((g = (p = this.options.preview) === null || p === void 0 ? void 0 : p.theme) === null || g === void 0) && g.list && (this.defaultOptions.preview.theme.list = this.options.preview.theme.list), !((S = (w = (v = this.options.preview) === null || v === void 0 ? void 0 : v.render) === null || w === void 0 ? void 0 : w.media) === null || S === void 0) && S.enable && (this.defaultOptions.preview.render.media.enable = this.options.preview.render.media.enable), !((D = this.options.hint) === null || D === void 0) && D.emoji && (this.defaultOptions.hint.emoji = this.options.hint.emoji), this.options.comment && (this.defaultOptions.comment = this.options.comment), this.options.cdn && (!((B = (I = this.options.preview) === null || I === void 0 ? void 0 : I.theme) === null || B === void 0) && B.path || (this.defaultOptions.preview.theme.path = "".concat(this.options.cdn, "/dist/css/content-theme")), !((_ = this.options.hint) === null || _ === void 0) && _.emojiPath || (this.defaultOptions.hint.emojiPath = "".concat(this.options.cdn, "/dist/images/emoji"))));
                  var W = (0, H_.T)(this.defaultOptions, this.options);
                  if (W.cache.enable && !W.cache.id)
                    throw new Error("need options.cache.id, see https://ld246.com/article/1549638745630#options");
                  return W;
                }, d.prototype.mergeToolbar = function(p) {
                  var g = this, v = [
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-export"></use></svg>',
                      name: "export",
                      tipPosition: "ne"
                    },
                    {
                      hotkey: "⌘E",
                      icon: '<svg><use xlink:href="#vditor-icon-emoji"></use></svg>',
                      name: "emoji",
                      tipPosition: "ne"
                    },
                    {
                      hotkey: "⌘H",
                      icon: '<svg><use xlink:href="#vditor-icon-headings"></use></svg>',
                      name: "headings",
                      tipPosition: "ne"
                    },
                    {
                      hotkey: "⌘B",
                      icon: '<svg><use xlink:href="#vditor-icon-bold"></use></svg>',
                      name: "bold",
                      prefix: "**",
                      suffix: "**",
                      tipPosition: "ne"
                    },
                    {
                      hotkey: "⌘I",
                      icon: '<svg><use xlink:href="#vditor-icon-italic"></use></svg>',
                      name: "italic",
                      prefix: "*",
                      suffix: "*",
                      tipPosition: "ne"
                    },
                    {
                      hotkey: "⌘D",
                      icon: '<svg><use xlink:href="#vditor-icon-strike"></use></svg>',
                      name: "strike",
                      prefix: "~~",
                      suffix: "~~",
                      tipPosition: "ne"
                    },
                    {
                      hotkey: "⌘K",
                      icon: '<svg><use xlink:href="#vditor-icon-link"></use></svg>',
                      name: "link",
                      prefix: "[",
                      suffix: "](https://)",
                      tipPosition: "n"
                    },
                    {
                      name: "|"
                    },
                    {
                      hotkey: "⌘L",
                      icon: '<svg><use xlink:href="#vditor-icon-list"></use></svg>',
                      name: "list",
                      prefix: "* ",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⌘O",
                      icon: '<svg><use xlink:href="#vditor-icon-ordered-list"></use></svg>',
                      name: "ordered-list",
                      prefix: "1. ",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⌘J",
                      icon: '<svg><use xlink:href="#vditor-icon-check"></use></svg>',
                      name: "check",
                      prefix: "* [ ] ",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⇧⌘I",
                      icon: '<svg><use xlink:href="#vditor-icon-outdent"></use></svg>',
                      name: "outdent",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⇧⌘O",
                      icon: '<svg><use xlink:href="#vditor-icon-indent"></use></svg>',
                      name: "indent",
                      tipPosition: "n"
                    },
                    {
                      name: "|"
                    },
                    {
                      hotkey: "⌘;",
                      icon: '<svg><use xlink:href="#vditor-icon-quote"></use></svg>',
                      name: "quote",
                      prefix: "> ",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⇧⌘H",
                      icon: '<svg><use xlink:href="#vditor-icon-line"></use></svg>',
                      name: "line",
                      prefix: "---",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⌘U",
                      icon: '<svg><use xlink:href="#vditor-icon-code"></use></svg>',
                      name: "code",
                      prefix: "```",
                      suffix: "\n```",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⌘G",
                      icon: '<svg><use xlink:href="#vditor-icon-inline-code"></use></svg>',
                      name: "inline-code",
                      prefix: "`",
                      suffix: "`",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⇧⌘B",
                      icon: '<svg><use xlink:href="#vditor-icon-before"></use></svg>',
                      name: "insert-before",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⇧⌘E",
                      icon: '<svg><use xlink:href="#vditor-icon-after"></use></svg>',
                      name: "insert-after",
                      tipPosition: "n"
                    },
                    {
                      name: "|"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-upload"></use></svg>',
                      name: "upload",
                      tipPosition: "n"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-record"></use></svg>',
                      name: "record",
                      tipPosition: "n"
                    },
                    {
                      hotkey: "⌘M",
                      icon: '<svg><use xlink:href="#vditor-icon-table"></use></svg>',
                      name: "table",
                      prefix: "| col1",
                      suffix: ` | col2 | col3 |
| --- | --- | --- |
|  |  |  |
|  |  |  |`,
                      tipPosition: "n"
                    },
                    {
                      name: "|"
                    },
                    {
                      hotkey: "⌘Z",
                      icon: '<svg><use xlink:href="#vditor-icon-undo"></use></svg>',
                      name: "undo",
                      tipPosition: "nw"
                    },
                    {
                      hotkey: "⌘Y",
                      icon: '<svg><use xlink:href="#vditor-icon-redo"></use></svg>',
                      name: "redo",
                      tipPosition: "nw"
                    },
                    {
                      name: "|"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-more"></use></svg>',
                      name: "more",
                      tipPosition: "e"
                    },
                    {
                      hotkey: "⌘'",
                      icon: '<svg><use xlink:href="#vditor-icon-fullscreen"></use></svg>',
                      name: "fullscreen",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-edit"></use></svg>',
                      name: "edit-mode",
                      tipPosition: "nw"
                    },
                    {
                      hotkey: "⌘P",
                      icon: '<svg><use xlink:href="#vditor-icon-both"></use></svg>',
                      name: "both",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-preview"></use></svg>',
                      name: "preview",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-align-center"></use></svg>',
                      name: "outline",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-theme"></use></svg>',
                      name: "content-theme",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-code-theme"></use></svg>',
                      name: "code-theme",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-bug"></use></svg>',
                      name: "devtools",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-info"></use></svg>',
                      name: "info",
                      tipPosition: "nw"
                    },
                    {
                      icon: '<svg><use xlink:href="#vditor-icon-help"></use></svg>',
                      name: "help",
                      tipPosition: "nw"
                    },
                    {
                      name: "br"
                    }
                  ], w = [];
                  return p.forEach(function(S) {
                    var D = S;
                    v.forEach(function(I) {
                      typeof S == "string" && I.name === S && (D = I), typeof S == "object" && I.name === S.name && (D = Object.assign({}, I, S));
                    }), S.toolbar && (D.toolbar = g.mergeToolbar(S.toolbar)), w.push(D);
                  }), w;
                }, d;
              }()
            ), F_ = (
              /** @class */
              function() {
                function d(p) {
                  var g = this;
                  this.composingLock = !1, this.commentIds = [];
                  var v = document.createElement("div");
                  v.className = "vditor-wysiwyg", v.innerHTML = '<pre class="vditor-reset" placeholder="'.concat(p.options.placeholder, `"
 contenteditable="true" spellcheck="false"></pre>
<div class="vditor-panel vditor-panel--none"></div>
<div class="vditor-panel vditor-panel--none">
    <button type="button" aria-label="`).concat(window.VditorI18n.comment, `" class="vditor-icon vditor-tooltipped vditor-tooltipped__n">
        <svg><use xlink:href="#vditor-icon-comment"></use></svg>
    </button>
</div>`), this.element = v.firstElementChild, this.popover = v.firstElementChild.nextElementSibling, this.selectPopover = v.lastElementChild, this.bindEvent(p), bo(p, this.element), Ar(p, this.element), vo(p, this.element), Ke(p, this.element), Y(p, this.element), wo(p, this.element), ko(p, this.element, this.copy), xo(p, this.element, this.copy), p.options.comment.enable && (this.selectPopover.querySelector("button").onclick = function() {
                    var w = Lute.NewNodeID(), S = getSelection().getRangeAt(0), D = S.cloneRange(), I = S.extractContents(), B, _, W = !1, Z = !1;
                    I.childNodes.forEach(function(fe, Ae) {
                      var Me = !1;
                      if (fe.nodeType === 3 ? Me = !0 : fe.classList.contains("vditor-comment") ? fe.classList.contains("vditor-comment") && fe.setAttribute("data-cmtids", fe.getAttribute("data-cmtids") + " " + w) : Me = !0, Me)
                        if (fe.nodeType !== 3 && fe.getAttribute("data-block") === "0" && Ae === 0 && D.startOffset > 0)
                          fe.innerHTML = '<span class="vditor-comment" data-cmtids="'.concat(w, '">').concat(fe.innerHTML, "</span>"), B = fe;
                        else if (fe.nodeType !== 3 && fe.getAttribute("data-block") === "0" && Ae === I.childNodes.length - 1 && D.endOffset < D.endContainer.textContent.length)
                          fe.innerHTML = '<span class="vditor-comment" data-cmtids="'.concat(w, '">').concat(fe.innerHTML, "</span>"), _ = fe;
                        else if (fe.nodeType !== 3 && fe.getAttribute("data-block") === "0")
                          Ae === 0 ? W = !0 : Ae === I.childNodes.length - 1 && (Z = !0), fe.innerHTML = '<span class="vditor-comment" data-cmtids="'.concat(w, '">').concat(fe.innerHTML, "</span>");
                        else {
                          var de = document.createElement("span");
                          de.classList.add("vditor-comment"), de.setAttribute("data-cmtids", w), fe.parentNode.insertBefore(de, fe), de.appendChild(fe);
                        }
                    });
                    var ye = (0, C.F9)(D.startContainer);
                    ye && (B ? (ye.insertAdjacentHTML("beforeend", B.innerHTML), B.remove()) : ye.textContent.trim().replace(a.g.ZWSP, "") === "" && W && ye.remove());
                    var ve = (0, C.F9)(D.endContainer);
                    ve && (_ ? (ve.insertAdjacentHTML("afterbegin", _.innerHTML), _.remove()) : ve.textContent.trim().replace(a.g.ZWSP, "") === "" && Z && ve.remove()), S.insertNode(I), p.options.comment.add(w, S.toString(), g.getComments(p, !0)), kt(p, {
                      enableAddUndoStack: !0,
                      enableHint: !1,
                      enableInput: !1
                    }), g.hideComment();
                  });
                }
                return d.prototype.getComments = function(p, g) {
                  var v = this;
                  if (g === void 0 && (g = !1), p.currentMode === "wysiwyg" && p.options.comment.enable) {
                    this.commentIds = [], this.element.querySelectorAll(".vditor-comment").forEach(function(S) {
                      v.commentIds = v.commentIds.concat(S.getAttribute("data-cmtids").split(" "));
                    }), this.commentIds = Array.from(new Set(this.commentIds));
                    var w = [];
                    if (g)
                      return this.commentIds.forEach(function(S) {
                        w.push({
                          id: S,
                          top: v.element.querySelector('.vditor-comment[data-cmtids="'.concat(S, '"]')).offsetTop
                        });
                      }), w;
                  } else
                    return [];
                }, d.prototype.triggerRemoveComment = function(p) {
                  var g = function(S, D) {
                    var I = new Set(D);
                    return S.filter(function(B) {
                      return !I.has(B);
                    });
                  };
                  if (p.currentMode === "wysiwyg" && p.options.comment.enable && p.wysiwyg.commentIds.length > 0) {
                    var v = JSON.parse(JSON.stringify(this.commentIds));
                    this.getComments(p);
                    var w = g(v, this.commentIds);
                    w.length > 0 && p.options.comment.remove(w);
                  }
                }, d.prototype.showComment = function() {
                  var p = (0, J.Ny)(this.element);
                  this.selectPopover.setAttribute("style", "left:".concat(p.left, "px;display:block;top:").concat(Math.max(-8, p.top - 21), "px"));
                }, d.prototype.hideComment = function() {
                  this.selectPopover.setAttribute("style", "display:none");
                }, d.prototype.unbindListener = function() {
                  window.removeEventListener("scroll", this.scrollListener);
                }, d.prototype.copy = function(p, g) {
                  var v = getSelection().getRangeAt(0);
                  if (v.toString() !== "") {
                    p.stopPropagation(), p.preventDefault();
                    var w = (0, C.lG)(v.startContainer, "CODE"), S = (0, C.lG)(v.endContainer, "CODE");
                    if (w && S && S.isSameNode(w)) {
                      var D = "";
                      w.parentElement.tagName === "PRE" ? D = v.toString() : D = "`" + v.toString() + "`", p.clipboardData.setData("text/plain", D), p.clipboardData.setData("text/html", "");
                      return;
                    }
                    var I = (0, C.lG)(v.startContainer, "A"), B = (0, C.lG)(v.endContainer, "A");
                    if (I && B && B.isSameNode(I)) {
                      var _ = I.getAttribute("title") || "";
                      _ && (_ = ' "'.concat(_, '"')), p.clipboardData.setData("text/plain", "[".concat(v.toString(), "](").concat(I.getAttribute("href")).concat(_, ")")), p.clipboardData.setData("text/html", "");
                      return;
                    }
                    var W = document.createElement("div");
                    W.appendChild(v.cloneContents()), p.clipboardData.setData("text/plain", g.lute.VditorDOM2Md(W.innerHTML).trim()), p.clipboardData.setData("text/html", "");
                  }
                }, d.prototype.bindEvent = function(p) {
                  var g = this;
                  this.unbindListener(), window.addEventListener("scroll", this.scrollListener = function() {
                    if (T(p, ["hint"]), !(g.popover.style.display !== "block" || g.selectPopover.style.display !== "block")) {
                      var v = parseInt(g.popover.getAttribute("data-top"), 10);
                      if (p.options.height !== "auto") {
                        if (p.options.toolbarConfig.pin && p.toolbar.element.getBoundingClientRect().top === 0) {
                          var w = Math.max(window.scrollY - p.element.offsetTop - 8, Math.min(v - p.wysiwyg.element.scrollTop, g.element.clientHeight - 21)) + "px";
                          g.popover.style.display === "block" && (g.popover.style.top = w), g.selectPopover.style.display === "block" && (g.selectPopover.style.top = w);
                        }
                        return;
                      } else if (!p.options.toolbarConfig.pin)
                        return;
                      var S = Math.max(v, window.scrollY - p.element.offsetTop - 8) + "px";
                      g.popover.style.display === "block" && (g.popover.style.top = S), g.selectPopover.style.display === "block" && (g.selectPopover.style.top = S);
                    }
                  }), this.element.addEventListener("scroll", function() {
                    if (T(p, ["hint"]), p.options.comment && p.options.comment.enable && p.options.comment.scroll && p.options.comment.scroll(p.wysiwyg.element.scrollTop), g.popover.style.display === "block") {
                      var v = parseInt(g.popover.getAttribute("data-top"), 10) - p.wysiwyg.element.scrollTop, w = -8;
                      p.options.toolbarConfig.pin && p.toolbar.element.getBoundingClientRect().top === 0 && (w = window.scrollY - p.element.offsetTop + w);
                      var S = Math.max(w, Math.min(v, g.element.clientHeight - 21)) + "px";
                      g.popover.style.top = S, g.selectPopover.style.top = S;
                    }
                  }), this.element.addEventListener("paste", function(v) {
                    wp(p, v, {
                      pasteCode: function(w) {
                        var S = (0, J.zh)(p), D = document.createElement("template");
                        D.innerHTML = w, S.insertNode(D.content.cloneNode(!0));
                        var I = (0, C.a1)(S.startContainer, "data-block", "0");
                        I ? I.outerHTML = p.lute.SpinVditorDOM(I.outerHTML) : p.wysiwyg.element.innerHTML = p.lute.SpinVditorDOM(p.wysiwyg.element.innerHTML), (0, J.ib)(p.wysiwyg.element, S);
                      }
                    });
                  }), this.element.addEventListener("compositionstart", function() {
                    g.composingLock = !0;
                  }), this.element.addEventListener("compositionend", function(v) {
                    var w = (0, O.W)(getSelection().getRangeAt(0).startContainer);
                    if (w && w.textContent === "") {
                      V(p);
                      return;
                    }
                    (0, f.vU)() || Ml(p, getSelection().getRangeAt(0).cloneRange(), v), g.composingLock = !1;
                  }), this.element.addEventListener("input", function(v) {
                    if (!(v.inputType === "deleteByDrag" || v.inputType === "insertFromDrop")) {
                      if (g.preventInput) {
                        g.preventInput = !1, kt(p);
                        return;
                      }
                      if (g.composingLock || v.data === "‘" || v.data === "“" || v.data === "《") {
                        kt(p);
                        return;
                      }
                      var w = getSelection().getRangeAt(0), S = (0, C.F9)(w.startContainer);
                      if (S || (Kn(p, w), S = (0, C.F9)(w.startContainer)), !!S) {
                        for (var D = (0, J.im)(S, p.wysiwyg.element, w).start, I = !0, B = D - 1; B > S.textContent.substr(0, D).lastIndexOf(`
`); B--)
                          if (S.textContent.charAt(B) !== " " && // 多个 tab 前删除不形成代码块 https://github.com/Vanessa219/vditor/issues/162 1
                          S.textContent.charAt(B) !== "	") {
                            I = !1;
                            break;
                          }
                        D === 0 && (I = !1);
                        for (var _ = !0, B = D - 1; B < S.textContent.length; B++)
                          if (S.textContent.charAt(B) !== " " && S.textContent.charAt(B) !== `
`) {
                            _ = !1;
                            break;
                          }
                        _ && /^#{1,6} $/.test(S.textContent) && (_ = !1);
                        var W = (0, O.W)(getSelection().getRangeAt(0).startContainer);
                        if (W && W.textContent === "" && (V(p), W.remove()), I && S.getAttribute("data-type") !== "code-block" || _ || $y(S.innerHTML) || qy(S.innerHTML) && S.previousElementSibling) {
                          typeof p.options.input == "function" && p.options.input(c(p));
                          return;
                        }
                        v.inputType === "insertParagraph" && g.element.innerHTML === "<p><br></p><p><br></p>" && S.previousElementSibling.remove(), Ml(p, w, v);
                      }
                    }
                  }), this.element.addEventListener("click", function(v) {
                    if (v.target.tagName === "INPUT") {
                      var w = v.target;
                      w.checked ? w.setAttribute("checked", "checked") : w.removeAttribute("checked"), g.preventInput = !0, getSelection().rangeCount > 0 && (0, J.Hc)(getSelection().getRangeAt(0)), kt(p);
                      return;
                    }
                    if (v.target.tagName === "IMG" && // plantuml 图片渲染不进行提示
                    !v.target.parentElement.classList.contains("vditor-wysiwyg__preview")) {
                      v.target.getAttribute("data-type") === "link-ref" ? Is(p, v.target) : as(v, p);
                      return;
                    }
                    var S = (0, C.lG)(v.target, "A");
                    if (S) {
                      p.options.link.click ? p.options.link.click(S) : p.options.link.isOpen && window.open(S.getAttribute("href")), v.preventDefault();
                      return;
                    }
                    var D = (0, J.zh)(p);
                    if (v.target.isEqualNode(g.element) && g.element.lastElementChild && D.collapsed) {
                      var I = g.element.lastElementChild.getBoundingClientRect();
                      v.y > I.top + I.height && (g.element.lastElementChild.tagName === "P" && g.element.lastElementChild.textContent.trim().replace(a.g.ZWSP, "") === "" ? (D.selectNodeContents(g.element.lastElementChild), D.collapse(!1)) : (g.element.insertAdjacentHTML("beforeend", '<p data-block="0">'.concat(a.g.ZWSP, "<wbr></p>")), (0, J.ib)(g.element, D)));
                    }
                    An(p);
                    var B = (0, C.fb)(v.target, "vditor-wysiwyg__preview");
                    B || (B = (0, C.fb)((0, J.zh)(p).startContainer, "vditor-wysiwyg__preview")), B && Dn(B, p), _t(v, p);
                  }), this.element.addEventListener("keyup", function(v) {
                    if (!(v.isComposing || (0, f.yl)(v))) {
                      v.key === "Enter" && un(p), (v.key === "Backspace" || v.key === "Delete") && p.wysiwyg.element.innerHTML !== "" && p.wysiwyg.element.childNodes.length === 1 && p.wysiwyg.element.firstElementChild && p.wysiwyg.element.firstElementChild.tagName === "P" && p.wysiwyg.element.firstElementChild.childElementCount === 0 && (p.wysiwyg.element.textContent === "" || p.wysiwyg.element.textContent === `
`) && (p.wysiwyg.element.innerHTML = "");
                      var w = (0, J.zh)(p);
                      if (v.key === "Backspace" && (0, f.vU)() && w.startContainer.textContent === `
` && w.startOffset === 1 && (w.startContainer.textContent = ""), Kn(p, w), An(p), !(v.key !== "ArrowDown" && v.key !== "ArrowRight" && v.key !== "Backspace" && v.key !== "ArrowLeft" && v.key !== "ArrowUp")) {
                        (v.key === "ArrowLeft" || v.key === "ArrowRight") && p.hint.render(p);
                        var S = (0, C.fb)(w.startContainer, "vditor-wysiwyg__preview");
                        if (!S && w.startContainer.nodeType !== 3 && w.startOffset > 0) {
                          var D = w.startContainer;
                          D.classList.contains("vditor-wysiwyg__block") && (S = D.lastElementChild);
                        }
                        if (S) {
                          var I = S.previousElementSibling;
                          if (I.style.display === "none") {
                            v.key === "ArrowDown" || v.key === "ArrowRight" ? Dn(S, p) : Dn(S, p, !1);
                            return;
                          }
                          var B = S.previousElementSibling;
                          if (B.tagName === "PRE" && (B = B.firstElementChild), v.key === "ArrowDown" || v.key === "ArrowRight") {
                            var D = S.parentElement, _ = Dt(D);
                            if (_ && _.nodeType !== 3) {
                              var W = _.querySelector(".vditor-wysiwyg__preview");
                              if (W) {
                                Dn(W, p);
                                return;
                              }
                            }
                            if (_.nodeType === 3) {
                              for (; _.textContent.length === 0 && _.nextSibling; )
                                _ = _.nextSibling;
                              w.setStart(_, 1);
                            } else
                              w.setStart(_.firstChild, 0);
                          } else
                            w.selectNodeContents(B), w.collapse(!1);
                        }
                      }
                    }
                  });
                }, d;
              }()
            ), V_ = /* @__PURE__ */ function() {
              var d = function(p, g) {
                return d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, w) {
                  v.__proto__ = w;
                } || function(v, w) {
                  for (var S in w) Object.prototype.hasOwnProperty.call(w, S) && (v[S] = w[S]);
                }, d(p, g);
              };
              return function(p, g) {
                if (typeof g != "function" && g !== null)
                  throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
                d(p, g);
                function v() {
                  this.constructor = p;
                }
                p.prototype = g === null ? Object.create(g) : (v.prototype = g.prototype, new v());
              };
            }(), q_ = (
              /** @class */
              function(d) {
                V_(p, d);
                function p(g, v) {
                  var w = d.call(this) || this;
                  if (w.isDestroyed = !1, w.version = a.H, typeof g == "string") {
                    if (v ? v.cache ? v.cache.id || (v.cache.id = "vditor".concat(g)) : v.cache = { id: "vditor".concat(g) } : v = {
                      cache: {
                        id: "vditor".concat(g)
                      }
                    }, !document.getElementById(g))
                      return w.showErrorTip("Failed to get element by id: ".concat(g)), w;
                    g = document.getElementById(g);
                  }
                  var S = new z_(v), D = S.merge();
                  if (D.i18n)
                    window.VditorI18n = D.i18n, w.init(g, D);
                  else if (["de_DE", "en_US", "es_ES", "fr_FR", "ja_JP", "ko_KR", "pt_BR", "ru_RU", "sv_SE", "vi_VN", "zh_CN", "zh_TW"].includes(D.lang)) {
                    var I = "vditorI18nScript", B = I + D.lang;
                    document.querySelectorAll('head script[id^="'.concat(I, '"]')).forEach(function(_) {
                      _.id !== B && document.head.removeChild(_);
                    }), (0, u.G)("".concat(D.cdn, "/dist/js/i18n/").concat(D.lang, ".js"), B).then(function() {
                      w.init(g, D);
                    }).catch(function(_) {
                      w.showErrorTip("GET ".concat(D.cdn, "/dist/js/i18n/").concat(D.lang, ".js net::ERR_ABORTED 404 (Not Found)"));
                    });
                  } else
                    throw new Error("options.lang error, see https://ld246.com/article/1549638745630#options");
                  return w;
                }
                return p.prototype.showErrorTip = function(g) {
                  var v = new J6();
                  document.body.appendChild(v.element), v.show(g, 0);
                }, p.prototype.updateToolbarConfig = function(g) {
                  this.vditor.toolbar.updateConfig(this.vditor, g);
                }, p.prototype.setTheme = function(g, v, w, S) {
                  this.vditor.options.theme = g, yt(this.vditor), v && (this.vditor.options.preview.theme.current = v, (0, Ue.Z)(v, S || this.vditor.options.preview.theme.path)), w && (this.vditor.options.preview.hljs.style = w, (0, Y6.Y)(w, this.vditor.options.cdn));
                }, p.prototype.getValue = function() {
                  return c(this.vditor);
                }, p.prototype.getCurrentMode = function() {
                  return this.vditor.currentMode;
                }, p.prototype.focus = function() {
                  this.vditor.currentMode === "sv" ? this.vditor.sv.element.focus() : this.vditor.currentMode === "wysiwyg" ? this.vditor.wysiwyg.element.focus() : this.vditor.currentMode === "ir" && this.vditor.ir.element.focus();
                }, p.prototype.blur = function() {
                  this.vditor.currentMode === "sv" ? this.vditor.sv.element.blur() : this.vditor.currentMode === "wysiwyg" ? this.vditor.wysiwyg.element.blur() : this.vditor.currentMode === "ir" && this.vditor.ir.element.blur();
                }, p.prototype.disabled = function() {
                  T(this.vditor, ["subToolbar", "hint", "popover"]), k(this.vditor.toolbar.elements, a.g.EDIT_TOOLBARS.concat(["undo", "redo", "fullscreen", "edit-mode"])), this.vditor[this.vditor.currentMode].element.setAttribute("contenteditable", "false");
                }, p.prototype.enable = function() {
                  b(this.vditor.toolbar.elements, a.g.EDIT_TOOLBARS.concat(["undo", "redo", "fullscreen", "edit-mode"])), this.vditor.undo.resetIcon(this.vditor), this.vditor[this.vditor.currentMode].element.setAttribute("contenteditable", "true");
                }, p.prototype.getSelection = function() {
                  if (this.vditor.currentMode === "wysiwyg")
                    return _i(this.vditor.wysiwyg.element);
                  if (this.vditor.currentMode === "sv")
                    return _i(this.vditor.sv.element);
                  if (this.vditor.currentMode === "ir")
                    return _i(this.vditor.ir.element);
                }, p.prototype.renderPreview = function(g) {
                  this.vditor.preview.render(this.vditor, g);
                }, p.prototype.getCursorPosition = function() {
                  return (0, J.Ny)(this.vditor[this.vditor.currentMode].element);
                }, p.prototype.isUploading = function() {
                  return this.vditor.upload.isUploading;
                }, p.prototype.clearCache = function() {
                  this.vditor.options.cache.enable && (0, f.pK)() && localStorage.removeItem(this.vditor.options.cache.id);
                }, p.prototype.disabledCache = function() {
                  this.vditor.options.cache.enable = !1;
                }, p.prototype.enableCache = function() {
                  if (!this.vditor.options.cache.id)
                    throw new Error("need options.cache.id, see https://ld246.com/article/1549638745630#options");
                  this.vditor.options.cache.enable = !0;
                }, p.prototype.html2md = function(g) {
                  return this.vditor.lute.HTML2Md(g);
                }, p.prototype.exportJSON = function(g) {
                  return this.vditor.lute.RenderJSON(g);
                }, p.prototype.getHTML = function() {
                  return K6(this.vditor);
                }, p.prototype.tip = function(g, v) {
                  this.vditor.tip.show(g, v);
                }, p.prototype.setPreviewMode = function(g) {
                  Uy(g, this.vditor);
                }, p.prototype.deleteValue = function() {
                  window.getSelection().isCollapsed || document.execCommand("delete", !1);
                }, p.prototype.updateValue = function(g) {
                  document.execCommand("insertHTML", !1, g);
                }, p.prototype.insertValue = function(g, v) {
                  v === void 0 && (v = !0);
                  var w = (0, J.zh)(this.vditor);
                  w.collapse(!0);
                  var S = document.createElement("template");
                  S.innerHTML = g, w.insertNode(S.content.cloneNode(!0)), w.collapse(!1), this.vditor.currentMode === "sv" ? (this.vditor.sv.preventInput = !0, v && ft(this.vditor)) : this.vditor.currentMode === "wysiwyg" ? v && Ml(this.vditor, getSelection().getRangeAt(0)) : this.vditor.currentMode === "ir" && (this.vditor.ir.preventInput = !0, v && mt(this.vditor, getSelection().getRangeAt(0), !0));
                }, p.prototype.insertMD = function(g) {
                  this.vditor.currentMode === "ir" ? (0, J.oC)(this.vditor.lute.Md2VditorIRDOM(g), this.vditor) : this.vditor.currentMode === "wysiwyg" ? (0, J.oC)(this.vditor.lute.Md2VditorDOM(g), this.vditor) : be(this.vditor, g), this.vditor.outline.render(this.vditor), xt(this.vditor);
                }, p.prototype.setValue = function(g, v) {
                  var w = this;
                  v === void 0 && (v = !1), this.vditor.currentMode === "sv" ? (this.vditor.sv.element.innerHTML = "<div data-block='0'>".concat(this.vditor.lute.SpinVditorSVDOM(g), "</div>"), gt(this.vditor, {
                    enableAddUndoStack: !0,
                    enableHint: !1,
                    enableInput: !1
                  })) : this.vditor.currentMode === "wysiwyg" ? ba(this.vditor, g, {
                    enableAddUndoStack: !0,
                    enableHint: !1,
                    enableInput: !1
                  }) : (this.vditor.ir.element.innerHTML = this.vditor.lute.Md2VditorIRDOM(g), this.vditor.ir.element.querySelectorAll(".vditor-ir__preview[data-render='2']").forEach(function(S) {
                    Re(S, w.vditor);
                  }), Mo(this.vditor, {
                    enableAddUndoStack: !0,
                    enableHint: !1,
                    enableInput: !1
                  })), this.vditor.outline.render(this.vditor), g || (T(this.vditor, ["emoji", "headings", "submenu", "hint"]), this.vditor.wysiwyg.popover && (this.vditor.wysiwyg.popover.style.display = "none"), this.clearCache()), v && this.clearStack();
                }, p.prototype.insertEmptyBlock = function(g) {
                  Tl(this.vditor, g);
                }, p.prototype.clearStack = function() {
                  this.vditor.undo.clearStack(this.vditor), this.vditor.undo.addToUndoStack(this.vditor);
                }, p.prototype.destroy = function() {
                  this.vditor.element.innerHTML = this.vditor.originalInnerHTML, this.vditor.element.classList.remove("vditor"), this.vditor.element.removeAttribute("style");
                  var g = document.getElementById("vditorIconScript");
                  g && g.remove(), this.clearCache(), yo(), this.vditor.wysiwyg.unbindListener(), this.vditor.options.after = void 0, this.isDestroyed = !0;
                }, p.prototype.getCommentIds = function() {
                  return this.vditor.currentMode !== "wysiwyg" ? [] : this.vditor.wysiwyg.getComments(this.vditor, !0);
                }, p.prototype.hlCommentIds = function(g) {
                  if (this.vditor.currentMode === "wysiwyg") {
                    var v = function(w) {
                      w.classList.remove("vditor-comment--hover"), g.forEach(function(S) {
                        w.getAttribute("data-cmtids").indexOf(S) > -1 && w.classList.add("vditor-comment--hover");
                      });
                    };
                    this.vditor.wysiwyg.element.querySelectorAll(".vditor-comment").forEach(function(w) {
                      v(w);
                    }), this.vditor.preview.element.style.display !== "none" && this.vditor.preview.element.querySelectorAll(".vditor-comment").forEach(function(w) {
                      v(w);
                    });
                  }
                }, p.prototype.unHlCommentIds = function(g) {
                  if (this.vditor.currentMode === "wysiwyg") {
                    var v = function(w) {
                      g.forEach(function(S) {
                        w.getAttribute("data-cmtids").indexOf(S) > -1 && w.classList.remove("vditor-comment--hover");
                      });
                    };
                    this.vditor.wysiwyg.element.querySelectorAll(".vditor-comment").forEach(function(w) {
                      v(w);
                    }), this.vditor.preview.element.style.display !== "none" && this.vditor.preview.element.querySelectorAll(".vditor-comment").forEach(function(w) {
                      v(w);
                    });
                  }
                }, p.prototype.removeCommentIds = function(g) {
                  var v = this;
                  if (this.vditor.currentMode === "wysiwyg") {
                    var w = function(S, D) {
                      var I = S.getAttribute("data-cmtids").split(" ");
                      I.find(function(B, _) {
                        if (B === D)
                          return I.splice(_, 1), !0;
                      }), I.length === 0 ? (S.outerHTML = S.innerHTML, (0, J.zh)(v.vditor).collapse(!0)) : S.setAttribute("data-cmtids", I.join(" "));
                    };
                    g.forEach(function(S) {
                      v.vditor.wysiwyg.element.querySelectorAll(".vditor-comment").forEach(function(D) {
                        w(D, S);
                      }), v.vditor.preview.element.style.display !== "none" && v.vditor.preview.element.querySelectorAll(".vditor-comment").forEach(function(D) {
                        w(D, S);
                      });
                    }), kt(this.vditor, {
                      enableAddUndoStack: !0,
                      enableHint: !1,
                      enableInput: !1
                    });
                  }
                }, p.prototype.init = function(g, v) {
                  var w = this;
                  this.isDestroyed || (this.vditor = {
                    currentMode: v.mode,
                    element: g,
                    hint: new NI(v.hint.extend),
                    lute: void 0,
                    options: v,
                    originalInnerHTML: g.innerHTML,
                    outline: new RI(window.VditorI18n.outline),
                    tip: new J6()
                  }, this.vditor.sv = new zI(this.vditor), this.vditor.undo = new B_(), this.vditor.wysiwyg = new F_(this.vditor), this.vditor.ir = new II(this.vditor), this.vditor.toolbar = new R_(this.vditor), v.resize.enable && (this.vditor.resize = new HI(this.vditor)), this.vditor.toolbar.elements.devtools && (this.vditor.devtools = new h()), (v.upload.url || v.upload.handler) && (this.vditor.upload = new Cl()), (0, u.G)(v._lutePath || "".concat(v.cdn, "/dist/js/lute/lute.min.js"), "vditorLuteScript").then(function() {
                    w.vditor.lute = (0, _I.X)({
                      autoSpace: w.vditor.options.preview.markdown.autoSpace,
                      gfmAutoLink: w.vditor.options.preview.markdown.gfmAutoLink,
                      codeBlockPreview: w.vditor.options.preview.markdown.codeBlockPreview,
                      emojiSite: w.vditor.options.hint.emojiPath,
                      emojis: w.vditor.options.hint.emoji,
                      fixTermTypo: w.vditor.options.preview.markdown.fixTermTypo,
                      footnotes: w.vditor.options.preview.markdown.footnotes,
                      headingAnchor: !1,
                      inlineMathDigit: w.vditor.options.preview.math.inlineDigit,
                      linkBase: w.vditor.options.preview.markdown.linkBase,
                      linkPrefix: w.vditor.options.preview.markdown.linkPrefix,
                      listStyle: w.vditor.options.preview.markdown.listStyle,
                      mark: w.vditor.options.preview.markdown.mark,
                      mathBlockPreview: w.vditor.options.preview.markdown.mathBlockPreview,
                      paragraphBeginningSpace: w.vditor.options.preview.markdown.paragraphBeginningSpace,
                      sanitize: w.vditor.options.preview.markdown.sanitize,
                      toc: w.vditor.options.preview.markdown.toc
                    }), w.vditor.preview = new BI(w.vditor), Ut(w.vditor), v.after && v.after(), v.icon && (0, u.J)("".concat(v.cdn, "/dist/js/icons/").concat(v.icon, ".js"), "vditorIconScript");
                  }));
                }, p;
              }(o.default)
            );
            const $_ = q_;
          })(), s = s.default, s;
        })()
      );
    });
  }(xm)), xm.exports;
}
var Q_ = Z_();
const eR = /* @__PURE__ */ QC(Q_);
function tR(n) {
  return n.ctrlKey || n.metaKey ? "vxzy".includes(n.key.toLowerCase()) : (/* @__PURE__ */ new Set([
    "tab",
    "enter",
    "backspace",
    "delete"
  ])).has(n.key.toLowerCase()) || n.key.length === 1;
}
class nR {
  constructor(e, t, r, i) {
    this.editor = new eR(e, {
      cdn: r,
      toolbarConfig: {
        pin: !0
      },
      preview: {
        maxWidth: 2147483647
      },
      // 监听键盘事件，当用户输入时，将需要保存
      keydown: (s) => {
        i.afterContentChange && tR(s) && i.afterContentChange(this);
      },
      after: () => {
        this.editor.setValue(t), i.afterRender && i.afterRender(this);
      }
    });
  }
  getMarkdownContent() {
    return this.editor.getValue();
  }
  getScrollTop() {
    return this.editor.vditor.element.parentElement.scrollTop;
  }
  setScrollTop(e) {
    let r = this.editor.vditor.element.parentElement;
    console.log("[mdnotes] Setting scrollTop value to ", e), r.scrollTo({
      top: e,
      left: 0,
      behavior: "smooth"
    });
  }
  gc() {
    this.editor.destroy();
  }
}
var e9 = typeof global == "object" && global && global.Object === Object && global, rR = typeof self == "object" && self && self.Object === Object && self, Pc = e9 || rR || Function("return this")(), Cg = Pc.Symbol, t9 = Object.prototype, iR = t9.hasOwnProperty, sR = t9.toString, Xh = Cg ? Cg.toStringTag : void 0;
function oR(n) {
  var e = iR.call(n, Xh), t = n[Xh];
  try {
    n[Xh] = void 0;
    var r = !0;
  } catch {
  }
  var i = sR.call(n);
  return r && (e ? n[Xh] = t : delete n[Xh]), i;
}
var aR = Object.prototype, lR = aR.toString;
function cR(n) {
  return lR.call(n);
}
var uR = "[object Null]", hR = "[object Undefined]", ak = Cg ? Cg.toStringTag : void 0;
function P0(n) {
  return n == null ? n === void 0 ? hR : uR : ak && ak in Object(n) ? oR(n) : cR(n);
}
function Mh(n) {
  return n != null && typeof n == "object";
}
var fR = "[object Symbol]";
function dR(n) {
  return typeof n == "symbol" || Mh(n) && P0(n) == fR;
}
var j2 = Array.isArray, pR = /\s/;
function mR(n) {
  for (var e = n.length; e-- && pR.test(n.charAt(e)); )
    ;
  return e;
}
var gR = /^\s+/;
function yR(n) {
  return n && n.slice(0, mR(n) + 1).replace(gR, "");
}
function Li(n) {
  var e = typeof n;
  return n != null && (e == "object" || e == "function");
}
var lk = NaN, bR = /^[-+]0x[0-9a-f]+$/i, vR = /^0b[01]+$/i, wR = /^0o[0-7]+$/i, kR = parseInt;
function ck(n) {
  if (typeof n == "number")
    return n;
  if (dR(n))
    return lk;
  if (Li(n)) {
    var e = typeof n.valueOf == "function" ? n.valueOf() : n;
    n = Li(e) ? e + "" : e;
  }
  if (typeof n != "string")
    return n === 0 ? n : +n;
  n = yR(n);
  var t = vR.test(n);
  return t || wR.test(n) ? kR(n.slice(2), t ? 2 : 8) : bR.test(n) ? lk : +n;
}
function n9(n) {
  return n;
}
var xR = "[object AsyncFunction]", SR = "[object Function]", CR = "[object GeneratorFunction]", MR = "[object Proxy]";
function dw(n) {
  if (!Li(n))
    return !1;
  var e = P0(n);
  return e == SR || e == CR || e == xR || e == MR;
}
var Zy = Pc["__core-js_shared__"], uk = function() {
  var n = /[^.]+$/.exec(Zy && Zy.keys && Zy.keys.IE_PROTO || "");
  return n ? "Symbol(src)_1." + n : "";
}();
function TR(n) {
  return !!uk && uk in n;
}
var AR = Function.prototype, ER = AR.toString;
function LR(n) {
  if (n != null) {
    try {
      return ER.call(n);
    } catch {
    }
    try {
      return n + "";
    } catch {
    }
  }
  return "";
}
var OR = /[\\^$.*+?()[\]{}|]/g, DR = /^\[object .+?Constructor\]$/, NR = Function.prototype, IR = Object.prototype, _R = NR.toString, RR = IR.hasOwnProperty, PR = RegExp(
  "^" + _R.call(RR).replace(OR, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function BR(n) {
  if (!Li(n) || TR(n))
    return !1;
  var e = dw(n) ? PR : DR;
  return e.test(LR(n));
}
function HR(n, e) {
  return n == null ? void 0 : n[e];
}
function pw(n, e) {
  var t = HR(n, e);
  return BR(t) ? t : void 0;
}
var hk = Object.create, zR = /* @__PURE__ */ function() {
  function n() {
  }
  return function(e) {
    if (!Li(e))
      return {};
    if (hk)
      return hk(e);
    n.prototype = e;
    var t = new n();
    return n.prototype = void 0, t;
  };
}();
function r9(n, e, t) {
  switch (t.length) {
    case 0:
      return n.call(e);
    case 1:
      return n.call(e, t[0]);
    case 2:
      return n.call(e, t[0], t[1]);
    case 3:
      return n.call(e, t[0], t[1], t[2]);
  }
  return n.apply(e, t);
}
function FR(n, e) {
  var t = -1, r = n.length;
  for (e || (e = Array(r)); ++t < r; )
    e[t] = n[t];
  return e;
}
var VR = 800, qR = 16, $R = Date.now;
function jR(n) {
  var e = 0, t = 0;
  return function() {
    var r = $R(), i = qR - (r - t);
    if (t = r, i > 0) {
      if (++e >= VR)
        return arguments[0];
    } else
      e = 0;
    return n.apply(void 0, arguments);
  };
}
function WR(n) {
  return function() {
    return n;
  };
}
var Mg = function() {
  try {
    var n = pw(Object, "defineProperty");
    return n({}, "", {}), n;
  } catch {
  }
}(), UR = Mg ? function(n, e) {
  return Mg(n, "toString", {
    configurable: !0,
    enumerable: !1,
    value: WR(e),
    writable: !0
  });
} : n9, KR = jR(UR), GR = 9007199254740991, JR = /^(?:0|[1-9]\d*)$/;
function i9(n, e) {
  var t = typeof n;
  return e = e ?? GR, !!e && (t == "number" || t != "symbol" && JR.test(n)) && n > -1 && n % 1 == 0 && n < e;
}
function mw(n, e, t) {
  e == "__proto__" && Mg ? Mg(n, e, {
    configurable: !0,
    enumerable: !0,
    value: t,
    writable: !0
  }) : n[e] = t;
}
function x1(n, e) {
  return n === e || n !== n && e !== e;
}
var YR = Object.prototype, XR = YR.hasOwnProperty;
function ZR(n, e, t) {
  var r = n[e];
  (!(XR.call(n, e) && x1(r, t)) || t === void 0 && !(e in n)) && mw(n, e, t);
}
function QR(n, e, t, r) {
  var i = !t;
  t || (t = {});
  for (var s = -1, o = e.length; ++s < o; ) {
    var a = e[s], l = void 0;
    l === void 0 && (l = n[a]), i ? mw(t, a, l) : ZR(t, a, l);
  }
  return t;
}
var fk = Math.max;
function eP(n, e, t) {
  return e = fk(e === void 0 ? n.length - 1 : e, 0), function() {
    for (var r = arguments, i = -1, s = fk(r.length - e, 0), o = Array(s); ++i < s; )
      o[i] = r[e + i];
    i = -1;
    for (var a = Array(e + 1); ++i < e; )
      a[i] = r[i];
    return a[e] = t(o), r9(n, this, a);
  };
}
function s9(n, e) {
  return KR(eP(n, e, n9), n + "");
}
var tP = 9007199254740991;
function o9(n) {
  return typeof n == "number" && n > -1 && n % 1 == 0 && n <= tP;
}
function gw(n) {
  return n != null && o9(n.length) && !dw(n);
}
function nP(n, e, t) {
  if (!Li(t))
    return !1;
  var r = typeof e;
  return (r == "number" ? gw(t) && i9(e, t.length) : r == "string" && e in t) ? x1(t[e], n) : !1;
}
function rP(n) {
  return s9(function(e, t) {
    var r = -1, i = t.length, s = i > 1 ? t[i - 1] : void 0, o = i > 2 ? t[2] : void 0;
    for (s = n.length > 3 && typeof s == "function" ? (i--, s) : void 0, o && nP(t[0], t[1], o) && (s = i < 3 ? void 0 : s, i = 1), e = Object(e); ++r < i; ) {
      var a = t[r];
      a && n(e, a, r, s);
    }
    return e;
  });
}
var iP = Object.prototype;
function a9(n) {
  var e = n && n.constructor, t = typeof e == "function" && e.prototype || iP;
  return n === t;
}
function sP(n, e) {
  for (var t = -1, r = Array(n); ++t < n; )
    r[t] = e(t);
  return r;
}
var oP = "[object Arguments]";
function dk(n) {
  return Mh(n) && P0(n) == oP;
}
var l9 = Object.prototype, aP = l9.hasOwnProperty, lP = l9.propertyIsEnumerable, W2 = dk(/* @__PURE__ */ function() {
  return arguments;
}()) ? dk : function(n) {
  return Mh(n) && aP.call(n, "callee") && !lP.call(n, "callee");
};
function cP() {
  return !1;
}
var c9 = typeof exports == "object" && exports && !exports.nodeType && exports, pk = c9 && typeof module == "object" && module && !module.nodeType && module, uP = pk && pk.exports === c9, mk = uP ? Pc.Buffer : void 0, hP = mk ? mk.isBuffer : void 0, u9 = hP || cP, fP = "[object Arguments]", dP = "[object Array]", pP = "[object Boolean]", mP = "[object Date]", gP = "[object Error]", yP = "[object Function]", bP = "[object Map]", vP = "[object Number]", wP = "[object Object]", kP = "[object RegExp]", xP = "[object Set]", SP = "[object String]", CP = "[object WeakMap]", MP = "[object ArrayBuffer]", TP = "[object DataView]", AP = "[object Float32Array]", EP = "[object Float64Array]", LP = "[object Int8Array]", OP = "[object Int16Array]", DP = "[object Int32Array]", NP = "[object Uint8Array]", IP = "[object Uint8ClampedArray]", _P = "[object Uint16Array]", RP = "[object Uint32Array]", hn = {};
hn[AP] = hn[EP] = hn[LP] = hn[OP] = hn[DP] = hn[NP] = hn[IP] = hn[_P] = hn[RP] = !0;
hn[fP] = hn[dP] = hn[MP] = hn[pP] = hn[TP] = hn[mP] = hn[gP] = hn[yP] = hn[bP] = hn[vP] = hn[wP] = hn[kP] = hn[xP] = hn[SP] = hn[CP] = !1;
function PP(n) {
  return Mh(n) && o9(n.length) && !!hn[P0(n)];
}
function BP(n) {
  return function(e) {
    return n(e);
  };
}
var h9 = typeof exports == "object" && exports && !exports.nodeType && exports, Zf = h9 && typeof module == "object" && module && !module.nodeType && module, HP = Zf && Zf.exports === h9, Qy = HP && e9.process, gk = function() {
  try {
    var n = Zf && Zf.require && Zf.require("util").types;
    return n || Qy && Qy.binding && Qy.binding("util");
  } catch {
  }
}(), yk = gk && gk.isTypedArray, f9 = yk ? BP(yk) : PP;
function zP(n, e) {
  var t = j2(n), r = !t && W2(n), i = !t && !r && u9(n), s = !t && !r && !i && f9(n), o = t || r || i || s, a = o ? sP(n.length, String) : [], l = a.length;
  for (var c in n)
    o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    i9(c, l)) || a.push(c);
  return a;
}
function FP(n, e) {
  return function(t) {
    return n(e(t));
  };
}
function VP(n) {
  var e = [];
  if (n != null)
    for (var t in Object(n))
      e.push(t);
  return e;
}
var qP = Object.prototype, $P = qP.hasOwnProperty;
function jP(n) {
  if (!Li(n))
    return VP(n);
  var e = a9(n), t = [];
  for (var r in n)
    r == "constructor" && (e || !$P.call(n, r)) || t.push(r);
  return t;
}
function d9(n) {
  return gw(n) ? zP(n) : jP(n);
}
var Md = pw(Object, "create");
function WP() {
  this.__data__ = Md ? Md(null) : {}, this.size = 0;
}
function UP(n) {
  var e = this.has(n) && delete this.__data__[n];
  return this.size -= e ? 1 : 0, e;
}
var KP = "__lodash_hash_undefined__", GP = Object.prototype, JP = GP.hasOwnProperty;
function YP(n) {
  var e = this.__data__;
  if (Md) {
    var t = e[n];
    return t === KP ? void 0 : t;
  }
  return JP.call(e, n) ? e[n] : void 0;
}
var XP = Object.prototype, ZP = XP.hasOwnProperty;
function QP(n) {
  var e = this.__data__;
  return Md ? e[n] !== void 0 : ZP.call(e, n);
}
var eB = "__lodash_hash_undefined__";
function tB(n, e) {
  var t = this.__data__;
  return this.size += this.has(n) ? 0 : 1, t[n] = Md && e === void 0 ? eB : e, this;
}
function kc(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
kc.prototype.clear = WP;
kc.prototype.delete = UP;
kc.prototype.get = YP;
kc.prototype.has = QP;
kc.prototype.set = tB;
function nB() {
  this.__data__ = [], this.size = 0;
}
function S1(n, e) {
  for (var t = n.length; t--; )
    if (x1(n[t][0], e))
      return t;
  return -1;
}
var rB = Array.prototype, iB = rB.splice;
function sB(n) {
  var e = this.__data__, t = S1(e, n);
  if (t < 0)
    return !1;
  var r = e.length - 1;
  return t == r ? e.pop() : iB.call(e, t, 1), --this.size, !0;
}
function oB(n) {
  var e = this.__data__, t = S1(e, n);
  return t < 0 ? void 0 : e[t][1];
}
function aB(n) {
  return S1(this.__data__, n) > -1;
}
function lB(n, e) {
  var t = this.__data__, r = S1(t, n);
  return r < 0 ? (++this.size, t.push([n, e])) : t[r][1] = e, this;
}
function ha(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
ha.prototype.clear = nB;
ha.prototype.delete = sB;
ha.prototype.get = oB;
ha.prototype.has = aB;
ha.prototype.set = lB;
var p9 = pw(Pc, "Map");
function cB() {
  this.size = 0, this.__data__ = {
    hash: new kc(),
    map: new (p9 || ha)(),
    string: new kc()
  };
}
function uB(n) {
  var e = typeof n;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? n !== "__proto__" : n === null;
}
function C1(n, e) {
  var t = n.__data__;
  return uB(e) ? t[typeof e == "string" ? "string" : "hash"] : t.map;
}
function hB(n) {
  var e = C1(this, n).delete(n);
  return this.size -= e ? 1 : 0, e;
}
function fB(n) {
  return C1(this, n).get(n);
}
function dB(n) {
  return C1(this, n).has(n);
}
function pB(n, e) {
  var t = C1(this, n), r = t.size;
  return t.set(n, e), this.size += t.size == r ? 0 : 1, this;
}
function Th(n) {
  var e = -1, t = n == null ? 0 : n.length;
  for (this.clear(); ++e < t; ) {
    var r = n[e];
    this.set(r[0], r[1]);
  }
}
Th.prototype.clear = cB;
Th.prototype.delete = hB;
Th.prototype.get = fB;
Th.prototype.has = dB;
Th.prototype.set = pB;
var m9 = FP(Object.getPrototypeOf, Object), mB = "[object Object]", gB = Function.prototype, yB = Object.prototype, g9 = gB.toString, bB = yB.hasOwnProperty, vB = g9.call(Object);
function wB(n) {
  if (!Mh(n) || P0(n) != mB)
    return !1;
  var e = m9(n);
  if (e === null)
    return !0;
  var t = bB.call(e, "constructor") && e.constructor;
  return typeof t == "function" && t instanceof t && g9.call(t) == vB;
}
function kB() {
  this.__data__ = new ha(), this.size = 0;
}
function xB(n) {
  var e = this.__data__, t = e.delete(n);
  return this.size = e.size, t;
}
function SB(n) {
  return this.__data__.get(n);
}
function CB(n) {
  return this.__data__.has(n);
}
var MB = 200;
function TB(n, e) {
  var t = this.__data__;
  if (t instanceof ha) {
    var r = t.__data__;
    if (!p9 || r.length < MB - 1)
      return r.push([n, e]), this.size = ++t.size, this;
    t = this.__data__ = new Th(r);
  }
  return t.set(n, e), this.size = t.size, this;
}
function Ah(n) {
  var e = this.__data__ = new ha(n);
  this.size = e.size;
}
Ah.prototype.clear = kB;
Ah.prototype.delete = xB;
Ah.prototype.get = SB;
Ah.prototype.has = CB;
Ah.prototype.set = TB;
var y9 = typeof exports == "object" && exports && !exports.nodeType && exports, bk = y9 && typeof module == "object" && module && !module.nodeType && module, AB = bk && bk.exports === y9, vk = AB ? Pc.Buffer : void 0;
vk && vk.allocUnsafe;
function EB(n, e) {
  return n.slice();
}
var wk = Pc.Uint8Array;
function LB(n) {
  var e = new n.constructor(n.byteLength);
  return new wk(e).set(new wk(n)), e;
}
function OB(n, e) {
  var t = LB(n.buffer);
  return new n.constructor(t, n.byteOffset, n.length);
}
function DB(n) {
  return typeof n.constructor == "function" && !a9(n) ? zR(m9(n)) : {};
}
function NB(n) {
  return function(e, t, r) {
    for (var i = -1, s = Object(e), o = r(e), a = o.length; a--; ) {
      var l = o[++i];
      if (t(s[l], l, s) === !1)
        break;
    }
    return e;
  };
}
var IB = NB(), eb = function() {
  return Pc.Date.now();
}, _B = "Expected a function", RB = Math.max, PB = Math.min;
function M1(n, e, t) {
  var r, i, s, o, a, l, c = 0, u = !1, h = !1, f = !0;
  if (typeof n != "function")
    throw new TypeError(_B);
  e = ck(e) || 0, Li(t) && (u = !!t.leading, h = "maxWait" in t, s = h ? RB(ck(t.maxWait) || 0, e) : s, f = "trailing" in t ? !!t.trailing : f);
  function m(O) {
    var R = r, F = i;
    return r = i = void 0, c = O, o = n.apply(F, R), o;
  }
  function y(O) {
    return c = O, a = setTimeout(x, e), u ? m(O) : o;
  }
  function b(O) {
    var R = O - l, F = O - c, H = e - R;
    return h ? PB(H, s - F) : H;
  }
  function k(O) {
    var R = O - l, F = O - c;
    return l === void 0 || R >= e || R < 0 || h && F >= s;
  }
  function x() {
    var O = eb();
    if (k(O))
      return M(O);
    a = setTimeout(x, b(O));
  }
  function M(O) {
    return a = void 0, f && r ? m(O) : (r = i = void 0, o);
  }
  function T() {
    a !== void 0 && clearTimeout(a), c = 0, r = l = i = a = void 0;
  }
  function E() {
    return a === void 0 ? o : M(eb());
  }
  function C() {
    var O = eb(), R = k(O);
    if (r = arguments, i = this, l = O, R) {
      if (a === void 0)
        return y(l);
      if (h)
        return clearTimeout(a), a = setTimeout(x, e), m(l);
    }
    return a === void 0 && (a = setTimeout(x, e)), o;
  }
  return C.cancel = T, C.flush = E, C;
}
function U2(n, e, t) {
  (t !== void 0 && !x1(n[e], t) || t === void 0 && !(e in n)) && mw(n, e, t);
}
function BB(n) {
  return Mh(n) && gw(n);
}
function K2(n, e) {
  if (!(e === "constructor" && typeof n[e] == "function") && e != "__proto__")
    return n[e];
}
function HB(n) {
  return QR(n, d9(n));
}
function zB(n, e, t, r, i, s, o) {
  var a = K2(n, t), l = K2(e, t), c = o.get(l);
  if (c) {
    U2(n, t, c);
    return;
  }
  var u = s ? s(a, l, t + "", n, e, o) : void 0, h = u === void 0;
  if (h) {
    var f = j2(l), m = !f && u9(l), y = !f && !m && f9(l);
    u = l, f || m || y ? j2(a) ? u = a : BB(a) ? u = FR(a) : m ? (h = !1, u = EB(l)) : y ? (h = !1, u = OB(l)) : u = [] : wB(l) || W2(l) ? (u = a, W2(a) ? u = HB(a) : (!Li(a) || dw(a)) && (u = DB(l))) : h = !1;
  }
  h && (o.set(l, u), i(u, l, r, s, o), o.delete(l)), U2(n, t, u);
}
function yw(n, e, t, r, i) {
  n !== e && IB(e, function(s, o) {
    if (i || (i = new Ah()), Li(s))
      zB(n, e, o, t, yw, r, i);
    else {
      var a = r ? r(K2(n, o), s, o + "", n, e, i) : void 0;
      a === void 0 && (a = s), U2(n, o, a);
    }
  }, d9);
}
function b9(n, e, t, r, i, s) {
  return Li(n) && Li(e) && (s.set(e, n), yw(n, e, void 0, b9, s), s.delete(e)), n;
}
var FB = rP(function(n, e, t, r) {
  yw(n, e, t, r);
}), VB = s9(function(n) {
  return n.push(void 0, b9), r9(FB, void 0, n);
}), qB = "Expected a function";
function T1(n, e, t) {
  var r = !0, i = !0;
  if (typeof n != "function")
    throw new TypeError(qB);
  return Li(t) && (r = "leading" in t ? !!t.leading : r, i = "trailing" in t ? !!t.trailing : i), M1(n, e, {
    leading: r,
    maxWait: e,
    trailing: i
  });
}
const $B = 1024;
let jB = 0, qi = class {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
};
class Mt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = jB++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Oi.match(e)), (t) => {
      let r = e(t);
      return r === void 0 ? null : [this, r];
    };
  }
}
Mt.closedBy = new Mt({ deserialize: (n) => n.split(" ") });
Mt.openedBy = new Mt({ deserialize: (n) => n.split(" ") });
Mt.group = new Mt({ deserialize: (n) => n.split(" ") });
Mt.isolate = new Mt({ deserialize: (n) => {
  if (n && n != "rtl" && n != "ltr" && n != "auto")
    throw new RangeError("Invalid value for isolate: " + n);
  return n || "auto";
} });
Mt.contextHash = new Mt({ perNode: !0 });
Mt.lookAhead = new Mt({ perNode: !0 });
Mt.mounted = new Mt({ perNode: !0 });
class Td {
  constructor(e, t, r) {
    this.tree = e, this.overlay = t, this.parser = r;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Mt.mounted.id];
  }
}
const WB = /* @__PURE__ */ Object.create(null);
let Oi = class v9 {
  /**
  @internal
  */
  constructor(e, t, r, i = 0) {
    this.name = e, this.props = t, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : WB, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new v9(e.name || "", t, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(Mt.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        t[i] = e[r];
    return (r) => {
      for (let i = r.prop(Mt.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = t[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
};
Oi.none = new Oi(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class bw {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      t.push(i ? new Oi(r.name, i, r.id, r.flags) : r);
    }
    return new bw(t);
  }
}
const Tp = /* @__PURE__ */ new WeakMap(), kk = /* @__PURE__ */ new WeakMap();
var xn;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(xn || (xn = {}));
class an {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, r, i, s) {
    if (this.type = e, this.children = t, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Td.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Tg(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, r = 0) {
    let i = Tp.get(this) || this.topNode, s = new Tg(i);
    return s.moveTo(e, t), Tp.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new wr(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let r = Ad(Tp.get(this) || this.topNode, e, t, !1);
    return Tp.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let r = Ad(kk.get(this) || this.topNode, e, t, !0);
    return kk.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, t = 0) {
    return GB(this, e, t);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & xn.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | xn.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= i && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : kw(Oi.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, r, i) => new an(this.type, t, r, i, this.propValues), e.makeTree || ((t, r, i) => new an(Oi.none, t, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return JB(e);
  }
}
an.empty = new an(Oi.none, [], [], 0);
class vw {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new vw(this.buffer, this.index);
  }
}
class el {
  /**
  Create a tree buffer.
  */
  constructor(e, t, r) {
    this.buffer = e, this.length = t, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return Oi.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[t], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, r, i, s) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != t && !(w9(s, i, o[l + 1], o[l + 2]) && (a = l, r > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, t, r) {
    let i = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let a = e, l = 0; a < t; ) {
      s[l++] = i[a++], s[l++] = i[a++] - r;
      let c = s[l++] = i[a++] - r;
      s[l++] = i[a++] - e, o = Math.max(o, c);
    }
    return new el(s, o, this.set);
  }
}
function w9(n, e, t, r) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return r >= e && t < e;
    case 0:
      return t < e && r > e;
    case 1:
      return t <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function Ad(n, e, t, r) {
  for (var i; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !r && n instanceof wr && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = r ? 0 : xn.IgnoreOverlays;
  if (r)
    for (let o = n, a = o.parent; a; o = a, a = o.parent)
      o instanceof wr && o.index < 0 && ((i = a.enter(e, t, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (n = a);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class k9 {
  cursor(e = 0) {
    return new Tg(this, e);
  }
  getChild(e, t = null, r = null) {
    let i = xk(this, e, t, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, r = null) {
    return xk(this, e, t, r);
  }
  resolve(e, t = 0) {
    return Ad(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Ad(this, e, t, !0);
  }
  matchContext(e) {
    return G2(this.parent, e);
  }
  enterUnfinishedNodesBefore(e) {
    let t = this.childBefore(e), r = this;
    for (; t; ) {
      let i = t.lastChild;
      if (!i || i.to != t.to)
        break;
      i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class wr extends k9 {
  constructor(e, t, r, i) {
    super(), this._tree = e, this.from = t, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = t > 0 ? a.length : -1; e != c; e += t) {
        let u = a[e], h = l[e] + o.from;
        if (w9(i, r, h, h + u.length)) {
          if (u instanceof el) {
            if (s & xn.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, t, r - h, i);
            if (f > -1)
              return new Gs(new UB(o, u, e, h), null, f);
          } else if (s & xn.IncludeAnonymous || !u.type.isAnonymous || ww(u)) {
            let f;
            if (!(s & xn.IgnoreMounts) && (f = Td.get(u)) && !f.overlay)
              return new wr(f.tree, h, e, o);
            let m = new wr(u, h, e, o);
            return s & xn.IncludeAnonymous || !m.type.isAnonymous ? m : m.nextChild(t < 0 ? u.children.length - 1 : 0, t, r, i);
          }
        }
      }
      if (s & xn.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    let i;
    if (!(r & xn.IgnoreOverlays) && (i = Td.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of i.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? a >= s : a > s))
          return new wr(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function xk(n, e, t, r) {
  let i = n.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (t != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(t), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function G2(n, e, t = e.length - 1) {
  for (let r = n; t >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[t] && e[t] != r.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class UB {
  constructor(e, t, r, i) {
    this.parent = e, this.buffer = t, this.index = r, this.start = i;
  }
}
class Gs extends k9 {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, r) {
    super(), this.context = e, this._parent = t, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, t, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, r);
    return s < 0 ? null : new Gs(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, r = 0) {
    if (r & xn.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new Gs(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Gs(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Gs(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), t.push(0);
    }
    return new an(this.type, e, t, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function x9(n) {
  if (!n.length)
    return null;
  let e = 0, t = n[0];
  for (let s = 1; s < n.length; s++) {
    let o = n[s];
    (o.from > t.from || o.to < t.to) && (t = o, e = s);
  }
  let r = t instanceof wr && t.index < 0 ? null : t.parent, i = n.slice();
  return r ? i[e] = r : i.splice(e, 1), new KB(i, t);
}
class KB {
  constructor(e, t) {
    this.heads = e, this.node = t;
  }
  get next() {
    return x9(this.heads);
  }
}
function GB(n, e, t) {
  let r = n.resolveInner(e, t), i = null;
  for (let s = r instanceof wr ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, t)), s = o;
    } else {
      let o = Td.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new wr(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(Ad(a, e, t, !1));
      }
    }
  return i ? x9(i) : r;
}
class Tg {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof wr)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof wr ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, r = this.mode) {
    return this.buffer ? r & xn.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & xn.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & xn.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (r < 0 ? t.buffer.length : t.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: r } = i);
    } else
      ({ index: t, _parent: r } = this._tree);
    for (; r; { index: t, _parent: r } = r)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let a = r._tree.children[s];
          if (this.mode & xn.IncludeAnonymous || a instanceof el || !a.type.isAnonymous || ww(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, r = 0;
    if (e && e.context == this.buffer)
      e: for (let i = this.index, s = this.stack.length; s >= 0; ) {
        for (let o = e; o; o = o._parent)
          if (o.index == i) {
            if (i == this.index)
              return o;
            t = o, r = s + 1;
            break e;
          }
        i = this.stack[--s];
      }
    for (let i = r; i < this.stack.length; i++)
      t = new Gs(this.buffer, t, this.stack[i]);
    return this.bufferNode = new Gs(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; ; ) {
        if (i && t && t(this), i = this.type.isAnonymous, !r)
          return;
        if (this.nextSibling())
          break;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given context—a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return G2(this.node.parent, e);
    let { buffer: t } = this.buffer, { types: r } = t.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return G2(this._tree, e, i);
      let o = r[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function ww(n) {
  return n.children.some((e) => e instanceof el || !e.type.isAnonymous || ww(e));
}
function JB(n) {
  var e;
  let { buffer: t, nodeSet: r, maxBufferLength: i = $B, reused: s = [], minRepeatType: o = r.types.length } = n, a = Array.isArray(t) ? new vw(t, t.length) : t, l = r.types, c = 0, u = 0;
  function h(C, O, R, F, H, z) {
    let { id: K, start: U, end: ae, size: ie } = a, he = u, Ie = c;
    for (; ie < 0; )
      if (a.next(), ie == -1) {
        let Re = s[K];
        R.push(Re), F.push(U - C);
        return;
      } else if (ie == -3) {
        c = K;
        return;
      } else if (ie == -4) {
        u = K;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${ie}`);
    let Oe = l[K], Ne, We, q = U - C;
    if (ae - U <= i && (We = k(a.pos - O, H))) {
      let Re = new Uint16Array(We.size - We.skip), J = a.pos - We.size, V = Re.length;
      for (; a.pos > J; )
        V = x(We.start, Re, V);
      Ne = new el(Re, ae - We.start, r), q = We.start - C;
    } else {
      let Re = a.pos - ie;
      a.next();
      let J = [], V = [], _t = K >= o ? K : -1, at = 0, mt = ae;
      for (; a.pos > Re; )
        _t >= 0 && a.id == _t && a.size >= 0 ? (a.end <= mt - i && (y(J, V, U, at, a.end, mt, _t, he, Ie), at = J.length, mt = a.end), a.next()) : z > 2500 ? f(U, Re, J, V) : h(U, Re, J, V, _t, z + 1);
      if (_t >= 0 && at > 0 && at < J.length && y(J, V, U, at, U, mt, _t, he, Ie), J.reverse(), V.reverse(), _t > -1 && at > 0) {
        let le = m(Oe, Ie);
        Ne = kw(Oe, J, V, 0, J.length, 0, ae - U, le, le);
      } else
        Ne = b(Oe, J, V, ae - U, he - ae, Ie);
    }
    R.push(Ne), F.push(q);
  }
  function f(C, O, R, F) {
    let H = [], z = 0, K = -1;
    for (; a.pos > O; ) {
      let { id: U, start: ae, end: ie, size: he } = a;
      if (he > 4)
        a.next();
      else {
        if (K > -1 && ae < K)
          break;
        K < 0 && (K = ie - i), H.push(U, ae, ie), z++, a.next();
      }
    }
    if (z) {
      let U = new Uint16Array(z * 4), ae = H[H.length - 2];
      for (let ie = H.length - 3, he = 0; ie >= 0; ie -= 3)
        U[he++] = H[ie], U[he++] = H[ie + 1] - ae, U[he++] = H[ie + 2] - ae, U[he++] = he;
      R.push(new el(U, H[2] - ae, r)), F.push(ae - C);
    }
  }
  function m(C, O) {
    return (R, F, H) => {
      let z = 0, K = R.length - 1, U, ae;
      if (K >= 0 && (U = R[K]) instanceof an) {
        if (!K && U.type == C && U.length == H)
          return U;
        (ae = U.prop(Mt.lookAhead)) && (z = F[K] + U.length + ae);
      }
      return b(C, R, F, H, z, O);
    };
  }
  function y(C, O, R, F, H, z, K, U, ae) {
    let ie = [], he = [];
    for (; C.length > F; )
      ie.push(C.pop()), he.push(O.pop() + R - H);
    C.push(b(r.types[K], ie, he, z - H, U - z, ae)), O.push(H - R);
  }
  function b(C, O, R, F, H, z, K) {
    if (z) {
      let U = [Mt.contextHash, z];
      K = K ? [U].concat(K) : [U];
    }
    if (H > 25) {
      let U = [Mt.lookAhead, H];
      K = K ? [U].concat(K) : [U];
    }
    return new an(C, O, R, F, K);
  }
  function k(C, O) {
    let R = a.fork(), F = 0, H = 0, z = 0, K = R.end - i, U = { size: 0, start: 0, skip: 0 };
    e: for (let ae = R.pos - C; R.pos > ae; ) {
      let ie = R.size;
      if (R.id == O && ie >= 0) {
        U.size = F, U.start = H, U.skip = z, z += 4, F += 4, R.next();
        continue;
      }
      let he = R.pos - ie;
      if (ie < 0 || he < ae || R.start < K)
        break;
      let Ie = R.id >= o ? 4 : 0, Oe = R.start;
      for (R.next(); R.pos > he; ) {
        if (R.size < 0)
          if (R.size == -3)
            Ie += 4;
          else
            break e;
        else R.id >= o && (Ie += 4);
        R.next();
      }
      H = Oe, F += ie, z += Ie;
    }
    return (O < 0 || F == C) && (U.size = F, U.start = H, U.skip = z), U.size > 4 ? U : void 0;
  }
  function x(C, O, R) {
    let { id: F, start: H, end: z, size: K } = a;
    if (a.next(), K >= 0 && F < o) {
      let U = R;
      if (K > 4) {
        let ae = a.pos - (K - 4);
        for (; a.pos > ae; )
          R = x(C, O, R);
      }
      O[--R] = U, O[--R] = z - C, O[--R] = H - C, O[--R] = F;
    } else K == -3 ? c = F : K == -4 && (u = F);
    return R;
  }
  let M = [], T = [];
  for (; a.pos > 0; )
    h(n.start || 0, n.bufferStart || 0, M, T, -1, 0);
  let E = (e = n.length) !== null && e !== void 0 ? e : M.length ? T[0] + M[0].length : 0;
  return new an(l[n.topID], M.reverse(), T.reverse(), E);
}
const Sk = /* @__PURE__ */ new WeakMap();
function Sm(n, e) {
  if (!n.isAnonymous || e instanceof el || e.type != n)
    return 1;
  let t = Sk.get(e);
  if (t == null) {
    t = 1;
    for (let r of e.children) {
      if (r.type != n || !(r instanceof an)) {
        t = 1;
        break;
      }
      t += Sm(n, r);
    }
    Sk.set(e, t);
  }
  return t;
}
function kw(n, e, t, r, i, s, o, a, l) {
  let c = 0;
  for (let y = r; y < i; y++)
    c += Sm(n, e[y]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function m(y, b, k, x, M) {
    for (let T = k; T < x; ) {
      let E = T, C = b[T], O = Sm(n, y[T]);
      for (T++; T < x; T++) {
        let R = Sm(n, y[T]);
        if (O + R >= u)
          break;
        O += R;
      }
      if (T == E + 1) {
        if (O > u) {
          let R = y[E];
          m(R.children, R.positions, 0, R.children.length, b[E] + M);
          continue;
        }
        h.push(y[E]);
      } else {
        let R = b[T - 1] + y[T - 1].length - C;
        h.push(kw(n, y, b, E, T, C, R, null, l));
      }
      f.push(C + M - s);
    }
  }
  return m(e, t, r, i, 0), (a || l)(h, f, o);
}
class Gce {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, r);
  }
  getBuffer(e, t) {
    let r = this.map.get(e);
    return r && r.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Gs ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof wr && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Gs ? this.getBuffer(e.context.buffer, e.index) : e instanceof wr ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class Xo {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, r, i, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], r = !1) {
    let i = [new Xo(0, e.length, e, 0, !1, r)];
    for (let s of t)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, r = 128) {
    if (!t.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < t.length ? t[a] : null, h = u ? u.fromA : 1e9;
      if (h - l >= r)
        for (; o && o.from < h; ) {
          let f = o;
          if (l >= f.from || h <= f.to || c) {
            let m = Math.max(f.from, l) - c, y = Math.min(f.to, h) - c;
            f = m >= y ? null : new Xo(m, y, f.tree, f.offset + c, a > 0, !!u);
          }
          if (f && i.push(f), o.to > h)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
let S9 = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, r) {
    return typeof e == "string" && (e = new YB(e)), r = r ? r.length ? r.map((i) => new qi(i.from, i.to)) : [new qi(0, 0)] : [new qi(0, e.length)], this.createParse(e, t || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, r) {
    let i = this.startParse(e, t, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class YB {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Yce(n) {
  return (e, t, r, i) => new ZB(e, n, t, r, i);
}
class Ck {
  constructor(e, t, r, i, s) {
    this.parser = e, this.parse = t, this.overlay = r, this.target = i, this.from = s;
  }
}
function Mk(n) {
  if (!n.length || n.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
}
class XB {
  constructor(e, t, r, i, s, o, a) {
    this.parser = e, this.predicate = t, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const J2 = new Mt({ perNode: !0 });
class ZB {
  constructor(e, t, r, i, s) {
    this.nest = t, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new an(r.type, r.children, r.positions, r.length, r.propValues.concat([[J2, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[Mt.mounted.id] = new Td(t, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new tH(this.fragments), t = null, r = null, i = new Tg(new wr(this.baseTree, this.ranges[0].from, 0, null), xn.IncludeAnonymous | xn.IgnoreMounts);
    e: for (let s, o; ; ) {
      let a = !0, l;
      if (this.stoppedAt != null && i.from >= this.stoppedAt)
        a = !1;
      else if (e.hasNode(i)) {
        if (t) {
          let c = t.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
          if (c)
            for (let u of c.mount.overlay) {
              let h = u.from + c.pos, f = u.to + c.pos;
              h >= i.from && f <= i.to && !t.ranges.some((m) => m.from < f && m.to > h) && t.ranges.push({ from: h, to: f });
            }
        }
        a = !1;
      } else if (r && (o = QB(r.ranges, i.from, i.to)))
        a = o != 2;
      else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
        i.tree || eH(i);
        let c = e.findMounts(i.from, s.parser);
        if (typeof s.overlay == "function")
          t = new XB(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, t);
        else {
          let u = Ek(this.ranges, s.overlay || (i.from < i.to ? [new qi(i.from, i.to)] : []));
          u.length && Mk(u), (u.length || !s.overlay) && this.inner.push(new Ck(s.parser, u.length ? s.parser.startParse(this.input, Lk(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((h) => new qi(h.from - i.from, h.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : a = !1;
        }
      } else if (t && (l = t.predicate(i)) && (l === !0 && (l = new qi(i.from, i.to)), l.from < l.to)) {
        let c = t.ranges.length - 1;
        c >= 0 && t.ranges[c].to == l.from ? t.ranges[c] = { from: t.ranges[c].from, to: l.to } : t.ranges.push(l);
      }
      if (a && i.firstChild())
        t && t.depth++, r && r.depth++;
      else
        for (; !i.nextSibling(); ) {
          if (!i.parent())
            break e;
          if (t && !--t.depth) {
            let c = Ek(this.ranges, t.ranges);
            c.length && (Mk(c), this.inner.splice(t.index, 0, new Ck(t.parser, t.parser.startParse(this.input, Lk(t.mounts, c), c), t.ranges.map((u) => new qi(u.from - t.start, u.to - t.start)), t.target, c[0].from))), t = t.prev;
          }
          r && !--r.depth && (r = r.prev);
        }
    }
  }
}
function QB(n, e, t) {
  for (let r of n) {
    if (r.from >= t)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= t ? 2 : 1;
  }
  return 0;
}
function Tk(n, e, t, r, i, s) {
  if (e < t) {
    let o = n.buffer[e + 1];
    r.push(n.slice(e, t, o)), i.push(o - s);
  }
}
function eH(n) {
  let { node: e } = n, t = [], r = e.context.buffer;
  do
    t.push(n.index), n.parent();
  while (!n.tree);
  let i = n.tree, s = i.children.indexOf(r), o = i.children[s], a = o.buffer, l = [s];
  function c(u, h, f, m, y, b) {
    let k = t[b], x = [], M = [];
    Tk(o, u, k, x, M, m);
    let T = a[k + 1], E = a[k + 2];
    l.push(x.length);
    let C = b ? c(k + 4, a[k + 3], o.set.types[a[k]], T, E - T, b - 1) : e.toTree();
    return x.push(C), M.push(T - m), Tk(o, a[k + 3], h, x, M, m), new an(f, x, M, y);
  }
  i.children[s] = c(0, a.length, Oi.none, 0, o.length, t.length - 1);
  for (let u of l) {
    let h = n.tree.children[u], f = n.tree.positions[u];
    n.yield(new wr(h, f + n.from, u, n._tree));
  }
}
class Ak {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(xn.IncludeAnonymous | xn.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, r = e - this.offset;
    for (; !this.done && t.from < r; )
      t.to >= e && t.enter(r, 1, xn.IgnoreOverlays | xn.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof an)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
class tH {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (t = r.tree.prop(J2)) !== null && t !== void 0 ? t : r.to, this.inner = new Ak(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(J2)) !== null && e !== void 0 ? e : t.to, this.inner = new Ak(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(Mt.mounted);
        if (o && o.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && i.push({
              frag: l,
              pos: s.from - l.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function Ek(n, e) {
  let t = null, r = e;
  for (let i = 1, s = 0; i < n.length; i++) {
    let o = n[i - 1].to, a = n[i].from;
    for (; s < r.length; s++) {
      let l = r[s];
      if (l.from >= a)
        break;
      l.to <= o || (t || (r = t = e.slice()), l.from < o ? (t[s] = new qi(l.from, o), l.to > a && t.splice(s + 1, 0, new qi(a, l.to))) : l.to > a ? t[s--] = new qi(a, l.to) : t.splice(s--, 1));
    }
  }
  return r;
}
function nH(n, e, t, r) {
  let i = 0, s = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let u = i == n.length ? 1e9 : o ? n[i].to : n[i].from, h = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
    if (o != a) {
      let f = Math.max(l, t), m = Math.min(u, h, r);
      f < m && c.push(new qi(f, m));
    }
    if (l = Math.min(u, h), l == 1e9)
      break;
    u == l && (o ? (o = !1, i++) : o = !0), h == l && (a ? (a = !1, s++) : a = !0);
  }
  return c;
}
function Lk(n, e) {
  let t = [];
  for (let { pos: r, mount: i, frag: s } of n) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), a = o + i.tree.length, l = Math.max(s.from, o), c = Math.min(s.to, a);
    if (i.overlay) {
      let u = i.overlay.map((f) => new qi(f.from + r, f.to + r)), h = nH(e, u, l, c);
      for (let f = 0, m = l; ; f++) {
        let y = f == h.length, b = y ? c : h[f].from;
        if (b > m && t.push(new Xo(m, b, i.tree, -o, s.from >= m || s.openStart, s.to <= b || s.openEnd)), y)
          break;
        m = h[f].to;
      }
    } else
      t.push(new Xo(l, c, i.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));
  }
  return t;
}
let Y2 = [], C9 = [];
(() => {
  let n = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
  for (let e = 0, t = 0; e < n.length; e++)
    (e % 2 ? C9 : Y2).push(t = t + n[e]);
})();
function rH(n) {
  if (n < 768) return !1;
  for (let e = 0, t = Y2.length; ; ) {
    let r = e + t >> 1;
    if (n < Y2[r]) t = r;
    else if (n >= C9[r]) e = r + 1;
    else return !0;
    if (e == t) return !1;
  }
}
function Ok(n) {
  return n >= 127462 && n <= 127487;
}
const Dk = 8205;
function iH(n, e, t = !0, r = !0) {
  return (t ? M9 : sH)(n, e, r);
}
function M9(n, e, t) {
  if (e == n.length) return e;
  e && T9(n.charCodeAt(e)) && A9(n.charCodeAt(e - 1)) && e--;
  let r = tb(n, e);
  for (e += Nk(r); e < n.length; ) {
    let i = tb(n, e);
    if (r == Dk || i == Dk || t && rH(i))
      e += Nk(i), r = i;
    else if (Ok(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && Ok(tb(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0) break;
      e += 2;
    } else
      break;
  }
  return e;
}
function sH(n, e, t) {
  for (; e > 0; ) {
    let r = M9(n, e - 2, t);
    if (r < e) return r;
    e--;
  }
  return 0;
}
function tb(n, e) {
  let t = n.charCodeAt(e);
  if (!A9(t) || e + 1 == n.length) return t;
  let r = n.charCodeAt(e + 1);
  return T9(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function T9(n) {
  return n >= 56320 && n < 57344;
}
function A9(n) {
  return n >= 55296 && n < 56320;
}
function Nk(n) {
  return n < 65536 ? 1 : 2;
}
class Bt {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, r) {
    [e, t] = sh(this, e, t);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), Cm.from(i, this.length - (t - e) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    [e, t] = sh(this, e, t);
    let r = [];
    return this.decompose(e, t, r, 0), Cm.from(r, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Qf(this), s = new Qf(e);
    for (let o = t, a = t; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (a += i.value.length, i.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Qf(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new E9(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new L9(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Bt.empty : e.length <= 32 ? new In(e) : Cm.from(In.split(e, []));
  }
}
class In extends Bt {
  constructor(e, t = oH(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = i + o.length;
      if ((t ? r : a) >= e)
        return new aH(i, a, r, o);
      i = a + 1, r++;
    }
  }
  decompose(e, t, r, i) {
    let s = e <= 0 && t >= this.length ? this : new In(Ik(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), a = Mm(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        r.push(new In(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        r.push(new In(a.slice(0, l)), new In(a.slice(l)));
      }
    } else
      r.push(s);
  }
  replace(e, t, r) {
    if (!(r instanceof In))
      return super.replace(e, t, r);
    [e, t] = sh(this, e, t);
    let i = Mm(this.text, Mm(r.text, Ik(this.text, 0, e)), t), s = this.length + r.length - (t - e);
    return i.length <= 32 ? new In(i, s) : Cm.from(In.split(i, []), s);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = sh(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > e && o && (i += r), e < l && t > s && (i += a.slice(Math.max(0, e - s), t - s)), s = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (t.push(new In(r, i)), r = [], i = -1);
    return i > -1 && t.push(new In(r, i)), t;
  }
}
let Cm = class tu extends Bt {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, t, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = i + o.length, l = r + o.lines - 1;
      if ((t ? l : a) >= e)
        return o.lineInner(e, t, r, i);
      i = a + 1, r = l + 1;
    }
  }
  decompose(e, t, r, i) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (e <= l && t >= o) {
        let c = i & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !c ? r.push(a) : a.decompose(e - o, t - o, r, c);
      }
      o = l + 1;
    }
  }
  replace(e, t, r) {
    if ([e, t] = sh(this, e, t), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], a = s + o.length;
        if (e >= s && t <= a) {
          let l = o.replace(e - s, t - s, r), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = l, new tu(u, this.length - (t - e) + r.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, t, r);
  }
  sliceString(e, t = this.length, r = `
`) {
    [e, t] = sh(this, e, t);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let a = this.children[s], l = o + a.length;
      o > e && s && (i += r), e < l && t > o && (i += a.sliceString(e - o, t - o, r)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof tu))
      return 0;
    let r = 0, [i, s, o, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, s += t) {
      if (i == o || s == a)
        return r;
      let l = this.children[i], c = e.children[s];
      if (l != c)
        return r + l.scanIdentical(c, t);
      r += l.length + 1;
    }
  }
  static from(e, t = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let m of e)
      r += m.lines;
    if (r < 32) {
      let m = [];
      for (let y of e)
        y.flatten(m);
      return new In(m, t);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, a = [], l = 0, c = -1, u = [];
    function h(m) {
      let y;
      if (m.lines > s && m instanceof tu)
        for (let b of m.children)
          h(b);
      else m.lines > o && (l > o || !l) ? (f(), a.push(m)) : m instanceof In && l && (y = u[u.length - 1]) instanceof In && m.lines + y.lines <= 32 ? (l += m.lines, c += m.length + 1, u[u.length - 1] = new In(y.text.concat(m.text), y.length + 1 + m.length)) : (l + m.lines > i && f(), l += m.lines, c += m.length + 1, u.push(m));
    }
    function f() {
      l != 0 && (a.push(u.length == 1 ? u[0] : tu.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let m of e)
      h(m);
    return f(), a.length == 1 ? a[0] : new tu(a, t);
  }
};
Bt.empty = /* @__PURE__ */ new In([""], 0);
function oH(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function Mm(n, e, t = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < n.length && i <= r; s++) {
    let a = n[s], l = i + a.length;
    l >= t && (l > r && (a = a.slice(0, r - i)), i < t && (a = a.slice(t - i)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), i = l + 1;
  }
  return e;
}
function Ik(n, e, t) {
  return Mm(n, [""], e, t);
}
class Qf {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof In ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, a = i instanceof In ? i.text.length : i.children.length;
      if (o == (t > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[r] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof In) {
        let l = i.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[r] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[r] += t) : (t < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof In ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class E9 {
  constructor(e, t, r) {
    this.value = "", this.done = !1, this.cursor = new Qf(e, t > r ? -1 : 1), this.pos = t > r ? e.length : 0, this.from = Math.min(t, r), this.to = Math.max(t, r);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let r = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= r ? i : t < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class L9 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: r, value: i } = this.inner.next(e);
    return t && this.afterBreak ? (this.value = "", this.afterBreak = !1) : t ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Bt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Qf.prototype[Symbol.iterator] = E9.prototype[Symbol.iterator] = L9.prototype[Symbol.iterator] = function() {
  return this;
});
class aH {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function sh(n, e, t) {
  return e = Math.max(0, Math.min(n.length, e)), [e, Math.max(e, Math.min(n.length, t))];
}
function fr(n, e, t = !0, r = !0) {
  return iH(n, e, t, r);
}
function lH(n) {
  return n >= 56320 && n < 57344;
}
function cH(n) {
  return n >= 55296 && n < 56320;
}
function Yr(n, e) {
  let t = n.charCodeAt(e);
  if (!cH(t) || e + 1 == n.length)
    return t;
  let r = n.charCodeAt(e + 1);
  return lH(r) ? (t - 55296 << 10) + (r - 56320) + 65536 : t;
}
function xw(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function Ws(n) {
  return n < 65536 ? 1 : 2;
}
const X2 = /\r\n?|\n/;
var hr = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(hr || (hr = {}));
class Qs {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t + 1];
      e += r < 0 ? this.sections[t] : r;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, r = 0, i = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    Z2(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new Qs(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : O9(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `this` happened before the ones in `other`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : Q2(this, e, t);
  }
  mapPos(e, t = -1, r = hr.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = i + a;
      if (l < 0) {
        if (c > e)
          return s + (e - i);
        s += a;
      } else {
        if (r != hr.Simple && c >= e && (r == hr.TrackDel && i < e && c > e || r == hr.TrackBefore && i < e || r == hr.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !a)
          return e == i || t < 0 ? s : s + l;
        s += l;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= t; ) {
      let s = this.sections[r++], o = this.sections[r++], a = i + s;
      if (o >= 0 && i <= t && a >= e)
        return i < e && a > t ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let r = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Qs(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Qs(e);
  }
}
class Jn extends Qs {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Z2(this, (t, r, i, s, o) => e = e.replace(i, i + (r - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return Q2(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < t.length; i += 2) {
      let o = t[i], a = t[i + 1];
      if (a >= 0) {
        t[i] = a, t[i + 1] = o;
        let l = i >> 1;
        for (; r.length < l; )
          r.push(Bt.empty);
        r.push(o ? e.slice(s, s + o) : Bt.empty);
      }
      s += o;
    }
    return new Jn(t, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : O9(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : Q2(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    Z2(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Qs.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], r = [], i = [], s = new Ed(this);
    e: for (let o = 0, a = 0; ; ) {
      let l = o == e.length ? 1e9 : e[o++];
      for (; a < l || a == l && s.len == 0; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, l - a);
        yr(i, u, -1);
        let h = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
        yr(t, u, h), h > 0 && qa(r, t, s.text), s.forward(u), a += u;
      }
      let c = e[o++];
      for (; a < c; ) {
        if (s.done)
          break e;
        let u = Math.min(s.len, c - a);
        yr(t, u, -1), yr(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;
      }
    }
    return {
      changes: new Jn(t, r),
      filtered: Qs.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let r = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, r) {
    let i = [], s = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !i.length)
        return;
      o < t && yr(i, t - o, -1);
      let h = new Jn(i, s);
      a = a ? a.compose(h.map(a)) : h, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let h of u)
          c(h);
      else if (u instanceof Jn) {
        if (u.length != t)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${t})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: h, to: f = h, insert: m } = u;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let y = m ? typeof m == "string" ? Bt.of(m.split(r || X2)) : m : Bt.empty, b = y.length;
        if (h == f && b == 0)
          return;
        h < o && l(), h > o && yr(i, h - o, -1), yr(i, f - h, b), qa(s, i, y), o = f;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Jn(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(Bt.empty);
          r[i] = Bt.of(s.slice(1)), t.push(s[0], r[i].length);
        }
      }
    }
    return new Jn(t, r);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Jn(e, t);
  }
}
function yr(n, e, t, r = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = n.length - 2;
  i >= 0 && t <= 0 && t == n[i + 1] ? n[i] += e : i >= 0 && e == 0 && n[i] == 0 ? n[i + 1] += t : r ? (n[i] += e, n[i + 1] += t) : n.push(e, t);
}
function qa(n, e, t) {
  if (t.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < r; )
      n.push(Bt.empty);
    n.push(t);
  }
}
function Z2(n, e, t) {
  let r = n.inserted;
  for (let i = 0, s = 0, o = 0; o < n.sections.length; ) {
    let a = n.sections[o++], l = n.sections[o++];
    if (l < 0)
      i += a, s += a;
    else {
      let c = i, u = s, h = Bt.empty;
      for (; c += a, u += l, l && r && (h = h.append(r[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        a = n.sections[o++], l = n.sections[o++];
      e(i, c, s, u, h), i = c, s = u;
    }
  }
}
function Q2(n, e, t, r = !1) {
  let i = [], s = r ? [] : null, o = new Ed(n), a = new Ed(e);
  for (let l = -1; ; ) {
    if (o.done && a.len || a.done && o.len)
      throw new Error("Mismatched change set lengths");
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      yr(i, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !t))) {
      let c = a.len;
      for (yr(i, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (yr(i, 0, o.ins), s && qa(s, i, o.text), l = o.i), o.forward(u), c -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let h = Math.min(u, a.len);
          c += h, u -= h, a.forward(h);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      yr(i, c, l < o.i ? o.ins : 0), s && l < o.i && qa(s, i, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return s ? Jn.createSet(i, s) : Qs.create(i);
      throw new Error("Mismatched change set lengths");
    }
  }
}
function O9(n, e, t = !1) {
  let r = [], i = t ? [] : null, s = new Ed(n), o = new Ed(e);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return i ? Jn.createSet(r, i) : Qs.create(r);
    if (s.ins == 0)
      yr(r, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      yr(r, 0, o.ins, a), i && qa(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), c = r.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          yr(r, l, u, a), i && u && qa(i, r, o.text);
        } else o.ins == -1 ? (yr(r, s.off ? 0 : s.len, l, a), i && qa(i, r, s.textBit(l))) : (yr(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), i && !o.off && qa(i, r, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > c), s.forward2(l), o.forward(l);
      }
    }
  }
}
class Ed {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Bt.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, r = this.i - 2 >> 1;
    return r >= t.length && !e ? Bt.empty : t[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
let Ap = class ev {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.flags = r;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, t) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new ev(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return ce.range(e, t);
    let r = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return ce.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(e, t = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!t || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ce.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new ev(e, t, r);
  }
};
class ce {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : ce.create(this.ranges.map((r) => r.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, t = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(e.ranges[r], t))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ce([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return ce.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let r = this.ranges.slice();
    return r[t] = e, ce.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ce(e.ranges.map((t) => Ap.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new ce([ce.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return ce.normalized(e.slice(), t);
      r = s.to;
    }
    return new ce(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, r, i) {
    return Ap.create(e, e, (t == 0 ? 0 : t < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, t, r, i) {
    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return t < e ? Ap.create(t, e, 48 | s) : Ap.create(e, t, (t > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let r = e[t];
    e.sort((i, s) => i.from - s.from), t = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        i <= t && t--, e.splice(--i, 2, s.anchor > s.head ? ce.range(l, a) : ce.range(a, l));
      }
    }
    return new ce(e, t);
  }
}
function D9(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Sw = 0;
class ze {
  constructor(e, t, r, i, s) {
    this.combine = e, this.compareInput = t, this.compare = r, this.isStatic = i, this.id = Sw++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new ze(e.combine || ((t) => t), e.compareInput || ((t, r) => t === r), e.compare || (e.combine ? (t, r) => t === r : Cw), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Tm([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Tm(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Tm(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (r) => r), this.compute([e], (r) => t(r.field(e)));
  }
}
function Cw(n, e) {
  return n == e || n.length == e.length && n.every((t, r) => t === e[r]);
}
class Tm {
  constructor(e, t, r, i) {
    this.dependencies = e, this.facet = t, this.type = r, this.value = i, this.id = Sw++;
  }
  dynamicSlot(e) {
    var t;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? c = !0 : (((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && u.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = r(h), 1;
      },
      update(h, f) {
        if (l && f.docChanged || c && (f.docChanged || f.selection) || tv(h, u)) {
          let m = r(h);
          if (a ? !_k(m, h.values[o], i) : !i(m, h.values[o]))
            return h.values[o] = m, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let m, y = f.config.address[s];
        if (y != null) {
          let b = Ag(f, y);
          if (this.dependencies.every((k) => k instanceof ze ? f.facet(k) === h.facet(k) : k instanceof rr ? f.field(k, !1) == h.field(k, !1) : !0) || (a ? _k(m = r(h), b, i) : i(m = r(h), b)))
            return h.values[o] = b, 0;
        } else
          m = r(h);
        return h.values[o] = m, 1;
      }
    };
  }
}
function _k(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let r = 0; r < n.length; r++)
    if (!t(n[r], e[r]))
      return !1;
  return !0;
}
function tv(n, e) {
  let t = !1;
  for (let r of e)
    ed(n, r) & 1 && (t = !0);
  return t;
}
function uH(n, e, t) {
  let r = t.map((l) => n[l.id]), i = t.map((l) => l.type), s = r.filter((l) => !(l & 1)), o = n[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < r.length; u++) {
      let h = Ag(l, r[u]);
      if (i[u] == 2)
        for (let f of h)
          c.push(f);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of r)
        ed(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!tv(l, s))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, c) {
      let u = tv(l, r), h = c.config.facets[e.id], f = c.facet(e);
      if (h && !u && Cw(t, h))
        return l.values[o] = f, 0;
      let m = a(l);
      return e.compare(m, f) ? (l.values[o] = f, 0) : (l.values[o] = m, 1);
    }
  };
}
const Ep = /* @__PURE__ */ ze.define({ static: !0 });
class rr {
  constructor(e, t, r, i, s) {
    this.id = e, this.createF = t, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new rr(Sw++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Ep).find((r) => r.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (r) => (r.values[t] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[t], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[t] = o, 1);
      },
      reconfigure: (r, i) => {
        let s = r.facet(Ep), o = i.facet(Ep), a;
        return (a = s.find((l) => l.field == this)) && a != o.find((l) => l.field == this) ? (r.values[t] = a.create(r), 1) : i.config.address[this.id] != null ? (r.values[t] = i.field(this), 0) : (r.values[t] = this.create(r), 1);
      }
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Ep.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const $l = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Zh(n) {
  return (e) => new N9(e, n);
}
const fl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ Zh($l.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ Zh($l.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ Zh($l.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ Zh($l.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ Zh($l.lowest)
};
class N9 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class oh {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new nv(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return oh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class nv {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
let Rk = class I9 {
  constructor(e, t, r, i, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of hH(e, t, o))
      f instanceof rr ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let f of i)
      a[f.id] = c.length << 1, c.push((m) => f.slot(m));
    let u = r == null ? void 0 : r.config.facets;
    for (let f in s) {
      let m = s[f], y = m[0].facet, b = u && u[f] || [];
      if (m.every(
        (k) => k.type == 0
        /* Provider.Static */
      ))
        if (a[y.id] = l.length << 1 | 1, Cw(b, m))
          l.push(r.facet(y));
        else {
          let k = y.combine(m.map((x) => x.value));
          l.push(r && y.compare(k, r.facet(y)) ? r.facet(y) : k);
        }
      else {
        for (let k of m)
          k.type == 0 ? (a[k.id] = l.length << 1 | 1, l.push(k.value)) : (a[k.id] = c.length << 1, c.push((x) => k.dynamicSlot(x)));
        a[y.id] = c.length << 1, c.push((k) => uH(k, y, m));
      }
    }
    let h = c.map((f) => f(a));
    return new I9(e, o, h, a, l, s);
  }
};
function hH(n, e, t) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = i.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = r[l].indexOf(o);
      c > -1 && r[l].splice(c, 1), o instanceof nv && t.delete(o.compartment);
    }
    if (i.set(o, a), Array.isArray(o))
      for (let c of o)
        s(c, a);
    else if (o instanceof nv) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, a);
    } else if (o instanceof N9)
      s(o.inner, o.prec);
    else if (o instanceof rr)
      r[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof Tm)
      r[a].push(o), o.facet.extensions && s(o.facet.extensions, $l.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, a);
    }
  }
  return s(n, $l.default), r.reduce((o, a) => o.concat(a));
}
function ed(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, r = n.status[t];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  n.status[t] = 4;
  let i = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | i;
}
function Ag(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const _9 = /* @__PURE__ */ ze.define(), rv = /* @__PURE__ */ ze.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), R9 = /* @__PURE__ */ ze.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), P9 = /* @__PURE__ */ ze.define(), B9 = /* @__PURE__ */ ze.define(), H9 = /* @__PURE__ */ ze.define(), z9 = /* @__PURE__ */ ze.define({
  combine: (n) => n.length ? n[0] : !1
});
class fa {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new fH();
  }
}
class fH {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new fa(this, e);
  }
}
class dH {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new pt(this, e);
  }
}
class pt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new pt(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new dH(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(t);
      s && r.push(s);
    }
    return r;
  }
}
pt.reconfigure = /* @__PURE__ */ pt.define();
pt.appendConfig = /* @__PURE__ */ pt.define();
let Nr = class mf {
  constructor(e, t, r, i, s, o) {
    this.startState = e, this.changes = t, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && D9(r, t.newLength), s.some((a) => a.type == mf.time) || (this.annotations = s.concat(mf.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, r, i, s, o) {
    return new mf(e, t, r, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(mf.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
};
Nr.time = /* @__PURE__ */ fa.define();
Nr.userEvent = /* @__PURE__ */ fa.define();
Nr.addToHistory = /* @__PURE__ */ fa.define();
Nr.remote = /* @__PURE__ */ fa.define();
function pH(n, e) {
  let t = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < n.length && (i == e.length || e[i] >= n[r]))
      s = n[r++], o = n[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function F9(n, e, t) {
  var r;
  let i, s, o;
  return t ? (i = e.changes, s = Jn.empty(e.changes.length), o = n.changes.compose(e.changes)) : (i = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = n.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: pt.mapEffects(n.effects, i).concat(pt.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function iv(n, e, t) {
  let r = e.selection, i = vu(e.annotations);
  return e.userEvent && (i = i.concat(Nr.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Jn ? e.changes : Jn.of(e.changes || [], t, n.facet(R9)),
    selection: r && (r instanceof ce ? r : ce.single(r.anchor, r.head)),
    effects: vu(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function V9(n, e, t) {
  let r = iv(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    r = F9(r, iv(n, e[s], o ? r.changes.newLength : n.doc.length), o);
  }
  let i = Nr.create(n, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return gH(t ? mH(i) : i);
}
function mH(n) {
  let e = n.startState, t = !0;
  for (let i of e.facet(P9)) {
    let s = i(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : pH(t, s));
  }
  if (t !== !0) {
    let i, s;
    if (t === !1)
      s = n.changes.invertedDesc, i = Jn.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = Nr.create(e, i, n.selection && n.selection.map(s), pt.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let r = e.facet(B9);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](n);
    s instanceof Nr ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Nr ? n = s[0] : n = V9(e, vu(s), !1);
  }
  return n;
}
function gH(n) {
  let e = n.startState, t = e.facet(H9), r = n;
  for (let i = t.length - 1; i >= 0; i--) {
    let s = t[i](n);
    s && Object.keys(s).length && (r = F9(r, iv(e, s, n.changes.newLength), !0));
  }
  return r == n ? n : Nr.create(e, n.changes, n.selection, r.effects, r.annotations, r.scrollIntoView);
}
const yH = [];
function vu(n) {
  return n == null ? yH : Array.isArray(n) ? n : [n];
}
var yn = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(yn || (yn = {}));
const bH = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let sv;
try {
  sv = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function vH(n) {
  if (sv)
    return sv.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || bH.test(t)))
      return !0;
  }
  return !1;
}
function wH(n) {
  return (e) => {
    if (!/\S/.test(e))
      return yn.Space;
    if (vH(e))
      return yn.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return yn.Word;
    return yn.Other;
  };
}
let bn = class us {
  constructor(e, t, r, i, s, o) {
    this.config = e, this.doc = t, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      ed(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return ed(this, r), Ag(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return V9(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: r, compartments: i } = t;
    for (let a of e.effects)
      a.is(oh.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((l, c) => i.set(c, l)), t = null), i.set(a.value.compartment, a.value.extension)) : a.is(pt.reconfigure) ? (t = null, r = a.value) : a.is(pt.appendConfig) && (t = null, r = vu(r).concat(a.value));
    let s;
    t ? s = e.startState.values.slice() : (t = Rk.resolve(r, i, this), s = new us(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(rv) ? e.newSelection : e.newSelection.asSingle();
    new us(t, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: ce.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, r = e(t.ranges[0]), i = this.changes(r.changes), s = [r.range], o = vu(r.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), c = this.changes(l.changes), u = c.map(i);
      for (let f = 0; f < a; f++)
        s[f] = s[f].map(u);
      let h = i.mapDesc(c, !0);
      s.push(l.range.map(h)), i = i.compose(u), o = pt.mapEffects(o, u).concat(pt.mapEffects(vu(l.effects), h));
    }
    return {
      changes: i,
      selection: ce.create(s, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Jn ? e : Jn.of(e, this.doc.length, this.facet(us.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Bt.of(e.split(this.facet(us.lineSeparator) || X2));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (ed(this, t), Ag(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof rr && this.config.address[i.id] != null && (t[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], a = e[s];
          i.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return us.create({
      doc: e.doc,
      selection: ce.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Rk.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof Bt ? e.doc : Bt.of((e.doc || "").split(t.staticFacet(us.lineSeparator) || X2)), i = e.selection ? e.selection instanceof ce ? e.selection : ce.single(e.selection.anchor, e.selection.head) : ce.single(0);
    return D9(i, r.length), t.staticFacet(rv) || (i = i.asSingle()), new us(t, r, i, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(us.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(us.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(z9);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let r of this.facet(us.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > t.length ? r : t[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, r = -1) {
    let i = [];
    for (let s of this.facet(_9))
      for (let o of s(this, t, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return wH(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, a = e - r;
    for (; o > 0; ) {
      let l = fr(t, o, !1);
      if (s(t.slice(l, o)) != yn.Word)
        break;
      o = l;
    }
    for (; a < i; ) {
      let l = fr(t, a);
      if (s(t.slice(a, l)) != yn.Word)
        break;
      a = l;
    }
    return o == a ? null : ce.range(o + r, a + r);
  }
};
bn.allowMultipleSelections = rv;
bn.tabSize = /* @__PURE__ */ ze.define({
  combine: (n) => n.length ? n[0] : 4
});
bn.lineSeparator = R9;
bn.readOnly = z9;
bn.phrases = /* @__PURE__ */ ze.define({
  compare(n, e) {
    let t = Object.keys(n), r = Object.keys(e);
    return t.length == r.length && t.every((i) => n[i] == e[i]);
  }
});
bn.languageData = _9;
bn.changeFilter = P9;
bn.transactionFilter = B9;
bn.transactionExtender = H9;
oh.reconfigure = /* @__PURE__ */ pt.define();
function lo(n, e, t = {}) {
  let r = {};
  for (let i of n)
    for (let s of Object.keys(i)) {
      let o = i[s], a = r[s];
      if (a === void 0)
        r[s] = o;
      else if (!(a === o || o === void 0)) if (Object.hasOwnProperty.call(t, s))
        r[s] = t[s](a, o);
      else
        throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class xc {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Ld.create(e, t, this);
  }
}
xc.prototype.startSide = xc.prototype.endSide = 0;
xc.prototype.point = !1;
xc.prototype.mapMode = hr.TrackDel;
class Ld {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.value = r;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Ld(e, t, r);
  }
}
function ov(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class Mw {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = s[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, t, r, i) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let r = [], i = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, h = this.to[l] + e, f, m;
      if (u == h) {
        let y = t.mapPos(u, c.startSide, c.mapMode);
        if (y == null || (f = m = y, c.startSide != c.endSide && (m = t.mapPos(u, c.endSide), m < f)))
          continue;
      } else if (f = t.mapPos(u, c.startSide), m = t.mapPos(h, c.endSide), f > m || f == m && c.startSide > 0 && c.endSide <= 0)
        continue;
      (m - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (a = Math.max(a, m - f)), r.push(c), i.push(f - o), s.push(m - o));
    }
    return { mapped: r.length ? new Mw(i, s, r, a) : null, pos: o };
  }
}
class Ht {
  constructor(e, t, r, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, r, i) {
    return new Ht(e, t, r, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (r && (t = t.slice().sort(ov)), this.isEmpty)
      return t.length ? Ht.of(t) : this;
    let a = new q9(this, null, -1).goto(0), l = 0, c = [], u = new ra();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let h = t[l++];
        u.addInner(h.from, h.to, h.value) || c.push(h);
      } else a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(Ld.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? Ht.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        i = Math.max(i, l.maxPoint), t.push(l), r.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: h } = l.map(a, e);
        u && (i = Math.max(i, u.maxPoint), t.push(u), r.push(h));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new Ht(r, t, s || Ht.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, t, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Od.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Od.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, r, i, s = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), a = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= s), l = Pk(o, a, r), c = new Qh(o, l, s), u = new Qh(a, l, s);
    r.iterGaps((h, f, m) => Bk(c, h, u, f, m, i)), r.empty && r.length == 0 && Bk(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, r = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && t.indexOf(u) < 0), o = t.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = Pk(s, o), l = new Qh(s, a, 0).goto(r), c = new Qh(o, a, 0).goto(r);
    for (; ; ) {
      if (l.to != c.to || !av(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, r, i, s = -1) {
    let o = new Qh(e, null, s).goto(t), a = t, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let u = o.activeForPoint(o.to), h = o.pointFrom < t ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
        i.point(a, c, o.point, u, h, o.pointRank), l = Math.min(o.openEnd(c), u.length);
      } else c > a && (i.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > r)
        return l + (o.point && o.to > r ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let r = new ra();
    for (let i of e instanceof Ld ? [e] : t ? kH(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return Ht.empty;
    let t = e[e.length - 1];
    for (let r = e.length - 2; r >= 0; r--)
      for (let i = e[r]; i != Ht.empty; i = i.nextLayer)
        t = new Ht(i.chunkPos, i.chunk, t, Math.max(i.maxPoint, t.maxPoint));
    return t;
  }
}
Ht.empty = /* @__PURE__ */ new Ht([], [], null, -1);
function kH(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let r = n[t];
      if (ov(e, r) > 0)
        return n.slice().sort(ov);
      e = r;
    }
  return n;
}
Ht.empty.nextLayer = Ht.empty;
class ra {
  finishChunk(e) {
    this.chunks.push(new Mw(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, r) {
    this.addInner(e, t, r) || (this.nextLayer || (this.nextLayer = new ra())).add(e, t, r);
  }
  /**
  @internal
  */
  addInner(e, t, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = t, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let r = t.value.length - 1;
    return this.last = t.value[r], this.lastFrom = t.from[r] + e, this.lastTo = t.to[r] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Ht.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Ht.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function Pk(n, e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = r.get(s.chunk[o]);
      a != null && (t ? t.mapPos(a) : a) == s.chunkPos[o] && !(t != null && t.touchesRange(a, a + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class q9 {
  constructor(e, t, r, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], r = e + t.from[this.rangeIndex];
        if (this.from = r, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Od {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new q9(o, t, r, s));
    return i.length == 1 ? i[0] : new Od(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let r of this.heap)
      r.goto(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      nb(this.heap, r);
    return this.next(), this;
  }
  forward(e, t) {
    for (let r of this.heap)
      r.forward(e, t);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      nb(this.heap, r);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), nb(this.heap, 0);
    }
  }
}
function nb(n, e) {
  for (let t = n[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= n.length)
      break;
    let i = n[r];
    if (r + 1 < n.length && i.compare(n[r + 1]) >= 0 && (i = n[r + 1], r++), t.compare(i) < 0)
      break;
    n[r] = t, n[e] = i, e = r;
  }
}
class Qh {
  constructor(e, t, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Od.from(e, t, r);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Lp(this.active, e), Lp(this.activeTo, e), Lp(this.activeRank, e), this.minActive = Hk(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; t < this.activeRank.length && (s - this.activeRank[t] || i - this.activeTo[t]) > 0; )
      t++;
    Op(this.active, t, r), Op(this.activeTo, t, i), Op(this.activeRank, t, s), e && Op(e, t, this.cursor.from), this.minActive = Hk(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && Lp(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && t.push(this.active[r]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      t++;
    return t;
  }
}
function Bk(n, e, t, r, i, s) {
  n.goto(e), t.goto(r);
  let o = r + i, a = r, l = r - e;
  for (; ; ) {
    let c = n.to + l - t.to, u = c || n.endSide - t.endSide, h = u < 0 ? n.to + l : t.to, f = Math.min(h, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && av(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(a, f, n.point, t.point) : f > a && !av(n.active, t.active) && s.compareRange(a, f, n.active, t.active), h > o)
      break;
    (c || n.openEnd != t.openEnd) && s.boundChange && s.boundChange(h), a = h, u <= 0 && n.next(), u >= 0 && t.next();
  }
}
function av(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function Lp(n, e) {
  for (let t = e, r = n.length - 1; t < r; t++)
    n[t] = n[t + 1];
  n.pop();
}
function Op(n, e, t) {
  for (let r = n.length - 1; r >= e; r--)
    n[r + 1] = n[r];
  n[e] = t;
}
function Hk(n, e) {
  let t = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || n[i].endSide - n[t].endSide) < 0 && (t = i, r = e[i]);
  return t;
}
function Eh(n, e, t = n.length) {
  let r = 0;
  for (let i = 0; i < t && i < n.length; )
    n.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = fr(n, i));
  return r;
}
function lv(n, e, t, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == n.length)
      break;
    s += n.charCodeAt(i) == 9 ? t - s % t : 1, i = fr(n, i);
  }
  return r === !0 ? -1 : n.length;
}
const cv = "ͼ", zk = typeof Symbol > "u" ? "__" + cv : Symbol.for(cv), uv = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Fk = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class tl {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: r } = t || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let u = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && a == null) return l.push(o[0] + ";");
      for (let m in a) {
        let y = a[m];
        if (/&/.test(m))
          s(
            m.split(/,\s*/).map((b) => o.map((k) => b.replace(/&/, k))).reduce((b, k) => b.concat(k)),
            y,
            l
          );
        else if (y && typeof y == "object") {
          if (!h) throw new RangeError("The value of a property (" + m + ") should be a primitive value.");
          s(i(m), y, u, f);
        } else y != null && u.push(m.replace(/_.*/, "").replace(/[A-Z]/g, (b) => "-" + b.toLowerCase()) + ": " + y + ";");
      }
      (u.length || f) && l.push((r && !h && !c ? o.map(r) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e) s(i(o), e[o], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Fk[zk] || 1;
    return Fk[zk] = e + 1, cv + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, t, r) {
    let i = e[uv], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new xH(e, s), i.mount(Array.isArray(t) ? t : [t], e);
  }
}
let Vk = /* @__PURE__ */ new Map();
class xH {
  constructor(e, t) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = Vk.get(r);
      if (s) return e[uv] = s;
      this.sheet = new i.CSSStyleSheet(), Vk.set(r, this);
    } else
      this.styleTag = r.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
    this.modules = [], e[uv] = this;
  }
  mount(e, t) {
    let r = this.sheet, i = 0, s = 0;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = this.modules.indexOf(a);
      if (l < s && l > -1 && (this.modules.splice(l, 1), s--, l = -1), l == -1) {
        if (this.modules.splice(s++, 0, a), r) for (let c = 0; c < a.rules.length; c++)
          r.insertRule(a.rules[c], i++);
      } else {
        for (; s < l; ) i += this.modules[s++].rules.length;
        i += a.rules.length, s++;
      }
    }
    if (r)
      t.adoptedStyleSheets.indexOf(this.sheet) < 0 && (t.adoptedStyleSheets = [this.sheet, ...t.adoptedStyleSheets]);
    else {
      let o = "";
      for (let l = 0; l < this.modules.length; l++)
        o += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = o;
      let a = t.head || t;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var ia = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Dd = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, SH = typeof navigator < "u" && /Mac/.test(navigator.platform), CH = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var cr = 0; cr < 10; cr++) ia[48 + cr] = ia[96 + cr] = String(cr);
for (var cr = 1; cr <= 24; cr++) ia[cr + 111] = "F" + cr;
for (var cr = 65; cr <= 90; cr++)
  ia[cr] = String.fromCharCode(cr + 32), Dd[cr] = String.fromCharCode(cr);
for (var rb in ia) Dd.hasOwnProperty(rb) || (Dd[rb] = ia[rb]);
function $9(n) {
  var e = SH && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || CH && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? Dd : ia)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Xt() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) {
      var i = t[r];
      typeof i == "string" ? n.setAttribute(r, i) : i != null && (n[r] = i);
    }
    e++;
  }
  for (; e < arguments.length; e++) j9(n, arguments[e]);
  return n;
}
function j9(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null) if (e.nodeType != null)
    n.appendChild(e);
  else if (Array.isArray(e))
    for (var t = 0; t < e.length; t++) j9(n, e[t]);
  else
    throw new RangeError("Unsupported child node: " + e);
}
function Nd(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function hv(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Am(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return hv(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function Id(n) {
  return n.nodeType == 3 ? Cc(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function td(n, e, t, r) {
  return t ? qk(n, e, t, r, -1) || qk(n, e, t, r, 1) : !1;
}
function Sc(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function Eg(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
function qk(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : ro(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Sc(n) + (i < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = i < 0 ? ro(n) : 0;
    } else
      return !1;
  }
}
function ro(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function A1(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function MH(n) {
  let e = n.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function W9(n, e) {
  let t = e.width / n.offsetWidth, r = e.height / n.offsetHeight;
  return (t > 0.995 && t < 1.005 || !isFinite(t) || Math.abs(e.width - n.offsetWidth) < 1) && (t = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - n.offsetHeight) < 1) && (r = 1), { scaleX: t, scaleY: r };
}
function TH(n, e, t, r, i, s, o, a) {
  let l = n.ownerDocument, c = l.defaultView || window;
  for (let u = n, h = !1; u && !h; )
    if (u.nodeType == 1) {
      let f, m = u == l.body, y = 1, b = 1;
      if (m)
        f = MH(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (h = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let M = u.getBoundingClientRect();
        ({ scaleX: y, scaleY: b } = W9(u, M)), f = {
          left: M.left,
          right: M.left + u.clientWidth * y,
          top: M.top,
          bottom: M.top + u.clientHeight * b
        };
      }
      let k = 0, x = 0;
      if (i == "nearest")
        e.top < f.top ? (x = e.top - (f.top + o), t > 0 && e.bottom > f.bottom + x && (x = e.bottom - f.bottom + o)) : e.bottom > f.bottom && (x = e.bottom - f.bottom + o, t < 0 && e.top - x < f.top && (x = e.top - (f.top + o)));
      else {
        let M = e.bottom - e.top, T = f.bottom - f.top;
        x = (i == "center" && M <= T ? e.top + M / 2 - T / 2 : i == "start" || i == "center" && t < 0 ? e.top - o : e.bottom - T + o) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (k = e.left - (f.left + s), t > 0 && e.right > f.right + k && (k = e.right - f.right + s)) : e.right > f.right && (k = e.right - f.right + s, t < 0 && e.left < f.left + k && (k = e.left - (f.left + s))) : k = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == a ? e.left - s : e.right - (f.right - f.left) + s) - f.left, k || x)
        if (m)
          c.scrollBy(k, x);
        else {
          let M = 0, T = 0;
          if (x) {
            let E = u.scrollTop;
            u.scrollTop += x / b, T = (u.scrollTop - E) * b;
          }
          if (k) {
            let E = u.scrollLeft;
            u.scrollLeft += k / y, M = (u.scrollLeft - E) * y;
          }
          e = {
            left: e.left - M,
            top: e.top - T,
            right: e.right - M,
            bottom: e.bottom - T
          }, M && Math.abs(M - k) < 1 && (r = "nearest"), T && Math.abs(T - x) < 1 && (i = "nearest");
        }
      if (m)
        break;
      (e.top < f.top || e.bottom > f.bottom || e.left < f.left || e.right > f.right) && (e = {
        left: Math.max(e.left, f.left),
        right: Math.min(e.right, f.right),
        top: Math.max(e.top, f.top),
        bottom: Math.min(e.bottom, f.bottom)
      }), u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function AH(n) {
  let e = n.ownerDocument, t, r;
  for (let i = n.parentNode; i && !(i == e.body || t && r); )
    if (i.nodeType == 1)
      !r && i.scrollHeight > i.clientHeight && (r = i), !t && i.scrollWidth > i.clientWidth && (t = i), i = i.assignedSlot || i.parentNode;
    else if (i.nodeType == 11)
      i = i.host;
    else
      break;
  return { x: t, y: r };
}
class EH {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: r } = e;
    this.set(t, Math.min(e.anchorOffset, t ? ro(t) : 0), r, Math.min(e.focusOffset, r ? ro(r) : 0));
  }
  set(e, t, r, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = r, this.focusOffset = i;
  }
}
let Xc = null;
function U9(n) {
  if (n.setActive)
    return n.setActive();
  if (Xc)
    return n.focus(Xc);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(Xc == null ? {
    get preventScroll() {
      return Xc = { preventScroll: !0 }, !0;
    }
  } : void 0), !Xc) {
    Xc = !1;
    for (let t = 0; t < e.length; ) {
      let r = e[t++], i = e[t++], s = e[t++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let $k;
function Cc(n, e, t = e) {
  let r = $k || ($k = document.createRange());
  return r.setEnd(n, t), r.setStart(n, e), r;
}
function wu(n, e, t, r) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let s = new KeyboardEvent("keydown", i);
  s.synthetic = !0, n.dispatchEvent(s);
  let o = new KeyboardEvent("keyup", i);
  return o.synthetic = !0, n.dispatchEvent(o), s.defaultPrevented || o.defaultPrevented;
}
function LH(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function K9(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function OH(n, e) {
  let t = e.focusNode, r = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, ro(t)); ; )
    if (r) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (t = i, r = ro(t));
    } else {
      if (t == n)
        return !0;
      r = Sc(t), t = t.parentNode;
    }
}
function G9(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
function J9(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r > 0)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r - 1], r = ro(t);
    } else if (t.parentNode && !Eg(t))
      r = Sc(t), t = t.parentNode;
    else
      return null;
  }
}
function Y9(n, e) {
  for (let t = n, r = e; ; ) {
    if (t.nodeType == 3 && r < t.nodeValue.length)
      return { node: t, offset: r };
    if (t.nodeType == 1 && r < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[r], r = 0;
    } else if (t.parentNode && !Eg(t))
      r = Sc(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
class br {
  constructor(e, t, r = !0) {
    this.node = e, this.offset = t, this.precise = r;
  }
  static before(e, t) {
    return new br(e.parentNode, Sc(e), t);
  }
  static after(e, t) {
    return new br(e.parentNode, Sc(e) + 1, t);
  }
}
const Tw = [];
class en {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return t;
      t += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let a = en.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, t && !t.written && t.node == r && s != o.dom && (t.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = jk(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && t && t.node == r && (t.written = !0); s; )
        s = jk(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, t), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[t];
    else {
      let i = ro(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !en.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, r = 0) {
    let i = -1, s = -1, o = -1, a = -1;
    for (let l = 0, c = r, u = r; l < this.children.length; l++) {
      let h = this.children[l], f = c + h.length;
      if (c < e && f > t)
        return h.domBoundsAround(e, t, c);
      if (f >= e && i == -1 && (i = l, s = c), c > t && h.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = f, c = f + h.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? r + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, r = Tw) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    r.length < 250 ? this.children.splice(e, t - e, ...r) : this.children = [].concat(this.children.slice(0, e), r, this.children.slice(t));
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new X9(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
en.prototype.breakAfter = 0;
function jk(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class X9 {
  constructor(e, t, r) {
    this.children = e, this.pos = t, this.i = r, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function Z9(n, e, t, r, i, s, o, a, l) {
  let { children: c } = n, u = c.length ? c[e] : null, h = s.length ? s[s.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(t, i, s.length ? h : null, t == 0, a, l))) {
    if (r < c.length) {
      let m = c[r];
      m && (i < m.length || m.breakAfter && (h != null && h.breakAfter)) ? (e == r && (m = m.split(i), i = 0), !f && h && m.merge(0, i, h, !0, 0, l) ? s[s.length - 1] = m : ((i || m.children.length && !m.children[0].length) && m.merge(0, i, null, !1, 0, l), s.push(m))) : m != null && m.breakAfter && (h ? h.breakAfter = 1 : o = 1), r++;
    }
    for (u && (u.breakAfter = o, t > 0 && (!o && s.length && u.merge(t, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (t < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(t, u.length, null, !1, a, 0), e++)); e < r && s.length; )
      if (c[r - 1].become(s[s.length - 1]))
        r--, s.pop(), l = s.length ? 0 : a;
      else if (c[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < r || s.length) && n.replaceChildren(e, r, s);
  }
}
function Q9(n, e, t, r, i, s) {
  let o = n.childCursor(), { i: a, off: l } = o.findPos(t, 1), { i: c, off: u } = o.findPos(e, -1), h = e - t;
  for (let f of r)
    h += f.length;
  n.length += h, Z9(n, c, u, a, l, r, 0, i, s);
}
let Xr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, fv = typeof document < "u" ? document : { documentElement: { style: {} } };
const dv = /* @__PURE__ */ /Edge\/(\d+)/.exec(Xr.userAgent), eM = /* @__PURE__ */ /MSIE \d/.test(Xr.userAgent), pv = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Xr.userAgent), E1 = !!(eM || pv || dv), Wk = !E1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(Xr.userAgent), ib = !E1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Xr.userAgent), DH = "webkitFontSmoothing" in fv.documentElement.style, tM = !E1 && /* @__PURE__ */ /Apple Computer/.test(Xr.vendor), Uk = tM && (/* @__PURE__ */ /Mobile\/\w+/.test(Xr.userAgent) || Xr.maxTouchPoints > 2);
var Pe = {
  mac: Uk || /* @__PURE__ */ /Mac/.test(Xr.platform),
  windows: /* @__PURE__ */ /Win/.test(Xr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Xr.platform),
  ie: E1,
  ie_version: eM ? fv.documentMode || 6 : pv ? +pv[1] : dv ? +dv[1] : 0,
  gecko: Wk,
  gecko_version: Wk ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Xr.userAgent) || [0, 0])[1] : 0,
  chrome: !!ib,
  chrome_version: ib ? +ib[1] : 0,
  ios: Uk,
  android: /* @__PURE__ */ /Android\b/.test(Xr.userAgent),
  safari: tM,
  webkit_version: DH ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(Xr.userAgent) || [0, 0])[1] : 0,
  tabSize: fv.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const NH = 256;
class ws extends en {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, r) {
    return this.flags & 8 || r && (!(r instanceof ws) || this.length - (t - e) + r.length > NH || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new ws(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new br(this.dom, e);
  }
  domBoundsAround(e, t, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return IH(this.dom, e, t);
  }
}
class sa extends en {
  constructor(e, t = [], r = 0) {
    super(), this.mark = e, this.children = t, this.length = r;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (K9(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof sa && r.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (Q9(this, e, t, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], r = 0, i = -1, s = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > e && t.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = s), r = l, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new sa(this.mark, t, o);
  }
  domAtPos(e) {
    return nM(this, e);
  }
  coordsAt(e, t) {
    return iM(this, e, t);
  }
}
function IH(n, e, t) {
  let r = n.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && t < 0 || e == r && t >= 0 ? Pe.chrome || Pe.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : t < 0 ? i-- : s < r && s++;
  let a = Cc(n, i, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : t >= 0) ? 0 : a.length - 1];
  return Pe.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? A1(l, o < 0) : l || null;
}
class $a extends en {
  static create(e, t, r) {
    return new $a(e, t, r);
  }
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let t = $a.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof $a) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof $a && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Bt.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, r = t && t.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : Bt.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? br.before(this.dom) : br.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? i.length - 1 : 0; s = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return A1(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class ah extends en {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof ah && e.side == this.side;
  }
  split() {
    return new ah(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? br.before(this.dom) : br.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Bt.empty;
  }
  get isHidden() {
    return !0;
  }
}
ws.prototype.children = $a.prototype.children = ah.prototype.children = Tw;
function nM(n, e) {
  let t = n.dom, { children: r } = n, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new br(t, 0);
}
function rM(n, e, t) {
  let r, { children: i } = n;
  t > 0 && e instanceof sa && i.length && (r = i[i.length - 1]) instanceof sa && r.mark.eq(e.mark) ? rM(r, e.children[0], t - 1) : (i.push(e), e.setParent(n)), n.length += e.length;
}
function iM(n, e, t) {
  let r = null, i = -1, s = null, o = -1;
  function a(c, u) {
    for (let h = 0, f = 0; h < c.children.length && f <= u; h++) {
      let m = c.children[h], y = f + m.length;
      y >= u && (m.children.length ? a(m, u - f) : (!s || s.isHidden && (t > 0 || RH(s, m))) && (y > u || f == y && m.getSide() > 0) ? (s = m, o = u - f) : (f < u || f == y && m.getSide() < 0 && !m.isHidden) && (r = m, i = u - f)), f = y;
    }
  }
  a(n, e);
  let l = (t < 0 ? r : s) || r || s;
  return l ? l.coordsAt(Math.max(0, l == r ? i : o), t) : _H(n);
}
function _H(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = Id(e);
  return t[t.length - 1] || null;
}
function RH(n, e) {
  let t = n.coordsAt(0, 1), r = e.coordsAt(0, 1);
  return t && r && r.top < t.bottom;
}
function mv(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const Kk = /* @__PURE__ */ Object.create(null);
function Lg(n, e, t) {
  if (n == e)
    return !0;
  n || (n = Kk), e || (e = Kk);
  let r = Object.keys(n), i = Object.keys(e);
  if (r.length - (t && r.indexOf(t) > -1 ? 1 : 0) != i.length - (t && i.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != t && (i.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function gv(n, e, t) {
  let r = !1;
  if (e)
    for (let i in e)
      t && i in t || (r = !0, i == "style" ? n.style.cssText = "" : n.removeAttribute(i));
  if (t)
    for (let i in t)
      e && e[i] == t[i] || (r = !0, i == "style" ? n.style.cssText = t[i] : n.setAttribute(i, t[i]));
  return r;
}
function PH(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let r = n.attributes[t];
    e[r.name] = r.value;
  }
  return e;
}
let da = class {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
};
var Ir = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(Ir || (Ir = {}));
let rt = class extends xc {
  constructor(e, t, r, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new B0(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return t += r && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new nl(e, t, t, r, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = sM(e, t);
      r = (s ? t ? -3e8 : -1 : 5e8) - 1, i = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new nl(e, r, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new H0(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Ht.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
};
rt.none = Ht.empty;
class B0 extends rt {
  constructor(e) {
    let { start: t, end: r } = sM(e);
    super(t ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, r;
    return this == e || e instanceof B0 && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && Lg(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
B0.prototype.point = !1;
class H0 extends rt {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof H0 && this.spec.class == e.spec.class && Lg(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
H0.prototype.mapMode = hr.TrackBefore;
H0.prototype.point = !0;
class nl extends rt {
  constructor(e, t, r, i, s, o) {
    super(t, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? t <= 0 ? hr.TrackBefore : hr.TrackAfter : hr.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Ir.WidgetRange : this.startSide <= 0 ? Ir.WidgetBefore : Ir.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof nl && BH(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
nl.prototype.point = !0;
function sM(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: r } = n;
  return t == null && (t = n.inclusive), r == null && (r = n.inclusive), { start: t ?? e, end: r ?? e };
}
function BH(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function Em(n, e, t, r = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + r >= n ? t[i] = Math.max(t[i], e) : t.push(n, e);
}
class Fn extends en {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, r, i, s, o) {
    if (r) {
      if (!(r instanceof Fn))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), Q9(this, e, t, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let t = new Fn();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: r, off: i } = this.childPos(e);
    i && (t.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Lg(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    rM(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, r = e.spec.class;
    t && (this.attrs = mv(t, this.attrs || {})), r && (this.attrs = mv({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return nM(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var r;
    this.dom ? this.flags & 4 && (K9(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (gv(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let i = this.dom.lastChild;
    for (; i && en.get(i) instanceof sa; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = en.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!Pe.ios || !this.children.some((s) => s instanceof ws))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let r of this.children) {
      if (!(r instanceof ws) || /[^ -~]/.test(r.text))
        return null;
      let i = Id(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, t = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let r = iM(this, e, t);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return e instanceof Fn && this.children.length == 0 && e.children.length == 0 && Lg(this.attrs, e.attrs) && this.breakAfter == e.breakAfter;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= t) {
        if (s instanceof Fn)
          return s;
        if (o > t)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class Zo extends en {
  constructor(e, t, r) {
    super(), this.widget = e, this.length = t, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, r, i, s, o) {
    return r && (!(r instanceof Zo) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? br.before(this.dom) : br.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let r = new Zo(this.widget, t, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return Tw;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Bt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Zo && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    let r = this.widget.coordsAt(this.dom, e, t);
    return r || (this.widget instanceof yv ? null : A1(this.dom.getBoundingClientRect(), this.length ? e == 0 : t <= 0));
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: r } = this.deco;
    return t == r ? !1 : e < 0 ? t < 0 : r > 0;
  }
}
class yv extends da {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
class nd {
  constructor(e, t, r, i) {
    this.doc = e, this.pos = t, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Zo && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Fn()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Dp(new ah(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Zo) && this.getLine();
  }
  buildText(e, t, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: a, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (a) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, e), s = Math.min(
        i,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - r)), this.getLine().append(Dp(new ws(this.text.slice(this.textOff, this.textOff + s)), t), r), this.atCursorPos = !0, this.textOff += s, e -= s, r = i <= s ? 0 : t.length;
    }
  }
  span(e, t, r, i) {
    this.buildText(t - e, r, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof nl) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (r instanceof nl)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Zo(r.widget || lh.block, a, r));
      else {
        let l = $a.create(r.widget || lh.inline, a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && s <= i.length && (e < t || r.startSide > 0), u = !l.isEditable && (e < t || s > i.length || r.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(Dp(new ah(1), i), s), s = i.length + Math.max(0, s - i.length)), h.append(Dp(l, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < t || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, r, i, s) {
    let o = new nd(e, t, r, s);
    return o.openEnd = Ht.spans(i, t, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Dp(n, e) {
  for (let t of e)
    n = new sa(t, [n], n.length);
  return n;
}
class lh extends da {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
lh.inline = /* @__PURE__ */ new lh("span");
lh.block = /* @__PURE__ */ new lh("div");
var pn = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(pn || (pn = {}));
const Mc = pn.LTR, Aw = pn.RTL;
function oM(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const HH = /* @__PURE__ */ oM("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), zH = /* @__PURE__ */ oM("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), bv = /* @__PURE__ */ Object.create(null), Ps = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  bv[e] = t, bv[t] = -e;
}
function aM(n) {
  return n <= 247 ? HH[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? zH[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8204 ? 256 : 64336 <= n && n <= 65023 ? 4 : 1;
}
const FH = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class ja {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? Aw : Mc;
  }
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.level = r;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, t) {
    return e == (this.dir == t);
  }
  /**
  @internal
  */
  static find(e, t, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= t && a.to >= t) {
        if (a.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? a.from < t : a.to > t : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function lM(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let r = n[t], i = e[t];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !lM(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const Zt = [];
function VH(n, e, t, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, a = s < r.length ? r[s].from : t, l = s ? 256 : i;
    for (let c = o, u = l, h = l; c < a; c++) {
      let f = aM(n.charCodeAt(c));
      f == 512 ? f = u : f == 8 && h == 4 && (f = 16), Zt[c] = f == 4 ? 2 : f, f & 7 && (h = f), u = f;
    }
    for (let c = o, u = l, h = l; c < a; c++) {
      let f = Zt[c];
      if (f == 128)
        c < a - 1 && u == Zt[c + 1] && u & 24 ? f = Zt[c] = u : Zt[c] = 256;
      else if (f == 64) {
        let m = c + 1;
        for (; m < a && Zt[m] == 64; )
          m++;
        let y = c && u == 8 || m < t && Zt[m] == 8 ? h == 1 ? 1 : 8 : 256;
        for (let b = c; b < m; b++)
          Zt[b] = y;
        c = m - 1;
      } else f == 8 && h == 1 && (Zt[c] = 1);
      u = f, f & 7 && (h = f);
    }
  }
}
function qH(n, e, t, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : t;
    for (let h = c, f, m, y; h < u; h++)
      if (m = bv[f = n.charCodeAt(h)])
        if (m < 0) {
          for (let b = a - 3; b >= 0; b -= 3)
            if (Ps[b + 1] == -m) {
              let k = Ps[b + 2], x = k & 2 ? i : k & 4 ? k & 1 ? s : i : 0;
              x && (Zt[h] = Zt[Ps[b]] = x), a = b;
              break;
            }
        } else {
          if (Ps.length == 189)
            break;
          Ps[a++] = h, Ps[a++] = f, Ps[a++] = l;
        }
      else if ((y = Zt[h]) == 2 || y == 1) {
        let b = y == i;
        l = b ? 0 : 1;
        for (let k = a - 3; k >= 0; k -= 3) {
          let x = Ps[k + 2];
          if (x & 2)
            break;
          if (b)
            Ps[k + 2] |= 2;
          else {
            if (x & 4)
              break;
            Ps[k + 2] |= 4;
          }
        }
      }
  }
}
function $H(n, e, t, r) {
  for (let i = 0, s = r; i <= t.length; i++) {
    let o = i ? t[i - 1].to : n, a = i < t.length ? t[i].from : e;
    for (let l = o; l < a; ) {
      let c = Zt[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (i == t.length)
              break;
            u = t[i++].to, a = i < t.length ? t[i].from : e;
          } else if (Zt[u] == 256)
            u++;
          else
            break;
        let h = s == 1, f = (u < e ? Zt[u] : r) == 1, m = h == f ? h ? 1 : 2 : r;
        for (let y = u, b = i, k = b ? t[b - 1].to : n; y > l; )
          y == k && (y = t[--b].from, k = b ? t[b - 1].to : n), Zt[--y] = m;
        l = u;
      } else
        s = c, l++;
    }
  }
}
function vv(n, e, t, r, i, s, o) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let l = e, c = 0; l < t; ) {
      let u = !0, h = !1;
      if (c == s.length || l < s[c].from) {
        let b = Zt[l];
        b != a && (u = !1, h = b == 16);
      }
      let f = !u && a == 1 ? [] : null, m = u ? r : r + 1, y = l;
      e: for (; ; )
        if (c < s.length && y == s[c].from) {
          if (h)
            break e;
          let b = s[c];
          if (!u)
            for (let k = b.to, x = c + 1; ; ) {
              if (k == t)
                break e;
              if (x < s.length && s[x].from == k)
                k = s[x++].to;
              else {
                if (Zt[k] == a)
                  break e;
                break;
              }
            }
          if (c++, f)
            f.push(b);
          else {
            b.from > l && o.push(new ja(l, b.from, m));
            let k = b.direction == Mc != !(m % 2);
            wv(n, k ? r + 1 : r, i, b.inner, b.from, b.to, o), l = b.to;
          }
          y = b.to;
        } else {
          if (y == t || (u ? Zt[y] != a : Zt[y] == a))
            break;
          y++;
        }
      f ? vv(n, l, y, r + 1, i, f, o) : l < y && o.push(new ja(l, y, m)), l = y;
    }
  else
    for (let l = t, c = s.length; l > e; ) {
      let u = !0, h = !1;
      if (!c || l > s[c - 1].to) {
        let b = Zt[l - 1];
        b != a && (u = !1, h = b == 16);
      }
      let f = !u && a == 1 ? [] : null, m = u ? r : r + 1, y = l;
      e: for (; ; )
        if (c && y == s[c - 1].to) {
          if (h)
            break e;
          let b = s[--c];
          if (!u)
            for (let k = b.from, x = c; ; ) {
              if (k == e)
                break e;
              if (x && s[x - 1].to == k)
                k = s[--x].from;
              else {
                if (Zt[k - 1] == a)
                  break e;
                break;
              }
            }
          if (f)
            f.push(b);
          else {
            b.to < l && o.push(new ja(b.to, l, m));
            let k = b.direction == Mc != !(m % 2);
            wv(n, k ? r + 1 : r, i, b.inner, b.from, b.to, o), l = b.from;
          }
          y = b.from;
        } else {
          if (y == e || (u ? Zt[y - 1] != a : Zt[y - 1] == a))
            break;
          y--;
        }
      f ? vv(n, y, l, r + 1, i, f, o) : y < l && o.push(new ja(y, l, m)), l = y;
    }
}
function wv(n, e, t, r, i, s, o) {
  let a = e % 2 ? 2 : 1;
  VH(n, i, s, r, a), qH(n, i, s, r, a), $H(i, s, r, a), vv(n, i, s, e, t, r, o);
}
function jH(n, e, t) {
  if (!n)
    return [new ja(0, 0, e == Aw ? 1 : 0)];
  if (e == Mc && !t.length && !FH.test(n))
    return cM(n.length);
  if (t.length)
    for (; n.length > Zt.length; )
      Zt[Zt.length] = 256;
  let r = [], i = e == Mc ? 0 : 1;
  return wv(n, i, i, t, 0, n.length, r), r;
}
function cM(n) {
  return [new ja(0, n, 0)];
}
let uM = "";
function WH(n, e, t, r, i) {
  var s;
  let o = r.head - n.from, a = ja.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), l = e[a], c = l.side(i, t);
  if (o == c) {
    let f = a += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    l = e[a = f], o = l.side(!i, t), c = l.side(i, t);
  }
  let u = fr(n.text, o, l.forward(i, t));
  (u < l.from || u > l.to) && (u = c), uM = n.text.slice(Math.min(o, u), Math.max(o, u));
  let h = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return h && u == c && h.level + (i ? 0 : 1) < l.level ? ce.cursor(h.side(!i, t) + n.from, h.forward(i, t) ? 1 : -1, h.level) : ce.cursor(u + n.from, l.forward(i, t) ? -1 : 1, l.level);
}
function UH(n, e, t) {
  for (let r = e; r < t; r++) {
    let i = aM(n.charCodeAt(r));
    if (i == 1)
      return Mc;
    if (i == 2 || i == 4)
      return Aw;
  }
  return Mc;
}
const hM = /* @__PURE__ */ ze.define(), fM = /* @__PURE__ */ ze.define(), dM = /* @__PURE__ */ ze.define(), pM = /* @__PURE__ */ ze.define(), kv = /* @__PURE__ */ ze.define(), mM = /* @__PURE__ */ ze.define(), gM = /* @__PURE__ */ ze.define(), Ew = /* @__PURE__ */ ze.define(), Lw = /* @__PURE__ */ ze.define(), yM = /* @__PURE__ */ ze.define({
  combine: (n) => n.some((e) => e)
}), bM = /* @__PURE__ */ ze.define({
  combine: (n) => n.some((e) => e)
}), vM = /* @__PURE__ */ ze.define();
class ku {
  constructor(e, t = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new ku(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new ku(ce.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Np = /* @__PURE__ */ pt.define({ map: (n, e) => n.map(e) }), wM = /* @__PURE__ */ pt.define();
function Qr(n, e, t) {
  let r = n.facet(pM);
  r.length ? r[0](e) : window.onerror && window.onerror(String(e), t, void 0, void 0, e) || (t ? console.error(t + ":", e) : console.error(e));
}
const Wo = /* @__PURE__ */ ze.define({ combine: (n) => n.length ? n[0] : !0 });
let KH = 0;
const gu = /* @__PURE__ */ ze.define({
  combine(n) {
    return n.filter((e, t) => {
      for (let r = 0; r < t; r++)
        if (n[r].plugin == e.plugin)
          return !1;
      return !0;
    });
  }
});
class $n {
  constructor(e, t, r, i, s) {
    this.id = e, this.create = t, this.domEventHandlers = r, this.domEventObservers = i, this.baseExtensions = s(this), this.extension = this.baseExtensions.concat(gu.of({ plugin: this, arg: void 0 }));
  }
  /**
  Create an extension for this plugin with the given argument.
  */
  of(e) {
    return this.baseExtensions.concat(gu.of({ plugin: this, arg: e }));
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = t || {};
    return new $n(KH++, e, r, i, (a) => {
      let l = [];
      return o && l.push(_d.of((c) => {
        let u = c.plugin(a);
        return u ? o(u) : rt.none;
      })), s && l.push(s(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return $n.define((r, i) => new e(r, i), t);
  }
}
class sb {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  get plugin() {
    return this.spec && this.spec.plugin;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (r) {
            if (Qr(t.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.plugin.create(e, this.spec.arg);
      } catch (t) {
        Qr(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Qr(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const kM = /* @__PURE__ */ ze.define(), Ow = /* @__PURE__ */ ze.define(), _d = /* @__PURE__ */ ze.define(), xM = /* @__PURE__ */ ze.define(), z0 = /* @__PURE__ */ ze.define(), SM = /* @__PURE__ */ ze.define();
function Gk(n, e) {
  let t = n.state.facet(SM);
  if (!t.length)
    return t;
  let r = t.map((s) => s instanceof Function ? s(n) : s), i = [];
  return Ht.spans(r, e.from, e.to, {
    point() {
    },
    span(s, o, a, l) {
      let c = s - e.from, u = o - e.from, h = i;
      for (let f = a.length - 1; f >= 0; f--, l--) {
        let m = a[f].spec.bidiIsolate, y;
        if (m == null && (m = UH(e.text, c, u)), l > 0 && h.length && (y = h[h.length - 1]).to == c && y.direction == m)
          y.to = u, h = y.inner;
        else {
          let b = { from: c, to: u, direction: m, inner: [] };
          h.push(b), h = b.inner;
        }
      }
    }
  }), i;
}
const CM = /* @__PURE__ */ ze.define();
function Dw(n) {
  let e = 0, t = 0, r = 0, i = 0;
  for (let s of n.state.facet(CM)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: t, top: r, bottom: i };
}
const gf = /* @__PURE__ */ ze.define();
class Ki {
  constructor(e, t, r, i) {
    this.fromA = e, this.toA = t, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new Ki(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, r = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, r), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i], c = o - a, u = l ? l.fromB : 1e9;
      for (; s < t.length && t[s] < u; ) {
        let h = t[s], f = t[s + 1], m = Math.max(a, h), y = Math.min(u, f);
        if (m <= y && new Ki(m + c, y + c, m, y).addToSet(r), f > u)
          break;
        s += 2;
      }
      if (!l)
        return r;
      new Ki(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), o = l.toA, a = l.toB;
    }
  }
}
class Og {
  constructor(e, t, r) {
    this.view = e, this.state = t, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Jn.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, a, l) => i.push(new Ki(s, o, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Og(e, t, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Returns true when
  [`viewportChanged`](https://codemirror.net/6/docs/ref/#view.ViewUpdate.viewportChanged) is true
  and the viewport change is not just the result of mapping it in
  response to document changes.
  */
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 18) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class Jk extends en {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [!1], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = rt.none, this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Fn()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ki(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var t;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(e);
    let i = -1;
    this.view.inputState.composing >= 0 && !this.view.observer.editContext && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? i = this.domChanged.newSel.head : !ez(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? JH(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      r = new Ki(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (Pe.ie || Pe.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = ZH(o, a, e.changes);
    return r = Ki.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = Pe.chrome || Pe.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Zo && o.widget instanceof yv && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, t, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = i.length - 1; ; o--) {
      let a = o >= 0 ? i[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: h } = a, f, m, y, b;
      if (r && r.range.fromB < h && r.range.toB > u) {
        let E = nd.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), C = nd.build(this.view.state.doc, r.range.toB, h, this.decorations, this.dynamicDecorationMap);
        m = E.breakAtStart, y = E.openStart, b = C.openEnd;
        let O = this.compositionView(r);
        C.breakAtStart ? O.breakAfter = 1 : C.content.length && O.merge(O.length, O.length, C.content[0], !1, C.openStart, 0) && (O.breakAfter = C.content[0].breakAfter, C.content.shift()), E.content.length && O.merge(0, 0, E.content[E.content.length - 1], !0, 0, E.openEnd) && E.content.pop(), f = E.content.concat(O).concat(C.content);
      } else
        ({ content: f, breakAtStart: m, openStart: y, openEnd: b } = nd.build(this.view.state.doc, u, h, this.decorations, this.dynamicDecorationMap));
      let { i: k, off: x } = s.findPos(c, 1), { i: M, off: T } = s.findPos(l, -1);
      Z9(this, M, T, k, x, f, m, y, b);
    }
    r && this.fixCompositionDOM(r);
  }
  updateEditContextFormatting(e) {
    this.editContextFormatting = this.editContextFormatting.map(e.changes);
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(wM) && (this.editContextFormatting = r.value);
  }
  compositionView(e) {
    let t = new ws(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: i } of e.marks)
      t = new sa(i, [t], t.length);
    let r = new Fn();
    return r.append(t, 0), r;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = en.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    t(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], t(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && !(this.view.state.facet(Wo) || this.dom.tabIndex > -1) && Am(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (Pe.gecko && a.empty && !this.hasComposition && GH(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = c = new br(h, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!td(l.node, l.offset, u.anchorNode, u.anchorOffset) || !td(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      Pe.android && Pe.chrome && this.dom.contains(u.focusNode) && QH(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Nd(this.view.root);
      if (h) if (a.empty) {
        if (Pe.gecko) {
          let f = YH(l.node, l.offset);
          if (f && f != 3) {
            let m = (f == 1 ? J9 : Y9)(l.node, l.offset);
            m && (l = new br(m.node, m.offset));
          }
        }
        h.collapse(l.node, l.offset), a.bidiLevel != null && h.caretBidiLevel !== void 0 && (h.caretBidiLevel = a.bidiLevel);
      } else if (h.extend) {
        h.collapse(l.node, l.offset);
        try {
          h.extend(c.node, c.offset);
        } catch {
        }
      } else {
        let f = document.createRange();
        a.anchor > a.head && ([l, c] = [c, l]), f.setEnd(c.node, c.offset), f.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(f);
      }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new br(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new br(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, t) {
    return this.hasComposition && t.empty && td(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == t.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, r = Nd(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !t.empty || !t.assoc || !r.modify)
      return;
    let o = Fn.find(this, t.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (t.head == a || t.head == a + o.length)
      return;
    let l = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(t.head + t.assoc);
    r.collapse(u.node, u.offset), r.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && r.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let t = this.dom, r;
    if (e.node != t)
      return e;
    for (let i = e.offset; !r && i < t.childNodes.length; i++) {
      let s = en.get(t.childNodes[i]);
      s instanceof Fn && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = en.get(t.childNodes[i]);
      s instanceof Fn && (r = s.domAtPos(s.length));
    }
    return r ? new br(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let r = en.get(t);
      if (r && r.rootView == this)
        return r;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, t) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: r } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (r < i.length || i instanceof Fn)
        break;
      t++, r = 0;
    }
    return this.children[t].domAtPos(r);
  }
  coordsAt(e, t) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      if (c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof Fn && !(r instanceof Fn && t >= 0)))
        r = a, i = c;
      else if (r && c == e && l == e && a instanceof Zo && Math.abs(t) < 2) {
        if (a.deco.startSide < 0)
          break;
        o && (r = null);
      }
      s = c;
    }
    return r ? r.coordsAt(e - i, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: r } = this.childPos(e, 1), i = this.children[t];
    if (!(i instanceof Fn))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(r, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(i instanceof ws))
      return null;
    let s = fr(i.text, r);
    if (s == r)
      return null;
    let o = Cc(i.dom, r, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == pn.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let h = this.children[u], f = c + h.length;
      if (f > i)
        break;
      if (c >= r) {
        let m = h.dom.getBoundingClientRect();
        if (t.push(m.height), o) {
          let y = h.dom.lastChild, b = y ? Id(y) : [];
          if (b.length) {
            let k = b[b.length - 1], x = l ? k.right - m.left : m.right - k.left;
            x > a && (a = x, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? pn.RTL : pn.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Fn) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Id(e.firstChild)[0];
      t = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new X9(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == t.viewports.length ? null : t.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let a = (t.lineBlockAt(o).bottom - t.lineBlockAt(r).top) / this.view.scaleY;
        e.push(rt.replace({
          widget: new yv(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return rt.set(e);
  }
  updateDeco() {
    let e = 1, t = this.view.state.facet(_d).map((s) => (this.dynamicDecorationMap[e++] = typeof s == "function") ? s(this.view) : s), r = !1, i = this.view.state.facet(xM).map((s, o) => {
      let a = typeof s == "function";
      return a && (r = !0), a ? s(this.view) : s;
    });
    for (i.length && (this.dynamicDecorationMap[e++] = r, t.push(Ht.join(i))), this.decorations = [
      this.editContextFormatting,
      ...t,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; e < this.decorations.length; )
      this.dynamicDecorationMap[e++] = !1;
    return this.decorations;
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    for (let c of this.view.state.facet(vM))
      try {
        if (c(this.view, e.range, e))
          return !0;
      } catch (u) {
        Qr(this.view.state, u, "scroll handler");
      }
    let { range: t } = e, r = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!r)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = Dw(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    TH(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == pn.LTR);
  }
}
function GH(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
function MM(n, e) {
  let t = n.observer.selectionRange;
  if (!t.focusNode)
    return null;
  let r = J9(t.focusNode, t.focusOffset), i = Y9(t.focusNode, t.focusOffset), s = r || i;
  if (i && r && i.node != r.node) {
    let a = en.get(i.node);
    if (!a || a instanceof ws && a.text != i.node.nodeValue)
      s = i;
    else if (n.docView.lastCompositionAfterCursor) {
      let l = en.get(r.node);
      !l || l instanceof ws && l.text != r.node.nodeValue || (s = i);
    }
  }
  if (n.docView.lastCompositionAfterCursor = s != r, !s)
    return null;
  let o = e - s.offset;
  return { from: o, to: o + s.node.nodeValue.length, node: s.node };
}
function JH(n, e, t) {
  let r = MM(n, t);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, a = i.nodeValue;
  if (/[\n\r]/.test(a) || n.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = e.invertedDesc, c = new Ki(l.mapPos(s), l.mapPos(o), s, o), u = [];
  for (let h = i.parentNode; ; h = h.parentNode) {
    let f = en.get(h);
    if (f instanceof sa)
      u.push({ node: h, deco: f.mark });
    else {
      if (f instanceof Fn || h.nodeName == "DIV" && h.parentNode == n.contentDOM)
        return { range: c, text: i, marks: u, line: h };
      if (h != n.contentDOM)
        u.push({ node: h, deco: new B0({
          inclusive: !0,
          attributes: PH(h),
          tagName: h.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function YH(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let XH = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Em(e, t, this.changes);
  }
  comparePoint(e, t) {
    Em(e, t, this.changes);
  }
  boundChange(e) {
    Em(e, e, this.changes);
  }
};
function ZH(n, e, t) {
  let r = new XH();
  return Ht.compare(n, e, t, r), r.changes;
}
function QH(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function ez(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (t = !0);
  }), t;
}
function tz(n, e, t = 1) {
  let r = n.charCategorizer(e), i = n.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return ce.cursor(e);
  s == 0 ? t = 1 : s == i.length && (t = -1);
  let o = s, a = s;
  t < 0 ? o = fr(i.text, s, !1) : a = fr(i.text, s);
  let l = r(i.text.slice(o, a));
  for (; o > 0; ) {
    let c = fr(i.text, o, !1);
    if (r(i.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < i.length; ) {
    let c = fr(i.text, a);
    if (r(i.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return ce.range(o + i.from, a + i.from);
}
function nz(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function rz(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function ob(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function Yk(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function Xk(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function xv(n, e, t) {
  let r, i, s, o, a = !1, l, c, u, h;
  for (let y = n.firstChild; y; y = y.nextSibling) {
    let b = Id(y);
    for (let k = 0; k < b.length; k++) {
      let x = b[k];
      i && ob(i, x) && (x = Yk(Xk(x, i.bottom), i.top));
      let M = nz(e, x), T = rz(t, x);
      if (M == 0 && T == 0)
        return y.nodeType == 3 ? Zk(y, e, t) : xv(y, e, t);
      (!r || o > T || o == T && s > M) && (r = y, i = x, s = M, o = T, a = M ? e < x.left ? k > 0 : k < b.length - 1 : !0), M == 0 ? t > x.bottom && (!u || u.bottom < x.bottom) ? (l = y, u = x) : t < x.top && (!h || h.top > x.top) && (c = y, h = x) : u && ob(u, x) ? u = Xk(u, x.bottom) : h && ob(h, x) && (h = Yk(h, x.top));
    }
  }
  if (u && u.bottom >= t ? (r = l, i = u) : h && h.top <= t && (r = c, i = h), !r)
    return { node: n, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return Zk(r, f, t);
  if (a && r.contentEditable != "false")
    return xv(r, f, t);
  let m = Array.prototype.indexOf.call(n.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: n, offset: m };
}
function Zk(n, e, t) {
  let r = n.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let a = 0; a < r; a++) {
    let l = Cc(n, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let h = (u.top > t ? u.top - t : t - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && h < s) {
        let f = e >= (u.left + u.right) / 2, m = f;
        if ((Pe.chrome || Pe.gecko) && Cc(n, a).getBoundingClientRect().left == u.right && (m = !f), h <= 0)
          return { node: n, offset: a + (m ? 1 : 0) };
        i = a + (m ? 1 : 0), s = h;
      }
    }
  }
  return { node: n, offset: i > -1 ? i : o > 0 ? n.nodeValue.length : 0 };
}
function TM(n, e, t, r = -1) {
  var i, s;
  let o = n.contentDOM.getBoundingClientRect(), a = o.top + n.viewState.paddingTop, l, { docHeight: c } = n.viewState, { x: u, y: h } = e, f = h - a;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let E = n.viewState.heightOracle.textHeight / 2, C = !1; l = n.elementAtHeight(f), l.type != Ir.Text; )
    for (; f = r > 0 ? l.bottom + E : l.top - E, !(f >= 0 && f <= c); ) {
      if (C)
        return t ? null : 0;
      C = !0, r = -r;
    }
  h = a + f;
  let m = l.from;
  if (m < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : Qk(n, o, l, u, h);
  if (m > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : Qk(n, o, l, u, h);
  let y = n.dom.ownerDocument, b = n.root.elementFromPoint ? n.root : y, k = b.elementFromPoint(u, h);
  k && !n.contentDOM.contains(k) && (k = null), k || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), k = b.elementFromPoint(u, h), k && !n.contentDOM.contains(k) && (k = null));
  let x, M = -1;
  if (k && ((i = n.docView.nearest(k)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (y.caretPositionFromPoint) {
      let E = y.caretPositionFromPoint(u, h);
      E && ({ offsetNode: x, offset: M } = E);
    } else if (y.caretRangeFromPoint) {
      let E = y.caretRangeFromPoint(u, h);
      E && ({ startContainer: x, startOffset: M } = E);
    }
    x && (!n.contentDOM.contains(x) || Pe.safari && iz(x, M, u) || Pe.chrome && sz(x, M, u)) && (x = void 0), x && (M = Math.min(ro(x), M));
  }
  if (!x || !n.docView.dom.contains(x)) {
    let E = Fn.find(n.docView, m);
    if (!E)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: x, offset: M } = xv(E.dom, u, h));
  }
  let T = n.docView.nearest(x);
  if (!T)
    return null;
  if (T.isWidget && ((s = T.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let E = T.dom.getBoundingClientRect();
    return e.y < E.top || e.y <= E.bottom && e.x <= (E.left + E.right) / 2 ? T.posAtStart : T.posAtEnd;
  } else
    return T.localPosFromDOM(x, M) + T.posAtStart;
}
function Qk(n, e, t, r, i) {
  let s = Math.round((r - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let a = n.viewState.heightOracle.textHeight, l = Math.floor((i - t.top - (n.defaultLineHeight - a) * 0.5) / a);
    s += l * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + lv(o, s, n.state.tabSize);
}
function AM(n, e, t) {
  let r, i = n;
  if (n.nodeType != 3 || e != (r = n.nodeValue.length))
    return !1;
  for (; ; ) {
    let s = i.nextSibling;
    if (s) {
      if (s.nodeName == "BR")
        break;
      return !1;
    } else {
      let o = i.parentNode;
      if (!o || o.nodeName == "DIV")
        break;
      i = o;
    }
  }
  return Cc(n, r - 1, r).getBoundingClientRect().right > t;
}
function iz(n, e, t) {
  return AM(n, e, t);
}
function sz(n, e, t) {
  if (e != 0)
    return AM(n, e, t);
  for (let i = n; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = n.nodeType == 1 ? n.getBoundingClientRect() : Cc(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - r.left > 5;
}
function Sv(n, e, t) {
  let r = n.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    let i;
    for (let s of r.type) {
      if (s.from > e)
        break;
      if (!(s.to < e)) {
        if (s.from < e && s.to > e)
          return s;
        (!i || s.type == Ir.Text && (i.type != s.type || (t < 0 ? s.from < e : s.to > e))) && (i = s);
      }
    }
    return i || r;
  }
  return r;
}
function oz(n, e, t, r) {
  let i = Sv(n, e.head, e.assoc || -1), s = !r || i.type != Ir.Text || !(n.lineWrapping || i.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), a = n.textDirectionAt(i.from), l = n.posAtCoords({
      x: t == (a == pn.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return ce.cursor(l, t ? -1 : 1);
  }
  return ce.cursor(t ? i.to : i.from, t ? -1 : 1);
}
function e7(n, e, t, r) {
  let i = n.state.doc.lineAt(e.head), s = n.bidiSpans(i), o = n.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let c = WH(i, s, o, a, t), u = uM;
    if (!c) {
      if (i.number == (t ? n.state.doc.lines : 1))
        return a;
      u = `
`, i = n.state.doc.line(i.number + (t ? 1 : -1)), s = n.bidiSpans(i), c = n.visualLineSide(i, !t);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!r)
        return c;
      l = r(u);
    }
    a = c;
  }
}
function az(n, e, t) {
  let r = n.state.charCategorizer(e), i = r(t);
  return (s) => {
    let o = r(s);
    return i == yn.Space && (i = o), i == o;
  };
}
function lz(n, e, t, r) {
  let i = e.head, s = t ? 1 : -1;
  if (i == (t ? n.state.doc.length : 0))
    return ce.cursor(i, e.assoc);
  let o = e.goalColumn, a, l = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(i, e.assoc || -1), u = n.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;
  else {
    let m = n.viewState.lineBlockAt(i);
    o == null && (o = Math.min(l.right - l.left, n.defaultCharacterWidth * (i - m.from))), a = (s < 0 ? m.top : m.bottom) + u;
  }
  let h = l.left + o, f = r ?? n.viewState.heightOracle.textHeight >> 1;
  for (let m = 0; ; m += 10) {
    let y = a + (f + m) * s, b = TM(n, { x: h, y }, !1, s);
    if (y < l.top || y > l.bottom || (s < 0 ? b < i : b > i)) {
      let k = n.docView.coordsForChar(b), x = !k || y < k.top ? -1 : 1;
      return ce.cursor(b, x, void 0, o);
    }
  }
}
function rd(n, e, t) {
  for (; ; ) {
    let r = 0;
    for (let i of n)
      i.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = r || t || (e - s < o - e ? -1 : 1);
          e = l < 0 ? s : o, r = l;
        }
      });
    if (!r)
      return e;
  }
}
function EM(n, e) {
  let t = null;
  for (let r = 0; r < e.ranges.length; r++) {
    let i = e.ranges[r], s = null;
    if (i.empty) {
      let o = rd(n, i.from, 0);
      o != i.from && (s = ce.cursor(o, -1));
    } else {
      let o = rd(n, i.from, -1), a = rd(n, i.to, 1);
      (o != i.from || a != i.to) && (s = ce.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a));
    }
    s && (t || (t = e.ranges.slice()), t[r] = s);
  }
  return t ? ce.create(t, e.mainIndex) : e;
}
function ab(n, e, t) {
  let r = rd(n.state.facet(z0).map((i) => i(n)), t.from, e.head > t.from ? -1 : 1);
  return r == t.from ? t : ce.cursor(r, r < t.from ? 1 : -1);
}
const yf = "￿";
class cz {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(bn.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += yf;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == t)
        break;
      let a = en.get(i), l = en.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Eg(i)) || Eg(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, t.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (a = i.exec(t)) && (s = a.index, o = a[0].length), this.append(t.slice(r, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = en.get(e), r = t && t.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == t && (r.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (uz(e, r.node, r.offset) ? t : 0));
  }
}
function uz(n, e, t) {
  for (; ; ) {
    if (!e || t < ro(e))
      return !1;
    if (e == n)
      return !0;
    t = Sc(e) + 1, e = e.parentNode;
  }
}
class t7 {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class hz {
  constructor(e, t, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "", this.domChanged = t > -1;
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, r, 0))) {
      let a = s || o ? [] : pz(e), l = new cz(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = mz(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !hv(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !hv(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((Pe.ios || Pe.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let h = Math.min(l, c), f = Math.max(l, c), m = u.from - h, y = u.to - f;
        (m == 0 || m == 1 || h == 0) && (y == 0 || y == -1 || f == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = ce.single(c, l);
    }
  }
}
function LM(n, e) {
  let t, { newSel: r } = e, i = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = i.from, c = null;
    (s === 8 || Pe.android && e.text.length < a - o) && (l = i.to, c = "end");
    let u = dz(n.state.doc.sliceString(o, a, yf), e.text, l - o, c);
    u && (Pe.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == yf + yf && u.toB--, t = {
      from: o + u.from,
      to: o + u.toA,
      insert: Bt.of(e.text.slice(u.from, u.toB).split(yf))
    });
  } else r && (!n.hasFocus && n.state.facet(Wo) || r.main.eq(i)) && (r = null);
  if (!t && !r)
    return !1;
  if (!t && e.typeOver && !i.empty && r && r.main.empty ? t = { from: i.from, to: i.to, insert: n.state.doc.slice(i.from, i.to) } : (Pe.mac || Pe.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (r && t.insert.length == 2 && (r = ce.single(r.main.anchor - 1, r.main.head - 1)), t = { from: t.from, to: t.to, insert: Bt.of([t.insert.toString().replace(".", " ")]) }) : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: n.state.doc.slice(i.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, i.to))
  } : Pe.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && n.lineWrapping && (r && (r = ce.single(r.main.anchor - 1, r.main.head - 1)), t = { from: i.from, to: i.to, insert: Bt.of([" "]) }), t)
    return Nw(n, t, r, s);
  if (r && !r.main.eq(i)) {
    let o = !1, a = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), a = n.inputState.lastSelectionOrigin, a == "select.pointer" && (r = EM(n.state.facet(z0).map((l) => l(n)), r))), n.dispatch({ selection: r, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function Nw(n, e, t, r = -1) {
  if (Pe.ios && n.inputState.flushIOSKey(e))
    return !0;
  let i = n.state.selection.main;
  if (Pe.android && (e.to == i.to && // GBoard will sometimes remove a space it just inserted
  // after a completion when you press enter
  (e.from == i.from || e.from == i.from - 1 && n.state.sliceDoc(e.from, i.from) == " ") && e.insert.length == 1 && e.insert.lines == 2 && wu(n.contentDOM, "Enter", 13) || (e.from == i.from - 1 && e.to == i.to && e.insert.length == 0 || r == 8 && e.insert.length < e.to - e.from && e.to > i.head) && wu(n.contentDOM, "Backspace", 8) || e.from == i.from && e.to == i.to + 1 && e.insert.length == 0 && wu(n.contentDOM, "Delete", 46)))
    return !0;
  let s = e.insert.toString();
  n.inputState.composing >= 0 && n.inputState.composing++;
  let o, a = () => o || (o = fz(n, e, t));
  return n.state.facet(mM).some((l) => l(n, e.from, e.to, s, a)) || n.dispatch(a()), !0;
}
function fz(n, e, t) {
  let r, i = n.state, s = i.selection.main, o = -1;
  if (e.from == e.to && e.from < s.from || e.from > s.to) {
    let l = e.from < s.from ? -1 : 1, c = l < 0 ? s.from : s.to, u = rd(i.facet(z0).map((h) => h(n)), c, l);
    e.from == u && (o = u);
  }
  if (o > -1)
    r = {
      changes: e,
      selection: ce.cursor(e.from + e.insert.length, -1)
    };
  else if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", c = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(n.state.toText(l + e.insert.sliceString(0, void 0, n.state.lineBreak) + c));
  } else {
    let l = i.changes(e), c = t && t.main.to <= l.newLength ? t.main : void 0;
    if (i.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let u = n.state.sliceDoc(e.from, e.to), h, f = t && MM(n, t.main.head);
      if (f) {
        let b = e.insert.length - (e.to - e.from);
        h = { from: f.from, to: f.to - b };
      } else
        h = n.state.doc.lineAt(s.head);
      let m = s.to - e.to, y = s.to - s.from;
      r = i.changeByRange((b) => {
        if (b.from == s.from && b.to == s.to)
          return { changes: l, range: c || b.map(l) };
        let k = b.to - m, x = k - u.length;
        if (b.to - b.from != y || n.state.sliceDoc(x, k) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        b.to >= h.from && b.from <= h.to)
          return { range: b };
        let M = i.changes({ from: x, to: k, insert: e.insert }), T = b.to - s.to;
        return {
          changes: M,
          range: c ? ce.range(Math.max(0, c.anchor + T), Math.max(0, c.head + T)) : b.map(M)
        };
      });
    } else
      r = {
        changes: l,
        selection: c && i.selection.replaceRange(c)
      };
  }
  let a = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, a += ".compose", n.inputState.compositionFirstChange && (a += ".start", n.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: a, scrollIntoView: !0 });
}
function dz(n, e, t, r) {
  let i = Math.min(n.length, e.length), s = 0;
  for (; s < i && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && n.length == e.length)
    return null;
  let o = n.length, a = e.length;
  for (; o > 0 && a > 0 && n.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (r == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    t -= o + l - s;
  }
  if (o < s && n.length < e.length) {
    let l = t <= s && t >= o ? s - t : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = t <= s && t >= a ? s - t : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function pz(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new t7(t, r)), (i != t || s != r) && e.push(new t7(i, s))), e;
}
function mz(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, r = n.length == 2 ? n[1].pos : t;
  return t > -1 && r > -1 ? ce.single(t + e, r + e) : null;
}
let gz = class {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, Pe.safari && e.contentDOM.addEventListener("input", () => null), Pe.gecko && Nz(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !Cz(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || (this.view.updateState != 0 ? Promise.resolve().then(() => this.runHandlers(e.type, e)) : this.runHandlers(e.type, e));
  }
  runHandlers(e, t) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, t);
      for (let i of r.handlers) {
        if (t.defaultPrevented)
          break;
        if (i(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = yz(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, a = r[s];
        a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent), a = null), a || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !t[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode))
      return !0;
    if (this.tabFocusMode > 0 && e.keyCode != 27 && DM.indexOf(e.keyCode) < 0 && (this.tabFocusMode = -1), Pe.android && Pe.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return Pe.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = OM.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || bz.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return !t || t.key == "Enter" && e && e.from < e.to && /^\S+$/.test(e.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, wu(this.view.contentDOM, t.key, t.keyCode, t instanceof KeyboardEvent ? t : void 0));
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : Pe.safari && !Pe.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.view.observer.update(e), this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function n7(n, e) {
  return (t, r) => {
    try {
      return e.call(n, r, t);
    } catch (i) {
      Qr(t.state, i);
    }
  };
}
function yz(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of n) {
    let i = r.spec, s = i && i.plugin.domEventHandlers, o = i && i.plugin.domEventObservers;
    if (s)
      for (let a in s) {
        let l = s[a];
        l && t(a).handlers.push(n7(r.value, l));
      }
    if (o)
      for (let a in o) {
        let l = o[a];
        l && t(a).observers.push(n7(r.value, l));
      }
  }
  for (let r in ks)
    t(r).handlers.push(ks[r]);
  for (let r in Xi)
    t(r).observers.push(Xi[r]);
  return e;
}
const OM = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], bz = "dthko", DM = [16, 17, 18, 20, 91, 92, 224, 225], Ip = 6;
function _p(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function vz(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class wz {
  constructor(e, t, r, i) {
    this.view = e, this.startEvent = t, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParents = AH(e.contentDOM), this.atoms = e.state.facet(z0).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(bn.allowMultipleSelections) && kz(e, t), this.dragging = Sz(e, t) && _M(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && vz(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let t = 0, r = 0, i = 0, s = 0, o = this.view.win.innerWidth, a = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: i, right: o } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: s, bottom: a } = this.scrollParents.y.getBoundingClientRect());
    let l = Dw(this.view);
    e.clientX - l.left <= i + Ip ? t = -_p(i - e.clientX) : e.clientX + l.right >= o - Ip && (t = _p(e.clientX - o)), e.clientY - l.top <= s + Ip ? r = -_p(s - e.clientY) : e.clientY + l.bottom >= a - Ip && (r = _p(e.clientY - a)), this.setScrollSpeed(t, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: e, y: t } = this.scrollSpeed;
    e && this.scrollParents.x && (this.scrollParents.x.scrollLeft += e, e = 0), t && this.scrollParents.y && (this.scrollParents.y.scrollTop += t, t = 0), (e || t) && this.view.win.scrollBy(e, t), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let { view: t } = this, r = EM(this.atoms, this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(t.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.transactions.some((t) => t.isUserEvent("input.type")) ? this.destroy() : this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function kz(n, e) {
  let t = n.state.facet(hM);
  return t.length ? t[0](e) : Pe.mac ? e.metaKey : e.ctrlKey;
}
function xz(n, e) {
  let t = n.state.facet(fM);
  return t.length ? t[0](e) : Pe.mac ? !e.altKey : !e.ctrlKey;
}
function Sz(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let r = Nd(n.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function Cz(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, r; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (r = en.get(t)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const ks = /* @__PURE__ */ Object.create(null), Xi = /* @__PURE__ */ Object.create(null), NM = Pe.ie && Pe.ie_version < 15 || Pe.ios && Pe.webkit_version < 604;
function Mz(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), IM(n, t.value);
  }, 50);
}
function L1(n, e, t) {
  for (let r of n.facet(e))
    t = r(t, n);
  return t;
}
function IM(n, e) {
  e = L1(n.state, Ew, e);
  let { state: t } = n, r, i = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (Cv != null && t.selection.ranges.every((l) => l.empty) && Cv == s.toString()) {
    let l = -1;
    r = t.changeByRange((c) => {
      let u = t.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let h = t.toText((o ? s.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: u.from, insert: h },
        range: ce.cursor(c.from + h.length)
      };
    });
  } else o ? r = t.changeByRange((l) => {
    let c = s.line(i++);
    return {
      changes: { from: l.from, to: l.to, insert: c.text },
      range: ce.cursor(l.from + c.length)
    };
  }) : r = t.replaceSelection(s);
  n.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Xi.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
ks.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && n.inputState.tabFocusMode != 0 && (n.inputState.tabFocusMode = Date.now() + 2e3), !1);
Xi.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
Xi.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
ks.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let r of n.state.facet(dM))
    if (t = r(n, e), t)
      break;
  if (!t && e.button == 0 && (t = Ez(n, e)), t) {
    let r = !n.hasFocus;
    n.inputState.startMouseSelection(new wz(n, e, t, r)), r && n.observer.ignore(() => {
      U9(n.contentDOM);
      let s = n.root.activeElement;
      s && !s.contains(n.contentDOM) && s.blur();
    });
    let i = n.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  } else
    n.inputState.setSelectionOrigin("select.pointer");
  return !1;
};
function r7(n, e, t, r) {
  if (r == 1)
    return ce.cursor(e, t);
  if (r == 2)
    return tz(n.state, e, t);
  {
    let i = Fn.find(n.docView, e), s = n.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, a = i ? i.posAtEnd : s.to;
    return a < n.state.doc.length && a == s.to && a++, ce.range(o, a);
  }
}
let i7 = (n, e, t) => e >= t.top && e <= t.bottom && n >= t.left && n <= t.right;
function Tz(n, e, t, r) {
  let i = Fn.find(n.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && i7(t, r, o))
    return -1;
  let a = i.coordsAt(s, 1);
  return a && i7(t, r, a) ? 1 : o && o.bottom >= r ? -1 : 1;
}
function s7(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: Tz(n, t, e.clientX, e.clientY) };
}
const Az = Pe.ie && Pe.ie_version <= 11;
let o7 = null, a7 = 0, l7 = 0;
function _M(n) {
  if (!Az)
    return n.detail;
  let e = o7, t = l7;
  return o7 = n, l7 = Date.now(), a7 = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (a7 + 1) % 3 : 1;
}
function Ez(n, e) {
  let t = s7(n, e), r = _M(e), i = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), i = i.map(s.changes));
    },
    get(s, o, a) {
      let l = s7(n, s), c, u = r7(n, l.pos, l.bias, r);
      if (t.pos != l.pos && !o) {
        let h = r7(n, t.pos, t.bias, r), f = Math.min(h.from, u.from), m = Math.max(h.to, u.to);
        u = f < u.from ? ce.range(f, m) : ce.range(m, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = Lz(i, l.pos)) ? c : a ? i.addRange(u) : ce.create([u]);
    }
  };
}
function Lz(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: r, to: i } = n.ranges[t];
    if (r <= e && i >= e)
      return ce.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
ks.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let i = n.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= t.to || o <= t.from) && (t = ce.range(s, o));
    }
  }
  let { inputState: r } = n;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", L1(n.state, Lw, n.state.sliceDoc(t.from, t.to))), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
ks.dragend = (n) => (n.inputState.draggedContent = null, !1);
function c7(n, e, t, r) {
  if (t = L1(n.state, Ew, t), !t)
    return;
  let i = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = r && s && xz(n, e) ? { from: s.from, to: s.to } : null, a = { from: i, insert: t }, l = n.state.changes(o ? [o, a] : a);
  n.focus(), n.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
ks.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let r = Array(t.length), i = 0, s = () => {
      ++i == t.length && c7(n, e, r.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[o] = a.result), s();
      }, a.readAsText(t[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return c7(n, e, r, !0), !0;
  }
  return !1;
};
ks.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = NM ? null : e.clipboardData;
  return t ? (IM(n, t.getData("text/plain") || t.getData("text/uri-list")), !0) : (Mz(n), !1);
};
function Oz(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let r = t.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), n.focus();
  }, 50);
}
function Dz(n) {
  let e = [], t = [], r = !1;
  for (let i of n.selection.ranges)
    i.empty || (e.push(n.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > i && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: L1(n, Lw, e.join(n.lineBreak)), ranges: t, linewise: r };
}
let Cv = null;
ks.copy = ks.cut = (n, e) => {
  let { text: t, ranges: r, linewise: i } = Dz(n.state);
  if (!t && !i)
    return !1;
  Cv = i ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = NM ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (Oz(n, t), !1);
};
const RM = /* @__PURE__ */ fa.define();
function PM(n, e) {
  let t = [];
  for (let r of n.facet(gM)) {
    let i = r(n, e);
    i && t.push(i);
  }
  return t.length ? n.update({ effects: t, annotations: RM.of(!0) }) : null;
}
function BM(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = PM(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
Xi.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), BM(n);
};
Xi.blur = (n) => {
  n.observer.clearSelectionRange(), BM(n);
};
Xi.compositionstart = Xi.compositionupdate = (n) => {
  n.observer.editContext || (n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0));
};
Xi.compositionend = (n) => {
  n.observer.editContext || (n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, Pe.chrome && Pe.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50));
};
Xi.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
ks.beforeinput = (n, e) => {
  var t, r;
  if (e.inputType == "insertReplacementText" && n.observer.editContext) {
    let s = (t = e.dataTransfer) === null || t === void 0 ? void 0 : t.getData("text/plain"), o = e.getTargetRanges();
    if (s && o.length) {
      let a = o[0], l = n.posAtDOM(a.startContainer, a.startOffset), c = n.posAtDOM(a.endContainer, a.endOffset);
      return Nw(n, { from: l, to: c, insert: n.state.toText(s) }, null), !0;
    }
  }
  let i;
  if (Pe.chrome && Pe.android && (i = OM.find((s) => s.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let s = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > s + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return Pe.ios && e.inputType == "deleteContentForward" && n.observer.flushSoon(), Pe.safari && e.inputType == "insertText" && n.inputState.composing >= 0 && setTimeout(() => Xi.compositionend(n, e), 20), !1;
};
const u7 = /* @__PURE__ */ new Set();
function Nz(n) {
  u7.has(n) || (u7.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const h7 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let ch = !1;
function f7() {
  ch = !1;
}
class Iz {
  constructor(e) {
    this.lineWrapping = e, this.doc = Bt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(e, t) {
    let r = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((t - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / Math.max(1, this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return h7.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, r, i, s, o) {
    let a = h7.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = r, this.textHeight = i, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class _z {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Us {
  /**
  @internal
  */
  constructor(e, t, r, i, s) {
    this.from = e, this.length = t, this.top = r, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ir.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof nl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Us(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var dn = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(dn || (dn = {}));
const Lm = 1e-3;
class _r {
  constructor(e, t, r = 2) {
    this.length = e, this.height = t, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e) {
    this.height != e && (Math.abs(this.height - e) > Lm && (ch = !0), this.height = e);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, r) {
    return _r.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, r, i) {
    let s = this, o = r.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: h } = i[a], f = s.lineAt(l, dn.ByPosNoHeight, r.setDoc(t), 0, 0), m = f.to >= c ? f : s.lineAt(c, dn.ByPosNoHeight, r, 0, 0);
      for (h += m.to - c, c = m.to; a > 0 && f.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < f.from && (f = s.lineAt(l, dn.ByPosNoHeight, r, 0, 0));
      u += f.from - l, l = f.from;
      let y = Iw.build(r.setDoc(o), e, u, h);
      s = Dg(s, s.replace(l, c, y));
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new vi(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (t == r)
        if (i > s * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
        } else if (s > i * 2) {
          let a = e[r];
          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, s -= a.size;
        } else
          break;
      else if (i < s) {
        let a = e[t++];
        a && (i += a.size);
      } else {
        let a = e[--r];
        a && (s += a.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, r++), new Rz(_r.of(e.slice(0, t)), o, _r.of(e.slice(r)));
  }
}
function Dg(n, e) {
  return n == e ? n : (n.constructor != e.constructor && (ch = !0), e);
}
_r.prototype.size = 1;
class HM extends _r {
  constructor(e, t, r) {
    super(e, t), this.deco = r;
  }
  blockAt(e, t, r, i) {
    return new Us(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, t, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, t, r, i, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class vi extends HM {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, r, i) {
    return new Us(i, this.length, r, this.height, this.breaks);
  }
  replace(e, t, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof vi || i instanceof lr && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof lr ? i = new vi(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : _r.of(r);
  }
  updateHeight(e, t = 0, r = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(i.heights[i.index++]) : (r || this.outdated) && this.setHeight(Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class lr extends _r {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let r = e.doc.lineAt(t).number, i = e.doc.lineAt(t + this.length).number, s = i - r + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: a };
  }
  blockAt(e, t, r, i) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(t, i);
    if (t.lineWrapping) {
      let c = i + (e < t.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length)), u = t.doc.lineAt(c), h = a + u.length * l, f = Math.max(r, e - h / 2);
      return new Us(u.from, u.length, f, h, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / a))), { from: u, length: h } = t.doc.line(s + c);
      return new Us(u, h, r + a * c, a, 0);
    }
  }
  lineAt(e, t, r, i, s) {
    if (t == dn.ByHeight)
      return this.blockAt(e, r, i, s);
    if (t == dn.ByPosNoHeight) {
      let { from: m, to: y } = r.doc.lineAt(e);
      return new Us(m, y - m, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, s), c = r.doc.lineAt(e), u = a + c.length * l, h = c.number - o, f = i + a * h + l * (c.from - s - h);
    return new Us(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, t, r, i, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, s);
    for (let u = e, h = i; u <= t; ) {
      let f = r.doc.lineAt(u);
      if (u == e) {
        let y = f.number - a;
        h += l * y + c * (e - s - y);
      }
      let m = l + c * f.length;
      o(new Us(f.from, f.length, h, m, 0)), h += m, u = f.to + 1;
    }
  }
  replace(e, t, r) {
    let i = this.length - t;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof lr ? r[r.length - 1] = new lr(s.length + i) : r.push(null, new lr(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof lr ? r[0] = new lr(e + s.length) : r.unshift(new lr(e - 1), null);
    }
    return _r.of(r);
  }
  decomposeLeft(e, t) {
    t.push(new lr(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new lr(this.length - e - 1));
  }
  updateHeight(e, t = 0, r = !1, i) {
    let s = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let o = [], a = Math.max(t, i.from), l = -1;
      for (i.from > t && o.push(new lr(i.from - t - 1).updateHeight(e, t)); a <= s && i.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let h = i.heights[i.index++];
        l == -1 ? l = h : Math.abs(h - l) >= Lm && (l = -2);
        let f = new vi(u, h);
        f.outdated = !1, o.push(f), a += u + 1;
      }
      a <= s && o.push(null, new lr(s - a).updateHeight(e, a));
      let c = _r.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= Lm || Math.abs(l - this.heightMetrics(e, t).perLine) >= Lm) && (ch = !0), Dg(this, c);
    } else (r || this.outdated) && (this.setHeight(e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Rz extends _r {
  constructor(e, t, r) {
    super(e.length + t + r.length, e.height + r.height, t | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, t, r, i) : this.right.blockAt(e, t, s, i + this.left.length + this.break);
  }
  lineAt(e, t, r, i, s) {
    let o = i + this.left.height, a = s + this.left.length + this.break, l = t == dn.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, t, r, i, s) : this.right.lineAt(e, t, r, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = t == dn.ByPosNoHeight ? dn.ByPosNoHeight : dn.ByPos;
    return l ? c.join(this.right.lineAt(a, u, r, o, a)) : this.left.lineAt(a, u, r, i, s).join(c);
  }
  forEachLine(e, t, r, i, s, o) {
    let a = i + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, r, i, s, o), t >= l && this.right.forEachLine(e, t, r, a, l, o);
    else {
      let c = this.lineAt(l, dn.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, r, a, l, o);
    }
  }
  replace(e, t, r) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of r)
      s.push(a);
    if (e > 0 && d7(s, o - 1), t < this.length) {
      let a = s.length;
      this.decomposeRight(t, s), d7(s, a);
    }
    return _r.of(s);
  }
  decomposeLeft(e, t) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (r++, e >= r && t.push(null)), e > r && this.right.decomposeLeft(e - r, t);
  }
  decomposeRight(e, t) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < r && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? _r.of(this.break ? [e, null, t] : [e, t]) : (this.left = Dg(this.left, e), this.right = Dg(this.right, t), this.setHeight(e.height + t.height), this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, r = !1, i) {
    let { left: s, right: o } = this, a = t + s.length + this.break, l = null;
    return i && i.from <= t + s.length && i.more ? l = s = s.updateHeight(e, t, r, i) : s.updateHeight(e, t, r), i && i.from <= a + o.length && i.more ? l = o = o.updateHeight(e, a, r, i) : o.updateHeight(e, a, r), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function d7(n, e) {
  let t, r;
  n[e] == null && (t = n[e - 1]) instanceof lr && (r = n[e + 1]) instanceof lr && n.splice(e - 1, 3, new lr(t.length + 1 + r.length));
}
const Pz = 5;
class Iw {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let r = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof vi ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new vi(r - this.pos, -1)), this.writtenTo = r, t > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, r) {
    if (e < t || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = t - e;
      r.block ? this.addBlock(new HM(o, i, r)) : (o || s || i >= Pz) && this.addLineDeco(i, s, o);
    } else t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new vi(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let r = new lr(t - e);
    return this.oracle.doc.lineAt(e).to == t && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof vi)
      return e;
    let t = new vi(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += t, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof vi) && !this.isCovered ? this.nodes.push(new vi(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof vi && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, r, i) {
    let s = new Iw(r, e);
    return Ht.spans(t, r, i, s, 0), s.finish(r);
  }
}
function Bz(n, e, t) {
  let r = new Hz();
  return Ht.compare(n, e, t, r, 0), r.changes;
}
class Hz {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, r, i) {
    (e < t || r && r.heightRelevant || i && i.heightRelevant) && Em(e, t, this.changes, 5);
  }
}
function zz(n, e) {
  let t = n.getBoundingClientRect(), r = n.ownerDocument, i = r.defaultView || window, s = Math.max(0, t.left), o = Math.min(i.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(i.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let u = c, h = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && h.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), a = Math.max(a, f.top), l = Math.min(c == n.parentNode ? i.innerHeight : l, f.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function Fz(n) {
  let e = n.getBoundingClientRect(), t = n.ownerDocument.defaultView || window;
  return e.left < t.innerWidth && e.right > 0 && e.top < t.innerHeight && e.bottom > 0;
}
function Vz(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class lb {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.size = r, this.displaySize = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = t[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return rt.replace({
      widget: new qz(this.displaySize * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class qz extends da {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class p7 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = m7, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = pn.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Ow).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new Iz(t), this.stateDeco = e.facet(_d).filter((r) => typeof r != "function"), this.heightMap = _r.empty().applyChanges(this.stateDeco, Bt.empty, this.heightOracle.setDoc(e.doc), [new Ki(0, 0, 0, e.doc.length)]);
    for (let r = 0; r < 2 && (this.viewport = this.getViewport(0, null), !!this.updateForViewport()); r++)
      ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = rt.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new Rp(s, o));
      }
    }
    return this.viewports = e.sort((r, i) => r.from - i.from), this.updateScaler();
  }
  updateScaler() {
    let e = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? m7 : new _w(this.heightOracle, this.heightMap, this.viewports), e.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(bf(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(_d).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = Ki.extendWithRanges(i, Bz(r, this.stateDeco, e ? e.changes : Jn.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    f7(), this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), (this.heightMap.height != o || ch) && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = o);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let c = l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, e.flags |= this.updateForViewport(), (c || !e.changes.empty || e.flags & 2) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(e.changes), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(bM) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, r = window.getComputedStyle(t), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? pn.RTL : pn.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: E, scaleY: C } = W9(t, a);
      (E > 5e-3 && Math.abs(this.scaleX - E) > 5e-3 || C > 5e-3 && Math.abs(this.scaleY - C) > 5e-3) && (this.scaleX = E, this.scaleY = C, c |= 16, o = l = !0);
    }
    let h = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, c |= 18), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 16);
    let m = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != m && (this.scrollAnchorHeight = -1, this.scrollTop = m), this.scrolledToBottom = G9(e.scrollDOM);
    let y = (this.printing ? Vz : zz)(t, this.paddingTop), b = y.top - this.pixelViewport.top, k = y.bottom - this.pixelViewport.bottom;
    this.pixelViewport = y;
    let x = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (x != this.inView && (this.inView = x, x && (l = !0)), !this.inView && !this.scrollTarget && !Fz(e.dom))
      return 0;
    let M = a.width;
    if ((this.contentDOMWidth != M || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 16), l) {
      let E = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(E) && (o = !0), o || i.lineWrapping && Math.abs(M - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: C, charWidth: O, textHeight: R } = e.docView.measureTextSize();
        o = C > 0 && i.refresh(s, C, O, R, Math.max(5, M / O), E), o && (e.docView.minWidth = 0, c |= 16);
      }
      b > 0 && k > 0 ? u = Math.max(b, k) : b < 0 && k < 0 && (u = Math.min(b, k)), f7();
      for (let C of this.viewports) {
        let O = C.from == this.viewport.from ? E : e.docView.measureVisibleLineHeights(C);
        this.heightMap = (o ? _r.empty().applyChanges(this.stateDeco, Bt.empty, this.heightOracle, [new Ki(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new _z(C.from, O));
      }
      ch && (c |= 2);
    }
    let T = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return T && (c & 2 && (c |= this.updateScaler()), this.viewport = this.getViewport(u, this.scrollTarget), c |= this.updateForViewport()), (c & 2 || T) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new Rp(i.lineAt(o - r * 1e3, dn.ByHeight, s, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, dn.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, dn.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - u / 2 : t.y == "start" || t.y == "nearest" && c < l.from ? f = h.top : f = h.bottom - u, l = new Rp(i.lineAt(f - 1e3 / 2, dn.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, dn.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let r = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new Rp(this.heightMap.lineAt(r, dn.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, dn.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, dn.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, dn.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || s >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let r = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || r.push(new lb(t.mapPos(i.from), t.mapPos(i.to), i.size, i.displaySize));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != pn.LTR && !r)
      return [];
    let a = [], l = (u, h, f, m) => {
      if (h - u < s)
        return;
      let y = this.state.selection.main, b = [y.from];
      y.empty || b.push(y.to);
      for (let x of b)
        if (x > u && x < h) {
          l(u, x - 10, f, m), l(x + 10, h, f, m);
          return;
        }
      let k = jz(e, (x) => x.from >= f.from && x.to <= f.to && Math.abs(x.from - u) < s && Math.abs(x.to - h) < s && !b.some((M) => x.from < M && x.to > M));
      if (!k) {
        if (h < f.to && t && r && t.visibleRanges.some((T) => T.from <= h && T.to >= h)) {
          let T = t.moveToLineBoundary(ce.cursor(h), !1, !0).head;
          T > u && (h = T);
        }
        let x = this.gapSize(f, u, h, m), M = r || x < 2e6 ? x : 2e6;
        k = new lb(u, h, x, M);
      }
      a.push(k);
    }, c = (u) => {
      if (u.length < o || u.type != Ir.Text)
        return;
      let h = $z(u.from, u.to, this.stateDeco);
      if (h.total < o)
        return;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, m, y;
      if (r) {
        let b = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, k, x;
        if (f != null) {
          let M = Bp(h, f), T = ((this.visibleBottom - this.visibleTop) / 2 + b) / u.height;
          k = M - T, x = M + T;
        } else
          k = (this.visibleTop - u.top - b) / u.height, x = (this.visibleBottom - u.top + b) / u.height;
        m = Pp(h, k), y = Pp(h, x);
      } else {
        let b = h.total * this.heightOracle.charWidth, k = i * this.heightOracle.charWidth, x = 0;
        if (b > 2e6)
          for (let O of e)
            O.from >= u.from && O.from < u.to && O.size != O.displaySize && O.from * this.heightOracle.charWidth + x < this.pixelViewport.left && (x = O.size - O.displaySize);
        let M = this.pixelViewport.left + x, T = this.pixelViewport.right + x, E, C;
        if (f != null) {
          let O = Bp(h, f), R = ((T - M) / 2 + k) / b;
          E = O - R, C = O + R;
        } else
          E = (M - k) / b, C = (T + k) / b;
        m = Pp(h, E), y = Pp(h, C);
      }
      m > u.from && l(u.from, m, u, h), y < u.to && l(y, u.to, u, h);
    };
    for (let u of this.viewportLines)
      Array.isArray(u.type) ? u.type.forEach(c) : c(u);
    return a;
  }
  gapSize(e, t, r, i) {
    let s = Bp(i, r) - Bp(i, t);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    lb.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = rt.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges(e) {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let r = [];
    Ht.spans(t, this.viewport.from, this.viewport.to, {
      span(s, o) {
        r.push({ from: s, to: o });
      },
      point() {
      }
    }, 20);
    let i = 0;
    if (r.length != this.visibleRanges.length)
      i = 12;
    else
      for (let s = 0; s < r.length && !(i & 8); s++) {
        let o = this.visibleRanges[s], a = r[s];
        (o.from != a.from || o.to != a.to) && (i |= 4, e && e.mapPos(o.from, -1) == a.from && e.mapPos(o.to, 1) == a.to || (i |= 8));
      }
    return this.visibleRanges = r, i;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || bf(this.heightMap.lineAt(e, dn.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return e >= this.viewportLines[0].top && e <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((t) => t.top <= e && t.bottom >= e) || bf(this.heightMap.lineAt(this.scaler.fromDOM(e), dn.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return bf(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Rp {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function $z(n, e, t) {
  let r = [], i = n, s = 0;
  return Ht.spans(t, n, e, {
    span() {
    },
    point(o, a) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = a;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function Pp({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(n * t);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], a = o - s;
    if (r <= a)
      return s + r;
    r -= a;
  }
}
function Bp(n, e) {
  let t = 0;
  for (let { from: r, to: i } of n.ranges) {
    if (e <= i) {
      t += e - r;
      break;
    }
    t += i - r;
  }
  return t / n.total;
}
function jz(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const m7 = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(n) {
    return n == this;
  }
};
class _w {
  constructor(e, t, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let c = t.lineAt(a, dn.ByPos, e, 0, 0).top, u = t.lineAt(l, dn.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, r = 0, i = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
  eq(e) {
    return e instanceof _w ? this.scale == e.scale && this.viewports.length == e.viewports.length && this.viewports.every((t, r) => t.from == e.viewports[r].from && t.to == e.viewports[r].to) : !1;
  }
}
function bf(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), r = e.toDOM(n.bottom);
  return new Us(n.from, n.length, t, r - t, Array.isArray(n._content) ? n._content.map((i) => bf(i, e)) : n._content);
}
const Hp = /* @__PURE__ */ ze.define({ combine: (n) => n.join(" ") }), Mv = /* @__PURE__ */ ze.define({ combine: (n) => n.indexOf(!0) > -1 }), Tv = /* @__PURE__ */ tl.newName(), zM = /* @__PURE__ */ tl.newName(), FM = /* @__PURE__ */ tl.newName(), VM = { "&light": "." + zM, "&dark": "." + FM };
function Av(n, e, t) {
  return new tl(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return n;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : n + " " + r;
    }
  });
}
const Wz = /* @__PURE__ */ Av("." + Tv, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    zIndex: 200
  },
  ".cm-gutters-before": { insetInlineStart: 0 },
  ".cm-gutters-after": { insetInlineEnd: 0 },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    border: "0px solid #ddd",
    "&.cm-gutters-before": { borderRightWidth: "1px" },
    "&.cm-gutters-after": { borderLeftWidth: "1px" }
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-dialog": {
    padding: "2px 19px 4px 6px",
    position: "relative",
    "& label": { fontSize: "80%" }
  },
  ".cm-dialog-close": {
    position: "absolute",
    top: "3px",
    right: "4px",
    backgroundColor: "inherit",
    border: "none",
    font: "inherit",
    fontSize: "14px",
    padding: "0"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top",
    userSelect: "none"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, VM), Uz = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, cb = Pe.ie && Pe.ie_version <= 11;
let Kz = class {
  constructor(e) {
    this.view = e, this.active = !1, this.editContext = null, this.selectionRange = new EH(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let r of t)
        this.queue.push(r);
      (Pe.ie && Pe.ie_version <= 11 || Pe.ios && e.composing) && t.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && Pe.android && e.constructor.EDIT_CONTEXT !== !1 && // Chrome <126 doesn't support inverted selections in edit context (#1392)
    !(Pe.chrome && Pe.chrome_version < 126) && (this.editContext = new Jz(e), e.state.facet(Wo) && (e.contentDOM.editContext = this.editContext.editContext)), cb && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(e) {
    (e.type == "change" || !e.type) && !e.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, r) => t != e[r]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Wo) ? r.root.activeElement != this.dom : !Am(this.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (Pe.ie && Pe.ie_version <= 11 || Pe.android && Pe.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && td(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Nd(e.root);
    if (!t)
      return !1;
    let r = Pe.safari && e.root.nodeType == 11 && e.root.activeElement == this.dom && Gz(this.view, t) || t;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = Am(this.dom, r);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && OH(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = t)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Uz), cb && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), cb && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && wu(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), t == -1 ? { from: t, to: r } = o : (t = Math.min(o.from, t), r = Math.max(o.to, r)));
    }
    return { from: t, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: r } = this.processRecords(), i = this.selectionChanged && Am(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new hz(this.view, e, t, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = LM(this.view, t);
    return this.view.state == r && (t.domChanged || t.newSel && !t.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let r = g7(t, e.previousSibling || e.target.previousSibling, -1), i = g7(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? t.posAfter(r) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(e) {
    this.editContext && (this.editContext.update(e), e.startState.facet(Wo) != e.state.facet(Wo) && (e.view.contentDOM.editContext = e.state.facet(Wo) ? this.editContext.editContext : null));
  }
  destroy() {
    var e, t, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function g7(n, e, t) {
  for (; e; ) {
    let r = en.get(e);
    if (r && r.parent == n)
      return r;
    let i = e.parentNode;
    e = i != n.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function y7(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.docView.domAtPos(n.state.selection.main.anchor);
  return td(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function Gz(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return y7(n, i);
  }
  let t = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.contentDOM.addEventListener("beforeinput", r, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", r, !0), t ? y7(n, t) : null;
}
class Jz {
  constructor(e) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.composing = null, this.resetRange(e.state);
    let t = this.editContext = new window.EditContext({
      text: e.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, e.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(e.state.selection.main.head)
    });
    this.handlers.textupdate = (r) => {
      let i = e.state.selection.main, { anchor: s, head: o } = i, a = this.toEditorPos(r.updateRangeStart), l = this.toEditorPos(r.updateRangeEnd);
      e.inputState.composing >= 0 && !this.composing && (this.composing = { contextBase: r.updateRangeStart, editorBase: a, drifted: !1 });
      let c = { from: a, to: l, insert: Bt.of(r.text.split(`
`)) };
      if (c.from == this.from && s < this.from ? c.from = s : c.to == this.to && s > this.to && (c.to = s), c.from == c.to && !c.insert.length) {
        let u = ce.single(this.toEditorPos(r.selectionStart), this.toEditorPos(r.selectionEnd));
        u.main.eq(i) || e.dispatch({ selection: u, userEvent: "select" });
        return;
      }
      if ((Pe.mac || Pe.android) && c.from == o - 1 && /^\. ?$/.test(r.text) && e.contentDOM.getAttribute("autocorrect") == "off" && (c = { from: a, to: l, insert: Bt.of([r.text.replace(".", " ")]) }), this.pendingContextChange = c, !e.state.readOnly) {
        let u = this.to - this.from + (c.to - c.from + c.insert.length);
        Nw(e, c, ce.single(this.toEditorPos(r.selectionStart, u), this.toEditorPos(r.selectionEnd, u)));
      }
      this.pendingContextChange && (this.revertPending(e.state), this.setSelection(e.state)), c.from < c.to && !c.insert.length && e.inputState.composing >= 0 && !/[\\p{Alphabetic}\\p{Number}_]/.test(t.text.slice(Math.max(0, r.updateRangeStart - 1), Math.min(t.text.length, r.updateRangeStart + 1))) && this.handlers.compositionend(r);
    }, this.handlers.characterboundsupdate = (r) => {
      let i = [], s = null;
      for (let o = this.toEditorPos(r.rangeStart), a = this.toEditorPos(r.rangeEnd); o < a; o++) {
        let l = e.coordsForChar(o);
        s = l && new DOMRect(l.left, l.top, l.right - l.left, l.bottom - l.top) || s || new DOMRect(), i.push(s);
      }
      t.updateCharacterBounds(r.rangeStart, i);
    }, this.handlers.textformatupdate = (r) => {
      let i = [];
      for (let s of r.getTextFormats()) {
        let o = s.underlineStyle, a = s.underlineThickness;
        if (!/none/i.test(o) && !/none/i.test(a)) {
          let l = this.toEditorPos(s.rangeStart), c = this.toEditorPos(s.rangeEnd);
          if (l < c) {
            let u = `text-decoration: underline ${/^[a-z]/.test(o) ? o + " " : o == "Dashed" ? "dashed " : o == "Squiggle" ? "wavy " : ""}${/thin/i.test(a) ? 1 : 2}px`;
            i.push(rt.mark({ attributes: { style: u } }).range(l, c));
          }
        }
      }
      e.dispatch({ effects: wM.of(rt.set(i)) });
    }, this.handlers.compositionstart = () => {
      e.inputState.composing < 0 && (e.inputState.composing = 0, e.inputState.compositionFirstChange = !0);
    }, this.handlers.compositionend = () => {
      if (e.inputState.composing = -1, e.inputState.compositionFirstChange = null, this.composing) {
        let { drifted: r } = this.composing;
        this.composing = null, r && this.reset(e.state);
      }
    };
    for (let r in this.handlers)
      t.addEventListener(r, this.handlers[r]);
    this.measureReq = { read: (r) => {
      this.editContext.updateControlBounds(r.contentDOM.getBoundingClientRect());
      let i = Nd(r.root);
      i && i.rangeCount && this.editContext.updateSelectionBounds(i.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(e) {
    let t = 0, r = !1, i = this.pendingContextChange;
    return e.changes.iterChanges((s, o, a, l, c) => {
      if (r)
        return;
      let u = c.length - (o - s);
      if (i && o >= i.to)
        if (i.from == s && i.to == o && i.insert.eq(c)) {
          i = this.pendingContextChange = null, t += u, this.to += u;
          return;
        } else
          i = null, this.revertPending(e.state);
      if (s += t, o += t, o <= this.from)
        this.from += u, this.to += u;
      else if (s < this.to) {
        if (s < this.from || o > this.to || this.to - this.from + c.length > 3e4) {
          r = !0;
          return;
        }
        this.editContext.updateText(this.toContextPos(s), this.toContextPos(o), c.toString()), this.to += u;
      }
      t += u;
    }), i && !r && this.revertPending(e.state), !r;
  }
  update(e) {
    let t = this.pendingContextChange, r = e.startState.selection.main;
    this.composing && (this.composing.drifted || !e.changes.touchesRange(r.from, r.to) && e.transactions.some((i) => !i.isUserEvent("input.type") && i.changes.touchesRange(this.from, this.to))) ? (this.composing.drifted = !0, this.composing.editorBase = e.changes.mapPos(this.composing.editorBase)) : !this.applyEdits(e) || !this.rangeIsValid(e.state) ? (this.pendingContextChange = null, this.reset(e.state)) : (e.docChanged || e.selectionSet || t) && this.setSelection(e.state), (e.geometryChanged || e.docChanged || e.selectionSet) && e.view.requestMeasure(this.measureReq);
  }
  resetRange(e) {
    let { head: t } = e.selection.main;
    this.from = Math.max(
      0,
      t - 1e4
      /* CxVp.Margin */
    ), this.to = Math.min(
      e.doc.length,
      t + 1e4
      /* CxVp.Margin */
    );
  }
  reset(e) {
    this.resetRange(e), this.editContext.updateText(0, this.editContext.text.length, e.doc.sliceString(this.from, this.to)), this.setSelection(e);
  }
  revertPending(e) {
    let t = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(t.from), this.toContextPos(t.from + t.insert.length), e.doc.sliceString(t.from, t.to));
  }
  setSelection(e) {
    let { main: t } = e.selection, r = this.toContextPos(Math.max(this.from, Math.min(this.to, t.anchor))), i = this.toContextPos(t.head);
    (this.editContext.selectionStart != r || this.editContext.selectionEnd != i) && this.editContext.updateSelection(r, i);
  }
  rangeIsValid(e) {
    let { head: t } = e.selection.main;
    return !(this.from > 0 && t - this.from < 500 || this.to < e.doc.length && this.to - t < 500 || this.to - this.from > 1e4 * 3);
  }
  toEditorPos(e, t = this.to - this.from) {
    e = Math.min(e, t);
    let r = this.composing;
    return r && r.drifted ? r.editorBase + (e - r.contextBase) : e + this.from;
  }
  toContextPos(e) {
    let t = this.composing;
    return t && t.drifted ? t.contextBase + (e - t.editorBase) : e - this.from;
  }
  destroy() {
    for (let e in this.handlers)
      this.editContext.removeEventListener(e, this.handlers[e]);
  }
}
let $e = class Ev {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return !!this.inputState && this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return !!this.inputState && this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    var t;
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((i) => i.forEach((s) => r(s, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || LH(e.parent) || document, this.viewState = new p7(e.state || bn.create(e)), e.scrollTo && e.scrollTo.is(Np) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(gu).map((i) => new sb(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new Kz(this), this.inputState = new gz(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Jk(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), !((t = document.fonts) === null || t === void 0) && t.ready && document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Nr ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, r = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((f) => f.annotation(RM)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = PM(s, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(bn.phrases) != this.state.facet(bn.phrases))
      return this.setState(s);
    i = Og.create(this, s, e), i.flags |= a;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: m } = f.state.selection;
          h = new ku(m.empty ? m : ce.cursor(m.head, m.head > m.anchor ? -1 : 1));
        }
        for (let m of f.effects)
          m.is(Np) && (h = m.value.clip(this.state));
      }
      this.viewState.update(i, h), this.bidiCache = Ng.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(gf) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(Hp) != i.state.facet(Hp) && (this.viewState.mustMeasureContent = !0), (t || r || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), t && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(kv))
        try {
          f(i);
        } catch (m) {
          Qr(this.state, m, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !LM(this, u) && c.force && wu(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new p7(e), this.plugins = e.facet(gu).map((r) => new sb(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new Jk(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(gu), r = e.state.facet(gu);
    if (t != r) {
      let i = [];
      for (let s of r) {
        let o = t.indexOf(s);
        if (o < 0)
          i.push(new sb(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    t != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let e of this.plugins) {
      let t = e.value;
      if (t && t.docViewUpdate)
        try {
          t.docViewUpdate(this);
        } catch (r) {
          Qr(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (G9(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let m = this.viewState.scrollAnchorAt(i);
            s = m.from, o = m.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((m) => {
          try {
            return m.read(this);
          } catch (y) {
            return Qr(this.state, y), b7;
          }
        }), h = Og.create(this, this.state, []), f = !1;
        h.flags |= l, t ? t.flags |= l : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h), f && this.docViewUpdate());
        for (let m = 0; m < c.length; m++)
          if (u[m] != b7)
            try {
              let y = c[m];
              y.write && y.write(u[m], this);
            } catch (y) {
              Qr(this.state, y);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let y = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (y > 1 || y < -1) {
                i = i + y, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(kv))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Tv + " " + (this.state.facet(Mv) ? FM : zM) + " " + this.state.facet(Hp);
  }
  updateAttrs() {
    let e = v7(this, kM, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: this.state.facet(Wo) ? "true" : "false",
      class: "cm-content",
      style: `${Pe.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), v7(this, Ow, t);
    let r = this.observer.ignore(() => {
      let i = gv(this.contentDOM, this.contentAttrs, t), s = gv(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, r;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(Ev.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(gf);
    let e = this.state.facet(Ev.cspNonce);
    tl.mount(this.root, this.styleModules.concat(Wz).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.plugin != e) && this.pluginMap.set(e, t = this.plugins.find((r) => r.plugin == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt)) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line break, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, r) {
    return ab(this, e, e7(this, e, t, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return ab(this, e, e7(this, e, t, (r) => az(this, e.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, t) {
    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[t ? r.length - 1 : 0];
    return ce.cursor(s.side(t, i) + e.from, s.forward(!t, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, r = !0) {
    return oz(this, e, t, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, r) {
    return ab(this, e, lz(this, e, t, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), TM(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, t);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[ja.find(s, e - i.from, -1, t)];
    return A1(r, o.dir == pn.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(yM) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Yz)
      return cM(e.length);
    let t = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || lM(s.isolates, r = Gk(this, e))))
        return s.order;
    r || (r = Gk(this, e));
    let i = jH(e.text, t, r);
    return this.bidiCache.push(new Ng(e.from, e.to, t, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Pe.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      U9(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    this.root.activeElement == this.contentDOM && this.contentDOM.blur();
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Np.of(new ku(typeof e == "number" ? ce.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return Np.of(new ku(ce.cursor(r.from), "start", "start", r.top - e, t, !0));
  }
  /**
  Enable or disable tab-focus mode, which disables key bindings
  for Tab and Shift-Tab, letting the browser's default
  focus-changing behavior go through instead. This is useful to
  prevent trapping keyboard users in your editor.
  
  Without argument, this toggles the mode. With a boolean, it
  enables (true) or disables it (false). Given a number, it
  temporarily enables the mode until that number of milliseconds
  have passed or another non-Tab key is pressed.
  */
  setTabFocusMode(e) {
    e == null ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : typeof e == "boolean" ? this.inputState.tabFocusMode = e ? 0 : -1 : this.inputState.tabFocusMode != 0 && (this.inputState.tabFocusMode = Date.now() + e);
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return $n.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return $n.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let r = tl.newName(), i = [Hp.of(r), gf.of(Av(`.${r}`, e))];
    return t && t.dark && i.push(Mv.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return fl.lowest(gf.of(Av("." + Tv, e, VM)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let r = e.querySelector(".cm-content"), i = r && en.get(r) || en.get(e);
    return ((t = i == null ? void 0 : i.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
};
$e.styleModule = gf;
$e.inputHandler = mM;
$e.clipboardInputFilter = Ew;
$e.clipboardOutputFilter = Lw;
$e.scrollHandler = vM;
$e.focusChangeEffect = gM;
$e.perLineTextDirection = yM;
$e.exceptionSink = pM;
$e.updateListener = kv;
$e.editable = Wo;
$e.mouseSelectionStyle = dM;
$e.dragMovesSelection = fM;
$e.clickAddsSelectionRange = hM;
$e.decorations = _d;
$e.outerDecorations = xM;
$e.atomicRanges = z0;
$e.bidiIsolatedRanges = SM;
$e.scrollMargins = CM;
$e.darkTheme = Mv;
$e.cspNonce = /* @__PURE__ */ ze.define({ combine: (n) => n.length ? n[0] : "" });
$e.contentAttributes = Ow;
$e.editorAttributes = kM;
$e.lineWrapping = /* @__PURE__ */ $e.contentAttributes.of({ class: "cm-lineWrapping" });
$e.announce = /* @__PURE__ */ pt.define();
const Yz = 4096, b7 = {};
class Ng {
  constructor(e, t, r, i, s, o) {
    this.from = e, this.to = t, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : pn.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !t.touchesRange(o.from, o.to) && r.push(new Ng(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function v7(n, e, t) {
  for (let r = n.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(n) : s;
    o && mv(o, t);
  }
  return t;
}
const Xz = Pe.mac ? "mac" : Pe.windows ? "win" : Pe.linux ? "linux" : "key";
function Zz(n, e) {
  const t = n.split(/-(?!$)/);
  let r = t[t.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const c = t[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), a && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function zp(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const Qz = /* @__PURE__ */ fl.default(/* @__PURE__ */ $e.domEventHandlers({
  keydown(n, e) {
    return $M(qM(e.state), n, e, "editor");
  }
})), Lh = /* @__PURE__ */ ze.define({ enables: Qz }), w7 = /* @__PURE__ */ new WeakMap();
function qM(n) {
  let e = n.facet(Lh), t = w7.get(e);
  return t || w7.set(e, t = nF(e.reduce((r, i) => r.concat(i), []))), t;
}
function eF(n, e, t) {
  return $M(qM(n.state), e, n, t);
}
let Pa = null;
const tF = 4e3;
function nF(n, e = Xz) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, a) => {
    let l = r[o];
    if (l == null)
      r[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, c, u) => {
    var h, f;
    let m = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), y = a.split(/ (?!$)/).map((x) => Zz(x, e));
    for (let x = 1; x < y.length; x++) {
      let M = y.slice(0, x).join(" ");
      i(M, !0), m[M] || (m[M] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(T) => {
          let E = Pa = { view: T, prefix: M, scope: o };
          return setTimeout(() => {
            Pa == E && (Pa = null);
          }, tF), !0;
        }]
      });
    }
    let b = y.join(" ");
    i(b, !1);
    let k = m[b] || (m[b] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = m._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && k.run.push(l), c && (k.preventDefault = !0), u && (k.stopPropagation = !0);
  };
  for (let o of n) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        let { any: h } = o;
        for (let f in u)
          u[f].run.push((m) => h(m, Lv));
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
let Lv = null;
function $M(n, e, t, r) {
  Lv = e;
  let i = $9(e), s = Yr(i, 0), o = Ws(s) == i.length && i != " ", a = "", l = !1, c = !1, u = !1;
  Pa && Pa.view == t && Pa.scope == r && (a = Pa.prefix + " ", DM.indexOf(e.keyCode) < 0 && (c = !0, Pa = null));
  let h = /* @__PURE__ */ new Set(), f = (k) => {
    if (k) {
      for (let x of k.run)
        if (!h.has(x) && (h.add(x), x(t)))
          return k.stopPropagation && (u = !0), !0;
      k.preventDefault && (k.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, m = n[r], y, b;
  return m && (f(m[a + zp(i, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Pe.windows && e.ctrlKey && e.altKey) && // Alt-combinations on macOS tend to be typed characters
  !(Pe.mac && e.altKey && !(e.ctrlKey || e.metaKey)) && (y = ia[e.keyCode]) && y != i ? (f(m[a + zp(y, e, !0)]) || e.shiftKey && (b = Dd[e.keyCode]) != i && b != y && f(m[a + zp(b, e, !1)])) && (l = !0) : o && e.shiftKey && f(m[a + zp(i, e, !0)]) && (l = !0), !l && f(m._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), Lv = null, l;
}
class F0 {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, r, i, s) {
    this.className = e, this.left = t, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = jM(e);
      return [new F0(t, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return rF(e, t, r);
  }
}
function jM(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == pn.LTR ? e.left : e.right - n.scrollDOM.clientWidth * n.scaleX) - n.scrollDOM.scrollLeft * n.scaleX, top: e.top - n.scrollDOM.scrollTop * n.scaleY };
}
function k7(n, e, t, r) {
  let i = n.coordsAtPos(e, t * 2);
  if (!i)
    return r;
  let s = n.dom.getBoundingClientRect(), o = (i.top + i.bottom) / 2, a = n.posAtCoords({ x: s.left + 1, y: o }), l = n.posAtCoords({ x: s.right - 1, y: o });
  return a == null || l == null ? r : { from: Math.max(r.from, Math.min(a, l)), to: Math.min(r.to, Math.max(a, l)) };
}
function rF(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let r = Math.max(t.from, n.viewport.from), i = Math.min(t.to, n.viewport.to), s = n.textDirection == pn.LTR, o = n.contentDOM, a = o.getBoundingClientRect(), l = jM(n), c = o.querySelector(".cm-line"), u = c && window.getComputedStyle(c), h = a.left + (u ? parseInt(u.paddingLeft) + Math.min(0, parseInt(u.textIndent)) : 0), f = a.right - (u ? parseInt(u.paddingRight) : 0), m = Sv(n, r, 1), y = Sv(n, i, -1), b = m.type == Ir.Text ? m : null, k = y.type == Ir.Text ? y : null;
  if (b && (n.lineWrapping || m.widgetLineBreaks) && (b = k7(n, r, 1, b)), k && (n.lineWrapping || y.widgetLineBreaks) && (k = k7(n, i, -1, k)), b && k && b.from == k.from && b.to == k.to)
    return M(T(t.from, t.to, b));
  {
    let C = b ? T(t.from, null, b) : E(m, !1), O = k ? T(null, t.to, k) : E(y, !0), R = [];
    return (b || m).to < (k || y).from - (b && k ? 1 : 0) || m.widgetLineBreaks > 1 && C.bottom + n.defaultLineHeight / 2 < O.top ? R.push(x(h, C.bottom, f, O.top)) : C.bottom < O.top && n.elementAtHeight((C.bottom + O.top) / 2).type == Ir.Text && (C.bottom = O.top = (C.bottom + O.top) / 2), M(C).concat(R).concat(M(O));
  }
  function x(C, O, R, F) {
    return new F0(e, C - l.left, O - l.top, R - C, F - O);
  }
  function M({ top: C, bottom: O, horizontal: R }) {
    let F = [];
    for (let H = 0; H < R.length; H += 2)
      F.push(x(R[H], C, R[H + 1], O));
    return F;
  }
  function T(C, O, R) {
    let F = 1e9, H = -1e9, z = [];
    function K(ie, he, Ie, Oe, Ne) {
      let We = n.coordsAtPos(ie, ie == R.to ? -2 : 2), q = n.coordsAtPos(Ie, Ie == R.from ? 2 : -2);
      !We || !q || (F = Math.min(We.top, q.top, F), H = Math.max(We.bottom, q.bottom, H), Ne == pn.LTR ? z.push(s && he ? h : We.left, s && Oe ? f : q.right) : z.push(!s && Oe ? h : q.left, !s && he ? f : We.right));
    }
    let U = C ?? R.from, ae = O ?? R.to;
    for (let ie of n.visibleRanges)
      if (ie.to > U && ie.from < ae)
        for (let he = Math.max(ie.from, U), Ie = Math.min(ie.to, ae); ; ) {
          let Oe = n.state.doc.lineAt(he);
          for (let Ne of n.bidiSpans(Oe)) {
            let We = Ne.from + Oe.from, q = Ne.to + Oe.from;
            if (We >= Ie)
              break;
            q > he && K(Math.max(We, he), C == null && We <= U, Math.min(q, Ie), O == null && q >= ae, Ne.dir);
          }
          if (he = Oe.to + 1, he >= Ie)
            break;
        }
    return z.length == 0 && K(U, C == null, ae, O == null, n.textDirection), { top: F, bottom: H, horizontal: z };
  }
  function E(C, O) {
    let R = a.top + (O ? C.top : C.bottom);
    return { top: R, bottom: R, horizontal: [] };
  }
}
function iF(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class sF {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Om) != e.state.facet(Om) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  docViewUpdate(e) {
    this.layer.updateOnDocViewUpdate !== !1 && e.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, r = e.facet(Om);
    for (; t < r.length && r[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: t } = this.view;
    (e != this.scaleX || t != this.scaleY) && (this.scaleX = e, this.scaleY = t, this.dom.style.transform = `scale(${1 / e}, ${1 / t})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, r) => !iF(t, this.drawn[r]))) {
      let t = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[r].constructor && i.update(t, this.drawn[r]) ? (t = t.nextSibling, r++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e, Pe.ios && (this.dom.style.display = this.dom.firstChild ? "" : "none");
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Om = /* @__PURE__ */ ze.define();
function WM(n) {
  return [
    $n.define((e) => new sF(e, n)),
    Om.of(n)
  ];
}
const Rd = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function UM(n = {}) {
  return [
    Rd.of(n),
    oF,
    aF,
    lF,
    bM.of(!0)
  ];
}
function KM(n) {
  return n.startState.facet(Rd) != n.state.facet(Rd);
}
const oF = /* @__PURE__ */ WM({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(Rd), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty || t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = i.empty ? i : ce.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let l of F0.forRange(n, o, a))
          r.push(l);
      }
    }
    return r;
  },
  update(n, e) {
    n.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = KM(n);
    return t && x7(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    x7(e.state, n);
  },
  class: "cm-cursorLayer"
});
function x7(n, e) {
  e.style.animationDuration = n.facet(Rd).cursorBlinkRate + "ms";
}
const aF = /* @__PURE__ */ WM({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : F0.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || KM(n);
  },
  class: "cm-selectionLayer"
}), lF = /* @__PURE__ */ fl.highest(/* @__PURE__ */ $e.theme({
  ".cm-line": {
    "& ::selection, &::selection": { backgroundColor: "transparent !important" },
    caretColor: "transparent !important"
  },
  ".cm-content": {
    caretColor: "transparent !important",
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
})), GM = /* @__PURE__ */ pt.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), vf = /* @__PURE__ */ rr.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, r) => r.is(GM) ? r.value : t, n);
  }
}), cF = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(vf);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(vf) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: n } = this, e = n.state.field(vf), t = e != null && n.coordsAtPos(e);
    if (!t)
      return null;
    let r = n.scrollDOM.getBoundingClientRect();
    return {
      left: t.left - r.left + n.scrollDOM.scrollLeft * n.scaleX,
      top: t.top - r.top + n.scrollDOM.scrollTop * n.scaleY,
      height: t.bottom - t.top
    };
  }
  drawCursor(n) {
    if (this.cursor) {
      let { scaleX: e, scaleY: t } = this.view;
      n ? (this.cursor.style.left = n.left / e + "px", this.cursor.style.top = n.top / t + "px", this.cursor.style.height = n.height / t + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(vf) != n && this.view.dispatch({ effects: GM.of(n) });
  }
}, {
  eventObservers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function uF() {
  return [vf, cF];
}
function S7(n, e, t, r, i) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, r), o = t, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        i(o + a.index, a);
}
function hF(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let r = [];
  for (let { from: i, to: s } of t)
    i = Math.max(n.state.doc.lineAt(i).from, i - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class fF {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
    else if (typeof r == "function")
      this.addMatch = (a, l, c, u) => {
        let h = r(a, l, c);
        h && u(c, c + a[0].length, h);
      };
    else if (r)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new ra(), r = t.add.bind(t);
    for (let { from: i, to: s } of hF(e, this.maxLength))
      S7(e.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, e, o, r));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {
      l >= e.view.viewport.from && a <= e.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));
    }), e.viewportMoved || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), r, i) : t;
  }
  updateRange(e, t, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), a = Math.min(s.to, i);
      if (a >= o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), h = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              h = a;
              break;
            }
        }
        let f = [], m, y = (b, k, x) => f.push(x.range(b, k));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (m = this.regexp.exec(l.text)) && m.index < h - l.from; )
            this.addMatch(m, e, m.index + l.from, y);
        else
          S7(e.state.doc, this.regexp, u, h, (b, k) => this.addMatch(k, e, b, y));
        t = t.update({ filterFrom: u, filterTo: h, filter: (b, k) => b < u || k > h, add: f });
      }
    }
    return t;
  }
}
const Ov = /x/.unicode != null ? "gu" : "g", dF = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Ov), pF = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let ub = null;
function mF() {
  var n;
  if (ub == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    ub = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return ub || !1;
}
const Dm = /* @__PURE__ */ ze.define({
  combine(n) {
    let e = lo(n, {
      render: null,
      specialChars: dF,
      addSpecialChars: null
    });
    return (e.replaceTabs = !mF()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Ov)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Ov)), e;
  }
});
function gF(n = {}) {
  return [Dm.of(n), yF()];
}
let C7 = null;
function yF() {
  return C7 || (C7 = $n.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = rt.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(Dm)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new fF({
        regexp: n.specialChars,
        decoration: (e, t, r) => {
          let { doc: i } = t.state, s = Yr(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), a = t.state.tabSize, l = Eh(o.text, a, r - o.from);
            return rt.replace({
              widget: new kF((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = rt.replace({ widget: new wF(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(Dm);
      n.startState.facet(Dm) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const bF = "•";
function vF(n) {
  return n >= 32 ? bF : n == 10 ? "␤" : String.fromCharCode(9216 + n);
}
class wF extends da {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = vF(this.code), r = e.state.phrase("Control character") + " " + (pF[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, t);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = t, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class kF extends da {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function xF() {
  return CF;
}
const SF = /* @__PURE__ */ rt.line({ class: "cm-activeLine" }), CF = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let r of n.state.selection.ranges) {
      let i = n.lineBlockAt(r.head);
      i.from > e && (t.push(SF.range(i.from)), e = i.from);
    }
    return rt.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), Dv = 2e3;
function MF(n, e, t) {
  let r = Math.min(e.line, t.line), i = Math.max(e.line, t.line), s = [];
  if (e.off > Dv || t.off > Dv || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = r; l <= i; l++) {
      let c = n.doc.line(l);
      c.length <= a && s.push(ce.range(c.from + o, c.to + a));
    }
  } else {
    let o = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = r; l <= i; l++) {
      let c = n.doc.line(l), u = lv(c.text, o, n.tabSize, !0);
      if (u < 0)
        s.push(ce.cursor(c.to));
      else {
        let h = lv(c.text, a, n.tabSize);
        s.push(ce.range(c.from + u, c.from + h));
      }
    }
  }
  return s;
}
function TF(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function M7(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = n.state.doc.lineAt(t), i = t - r.from, s = i > Dv ? -1 : i == r.length ? TF(n, e.clientX) : Eh(r.text, n.state.tabSize, t - r.from);
  return { line: r.number, col: s, off: i };
}
function AF(n, e) {
  let t = M7(n, e), r = n.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(t.line).from), o = i.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let a = M7(n, i);
      if (!a)
        return r;
      let l = MF(n.state, t, a);
      return l.length ? o ? ce.create(l.concat(r.ranges)) : ce.create(l) : r;
    }
  } : null;
}
function EF(n) {
  let e = (t) => t.altKey && t.button == 0;
  return $e.mouseSelectionStyle.of((t, r) => e(r) ? AF(t, r) : null);
}
const LF = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, OF = { style: "cursor: crosshair" };
function DF(n = {}) {
  let [e, t] = LF[n.key || "Alt"], r = $n.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    r,
    $e.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? OF : null;
    })
  ];
}
const ef = "-10000px";
class JM {
  constructor(e, t, r, i) {
    this.facet = t, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));
  }
  update(e, t) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = t ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l], u = -1;
      if (c) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let f = this.tooltips[h];
          f && f.create == c.create && (u = h);
        }
        if (u < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let h = o[l] = this.tooltipViews[u];
          a && (a[l] = t[u]), h.update && h.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return t && (a.forEach((l, c) => t[c] = l), t.length = a.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function NF(n) {
  let e = n.dom.ownerDocument.documentElement;
  return { top: 0, left: 0, bottom: e.clientHeight, right: e.clientWidth };
}
const hb = /* @__PURE__ */ ze.define({
  combine: (n) => {
    var e, t, r;
    return {
      position: Pe.ios ? "absolute" : ((e = n.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((r = n.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || NF
    };
  }
}), T7 = /* @__PURE__ */ new WeakMap(), Rw = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.view = n, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(hb);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new JM(n, Pw, (t, r) => this.createTooltip(t, r), (t) => {
      this.resizeObserver && this.resizeObserver.unobserve(t.dom), t.dom.remove();
    }), this.above = this.manager.tooltips.map((t) => !!t.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n, this.above);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, r = n.state.facet(hb);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n, e) {
    let t = n.create(this.view), r = e ? e.dom : null;
    if (t.dom.classList.add("cm-tooltip"), n.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", t.dom.appendChild(i);
    }
    return t.dom.style.position = this.position, t.dom.style.top = ef, t.dom.style.left = "0px", this.container.insertBefore(t.dom, r), t.mount && t.mount(this.view), this.resizeObserver && this.resizeObserver.observe(t.dom), t;
  }
  destroy() {
    var n, e, t;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (n = r.destroy) === null || n === void 0 || n.call(r);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (t = this.intersectionObserver) === null || t === void 0 || t.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = 1, e = 1, t = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: s } = this.manager.tooltipViews[0];
      if (Pe.gecko)
        t = s.offsetParent != this.container.ownerDocument.body;
      else if (s.style.top == ef && s.style.left == "0px") {
        let o = s.getBoundingClientRect();
        t = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (t || this.position == "absolute")
      if (this.parent) {
        let s = this.parent.getBoundingClientRect();
        s.width && s.height && (n = s.width / this.parent.offsetWidth, e = s.height / this.parent.offsetHeight);
      } else
        ({ scaleX: n, scaleY: e } = this.view.viewState);
    let r = this.view.scrollDOM.getBoundingClientRect(), i = Dw(this.view);
    return {
      visible: {
        left: r.left + i.left,
        top: r.top + i.top,
        right: r.right - i.right,
        bottom: r.bottom - i.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((s, o) => {
        let a = this.manager.tooltipViews[o];
        return a.getCoords ? a.getCoords(s.pos) : this.view.coordsAtPos(s.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: s }) => s.getBoundingClientRect()),
      space: this.view.state.facet(hb).tooltipSpace(this.view),
      scaleX: n,
      scaleY: e,
      makeAbsolute: t
    };
  }
  writeMeasure(n) {
    var e;
    if (n.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { visible: t, space: r, scaleX: i, scaleY: s } = n, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, h = n.pos[a], f = n.size[a];
      if (!h || l.clip !== !1 && (h.bottom <= Math.max(t.top, r.top) || h.top >= Math.min(t.bottom, r.bottom) || h.right < Math.max(t.left, r.left) - 0.1 || h.left > Math.min(t.right, r.right) + 0.1)) {
        u.style.top = ef;
        continue;
      }
      let m = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, y = m ? 7 : 0, b = f.right - f.left, k = (e = T7.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, x = c.offset || _F, M = this.view.textDirection == pn.LTR, T = f.width > r.right - r.left ? M ? r.left : r.right - f.width : M ? Math.max(r.left, Math.min(h.left - (m ? 14 : 0) + x.x, r.right - b)) : Math.min(Math.max(r.left, h.left - b + (m ? 14 : 0) - x.x), r.right - b), E = this.above[a];
      !l.strictSide && (E ? h.top - k - y - x.y < r.top : h.bottom + k + y + x.y > r.bottom) && E == r.bottom - h.bottom > h.top - r.top && (E = this.above[a] = !E);
      let C = (E ? h.top - r.top : r.bottom - h.bottom) - y;
      if (C < k && c.resize !== !1) {
        if (C < this.view.defaultLineHeight) {
          u.style.top = ef;
          continue;
        }
        T7.set(c, k), u.style.height = (k = C) / s + "px";
      } else u.style.height && (u.style.height = "");
      let O = E ? h.top - k - y - x.y : h.bottom + y + x.y, R = T + b;
      if (c.overlap !== !0)
        for (let F of o)
          F.left < R && F.right > T && F.top < O + k && F.bottom > O && (O = E ? F.top - k - 2 - y : F.bottom + y + 2);
      if (this.position == "absolute" ? (u.style.top = (O - n.parent.top) / s + "px", A7(u, (T - n.parent.left) / i)) : (u.style.top = O / s + "px", A7(u, T / i)), m) {
        let F = h.left + (M ? x.x : -x.x) - (T + 14 - 7);
        m.style.left = F / i + "px";
      }
      c.overlap !== !0 && o.push({ left: T, top: O, right: R, bottom: O + k }), u.classList.toggle("cm-tooltip-above", E), u.classList.toggle("cm-tooltip-below", !E), c.positioned && c.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = ef;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function A7(n, e) {
  let t = parseInt(n.style.left, 10);
  (isNaN(t) || Math.abs(e - t) > 1) && (n.style.left = e + "px");
}
const IF = /* @__PURE__ */ $e.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), _F = { x: 0, y: 0 }, Pw = /* @__PURE__ */ ze.define({
  enables: [Rw, IF]
}), Ig = /* @__PURE__ */ ze.define({
  combine: (n) => n.reduce((e, t) => e.concat(t), [])
});
class O1 {
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new O1(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new JM(e, Ig, (t, r) => this.createHostedView(t, r), (t) => t.dom.remove());
  }
  createHostedView(e, t) {
    let r = e.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, t ? t.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
  passProp(e) {
    let t;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (t === void 0)
          t = i;
        else if (t !== i)
          return;
      }
    }
    return t;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const RF = /* @__PURE__ */ Pw.compute([Ig], (n) => {
  let e = n.facet(Ig);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.map((t) => {
      var r;
      return (r = t.end) !== null && r !== void 0 ? r : t.pos;
    })),
    create: O1.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class PF {
  constructor(e, t, r, i, s) {
    this.view = e, this.source = t, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, r = e.docView.nearest(t.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof $a)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(t), i == null)
        return;
      let a = e.coordsAtPos(i);
      if (!a || t.y < a.top || t.y > a.bottom || t.x < a.left - e.defaultCharacterWidth || t.x > a.right + e.defaultCharacterWidth)
        return;
      let l = e.bidiSpans(e.state.doc.lineAt(i)).find((u) => u.from <= i && u.to >= i), c = l && l.dir == pn.RTL ? -1 : 1;
      s = t.x < a.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let a = this.pending = { pos: i };
      o.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => Qr(e.state, l, "hover tooltip"));
    } else o && !(Array.isArray(o) && !o.length) && e.dispatch({ effects: this.setHover.of(Array.isArray(o) ? o : [o]) });
  }
  get tooltip() {
    let e = this.view.plugin(Rw), t = e ? e.manager.tooltips.findIndex((r) => r.create == O1.create) : -1;
    return t > -1 ? e.manager.tooltipViews[t] : null;
  }
  mousemove(e) {
    var t, r;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: s } = this;
    if (i.length && s && !BF(s.dom, e) || this.pending) {
      let { pos: o } = i[0] || this.pending, a = (r = (t = i[0]) === null || t === void 0 ? void 0 : t.end) !== null && r !== void 0 ? r : o;
      (o == a ? this.view.posAtCoords(this.lastMove) != o : !HF(this.view, o, a, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: t } = this;
    if (t.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(e) {
    let t = (r) => {
      e.removeEventListener("mouseleave", t), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    e.addEventListener("mouseleave", t);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const Fp = 4;
function BF(n, e) {
  let { left: t, right: r, top: i, bottom: s } = n.getBoundingClientRect(), o;
  if (o = n.querySelector(".cm-tooltip-arrow")) {
    let a = o.getBoundingClientRect();
    i = Math.min(a.top, i), s = Math.max(a.bottom, s);
  }
  return e.clientX >= t - Fp && e.clientX <= r + Fp && e.clientY >= i - Fp && e.clientY <= s + Fp;
}
function HF(n, e, t, r, i, s) {
  let o = n.scrollDOM.getBoundingClientRect(), a = n.documentTop + n.documentPadding.top + n.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, a) < i)
    return !1;
  let l = n.posAtCoords({ x: r, y: i }, !1);
  return l >= e && l <= t;
}
function zF(n, e = {}) {
  let t = pt.define(), r = rr.define({
    create() {
      return [];
    },
    update(i, s) {
      if (i.length && (e.hideOnChange && (s.docChanged || s.selection) ? i = [] : e.hideOn && (i = i.filter((o) => !e.hideOn(s, o))), s.docChanged)) {
        let o = [];
        for (let a of i) {
          let l = s.changes.mapPos(a.pos, -1, hr.TrackDel);
          if (l != null) {
            let c = Object.assign(/* @__PURE__ */ Object.create(null), a);
            c.pos = l, c.end != null && (c.end = s.changes.mapPos(c.end)), o.push(c);
          }
        }
        i = o;
      }
      for (let o of s.effects)
        o.is(t) && (i = o.value), o.is(FF) && (i = []);
      return i;
    },
    provide: (i) => Ig.from(i)
  });
  return {
    active: r,
    extension: [
      r,
      $n.define((i) => new PF(
        i,
        n,
        r,
        t,
        e.hoverTime || 300
        /* Hover.Time */
      )),
      RF
    ]
  };
}
function YM(n, e) {
  let t = n.plugin(Rw);
  if (!t)
    return null;
  let r = t.manager.tooltips.indexOf(e);
  return r < 0 ? null : t.manager.tooltipViews[r];
}
const FF = /* @__PURE__ */ pt.define(), E7 = /* @__PURE__ */ ze.define({
  combine(n) {
    let e, t;
    for (let r of n)
      e = e || r.topContainer, t = t || r.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Pd(n, e) {
  let t = n.plugin(XM), r = t ? t.specs.indexOf(e) : -1;
  return r > -1 ? t.panels[r] : null;
}
const XM = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(Bd), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(E7);
    this.top = new Vp(n, !0, e.topContainer), this.bottom = new Vp(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(E7);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Vp(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Vp(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(Bd);
    if (t != this.input) {
      let r = t.filter((l) => l), i = [], s = [], o = [], a = [];
      for (let l of r) {
        let c = this.specs.indexOf(l), u;
        c < 0 ? (u = l(n.view), a.push(u)) : (u = this.panels[c], u.update && u.update(n)), i.push(u), (u.top ? s : o).push(u);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => $e.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Vp {
  constructor(e, t, r) {
    this.view = e, this.top = t, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = L7(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = L7(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function L7(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const Bd = /* @__PURE__ */ ze.define({
  enables: XM
});
class oa extends xc {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
oa.prototype.elementClass = "";
oa.prototype.toDOM = void 0;
oa.prototype.mapMode = hr.TrackBefore;
oa.prototype.startSide = oa.prototype.endSide = -1;
oa.prototype.point = !0;
const Nm = /* @__PURE__ */ ze.define(), VF = /* @__PURE__ */ ze.define(), qF = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Ht.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {},
  side: "before"
}, id = /* @__PURE__ */ ze.define();
function $F(n) {
  return [ZM(), id.of({ ...qF, ...n })];
}
const O7 = /* @__PURE__ */ ze.define({
  combine: (n) => n.some((e) => e)
});
function ZM(n) {
  return [
    jF
  ];
}
const jF = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.view = n, this.domAfter = null, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters cm-gutters-before", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(id).map((e) => new N7(n, e)), this.fixed = !n.state.facet(O7);
    for (let e of this.gutters)
      e.config.side == "after" ? this.getDOMAfter().appendChild(e.dom) : this.dom.appendChild(e.dom);
    this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  getDOMAfter() {
    return this.domAfter || (this.domAfter = document.createElement("div"), this.domAfter.className = "cm-gutters cm-gutters-after", this.domAfter.setAttribute("aria-hidden", "true"), this.domAfter.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.domAfter.style.position = this.fixed ? "sticky" : "", this.view.scrollDOM.appendChild(this.domAfter)), this.domAfter;
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, r = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(r < (t.to - t.from) * 0.8);
    }
    if (n.geometryChanged) {
      let e = this.view.contentHeight / this.view.scaleY + "px";
      this.dom.style.minHeight = e, this.domAfter && (this.domAfter.style.minHeight = e);
    }
    this.view.state.facet(O7) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : "", this.domAfter && (this.domAfter.style.position = this.fixed ? "sticky" : "")), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && (this.dom.remove(), this.domAfter && this.domAfter.remove());
    let t = Ht.iter(this.view.state.facet(Nm), this.view.viewport.from), r = [], i = this.gutters.map((s) => new WF(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Ir.Text && o) {
            Nv(t, r, a.from);
            for (let l of i)
              l.line(this.view, a, r);
            o = !1;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (s.type == Ir.Text) {
        Nv(t, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    n && (this.view.scrollDOM.insertBefore(this.dom, e), this.domAfter && this.view.scrollDOM.appendChild(this.domAfter));
  }
  updateGutters(n) {
    let e = n.startState.facet(id), t = n.state.facet(id), r = n.docChanged || n.heightChanged || n.viewportChanged || !Ht.eq(n.startState.facet(Nm), n.state.facet(Nm), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(n) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new N7(this.view, s)) : (this.gutters[o].update(n), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        s.config.side == "after" ? this.getDOMAfter().appendChild(s.dom) : this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove(), this.domAfter && this.domAfter.remove();
  }
}, {
  provide: (n) => $e.scrollMargins.of((e) => {
    let t = e.plugin(n);
    if (!t || t.gutters.length == 0 || !t.fixed)
      return null;
    let r = t.dom.offsetWidth * e.scaleX, i = t.domAfter ? t.domAfter.offsetWidth * e.scaleX : 0;
    return e.textDirection == pn.LTR ? { left: r, right: i } : { right: r, left: i };
  })
});
function D7(n) {
  return Array.isArray(n) ? n : [n];
}
function Nv(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class WF {
  constructor(e, t, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = Ht.iter(e.markers, t.from);
  }
  addElement(e, t, r) {
    let { gutter: i } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new QM(e, o, s, r);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = t.bottom, this.i++;
  }
  line(e, t, r) {
    let i = [];
    Nv(this.cursor, i, t.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, t, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, i);
  }
  widget(e, t) {
    let r = this.gutter.config.widgetMarker(e, t.widget, t), i = r ? [r] : null;
    for (let s of e.state.facet(VF)) {
      let o = s(e, t.widget, t);
      o && (i || (i = [])).push(o);
    }
    i && this.addElement(e, t, i);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class N7 {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in t.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = i.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[r](e, a, i) && i.preventDefault();
      });
    this.markers = D7(t.markers(e)), t.initialSpacer && (this.spacer = new QM(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = D7(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !Ht.eq(this.markers, t, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class QM {
  constructor(e, t, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, r, i);
  }
  update(e, t, r, i) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), UF(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < t.length ? t[s++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (r += " " + u);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            a = h, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && o++;
    }
    this.dom.className = r, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function UF(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const KF = /* @__PURE__ */ ze.define(), GF = /* @__PURE__ */ ze.define(), yu = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let r = Object.assign({}, e);
        for (let i in t) {
          let s = r[i], o = t[i];
          r[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
        }
        return r;
      }
    });
  }
});
class fb extends oa {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function db(n, e) {
  return n.state.facet(yu).formatNumber(e, n.state);
}
const JF = /* @__PURE__ */ id.compute([yu], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(KF);
  },
  lineMarker(e, t, r) {
    return r.some((i) => i.toDOM) ? null : new fb(db(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: (e, t, r) => {
    for (let i of e.state.facet(GF)) {
      let s = i(e, t, r);
      if (s)
        return s;
    }
    return null;
  },
  lineMarkerChange: (e) => e.startState.facet(yu) != e.state.facet(yu),
  initialSpacer(e) {
    return new fb(db(e, I7(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let r = db(t.view, I7(t.view.state.doc.lines));
    return r == e.number ? e : new fb(r);
  },
  domEventHandlers: n.facet(yu).domEventHandlers,
  side: "before"
}));
function YF(n = {}) {
  return [
    yu.of(n),
    ZM(),
    JF
  ];
}
function I7(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const XF = /* @__PURE__ */ new class extends oa {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), ZF = /* @__PURE__ */ Nm.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.head).from;
    i > t && (t = i, e.push(XF.range(i)));
  }
  return Ht.of(e);
});
function QF() {
  return ZF;
}
let eV = 0;
class zi {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.set = t, this.base = r, this.modified = i, this.id = eV++;
  }
  toString() {
    let { name: e } = this;
    for (let t of this.modified)
      t.name && (e = `${t.name}(${e})`);
    return e;
  }
  static define(e, t) {
    let r = typeof e == "string" ? e : "?";
    if (e instanceof zi && (t = e), t != null && t.base)
      throw new Error("Can not derive from a modified tag");
    let i = new zi(r, [], null, []);
    if (i.set.push(i), t)
      for (let s of t.set)
        i.set.push(s);
    return i;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(e) {
    let t = new _g(e);
    return (r) => r.modified.indexOf(t) > -1 ? r : _g.get(r.base || r, r.modified.concat(t).sort((i, s) => i.id - s.id));
  }
}
let tV = 0;
class _g {
  constructor(e) {
    this.name = e, this.instances = [], this.id = tV++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let r = t[0].instances.find((a) => a.base == e && nV(t, a.modified));
    if (r)
      return r;
    let i = [], s = new zi(e.name, i, e, t);
    for (let a of t)
      a.instances.push(s);
    let o = rV(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          i.push(_g.get(a, l));
    return s;
  }
}
function nV(n, e) {
  return n.length == e.length && n.every((t, r) => t == e[r]);
}
function rV(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(n[t]));
  return e.sort((t, r) => r.length - t.length);
}
function iV(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    Array.isArray(r) || (r = [r]);
    for (let i of t.split(" "))
      if (i) {
        let s = [], o = 2, a = i;
        for (let h = 0; ; ) {
          if (a == "..." && h > 0 && h + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == i.length)
            break;
          let m = i[h++];
          if (h == i.length && m == "!") {
            o = 0;
            break;
          }
          if (m != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(h);
        }
        let l = s.length - 1, c = s[l];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new Rg(r, o, l > 0 ? s.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return eT.add(e);
}
const eT = new Mt();
class Rg {
  constructor(e, t, r, i) {
    this.tags = e, this.mode = t, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rg.empty = new Rg([], 2, null);
function tT(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let a of s)
        for (let l of a.set) {
          let c = t[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function sV(n, e) {
  let t = null;
  for (let r of n) {
    let i = r.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function oV(n, e, t, r = 0, i = n.length) {
  let s = new aV(r, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class aV {
  constructor(e, t, r) {
    this.at = e, this.highlighters = t, this.span = r, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, r, i, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= r || l <= t)
      return;
    o.isTop && (s = this.highlighters.filter((m) => !m.scope || m.scope(o)));
    let c = i, u = lV(e) || Rg.empty, h = sV(s, u.tags);
    if (h && (c && (c += " "), c += h, u.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(Math.max(t, a), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(Mt.mounted);
    if (f && f.overlay) {
      let m = e.node.enter(f.overlay[0].from + a, 1), y = this.highlighters.filter((k) => !k.scope || k.scope(f.tree.type)), b = e.firstChild();
      for (let k = 0, x = a; ; k++) {
        let M = k < f.overlay.length ? f.overlay[k] : null, T = M ? M.from + a : l, E = Math.max(t, x), C = Math.min(r, T);
        if (E < C && b)
          for (; e.from < C && (this.highlightRange(e, E, C, i, s), this.startSpan(Math.min(C, e.to), c), !(e.to >= T || !e.nextSibling())); )
            ;
        if (!M || T > r)
          break;
        x = M.to + a, x > t && (this.highlightRange(m.cursor(), Math.max(t, M.from + a), Math.min(r, x), "", y), this.startSpan(Math.min(r, x), c));
      }
      b && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, t, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function lV(n) {
  let e = n.type.prop(eT);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const Le = zi.define, qp = Le(), Da = Le(), _7 = Le(Da), R7 = Le(Da), Na = Le(), $p = Le(Na), pb = Le(Na), zs = Le(), Ll = Le(zs), Bs = Le(), Hs = Le(), Iv = Le(), tf = Le(Iv), jp = Le(), se = {
  /**
  A comment.
  */
  comment: qp,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Le(qp),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Le(qp),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Le(qp),
  /**
  Any kind of identifier.
  */
  name: Da,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Le(Da),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: _7,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Le(_7),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: R7,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Le(R7),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Le(Da),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Le(Da),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Le(Da),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Le(Da),
  /**
  A literal value.
  */
  literal: Na,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: $p,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Le($p),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Le($p),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Le($p),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: pb,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Le(pb),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Le(pb),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Le(Na),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Le(Na),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Le(Na),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Le(Na),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Le(Na),
  /**
  A language keyword.
  */
  keyword: Bs,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Le(Bs),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Le(Bs),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Le(Bs),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Le(Bs),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Le(Bs),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Le(Bs),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Le(Bs),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Le(Bs),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Le(Bs),
  /**
  An operator.
  */
  operator: Hs,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Le(Hs),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Le(Hs),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Le(Hs),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Le(Hs),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Le(Hs),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Le(Hs),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Le(Hs),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Le(Hs),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Le(Hs),
  /**
  Program or markup punctuation.
  */
  punctuation: Iv,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Le(Iv),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: tf,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Le(tf),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Le(tf),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Le(tf),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Le(tf),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: zs,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Ll,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Le(Ll),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Le(Ll),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Le(Ll),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Le(Ll),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Le(Ll),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Le(Ll),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: Le(zs),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Le(zs),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Le(zs),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Le(zs),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Le(zs),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Le(zs),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Le(zs),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Le(zs),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Le(),
  /**
  Deleted text.
  */
  deleted: Le(),
  /**
  Changed text.
  */
  changed: Le(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Le(),
  /**
  Metadata or meta-instruction.
  */
  meta: jp,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Le(jp),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Le(jp),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Le(jp),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: zi.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: zi.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: zi.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: zi.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: zi.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: zi.defineModifier("special")
};
for (let n in se) {
  let e = se[n];
  e instanceof zi && (e.name = n);
}
tT([
  { tag: se.link, class: "tok-link" },
  { tag: se.heading, class: "tok-heading" },
  { tag: se.emphasis, class: "tok-emphasis" },
  { tag: se.strong, class: "tok-strong" },
  { tag: se.keyword, class: "tok-keyword" },
  { tag: se.atom, class: "tok-atom" },
  { tag: se.bool, class: "tok-bool" },
  { tag: se.url, class: "tok-url" },
  { tag: se.labelName, class: "tok-labelName" },
  { tag: se.inserted, class: "tok-inserted" },
  { tag: se.deleted, class: "tok-deleted" },
  { tag: se.literal, class: "tok-literal" },
  { tag: se.string, class: "tok-string" },
  { tag: se.number, class: "tok-number" },
  { tag: [se.regexp, se.escape, se.special(se.string)], class: "tok-string2" },
  { tag: se.variableName, class: "tok-variableName" },
  { tag: se.local(se.variableName), class: "tok-variableName tok-local" },
  { tag: se.definition(se.variableName), class: "tok-variableName tok-definition" },
  { tag: se.special(se.variableName), class: "tok-variableName2" },
  { tag: se.definition(se.propertyName), class: "tok-propertyName tok-definition" },
  { tag: se.typeName, class: "tok-typeName" },
  { tag: se.namespace, class: "tok-namespace" },
  { tag: se.className, class: "tok-className" },
  { tag: se.macroName, class: "tok-macroName" },
  { tag: se.propertyName, class: "tok-propertyName" },
  { tag: se.operator, class: "tok-operator" },
  { tag: se.comment, class: "tok-comment" },
  { tag: se.meta, class: "tok-meta" },
  { tag: se.invalid, class: "tok-invalid" },
  { tag: se.punctuation, class: "tok-punctuation" }
]);
var mb;
const Ul = /* @__PURE__ */ new Mt();
function nT(n) {
  return ze.define({
    combine: n ? (e) => e.concat(n) : void 0
  });
}
const cV = /* @__PURE__ */ new Mt();
class $i {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, r = [], i = "") {
    this.data = e, this.name = i, bn.prototype.hasOwnProperty("tree") || Object.defineProperty(bn.prototype, "tree", { get() {
      return dr(this);
    } }), this.parser = t, this.extension = [
      rl.of(this),
      bn.languageData.of((s, o, a) => {
        let l = P7(s, o, a), c = l.type.prop(Ul);
        if (!c)
          return [];
        let u = s.facet(c), h = l.type.prop(cV);
        if (h) {
          let f = l.resolve(o - l.from, a);
          for (let m of h)
            if (m.test(f, s)) {
              let y = s.facet(m.facet);
              return m.type == "replace" ? y : y.concat(u);
            }
        }
        return u;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, r = -1) {
    return P7(e, t, r).type.prop(Ul) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(rl);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(Ul) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(Mt.mounted);
      if (a) {
        if (a.tree.prop(Ul) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + o, to: l.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (i(a.tree, a.overlay[0].from + o), r.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let c = s.children[l];
        c instanceof an && i(c, s.positions[l] + o);
      }
    };
    return i(dr(e), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
$i.setState = /* @__PURE__ */ pt.define();
function P7(n, e, t) {
  let r = n.facet(rl), i = dr(n).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, t, xn.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class _v extends $i {
  constructor(e, t, r) {
    super(e, t, [], r), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = nT(e.languageData);
    return new _v(t, e.parser.configure({
      props: [Ul.add((r) => r.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new _v(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function dr(n) {
  let e = n.field($i.state, !1);
  return e ? e.tree : an.empty;
}
class uV {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let r = this.cursorPos - this.string.length;
    return e < r || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - r, t - r);
  }
}
let nf = null, Rv = class Pv {
  constructor(e, t, r = [], i, s, o, a, l) {
    this.parser = e, this.state = t, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Pv(e, t, [], an.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new uV(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != an.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(Xo.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(Xo.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = nf;
    nf = this;
    try {
      return e();
    } finally {
      nf = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = B7(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, h, f) => l.push({ fromA: c, toA: u, fromB: h, toB: f })), r = Xo.applyChanges(r, l), i = an.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          u < h && a.push({ from: u, to: h });
        }
      }
    }
    return new Pv(this.parser, t, r, i, s, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = B7(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends S9 {
      createParse(t, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = nf;
            if (l) {
              for (let c of i)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new an(Oi.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return nf;
  }
};
function B7(n, e, t) {
  return Xo.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class uh {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, r) || t.takeTree(), new uh(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), r = Rv.create(e.facet(rl).parser, e, { from: 0, to: t });
    return r.work(20, t) || r.takeTree(), new uh(r);
  }
}
$i.state = /* @__PURE__ */ rr.define({
  create: uh.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is($i.setState))
        return t.value;
    return e.startState.facet(rl) != e.state.facet(rl) ? uh.init(e.state) : n.apply(e);
  }
});
let rT = (n) => {
  let e = setTimeout(
    () => n(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (rT = (n) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(n, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const gb = typeof navigator < "u" && (!((mb = navigator.scheduling) === null || mb === void 0) && mb.isInputPending) ? () => navigator.scheduling.isInputPending() : null, hV = /* @__PURE__ */ $n.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field($i.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field($i.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = rT(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field($i.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !gb ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < i && r.doc.length > i + 1e3, l = s.context.work(() => gb && gb() || Date.now() > o, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: $i.setState.of(new uh(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Qr(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), rl = /* @__PURE__ */ ze.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    $i.state,
    hV,
    $e.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class fV {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
class ee {
  constructor(e, t, r, i, s, o = void 0) {
    this.name = e, this.alias = t, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  /**
  Start loading the the language. Will return a promise that
  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
  object when the language successfully loads.
  */
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  /**
  Create a language description.
  */
  static of(e) {
    let { load: t, support: r } = e;
    if (!t) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      t = () => Promise.resolve(r);
    }
    return new ee(e.name, (e.alias || []).concat(e.name).map((i) => i.toLowerCase()), e.extensions || [], e.filename, t, r);
  }
  /**
  Look for a language in the given array of descriptions that
  matches the filename. Will first match
  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
  and return the first language that matches.
  */
  static matchFilename(e, t) {
    for (let i of e)
      if (i.filename && i.filename.test(t))
        return i;
    let r = /\.([^.]+)$/.exec(t);
    if (r) {
      for (let i of e)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  /**
  Look for a language whose name or alias matches the the given
  name (case-insensitively). If `fuzzy` is true, and no direct
  matchs is found, this'll also search for a language whose name
  or alias occurs in the string (for names shorter than three
  characters, only when surrounded by non-word characters).
  */
  static matchLanguageName(e, t, r = !0) {
    t = t.toLowerCase();
    for (let i of e)
      if (i.alias.some((s) => s == t))
        return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = t.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(t[o - 1]) && !/\w/.test(t[o + s.length])))
            return i;
        }
    return null;
  }
}
const dV = /* @__PURE__ */ ze.define(), D1 = /* @__PURE__ */ ze.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function Tc(n) {
  let e = n.facet(D1);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function Hd(n, e) {
  let t = "", r = n.tabSize, i = n.facet(D1)[0];
  if (i == "	") {
    for (; e >= r; )
      t += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    t += i;
  return t;
}
function Bw(n, e) {
  n instanceof bn && (n = new N1(n));
  for (let r of n.state.facet(dV)) {
    let i = r(n, e);
    if (i !== void 0)
      return i;
  }
  let t = dr(n.state);
  return t.length >= e ? pV(n, t, e) : null;
}
class N1 {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Tc(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, t);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Eh(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: r, from: i } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const iT = /* @__PURE__ */ new Mt();
function pV(n, e, t) {
  let r = e.resolveStack(t), i = e.resolveInner(t, -1).resolve(t, 0).enterUnfinishedNodesBefore(t);
  if (i != r.node) {
    let s = [];
    for (let o = i; o && !(o.from < r.node.from || o.to > r.node.to || o.from == r.node.from && o.type == r.node.type); o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return sT(r, n, t);
}
function sT(n, e, t) {
  for (let r = n; r; r = r.next) {
    let i = gV(r.node);
    if (i)
      return i(Hw.create(e, t, r));
  }
  return 0;
}
function mV(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function gV(n) {
  let e = n.type.prop(iT);
  if (e)
    return e;
  let t = n.firstChild, r;
  if (t && (r = t.type.prop(Mt.closedBy))) {
    let i = n.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => oT(o, !0, 1, void 0, s && !mV(o) ? i.from : void 0);
  }
  return n.parent == null ? yV : null;
}
function yV() {
  return 0;
}
class Hw extends N1 {
  constructor(e, t, r) {
    super(e.state, e.options), this.base = e, this.pos = t, this.context = r;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, t, r) {
    return new Hw(e, t, r);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(t.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (bV(r, e))
        break;
      t = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return sT(this.context.next, this.base, this.pos);
  }
}
function bV(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function vV(n) {
  let e = n.node, t = e.childAfter(e.from), r = e.lastChild;
  if (!t)
    return null;
  let i = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == r)
      return null;
    if (!l.type.isSkipped) {
      if (l.from >= o)
        return null;
      let c = /^ */.exec(s.text.slice(t.to - s.from))[0].length;
      return { from: t.from, to: t.to + c };
    }
    a = l.to;
  }
}
function rue({ closing: n, align: e = !0, units: t = 1 }) {
  return (r) => oT(r, e, t, n);
}
function oT(n, e, t, r, i) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, a = r && s.slice(o, o + r.length) == r || i == n.pos + o, l = e ? vV(n) : null;
  return l ? a ? n.column(l.from) : n.column(l.to) : n.baseIndent + (a ? 0 : n.unit * t);
}
const iue = (n) => n.baseIndent;
function sue({ except: n, units: e = 1 } = {}) {
  return (t) => {
    let r = n && n.test(t.textAfter);
    return t.baseIndent + (r ? 0 : e * t.unit);
  };
}
const wV = 200;
function kV() {
  return bn.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: r } = n.newSelection.main, i = t.lineAt(r);
    if (r > i.from + wV)
      return n;
    let s = t.sliceString(i.from, r);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let h = Bw(o, u.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], m = Hd(o, h);
      f != m && l.push({ from: u.from, to: u.from + f.length, insert: m });
    }
    return l.length ? [n, { changes: l, sequential: !0 }] : n;
  });
}
const xV = /* @__PURE__ */ ze.define(), SV = /* @__PURE__ */ new Mt();
function oue(n) {
  let e = n.firstChild, t = n.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? n.to : t.from } : null;
}
function CV(n, e, t) {
  let r = dr(n);
  if (r.length < t)
    return null;
  let i = r.resolveStack(t, 1), s = null;
  for (let o = i; o; o = o.next) {
    let a = o.node;
    if (a.to <= t || a.from > t)
      continue;
    if (s && a.from < e)
      break;
    let l = a.type.prop(SV);
    if (l && (a.to < r.length - 50 || r.length == n.doc.length || !MV(a))) {
      let c = l(a, n);
      c && c.from <= t && c.from >= e && c.to > t && (s = c);
    }
  }
  return s;
}
function MV(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function Pg(n, e, t) {
  for (let r of n.facet(xV)) {
    let i = r(n, e, t);
    if (i)
      return i;
  }
  return CV(n, e, t);
}
function aT(n, e) {
  let t = e.mapPos(n.from, 1), r = e.mapPos(n.to, -1);
  return t >= r ? void 0 : { from: t, to: r };
}
const I1 = /* @__PURE__ */ pt.define({ map: aT }), V0 = /* @__PURE__ */ pt.define({ map: aT });
function lT(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((r) => r.from <= t && r.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const Ac = /* @__PURE__ */ rr.define({
  create() {
    return rt.none;
  },
  update(n, e) {
    e.isUserEvent("delete") && e.changes.iterChangedRanges((t, r) => n = H7(n, t, r)), n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is(I1) && !TV(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(hT), i = r ? rt.replace({ widget: new IV(r(e.state, t.value)) }) : z7;
        n = n.update({ add: [i.range(t.value.from, t.value.to)] });
      } else t.is(V0) && (n = n.update({
        filter: (r, i) => t.value.from != r || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    return e.selection && (n = H7(n, e.selection.main.head)), n;
  },
  provide: (n) => $e.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (r, i) => {
      t.push(r, i);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let r = n[t++], i = n[t++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(z7.range(r, i));
    }
    return rt.set(e, !0);
  }
});
function H7(n, e, t = e) {
  let r = !1;
  return n.between(e, t, (i, s) => {
    i < t && s > e && (r = !0);
  }), r ? n.update({
    filterFrom: e,
    filterTo: t,
    filter: (i, s) => i >= t || s <= e
  }) : n;
}
function Bg(n, e, t) {
  var r;
  let i = null;
  return (r = n.field(Ac, !1)) === null || r === void 0 || r.between(e, t, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function TV(n, e, t) {
  let r = !1;
  return n.between(e, e, (i, s) => {
    i == e && s == t && (r = !0);
  }), r;
}
function cT(n, e) {
  return n.field(Ac, !1) ? e : e.concat(pt.appendConfig.of(fT()));
}
const AV = (n) => {
  for (let e of lT(n)) {
    let t = Pg(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: cT(n.state, [I1.of(t), uT(n, t)]) }), !0;
  }
  return !1;
}, EV = (n) => {
  if (!n.state.field(Ac, !1))
    return !1;
  let e = [];
  for (let t of lT(n)) {
    let r = Bg(n.state, t.from, t.to);
    r && e.push(V0.of(r), uT(n, r, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function uT(n, e, t = !0) {
  let r = n.state.doc.lineAt(e.from).number, i = n.state.doc.lineAt(e.to).number;
  return $e.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${r} ${n.state.phrase("to")} ${i}.`);
}
const LV = (n) => {
  let { state: e } = n, t = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = n.lineBlockAt(r), s = Pg(e, i.from, i.to);
    s && t.push(I1.of(s)), r = (s ? n.lineBlockAt(s.to) : i).to + 1;
  }
  return t.length && n.dispatch({ effects: cT(n.state, t) }), !!t.length;
}, OV = (n) => {
  let e = n.state.field(Ac, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (r, i) => {
    t.push(V0.of({ from: r, to: i }));
  }), n.dispatch({ effects: t }), !0;
}, DV = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: AV },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: EV },
  { key: "Ctrl-Alt-[", run: LV },
  { key: "Ctrl-Alt-]", run: OV }
], NV = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
}, hT = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, NV);
  }
});
function fT(n) {
  return [Ac, PV];
}
function dT(n, e) {
  let { state: t } = n, r = t.facet(hT), i = (o) => {
    let a = n.lineBlockAt(n.posAtDOM(o.target)), l = Bg(n.state, a.from, a.to);
    l && n.dispatch({ effects: V0.of(l) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(n, i, e);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const z7 = /* @__PURE__ */ rt.replace({ widget: /* @__PURE__ */ new class extends da {
  toDOM(n) {
    return dT(n, null);
  }
}() });
class IV extends da {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return dT(e, this.value);
  }
}
const _V = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class yb extends oa {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function RV(n = {}) {
  let e = { ..._V, ...n }, t = new yb(e, !0), r = new yb(e, !1), i = $n.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(rl) != o.state.facet(rl) || o.startState.field(Ac, !1) != o.state.field(Ac, !1) || dr(o.startState) != dr(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let a = new ra();
      for (let l of o.viewportLineBlocks) {
        let c = Bg(o.state, l.from, l.to) ? r : Pg(o.state, l.from, l.to) ? t : null;
        c && a.add(l.from, l.from, c);
      }
      return a.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    $F({
      class: "cm-foldGutter",
      markers(o) {
        var a;
        return ((a = o.plugin(i)) === null || a === void 0 ? void 0 : a.markers) || Ht.empty;
      },
      initialSpacer() {
        return new yb(e, !1);
      },
      domEventHandlers: {
        ...s,
        click: (o, a, l) => {
          if (s.click && s.click(o, a, l))
            return !0;
          let c = Bg(o.state, a.from, a.to);
          if (c)
            return o.dispatch({ effects: V0.of(c) }), !0;
          let u = Pg(o.state, a.from, a.to);
          return u ? (o.dispatch({ effects: I1.of(u) }), !0) : !1;
        }
      }
    }),
    fT()
  ];
}
const PV = /* @__PURE__ */ $e.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class q0 {
  constructor(e, t) {
    this.specs = e;
    let r;
    function i(a) {
      let l = tl.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, o = t.scope;
    this.scope = o instanceof $i ? (a) => a.prop(Ul) == o.data : o ? (a) => a == o : void 0, this.style = tT(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new tl(r) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new q0(e, t || {});
  }
}
const Bv = /* @__PURE__ */ ze.define(), pT = /* @__PURE__ */ ze.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function bb(n) {
  let e = n.facet(Bv);
  return e.length ? e : n.facet(pT);
}
function mT(n, e) {
  let t = [HV], r;
  return n instanceof q0 && (n.module && t.push($e.styleModule.of(n.module)), r = n.themeType), e != null && e.fallback ? t.push(pT.of(n)) : r ? t.push(Bv.computeN([$e.darkTheme], (i) => i.facet($e.darkTheme) == (r == "dark") ? [n] : [])) : t.push(Bv.of(n)), t;
}
class BV {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = dr(e.state), this.decorations = this.buildDeco(e, bb(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let t = dr(e.state), r = bb(e.state), i = r != bb(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    t.length < s.to && !i && t.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return rt.none;
    let r = new ra();
    for (let { from: i, to: s } of e.visibleRanges)
      oV(this.tree, t, (o, a, l) => {
        r.add(o, a, this.markCache[l] || (this.markCache[l] = rt.mark({ class: l })));
      }, i, s);
    return r.finish();
  }
}
const HV = /* @__PURE__ */ fl.high(/* @__PURE__ */ $n.fromClass(BV, {
  decorations: (n) => n.decorations
})), zV = /* @__PURE__ */ q0.define([
  {
    tag: se.meta,
    color: "#404740"
  },
  {
    tag: se.link,
    textDecoration: "underline"
  },
  {
    tag: se.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: se.emphasis,
    fontStyle: "italic"
  },
  {
    tag: se.strong,
    fontWeight: "bold"
  },
  {
    tag: se.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: se.keyword,
    color: "#708"
  },
  {
    tag: [se.atom, se.bool, se.url, se.contentSeparator, se.labelName],
    color: "#219"
  },
  {
    tag: [se.literal, se.inserted],
    color: "#164"
  },
  {
    tag: [se.string, se.deleted],
    color: "#a11"
  },
  {
    tag: [se.regexp, se.escape, /* @__PURE__ */ se.special(se.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ se.definition(se.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ se.local(se.variableName),
    color: "#30a"
  },
  {
    tag: [se.typeName, se.namespace],
    color: "#085"
  },
  {
    tag: se.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ se.special(se.variableName), se.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ se.definition(se.propertyName),
    color: "#00c"
  },
  {
    tag: se.comment,
    color: "#940"
  },
  {
    tag: se.invalid,
    color: "#f00"
  }
]), FV = /* @__PURE__ */ $e.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), gT = 1e4, yT = "()[]{}", bT = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, {
      afterCursor: !0,
      brackets: yT,
      maxScanDistance: gT,
      renderMatch: $V
    });
  }
}), VV = /* @__PURE__ */ rt.mark({ class: "cm-matchingBracket" }), qV = /* @__PURE__ */ rt.mark({ class: "cm-nonmatchingBracket" });
function $V(n) {
  let e = [], t = n.matched ? VV : qV;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const jV = /* @__PURE__ */ rr.define({
  create() {
    return rt.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], r = e.state.facet(bT);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = Js(e.state, i.head, -1, r) || i.head > 0 && Js(e.state, i.head - 1, 1, r) || r.afterCursor && (Js(e.state, i.head, 1, r) || i.head < e.state.doc.length && Js(e.state, i.head + 1, -1, r));
      s && (t = t.concat(r.renderMatch(s, e.state)));
    }
    return rt.set(t, !0);
  },
  provide: (n) => $e.decorations.from(n)
}), WV = [
  jV,
  FV
];
function UV(n = {}) {
  return [bT.of(n), WV];
}
const KV = /* @__PURE__ */ new Mt();
function Hv(n, e, t) {
  let r = n.prop(e < 0 ? Mt.openedBy : Mt.closedBy);
  if (r)
    return r;
  if (n.name.length == 1) {
    let i = t.indexOf(n.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function zv(n) {
  let e = n.type.prop(KV);
  return e ? e(n.node) : n;
}
function Js(n, e, t, r = {}) {
  let i = r.maxScanDistance || gT, s = r.brackets || yT, o = dr(n), a = o.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let c = Hv(l.type, t, s);
    if (c && l.from < l.to) {
      let u = zv(l);
      if (u && (t > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return GV(n, e, t, l, u, c, s);
    }
  }
  return JV(n, e, t, o, a.type, i, s);
}
function GV(n, e, t, r, i, s, o) {
  let a = r.parent, l = { from: i.from, to: i.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (t < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))
    do
      if (t < 0 ? u.to <= r.from : u.from >= r.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let h = zv(u);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (Hv(u.type, t, o))
          c++;
        else if (Hv(u.type, -t, o)) {
          if (c == 0) {
            let h = zv(u);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function JV(n, e, t, r, i, s, o) {
  let a = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, u = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), h = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let m = u.value;
    t < 0 && (f += m.length);
    let y = e + f * t;
    for (let b = t > 0 ? 0 : m.length - 1, k = t > 0 ? m.length : -1; b != k; b += t) {
      let x = o.indexOf(m[b]);
      if (!(x < 0 || r.resolveInner(y + b, 1).type != i))
        if (x % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: y + b, to: y + b + 1 }, matched: x >> 1 == l >> 1 };
          h--;
        }
    }
    t > 0 && (f += m.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
function F7(n, e, t, r = 0, i = 0) {
  e == null && (e = n.search(/[^\s\u00a0]/), e == -1 && (e = n.length));
  let s = i;
  for (let o = r; o < e; o++)
    n.charCodeAt(o) == 9 ? s += t - s % t : s++;
  return s;
}
class vT {
  /**
  Create a stream.
  */
  constructor(e, t, r, i) {
    this.string = e, this.tabSize = t, this.indentUnit = r, this.overrideIndent = i, this.pos = 0, this.start = 0, this.lastColumnPos = 0, this.lastColumnValue = 0;
  }
  /**
  True if we are at the end of the line.
  */
  eol() {
    return this.pos >= this.string.length;
  }
  /**
  True if we are at the start of the line.
  */
  sol() {
    return this.pos == 0;
  }
  /**
  Get the next code unit after the current position, or undefined
  if we're at the end of the line.
  */
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  /**
  Read the next code unit and advance `this.pos`.
  */
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  /**
  Match the next character against the given string, regular
  expression, or predicate. Consume and return it if it matches.
  */
  eat(e) {
    let t = this.string.charAt(this.pos), r;
    if (typeof e == "string" ? r = t == e : r = t && (e instanceof RegExp ? e.test(t) : e(t)), r)
      return ++this.pos, t;
  }
  /**
  Continue matching characters that match the given string,
  regular expression, or predicate function. Return true if any
  characters were consumed.
  */
  eatWhile(e) {
    let t = this.pos;
    for (; this.eat(e); )
      ;
    return this.pos > t;
  }
  /**
  Consume whitespace ahead of `this.pos`. Return true if any was
  found.
  */
  eatSpace() {
    let e = this.pos;
    for (; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
      ++this.pos;
    return this.pos > e;
  }
  /**
  Move to the end of the line.
  */
  skipToEnd() {
    this.pos = this.string.length;
  }
  /**
  Move to directly before the given character, if found on the
  current line.
  */
  skipTo(e) {
    let t = this.string.indexOf(e, this.pos);
    if (t > -1)
      return this.pos = t, !0;
  }
  /**
  Move back `n` characters.
  */
  backUp(e) {
    this.pos -= e;
  }
  /**
  Get the column position at `this.pos`.
  */
  column() {
    return this.lastColumnPos < this.start && (this.lastColumnValue = F7(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue;
  }
  /**
  Get the indentation column of the current line.
  */
  indentation() {
    var e;
    return (e = this.overrideIndent) !== null && e !== void 0 ? e : F7(this.string, null, this.tabSize);
  }
  /**
  Match the input against the given string or regular expression
  (which should start with a `^`). Return true or the regexp match
  if it matches.
  
  Unless `consume` is set to `false`, this will move `this.pos`
  past the matched text.
  
  When matching a string `caseInsensitive` can be set to true to
  make the match case-insensitive.
  */
  match(e, t, r) {
    if (typeof e == "string") {
      let i = (o) => r ? o.toLowerCase() : o, s = this.string.substr(this.pos, e.length);
      return i(s) == i(e) ? (t !== !1 && (this.pos += e.length), !0) : null;
    } else {
      let i = this.string.slice(this.pos).match(e);
      return i && i.index > 0 ? null : (i && t !== !1 && (this.pos += i[0].length), i);
    }
  }
  /**
  Get the current token.
  */
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function YV(n) {
  return {
    name: n.name || "",
    token: n.token,
    blankLine: n.blankLine || (() => {
    }),
    startState: n.startState || (() => !0),
    copyState: n.copyState || XV,
    indent: n.indent || (() => null),
    languageData: n.languageData || {},
    tokenTable: n.tokenTable || Vw,
    mergeTokens: n.mergeTokens !== !1
  };
}
function XV(n) {
  if (typeof n != "object")
    return n;
  let e = {};
  for (let t in n) {
    let r = n[t];
    e[t] = r instanceof Array ? r.slice() : r;
  }
  return e;
}
const V7 = /* @__PURE__ */ new WeakMap();
class zw extends $i {
  constructor(e) {
    let t = nT(e.languageData), r = YV(e), i, s = new class extends S9 {
      createParse(o, a, l) {
        return new QV(i, o, a, l);
      }
    }();
    super(t, s, [], e.name), this.topNode = nq(t, this), i = this, this.streamParser = r, this.stateAfter = new Mt({ perNode: !0 }), this.tokenTable = e.tokenTable ? new ST(r.tokenTable) : tq;
  }
  /**
  Define a stream language.
  */
  static define(e) {
    return new zw(e);
  }
  /**
  @internal
  */
  getIndent(e) {
    let t, { overrideIndentation: r } = e.options;
    r && (t = V7.get(e.state), t != null && t < e.pos - 1e4 && (t = void 0));
    let i = Fw(this, e.node.tree, e.node.from, e.node.from, t ?? e.pos), s, o;
    if (i ? (o = i.state, s = i.pos + 1) : (o = this.streamParser.startState(e.unit), s = e.node.from), e.pos - s > 1e4)
      return null;
    for (; s < e.pos; ) {
      let l = e.state.doc.lineAt(s), c = Math.min(e.pos, l.to);
      if (l.length) {
        let u = r ? r(l.from) : -1, h = new vT(l.text, e.state.tabSize, e.unit, u < 0 ? void 0 : u);
        for (; h.pos < c - l.from; )
          kT(this.streamParser.token, h, o);
      } else
        this.streamParser.blankLine(o, e.unit);
      if (c == e.pos)
        break;
      s = l.to + 1;
    }
    let a = e.lineAt(e.pos);
    return r && t == null && V7.set(e.state, a.from), this.streamParser.indent(o, /^\s*(.*)/.exec(a.text)[1], e);
  }
  get allowsNesting() {
    return !1;
  }
}
function Fw(n, e, t, r, i) {
  let s = t >= r && t + e.length <= i && e.prop(n.stateAfter);
  if (s)
    return { state: n.streamParser.copyState(s), pos: t + e.length };
  for (let o = e.children.length - 1; o >= 0; o--) {
    let a = e.children[o], l = t + e.positions[o], c = a instanceof an && l < i && Fw(n, a, l, r, i);
    if (c)
      return c;
  }
  return null;
}
function wT(n, e, t, r, i) {
  if (i && t <= 0 && r >= e.length)
    return e;
  !i && t == 0 && e.type == n.topNode && (i = !0);
  for (let s = e.children.length - 1; s >= 0; s--) {
    let o = e.positions[s], a = e.children[s], l;
    if (o < r && a instanceof an) {
      if (!(l = wT(n, a, t - o, r - o, i)))
        break;
      return i ? new an(e.type, e.children.slice(0, s).concat(l), e.positions.slice(0, s + 1), o + l.length) : l;
    }
  }
  return null;
}
function ZV(n, e, t, r, i) {
  for (let s of e) {
    let o = s.from + (s.openStart ? 25 : 0), a = s.to - (s.openEnd ? 25 : 0), l = o <= t && a > t && Fw(n, s.tree, 0 - s.offset, t, a), c;
    if (l && l.pos <= r && (c = wT(n, s.tree, t + s.offset, l.pos + s.offset, !1)))
      return { state: l.state, tree: c };
  }
  return { state: n.streamParser.startState(i ? Tc(i) : 4), tree: an.empty };
}
class QV {
  constructor(e, t, r, i) {
    this.lang = e, this.input = t, this.fragments = r, this.ranges = i, this.stoppedAt = null, this.chunks = [], this.chunkPos = [], this.chunk = [], this.chunkReused = void 0, this.rangeIndex = 0, this.to = i[i.length - 1].to;
    let s = Rv.get(), o = i[0].from, { state: a, tree: l } = ZV(e, r, o, this.to, s == null ? void 0 : s.state);
    this.state = a, this.parsedPos = this.chunkStart = o + l.length;
    for (let c = 0; c < l.children.length; c++)
      this.chunks.push(l.children[c]), this.chunkPos.push(l.positions[c]);
    s && this.parsedPos < s.viewport.from - 1e5 && i.some((c) => c.from <= s.viewport.from && c.to >= s.viewport.from) && (this.state = this.lang.streamParser.startState(Tc(s.state)), s.skipUntilInView(this.parsedPos, s.viewport.from), this.parsedPos = s.viewport.from), this.moveRangeIndex();
  }
  advance() {
    let e = Rv.get(), t = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt), r = Math.min(
      t,
      this.chunkStart + 512
      /* C.ChunkSize */
    );
    for (e && (r = Math.min(r, e.viewport.to)); this.parsedPos < r; )
      this.parseLine(e);
    return this.chunkStart < this.parsedPos && this.finishChunk(), this.parsedPos >= t ? this.finish() : e && this.parsedPos >= e.viewport.to ? (e.skipUntilInView(this.parsedPos, t), this.finish()) : null;
  }
  stopAt(e) {
    this.stoppedAt = e;
  }
  lineAfter(e) {
    let t = this.input.chunk(e);
    if (this.input.lineChunks)
      t == `
` && (t = "");
    else {
      let r = t.indexOf(`
`);
      r > -1 && (t = t.slice(0, r));
    }
    return e + t.length <= this.to ? t : t.slice(0, this.to - e);
  }
  nextLine() {
    let e = this.parsedPos, t = this.lineAfter(e), r = e + t.length;
    for (let i = this.rangeIndex; ; ) {
      let s = this.ranges[i].to;
      if (s >= r || (t = t.slice(0, s - (r - t.length)), i++, i == this.ranges.length))
        break;
      let o = this.ranges[i].from, a = this.lineAfter(o);
      t += a, r = o + a.length;
    }
    return { line: t, end: r };
  }
  skipGapsTo(e, t, r) {
    for (; ; ) {
      let i = this.ranges[this.rangeIndex].to, s = e + t;
      if (r > 0 ? i > s : i >= s)
        break;
      let o = this.ranges[++this.rangeIndex].from;
      t += o - i;
    }
    return t;
  }
  moveRangeIndex() {
    for (; this.ranges[this.rangeIndex].to < this.parsedPos; )
      this.rangeIndex++;
  }
  emitToken(e, t, r, i) {
    let s = 4;
    if (this.ranges.length > 1) {
      i = this.skipGapsTo(t, i, 1), t += i;
      let a = this.chunk.length;
      i = this.skipGapsTo(r, i, -1), r += i, s += this.chunk.length - a;
    }
    let o = this.chunk.length - 4;
    return this.lang.streamParser.mergeTokens && s == 4 && o >= 0 && this.chunk[o] == e && this.chunk[o + 2] == t ? this.chunk[o + 2] = r : this.chunk.push(e, t, r, s), i;
  }
  parseLine(e) {
    let { line: t, end: r } = this.nextLine(), i = 0, { streamParser: s } = this.lang, o = new vT(t, e ? e.state.tabSize : 4, e ? Tc(e.state) : 2);
    if (o.eol())
      s.blankLine(this.state, o.indentUnit);
    else
      for (; !o.eol(); ) {
        let a = kT(s.token, o, this.state);
        if (a && (i = this.emitToken(this.lang.tokenTable.resolve(a), this.parsedPos + o.start, this.parsedPos + o.pos, i)), o.start > 1e4)
          break;
      }
    this.parsedPos = r, this.moveRangeIndex(), this.parsedPos < this.to && this.parsedPos++;
  }
  finishChunk() {
    let e = an.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet: eq,
      topID: 0,
      maxBufferLength: 512,
      reused: this.chunkReused
    });
    e = new an(e.type, e.children, e.positions, e.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]), this.chunks.push(e), this.chunkPos.push(this.chunkStart - this.ranges[0].from), this.chunk = [], this.chunkReused = void 0, this.chunkStart = this.parsedPos;
  }
  finish() {
    return new an(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function kT(n, e, t) {
  e.start = e.pos;
  for (let r = 0; r < 10; r++) {
    let i = n(e, t);
    if (e.pos > e.start)
      return i;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const Vw = /* @__PURE__ */ Object.create(null), zd = [Oi.none], eq = /* @__PURE__ */ new bw(zd), q7 = [], $7 = /* @__PURE__ */ Object.create(null), xT = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  xT[n] = /* @__PURE__ */ CT(Vw, e);
class ST {
  constructor(e) {
    this.extra = e, this.table = Object.assign(/* @__PURE__ */ Object.create(null), xT);
  }
  resolve(e) {
    return e ? this.table[e] || (this.table[e] = CT(this.extra, e)) : 0;
  }
}
const tq = /* @__PURE__ */ new ST(Vw);
function vb(n, e) {
  q7.indexOf(n) > -1 || (q7.push(n), console.warn(e));
}
function CT(n, e) {
  let t = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = n[c] || se[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : vb(c, `Modifier ${c} used at start of tag`) : l.length ? vb(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : vb(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      t.push(c);
  }
  if (!t.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + t.map((a) => a.id), s = $7[i];
  if (s)
    return s.id;
  let o = $7[i] = Oi.define({
    id: zd.length,
    name: r,
    props: [iV({ [r]: t })]
  });
  return zd.push(o), o.id;
}
function nq(n, e) {
  let t = Oi.define({ id: zd.length, name: "Document", props: [
    Ul.add(() => n),
    iT.add(() => (r) => e.getIndent(r))
  ], top: !0 });
  return zd.push(t), t;
}
pn.RTL, pn.LTR;
function ue(n) {
  return new fV(zw.define(n));
}
function xa(n) {
  return import("./index-D3qc_gyi.mjs").then((e) => e.sql({ dialect: e[n] }));
}
const rq = [
  // New-style language modes
  /* @__PURE__ */ ee.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./index-D8Xf6HWh.mjs").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./index-D8Xf6HWh.mjs").then((n) => n.cpp());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return xa("Cassandra");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./index-BXyMo7Ig.mjs").then((n) => n.css());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./index-JaDDsEA4.mjs").then((n) => n.go());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./index-CH8Efc5e.mjs").then((n) => n.html());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./index-BaAqEtzc.mjs").then((n) => n.java());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./index-ClxHOLkH.mjs").then((n) => n.javascript());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./index-D_veKiKP.mjs").then((n) => n.json());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./index-ClxHOLkH.mjs").then((n) => n.javascript({ jsx: !0 }));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./index-gcAiIMhg.mjs").then((n) => n.less());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./index-BGPSdy8C.mjs").then((n) => n.liquid());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "MariaDB SQL",
    load() {
      return xa("MariaSQL");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./index-ZL9r56E2.mjs").then((n) => n.markdown());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "MS SQL",
    load() {
      return xa("MSSQL");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "MySQL",
    load() {
      return xa("MySQL");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./index-D1JAqljg.mjs").then((n) => n.php());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return xa("PLSQL");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "PostgreSQL",
    load() {
      return xa("PostgreSQL");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./index-BfrKxX3w.mjs").then((n) => n.python());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./index-r9lkTZ4O.mjs").then((n) => n.rust());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./index-CTfJUD7d.mjs").then((n) => n.sass({ indented: !0 }));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./index-CTfJUD7d.mjs").then((n) => n.sass());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return xa("StandardSQL");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SQLite",
    load() {
      return xa("SQLite");
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./index-ClxHOLkH.mjs").then((n) => n.javascript({ jsx: !0, typescript: !0 }));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./index-ClxHOLkH.mjs").then((n) => n.javascript({ typescript: !0 }));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./index-BjXlUCDr.mjs").then((n) => n.wast());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./index-Ce5V7eno.mjs").then((n) => n.xml());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./index-Bev0ob0U.mjs").then((n) => n.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  /* @__PURE__ */ ee.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-B2DGVGxc.mjs").then((n) => ue(n.apl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-2LVJmxlE.mjs").then((n) => ue(n.asciiArmor));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-jKiBa2Ya.mjs").then((n) => ue(n.asn1({})));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-DS281yxp.mjs").then((n) => ue(n.asterisk));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-C_p9pTT8.mjs").then((n) => ue(n.brainfuck));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-BlTKFDRj.mjs").then((n) => ue(n.cobol));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.csharp));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-CCKyeQKf.mjs").then((n) => ue(n.clojure));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-CCKyeQKf.mjs").then((n) => ue(n.clojure));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-BkF-NPzE.mjs").then((n) => ue(n.gss));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-CuaCgAKt.mjs").then((n) => ue(n.cmake));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-BVCvwO8I.mjs").then((n) => ue(n.coffeeScript));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-D_kxz07b.mjs").then((n) => ue(n.commonLisp));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-BMq4Fwjl.mjs").then((n) => ue(n.cypher));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-BkR3uSy8.mjs").then((n) => ue(n.cython));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-D309uH6_.mjs").then((n) => ue(n.crystal));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-BZcgY6La.mjs").then((n) => ue(n.d));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.dart));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-Cg9d_RX2.mjs").then((n) => ue(n.diff));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-BmicwmnY.mjs").then((n) => ue(n.dockerFile));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-CtLokQ-U.mjs").then((n) => ue(n.dtd));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-QYeExnWK.mjs").then((n) => ue(n.dylan));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "EBNF",
    load() {
      return import("./ebnf-DUPDuY4r.mjs").then((n) => ue(n.ebnf));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-CiXN-g_D.mjs").then((n) => ue(n.ecl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-CCKyeQKf.mjs").then((n) => ue(n.clojure));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-yQhjl4T1.mjs").then((n) => ue(n.eiffel));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-CNT9vbN0.mjs").then((n) => ue(n.elm));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-CFOYdy9e.mjs").then((n) => ue(n.erlang));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Esper",
    load() {
      return import("./sql-CfG5lQ3l.mjs").then((n) => ue(n.esper));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-CYi8BYN3.mjs").then((n) => ue(n.factor));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "FCL",
    load() {
      return import("./fcl-CPC2WYrI.mjs").then((n) => ue(n.fcl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-BmxRyE9S.mjs").then((n) => ue(n.forth));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-9bvPyrOW.mjs").then((n) => ue(n.fortran));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-BSnXJBGA.mjs").then((n) => ue(n.fSharp));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-cpmYfFX2.mjs").then((n) => ue(n.gas));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-CJuwpceU.mjs").then((n) => ue(n.gherkin));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-DZeT_VM-.mjs").then((n) => ue(n.groovy));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-Bvt3Qq1t.mjs").then((n) => ue(n.haskell));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-70NVW1pR.mjs").then((n) => ue(n.haxe));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-70NVW1pR.mjs").then((n) => ue(n.hxml));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "HTTP",
    load() {
      return import("./http-D9LttvKF.mjs").then((n) => ue(n.http));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-B6TRFYjl.mjs").then((n) => ue(n.idl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-C2yteZeJ.mjs").then((n) => ue(n.jsonld));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-DnB6dQmV.mjs").then((n) => ue(n.jinja2));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-DpvXAuO6.mjs").then((n) => ue(n.julia));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.kotlin));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-CanGTf8u.mjs").then((n) => ue(n.liveScript));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-XplVlWi_.mjs").then((n) => ue(n.lua));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-CFBPAOaF.mjs").then((n) => ue(n.mirc));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-jaRHnSxC.mjs").then((n) => ue(n.mathematica));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-vUgVs--1.mjs").then((n) => ue(n.modelica));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-CQoS1kWX.mjs").then((n) => ue(n.mumps));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-BctzC1hL.mjs").then((n) => ue(n.mbox));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-zDPm3Z74.mjs").then((n) => ue(n.nginx));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-DYWPgAyk.mjs").then((n) => ue(n.nsis));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-CsNjv2QF.mjs").then((n) => ue(n.ntriples));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.objectiveC));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.objectiveCpp));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-BSnXJBGA.mjs").then((n) => ue(n.oCaml));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-C8PmmSRH.mjs").then((n) => ue(n.octave));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-Ce8aN8oE.mjs").then((n) => ue(n.oz));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-De0D6mP7.mjs").then((n) => ue(n.pascal));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-B4bSCe1C.mjs").then((n) => ue(n.perl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-D24Z8EXi.mjs").then((n) => ue(n.pig));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-DkYVfTzP.mjs").then((n) => ue(n.powerShell));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-Dn9wna3M.mjs").then((n) => ue(n.properties));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-BPIjwpzm.mjs").then((n) => ue(n.protobuf));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-DNXUX8Xe.mjs").then((n) => ue(n.pug));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-nyd4dhjf.mjs").then((n) => ue(n.puppet));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-DyHZGnqm.mjs").then((n) => ue(n.q));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-LKEuhEGI.mjs").then((n) => ue(n.r));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-IznJm2Xc.mjs").then((n) => ue(n.rpmChanges));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-IznJm2Xc.mjs").then((n) => ue(n.rpmSpec));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-CcYfvIk6.mjs").then((n) => ue(n.ruby));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-7E8yHoCW.mjs").then((n) => ue(n.sas));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.scala));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-DjibxsNh.mjs").then((n) => ue(n.scheme));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-C0C2sNA_.mjs").then((n) => ue(n.shell));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-Bwz7vjP5.mjs").then((n) => ue(n.sieve));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-Bhddl2pB.mjs").then((n) => ue(n.smalltalk));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Solr",
    load() {
      return import("./solr-BNlsLglM.mjs").then((n) => ue(n.solr));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-BSnXJBGA.mjs").then((n) => ue(n.sml));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-FarWu_Gb.mjs").then((n) => ue(n.sparql));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-C-cy4P5N.mjs").then((n) => ue(n.spreadsheet));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-BMALKCNj.mjs").then((n) => ue(n.squirrel));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-CAdqWld3.mjs").then((n) => ue(n.stylus));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-DSxqR9R6.mjs").then((n) => ue(n.swift));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "sTeX",
    load() {
      return import("./stex-Du4h4KAU.mjs").then((n) => ue(n.stex));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-Du4h4KAU.mjs").then((n) => ue(n.stex));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-CiS1jyi5.mjs").then((n) => ue(n.verilog));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-xfoLljhY.mjs").then((n) => ue(n.tcl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-D1AWE-pc.mjs").then((n) => ue(n.textile));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-5wqsXtSk.mjs").then((n) => ue(n.tiddlyWiki));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-__Kn3CeS.mjs").then((n) => ue(n.tiki));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-DWAmxCjl.mjs").then((n) => ue(n.toml));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-D2UO-fKf.mjs").then((n) => ue(n.troff));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-Bsa4sfRm.mjs").then((n) => ue(n.ttcn));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-Bac_acMi.mjs").then((n) => ue(n.ttcnCfg));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-xwJUxoPV.mjs").then((n) => ue(n.turtle));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-CjfDENEo.mjs").then((n) => ue(n.webIDL));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-c2kQGd6-.mjs").then((n) => ue(n.vb));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-1f_Dhg5H.mjs").then((n) => ue(n.vbScript));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-DJd0pTTC.mjs").then((n) => ue(n.velocity));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-CiS1jyi5.mjs").then((n) => ue(n.verilog));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-T9HkrbI2.mjs").then((n) => ue(n.vhdl));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-BUQdORAS.mjs").then((n) => ue(n.xQuery));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-C0absKBh.mjs").then((n) => ue(n.yacas));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-Pki2zAjW.mjs").then((n) => ue(n.z80));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-Cpl0NYLN.mjs").then((n) => ue(n.mscgen));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-Cpl0NYLN.mjs").then((n) => ue(n.xu));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-Cpl0NYLN.mjs").then((n) => ue(n.msgenny));
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./index-BXZyGacc.mjs").then((n) => n.vue());
    }
  }),
  /* @__PURE__ */ ee.of({
    name: "Angular Template",
    load() {
      return import("./index-DmHbiFvY.mjs").then((n) => n.angular());
    }
  })
], iq = "#e5c07b", j7 = "#e06c75", sq = "#56b6c2", oq = "#ffffff", Im = "#abb2bf", Fv = "#7d8799", aq = "#61afef", lq = "#98c379", W7 = "#d19a66", cq = "#c678dd", uq = "#21252b", U7 = "#2c313a", K7 = "#282c34", wb = "#353a42", hq = "#3E4451", G7 = "#528bff", fq = /* @__PURE__ */ $e.theme({
  "&": {
    color: Im,
    backgroundColor: K7
  },
  ".cm-content": {
    caretColor: G7
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: G7 },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: hq },
  ".cm-panels": { backgroundColor: uq, color: Im },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847"
  },
  ".cm-gutters": {
    backgroundColor: K7,
    color: Fv,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: U7
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: wb
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: wb,
    borderBottomColor: wb
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: U7,
      color: Im
    }
  }
}, { dark: !0 }), dq = /* @__PURE__ */ q0.define([
  {
    tag: se.keyword,
    color: cq
  },
  {
    tag: [se.name, se.deleted, se.character, se.propertyName, se.macroName],
    color: j7
  },
  {
    tag: [/* @__PURE__ */ se.function(se.variableName), se.labelName],
    color: aq
  },
  {
    tag: [se.color, /* @__PURE__ */ se.constant(se.name), /* @__PURE__ */ se.standard(se.name)],
    color: W7
  },
  {
    tag: [/* @__PURE__ */ se.definition(se.name), se.separator],
    color: Im
  },
  {
    tag: [se.typeName, se.className, se.number, se.changed, se.annotation, se.modifier, se.self, se.namespace],
    color: iq
  },
  {
    tag: [se.operator, se.operatorKeyword, se.url, se.escape, se.regexp, se.link, /* @__PURE__ */ se.special(se.string)],
    color: sq
  },
  {
    tag: [se.meta, se.comment],
    color: Fv
  },
  {
    tag: se.strong,
    fontWeight: "bold"
  },
  {
    tag: se.emphasis,
    fontStyle: "italic"
  },
  {
    tag: se.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: se.link,
    color: Fv,
    textDecoration: "underline"
  },
  {
    tag: se.heading,
    fontWeight: "bold",
    color: j7
  },
  {
    tag: [se.atom, se.bool, /* @__PURE__ */ se.special(se.variableName)],
    color: W7
  },
  {
    tag: [se.processingInstruction, se.string, se.inserted],
    color: lq
  },
  {
    tag: se.invalid,
    color: oq
  }
]), pq = [fq, /* @__PURE__ */ mT(dq)];
function ar(n) {
  this.content = n;
}
ar.prototype = {
  constructor: ar,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), s = r.content.slice();
    return i == -1 ? s.push(t || n, e) : (s[i + 1] = e, t && (s[i] = t)), new ar(s);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1) return this;
    var t = this.content.slice();
    return t.splice(e, 2), new ar(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new ar([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new ar(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), s = r.find(n);
    return i.splice(s == -1 ? i.length : s, 0, e, t), new ar(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = ar.from(n), n.size ? new ar(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = ar.from(n), n.size ? new ar(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = ar.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
ar.from = function(n) {
  if (n instanceof ar) return n;
  var e = [];
  if (n) for (var t in n) e.push(t, n[t]);
  return new ar(e);
};
function MT(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), s = e.child(r);
    if (i == s) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(s))
      return t;
    if (i.isText && i.text != s.text) {
      for (let o = 0; i.text[o] == s.text[o]; o++)
        t++;
      return t;
    }
    if (i.content.size || s.content.size) {
      let o = MT(i.content, s.content, t + 1);
      if (o != null)
        return o;
    }
    t += i.nodeSize;
  }
}
function TT(n, e, t, r) {
  for (let i = n.childCount, s = e.childCount; ; ) {
    if (i == 0 || s == 0)
      return i == s ? null : { a: t, b: r };
    let o = n.child(--i), a = e.child(--s), l = o.nodeSize;
    if (o == a) {
      t -= l, r -= l;
      continue;
    }
    if (!o.sameMarkup(a))
      return { a: t, b: r };
    if (o.isText && o.text != a.text) {
      let c = 0, u = Math.min(o.text.length, a.text.length);
      for (; c < u && o.text[o.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, t--, r--;
      return { a: t, b: r };
    }
    if (o.content.size || a.content.size) {
      let c = TT(o.content, a.content, t - 1, r - 1);
      if (c)
        return c;
    }
    t -= l, r -= l;
  }
}
class pe {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, s) {
    for (let o = 0, a = 0; a < t; o++) {
      let l = this.content[o], c = a + l.nodeSize;
      if (c > e && r(l, i + a, s || null, o) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, t - u), r, i + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let s = "", o = !0;
    return this.nodesBetween(e, t, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, t - l) : a.isLeaf ? i ? typeof i == "function" ? i(a) : i : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (o ? o = !1 : s += r), s += c;
    }, 0), s;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), s = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), s = 1); s < e.content.length; s++)
      i.push(e.content[s]);
    return new pe(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let s = 0, o = 0; o < t; s++) {
        let a = this.content[s], l = o + a.nodeSize;
        l > e && ((o < e || l > t) && (a.isText ? a = a.cut(Math.max(0, e - o), Math.min(a.text.length, t - o)) : a = a.cut(Math.max(0, e - o - 1), Math.min(a.content.size, t - o - 1))), r.push(a), i += a.nodeSize), o = l;
      }
    return new pe(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? pe.empty : e == 0 && t == this.content.length ? this : new pe(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), s = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new pe(i, s);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new pe([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new pe(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return MT(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return TT(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return Wp(0, e);
    if (e == this.size)
      return Wp(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let t = 0, r = 0; ; t++) {
      let i = this.child(t), s = r + i.nodeSize;
      if (s >= e)
        return s == e ? Wp(t + 1, s) : Wp(t, r);
      r = s;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return pe.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new pe(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return pe.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      r += s.nodeSize, i && s.isText && e[i - 1].sameMarkup(s) ? (t || (t = e.slice(0, i)), t[t.length - 1] = s.withText(t[t.length - 1].text + s.text)) : t && t.push(s);
    }
    return new pe(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return pe.empty;
    if (e instanceof pe)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new pe([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
pe.empty = new pe([], 0);
const kb = { index: 0, offset: 0 };
function Wp(n, e) {
  return kb.index = n, kb.offset = e, kb;
}
function Hg(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!Hg(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !Hg(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
class wt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (this.eq(s))
        return e;
      if (this.type.excludes(s.type))
        t || (t = e.slice(0, i));
      else {
        if (s.type.excludes(this.type))
          return e;
        !r && s.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(s);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && Hg(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    let i = r.create(t.attrs);
    return r.checkAttrs(i.attrs), i;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return wt.none;
    if (e instanceof wt)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
}
wt.none = [];
class zg extends Error {
}
let He = class nu {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = ET(this.content, e + this.openStart, t);
    return r && new nu(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new nu(AT(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return nu.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new nu(pe.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let s = e.firstChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.firstChild)
      r++;
    for (let s = e.lastChild; s && !s.isLeaf && (t || !s.type.spec.isolating); s = s.lastChild)
      i++;
    return new nu(e, r, i);
  }
};
He.empty = new He(pe.empty, 0, 0);
function AT(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), s = n.maybeChild(r), { index: o, offset: a } = n.findIndex(t);
  if (i == e || s.isText) {
    if (a != t && !n.child(o).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != o)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, s.copy(AT(s.content, e - i - 1, t - i - 1)));
}
function ET(n, e, t, r) {
  let { index: i, offset: s } = n.findIndex(e), o = n.maybeChild(i);
  if (s == e || o.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let a = ET(o.content, e - s - 1, t, o);
  return a && n.replaceChild(i, o.copy(a));
}
function mq(n, e, t) {
  if (t.openStart > n.depth)
    throw new zg("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new zg("Inconsistent open depths");
  return LT(n, e, t, 0);
}
function LT(n, e, t, r) {
  let i = n.index(r), s = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let o = LT(n, e, t, r + 1);
    return s.copy(s.content.replaceChild(i, o));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let o = n.parent, a = o.content;
      return dc(o, a.cut(0, n.parentOffset).append(t.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: o, end: a } = gq(t, n);
      return dc(s, DT(n, o, a, e, r));
    }
  else return dc(s, Fg(n, e, r));
}
function OT(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new zg("Cannot join " + e.type.name + " onto " + n.type.name);
}
function Vv(n, e, t) {
  let r = n.node(t);
  return OT(r, e.node(t)), r;
}
function fc(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function sd(n, e, t, r) {
  let i = (e || n).node(t), s = 0, o = e ? e.index(t) : i.childCount;
  n && (s = n.index(t), n.depth > t ? s++ : n.textOffset && (fc(n.nodeAfter, r), s++));
  for (let a = s; a < o; a++)
    fc(i.child(a), r);
  e && e.depth == t && e.textOffset && fc(e.nodeBefore, r);
}
function dc(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function DT(n, e, t, r, i) {
  let s = n.depth > i && Vv(n, e, i + 1), o = r.depth > i && Vv(t, r, i + 1), a = [];
  return sd(null, n, i, a), s && o && e.index(i) == t.index(i) ? (OT(s, o), fc(dc(s, DT(n, e, t, r, i + 1)), a)) : (s && fc(dc(s, Fg(n, e, i + 1)), a), sd(e, t, i, a), o && fc(dc(o, Fg(t, r, i + 1)), a)), sd(r, null, i, a), new pe(a);
}
function Fg(n, e, t) {
  let r = [];
  if (sd(null, n, t, r), n.depth > t) {
    let i = Vv(n, e, t + 1);
    fc(dc(i, Fg(n, e, t + 1)), r);
  }
  return sd(e, null, t, r), new pe(r);
}
function gq(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let s = t - 1; s >= 0; s--)
    i = e.node(s).copy(pe.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class Fd {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let s = 0; s < e; s++)
      i += r.child(s).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return wt.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let a = r;
      r = i, i = a;
    }
    let s = r.marks;
    for (var o = 0; o < s.length; o++)
      s[o].type.spec.inclusive === !1 && (!i || !s[o].isInSet(i.marks)) && (s = s[o--].removeFromSet(s));
    return s;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var s = 0; s < r.length; s++)
      r[s].type.spec.inclusive === !1 && (!i || !r[s].isInSet(i.marks)) && (r = r[s--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new NT(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, s = t;
    for (let o = e; ; ) {
      let { index: a, offset: l } = o.content.findIndex(s), c = s - l;
      if (r.push(o, a, i + l), !c || (o = o.child(a), o.isText))
        break;
      s = c - 1, i += l + 1;
    }
    return new Fd(t, r, s);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    let r = J7.get(e);
    if (r)
      for (let s = 0; s < r.elts.length; s++) {
        let o = r.elts[s];
        if (o.pos == t)
          return o;
      }
    else
      J7.set(e, r = new yq());
    let i = r.elts[r.i] = Fd.resolve(e, t);
    return r.i = (r.i + 1) % bq, i;
  }
}
class yq {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const bq = 12, J7 = /* @__PURE__ */ new WeakMap();
class NT {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const vq = /* @__PURE__ */ Object.create(null);
let Qo = class qv {
  /**
  @internal
  */
  constructor(e, t, r, i = wt.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || pe.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && Hg(this.attrs, t || e.defaultAttrs || vq) && wt.sameSet(this.marks, r || wt.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new qv(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new qv(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return He.empty;
    let i = this.resolve(e), s = this.resolve(t), o = r ? 0 : i.sharedDepth(t), a = i.start(o), c = i.node(o).content.cut(i.pos - a, s.pos - a);
    return new He(c, i.depth - o, s.depth - o);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return mq(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Fd.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Fd.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (s) => (r.isInSet(s.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), IT(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = pe.empty, i = 0, s = r.childCount) {
    let o = this.contentMatchAt(e).matchFragment(r, i, s), a = o && o.matchFragment(this.content, t);
    if (!a || !a.validEnd)
      return !1;
    for (let l = i; l < s; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let s = this.contentMatchAt(e).matchType(r), o = s && s.matchFragment(this.content, t);
    return o ? o.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = wt.none;
    for (let t = 0; t < this.marks.length; t++) {
      let r = this.marks[t];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!wt.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = pe.fromJSON(e, t.content), s = e.nodeType(t.type).create(t.attrs, i, r);
    return s.type.checkAttrs(s.attrs), s;
  }
};
Qo.prototype.text = void 0;
let wq = class $v extends Qo {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : IT(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new $v(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new $v(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
};
function IT(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class Ec {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new kq(e, t);
    if (r.next == null)
      return Ec.empty;
    let i = _T(r);
    r.next && r.err("Unexpected trailing text");
    let s = Eq(Aq(i));
    return Lq(s, r), s;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let s = t; i && s < r; s++)
      i = i.matchType(e.child(s).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function s(o, a) {
      let l = o.matchFragment(e, r);
      if (l && (!t || l.validEnd))
        return pe.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < o.next.length; c++) {
        let { type: u, next: h } = o.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(h) == -1) {
          i.push(h);
          let f = s(h, a.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return s(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), s = i.match;
      if (s.matchType(e)) {
        let o = [];
        for (let a = i; a.type; a = a.via)
          o.push(a.type);
        return o.reverse();
      }
      for (let o = 0; o < s.next.length; o++) {
        let { type: a, next: l } = s.next[o];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in t) && (!i.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: i }), t[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let s = i + (r.validEnd ? "*" : " ") + " ";
      for (let o = 0; o < r.next.length; o++)
        s += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next);
      return s;
    }).join(`
`);
  }
}
Ec.empty = new Ec(!0);
class kq {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function _T(n) {
  let e = [];
  do
    e.push(xq(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function xq(n) {
  let e = [];
  do
    e.push(Sq(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function Sq(n) {
  let e = Tq(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = Cq(n, e);
    else
      break;
  return e;
}
function Y7(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function Cq(n, e) {
  let t = Y7(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = Y7(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function Mq(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let s in t) {
    let o = t[s];
    o.isInGroup(e) && i.push(o);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function Tq(n) {
  if (n.eat("(")) {
    let e = _T(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = Mq(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function Aq(n) {
  let e = [[]];
  return i(s(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(o, a, l) {
    let c = { term: l, to: a };
    return e[o].push(c), c;
  }
  function i(o, a) {
    o.forEach((l) => l.to = a);
  }
  function s(o, a) {
    if (o.type == "choice")
      return o.exprs.reduce((l, c) => l.concat(s(c, a)), []);
    if (o.type == "seq")
      for (let l = 0; ; l++) {
        let c = s(o.exprs[l], a);
        if (l == o.exprs.length - 1)
          return c;
        i(c, a = t());
      }
    else if (o.type == "star") {
      let l = t();
      return r(a, l), i(s(o.expr, l), l), [r(l)];
    } else if (o.type == "plus") {
      let l = t();
      return i(s(o.expr, a), l), i(s(o.expr, l), l), [r(l)];
    } else {
      if (o.type == "opt")
        return [r(a)].concat(s(o.expr, a));
      if (o.type == "range") {
        let l = a;
        for (let c = 0; c < o.min; c++) {
          let u = t();
          i(s(o.expr, l), u), l = u;
        }
        if (o.max == -1)
          i(s(o.expr, l), l);
        else
          for (let c = o.min; c < o.max; c++) {
            let u = t();
            r(l, u), i(s(o.expr, l), u), l = u;
          }
        return [r(l)];
      } else {
        if (o.type == "name")
          return [r(a, void 0, o.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function RT(n, e) {
  return e - n;
}
function X7(n, e) {
  let t = [];
  return r(e), t.sort(RT);
  function r(i) {
    let s = n[i];
    if (s.length == 1 && !s[0].term)
      return r(s[0].to);
    t.push(i);
    for (let o = 0; o < s.length; o++) {
      let { term: a, to: l } = s[o];
      !a && t.indexOf(l) == -1 && r(l);
    }
  }
}
function Eq(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(X7(n, 0));
  function t(r) {
    let i = [];
    r.forEach((o) => {
      n[o].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < i.length; u++)
          i[u][0] == a && (c = i[u][1]);
        X7(n, l).forEach((u) => {
          c || i.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let s = e[r.join(",")] = new Ec(r.indexOf(n.length - 1) > -1);
    for (let o = 0; o < i.length; o++) {
      let a = i[o][1].sort(RT);
      s.next.push({ type: i[o][0], next: e[a.join(",")] || t(a) });
    }
    return s;
  }
}
function Lq(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], s = !i.validEnd, o = [];
    for (let a = 0; a < i.next.length; a++) {
      let { type: l, next: c } = i.next[a];
      o.push(l.name), s && !(l.isText || l.hasRequiredAttrs()) && (s = !1), r.indexOf(c) == -1 && r.push(c);
    }
    s && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function PT(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function BT(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let s = n[r];
      if (s.hasDefault)
        i = s.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function HT(n, e, t, r) {
  for (let i in e)
    if (!(i in n))
      throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`);
  for (let i in n) {
    let s = n[i];
    s.validate && s.validate(e[i]);
  }
}
function zT(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      t[r] = new Dq(n, r, e[r]);
  return t;
}
let Vg = class FT {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = zT(e, r.attrs), this.defaultAttrs = PT(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Ec.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : BT(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Qo(this, this.computeAttrs(e), pe.from(t), wt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = pe.from(t), this.checkContent(t), new Qo(this, this.computeAttrs(e), t, wt.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = pe.from(t), t.size) {
      let o = this.contentMatch.fillBefore(t);
      if (!o)
        return null;
      t = o.append(t);
    }
    let i = this.contentMatch.matchFragment(t), s = i && i.fillBefore(pe.empty, !0);
    return s ? new Qo(this, e, t.append(s), wt.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    HT(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : wt.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((s, o) => r[s] = new FT(s, t, o));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let s in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function Oq(n, e, t) {
  let r = t.split("|");
  return (i) => {
    let s = i === null ? "null" : typeof i;
    if (r.indexOf(s) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${s}`);
  };
}
class Dq {
  constructor(e, t, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? Oq(e, t, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class _1 {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = zT(e, i.attrs), this.excluded = null;
    let s = PT(this.attrs);
    this.instance = s ? new wt(this, s) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new wt(this, BT(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((s, o) => r[s] = new _1(s, i++, t, o)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    HT(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class VT {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = ar.from(e.nodes), t.marks = ar.from(e.marks || {}), this.nodes = Vg.compile(this.spec.nodes, this), this.marks = _1.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let s = this.nodes[i], o = s.spec.content || "", a = s.spec.marks;
      if (s.contentMatch = r[o] || (r[o] = Ec.parse(o, this.nodes)), s.inlineContent = s.contentMatch.inlineContent, s.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!s.isInline || !s.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = s;
      }
      s.markSet = a == "_" ? null : a ? Z7(this, a.split(" ")) : a == "" || !s.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let s = this.marks[i], o = s.spec.excludes;
      s.excluded = o == null ? [s] : o == "" ? [] : Z7(this, o.split(" "));
    }
    this.nodeFromJSON = (i) => Qo.fromJSON(this, i), this.markFromJSON = (i) => wt.fromJSON(this, i), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Vg) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new wq(r, r.defaultAttrs, e, wt.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function Z7(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], s = n.marks[i], o = s;
    if (s)
      t.push(s);
    else
      for (let a in n.marks) {
        let l = n.marks[a];
        (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && t.push(o = l);
      }
    if (!o)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
function Nq(n) {
  return n.tag != null;
}
function Iq(n) {
  return n.style != null;
}
let R1 = class jv {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    t.forEach((i) => {
      if (Nq(i))
        this.tags.push(i);
      else if (Iq(i)) {
        let s = /[^=]*/.exec(i.style)[0];
        r.indexOf(s) < 0 && r.push(s), this.styles.push(i);
      }
    }), this.normalizeLists = !this.tags.some((i) => {
      if (!/^(ul|ol)\b/.test(i.tag) || !i.node)
        return !1;
      let s = e.nodes[i.node];
      return s.contentMatch.matchType(s);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new ex(this, t, !1);
    return r.addAll(e, wt.none, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new ex(this, t, !0);
    return r.addAll(e, wt.none, t.from, t.to), He.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let s = this.tags[i];
      if (Pq(e, s.tag) && (s.namespace === void 0 || e.namespaceURI == s.namespace) && (!s.context || t.matchesContext(s.context))) {
        if (s.getAttrs) {
          let o = s.getAttrs(e);
          if (o === !1)
            continue;
          s.attrs = o || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let s = i ? this.styles.indexOf(i) + 1 : 0; s < this.styles.length; s++) {
      let o = this.styles[s], a = o.style;
      if (!(a.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != t))) {
        if (o.getAttrs) {
          let l = o.getAttrs(t);
          if (l === !1)
            continue;
          o.attrs = l || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let s = i.priority == null ? 50 : i.priority, o = 0;
      for (; o < t.length; o++) {
        let a = t[o];
        if ((a.priority == null ? 50 : a.priority) < s)
          break;
      }
      t.splice(o, 0, i);
    }
    for (let i in e.marks) {
      let s = e.marks[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = tx(o)), o.mark || o.ignore || o.clearMark || (o.mark = i);
      });
    }
    for (let i in e.nodes) {
      let s = e.nodes[i].spec.parseDOM;
      s && s.forEach((o) => {
        r(o = tx(o)), o.node || o.ignore || o.mark || (o.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new jv(e, jv.schemaRules(e)));
  }
};
const qT = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, _q = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, $T = { ol: !0, ul: !0 }, Vd = 1, Wv = 2, od = 4;
function Q7(n, e, t) {
  return e != null ? (e ? Vd : 0) | (e === "full" ? Wv : 0) : n && n.whitespace == "pre" ? Vd | Wv : t & ~od;
}
class Up {
  constructor(e, t, r, i, s, o) {
    this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = wt.none, this.match = s || (o & od ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(pe.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Vd)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let s = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = s.withText(s.text.slice(0, s.text.length - i[0].length));
      }
    }
    let t = pe.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(pe.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !qT.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class ex {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let i = t.topNode, s, o = Q7(null, t.preserveWhitespace, 0) | (r ? od : 0);
    i ? s = new Up(i.type, i.attrs, wt.none, !0, t.topMatch || i.type.contentMatch, o) : r ? s = new Up(null, null, wt.none, !0, null, o) : s = new Up(e.schema.topNodeType, null, wt.none, !0, null, o), this.nodes = [s], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, t) {
    e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t);
  }
  addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, s = i.options & Wv ? "full" : this.localPreserveWS || (i.options & Vd) > 0;
    if (s === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s)
        s !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`);
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let o = i.content[i.content.length - 1], a = e.previousSibling;
        (!o || a && a.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t, r) {
    let i = this.localPreserveWS, s = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let o = e.nodeName.toLowerCase(), a;
    $T.hasOwnProperty(o) && this.parser.normalizeLists && Rq(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
    e: if (l ? l.ignore : _q.hasOwnProperty(o))
      this.findInside(e), this.ignoreFallback(e, t);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, u = this.needsBlock;
      if (qT.hasOwnProperty(o))
        s.content.length && s.content[0].isInline && this.open && (this.open--, s = this.top), c = !0, s.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, t);
        break e;
      }
      let h = l && l.skip ? t : this.readStyles(e, t);
      h && this.addAll(e, h), c && this.sync(s), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, t);
      c && this.addElementByRule(e, l, c, l.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = i;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t);
  }
  // Called for ignored nodes
  ignoreFallback(e, t) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, t) {
    let r = e.style;
    if (r && r.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let s = this.parser.matchedStyles[i], o = r.getPropertyValue(s);
        if (o)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(s, o, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? t = t.filter((c) => !l.clearMark(c)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return t;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r, i) {
    let s, o;
    if (t.node)
      if (o = this.parser.schema.nodes[t.node], o.isLeaf)
        this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let l = this.enter(o, t.attrs || null, r, t.preserveWhitespace);
        l && (s = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[t.mark];
      r = r.concat(l.create(t.attrs));
    }
    let a = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (i)
      this.addElement(e, r, i);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r, !1));
    else {
      let l = e;
      typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    s && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r, i) {
    let s = r || 0;
    for (let o = r ? e.childNodes[r] : e.firstChild, a = i == null ? null : e.childNodes[i]; o != a; o = o.nextSibling, ++s)
      this.findAtPoint(e, s), this.addDOM(o, t);
    this.findAtPoint(e, s);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, t, r) {
    let i, s;
    for (let o = this.open, a = 0; o >= 0; o--) {
      let l = this.nodes[o], c = l.findWrapping(e);
      if (c && (!i || i.length > c.length + a) && (i = c, s = l, !c.length))
        break;
      if (l.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!i)
      return null;
    this.sync(s);
    for (let o = 0; o < i.length; o++)
      t = this.enterInner(i[o], null, t, !1);
    return t;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, t, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let s = this.textblockFromContext();
      s && (t = this.enterInner(s, null, t));
    }
    let i = this.findPlace(e, t, r);
    if (i) {
      this.closeExtra();
      let s = this.top;
      s.match && (s.match = s.match.matchType(e.type));
      let o = wt.none;
      for (let a of i.concat(e.marks))
        (s.type ? s.type.allowsMarkType(a.type) : nx(a.type, e.type)) && (o = a.addToSet(o));
      return s.content.push(e.mark(o)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r, i) {
    let s = this.findPlace(e.create(t), r, !1);
    return s && (s = this.enterInner(e, t, r, !0, i)), s;
  }
  // Open a node of the given type
  enterInner(e, t, r, i = !1, s) {
    this.closeExtra();
    let o = this.top;
    o.match = o.match && o.match.matchType(e);
    let a = Q7(e, s, o.options);
    o.options & od && o.content.length == 0 && (a |= od);
    let l = wt.none;
    return r = r.filter((c) => (o.type ? o.type.allowsMarkType(c.type) : nx(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new Up(e, t, l, i, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--) {
      if (this.nodes[t] == e)
        return this.open = t, !0;
      this.localPreserveWS && (this.nodes[t].options |= Vd);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), s = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (a, l) => {
      for (; a >= 0; a--) {
        let c = t[a];
        if (c == "") {
          if (a == t.length - 1 || a == 0)
            continue;
          for (; l >= s; l--)
            if (o(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= s ? r.node(l - s).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return o(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function Rq(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && $T.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function Pq(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function tx(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function nx(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let s = [], o = (a) => {
      s.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || s.indexOf(u) < 0 && o(u))
          return !0;
      }
    };
    if (o(i.contentMatch))
      return !0;
  }
}
class Bc {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = xb(t).createDocumentFragment());
    let i = r, s = [];
    return e.forEach((o) => {
      if (s.length || o.marks.length) {
        let a = 0, l = 0;
        for (; a < s.length && l < o.marks.length; ) {
          let c = o.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(s[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < s.length; )
          i = s.pop()[1];
        for (; l < o.marks.length; ) {
          let c = o.marks[l++], u = this.serializeMark(c, o.isInline, t);
          u && (s.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(o, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = _m(xb(t), this.nodes[e.type.name](e), null, e.attrs);
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let s = this.serializeMark(e.marks[i], e.isInline, t);
      s && ((s.contentDOM || s.dom).appendChild(r), r = s.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && _m(xb(r), i(e, t), null, e.attrs);
  }
  static renderSpec(e, t, r = null, i) {
    return _m(e, t, r, i);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new Bc(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = rx(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return rx(e.marks);
  }
}
function rx(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function xb(n) {
  return n.document || window.document;
}
const ix = /* @__PURE__ */ new WeakMap();
function Bq(n) {
  let e = ix.get(n);
  return e === void 0 && ix.set(n, e = Hq(n)), e;
}
function Hq(n) {
  let e = null;
  function t(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let i = 0; i < r.length; i++)
            t(r[i]);
      else
        for (let i in r)
          t(r[i]);
  }
  return t(n), e;
}
function _m(n, e, t, r) {
  if (typeof e == "string")
    return { dom: n.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let i = e[0], s;
  if (typeof i != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (s = Bq(r)) && s.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let o = i.indexOf(" ");
  o > 0 && (t = i.slice(0, o), i = i.slice(o + 1));
  let a, l = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let h in c)
      if (c[h] != null) {
        let f = h.indexOf(" ");
        f > 0 ? l.setAttributeNS(h.slice(0, f), h.slice(f + 1), c[h]) : h == "style" && l.style ? l.style.cssText = c[h] : l.setAttribute(h, c[h]);
      }
  }
  for (let h = u; h < e.length; h++) {
    let f = e[h];
    if (f === 0) {
      if (h < e.length - 1 || h > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: m, contentDOM: y } = _m(n, f, t, r);
      if (l.appendChild(m), y) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = y;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const jT = 65535, WT = Math.pow(2, 16);
function zq(n, e) {
  return n + e * WT;
}
function sx(n) {
  return n & jT;
}
function Fq(n) {
  return (n - (n & jT)) / WT;
}
const UT = 1, KT = 2, Rm = 4, GT = 8;
class Uv {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & GT) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (UT | Rm)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (KT | Rm)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Rm) > 0;
  }
}
class ki {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && ki.empty)
      return ki.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = sx(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + Fq(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? i : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = this.ranges[a + o], h = l + c;
      if (e <= h) {
        let f = c ? e == l ? -1 : e == h ? 1 : t : t, m = l + i + (f < 0 ? 0 : u);
        if (r)
          return m;
        let y = e == (t < 0 ? l : h) ? null : zq(a / 3, e - l), b = e == l ? KT : e == h ? UT : Rm;
        return (t < 0 ? e != l : e != h) && (b |= GT), new Uv(m, b, y);
      }
      i += u - c;
    }
    return r ? e + i : new Uv(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = sx(t), s = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + s], u = l + c;
      if (e <= u && a == i * 3)
        return !0;
      r += this.ranges[a + o] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, s = 0; i < this.ranges.length; i += 3) {
      let o = this.ranges[i], a = o - (this.inverted ? s : 0), l = o + (this.inverted ? 0 : s), c = this.ranges[i + t], u = this.ranges[i + r];
      e(a, a + c, l, l + u), s += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new ki(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? ki.empty : new ki(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
ki.empty = new ki([]);
class qd {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, t, r = 0, i = e ? e.length : 0) {
    this.mirror = t, this.from = r, this.to = i, this._maps = e || [], this.ownData = !(e || t);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new qd(this._maps, this.mirror, e, t);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), t != null && this.setMirror(this._maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this._maps.length; t < e._maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this._maps.length + e._maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e._maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new qd();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let s = this.from; s < this.to; s++) {
      let o = this._maps[s], a = o.mapResult(e, t);
      if (a.recover != null) {
        let l = this.getMirror(s);
        if (l != null && l > s && l < this.to) {
          s = l, e = this._maps[l].recover(a.recover);
          continue;
        }
      }
      i |= a.delInfo, e = a.pos;
    }
    return r ? e : new Uv(e, i, null);
  }
}
const Sb = /* @__PURE__ */ Object.create(null);
class xr {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return ki.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Sb[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in Sb)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Sb[e] = t, t.prototype.jsonID = e, t;
  }
}
class Vn {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Vn(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Vn(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return Vn.ok(e.replace(t, r, i));
    } catch (s) {
      if (s instanceof zg)
        return Vn.fail(s.message);
      throw s;
    }
  }
}
function qw(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let s = n.child(i);
    s.content.size && (s = s.copy(qw(s.content, e, s))), s.isInline && (s = e(s, t, i)), r.push(s);
  }
  return pe.fromArray(r);
}
class Ko extends xr {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), s = new He(qw(t.content, (o, a) => !o.isAtom || !a.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd);
    return Vn.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new Ys(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Ko(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ko && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ko(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Ko(t.from, t.to, e.markFromJSON(t.mark));
  }
}
xr.jsonID("addMark", Ko);
class Ys extends xr {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new He(qw(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return Vn.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Ko(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Ys(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ys && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ys(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Ys(t.from, t.to, e.markFromJSON(t.mark));
  }
}
xr.jsonID("removeMark", Ys);
class Wa extends xr {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Vn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return Vn.fromReplace(e, this.pos, this.pos + 1, new He(pe.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new Wa(this.pos, t.marks[i]);
        return new Wa(this.pos, this.mark);
      }
    }
    return new Lc(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Wa(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Wa(t.pos, e.markFromJSON(t.mark));
  }
}
xr.jsonID("addNodeMark", Wa);
class Lc extends xr {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Vn.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return Vn.fromReplace(e, this.pos, this.pos + 1, new He(pe.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Wa(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Lc(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Lc(t.pos, e.markFromJSON(t.mark));
  }
}
xr.jsonID("removeNodeMark", Lc);
class er extends xr {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Kv(e, this.from, this.to) ? Vn.fail("Structure replace would overwrite content") : Vn.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new ki([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new er(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new er(t.pos, Math.max(t.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof er) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? He.empty : new He(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new er(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? He.empty : new He(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new er(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new er(t.from, t.to, He.fromJSON(e, t.slice), !!t.structure);
  }
}
xr.jsonID("replace", er);
class kr extends xr {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, s, o, a = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = s, this.insert = o, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Kv(e, this.from, this.gapFrom) || Kv(e, this.gapTo, this.to)))
      return Vn.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return Vn.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? Vn.fromReplace(e, this.from, this.to, r) : Vn.fail("Content does not fit in gap");
  }
  getMap() {
    return new ki([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new kr(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), s = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || s > r.pos ? null : new kr(t.pos, r.pos, i, s, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new kr(t.from, t.to, t.gapFrom, t.gapTo, He.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
xr.jsonID("replaceAround", kr);
function Kv(n, e, t) {
  let r = n.resolve(e), i = t - e, s = r.depth;
  for (; i > 0 && s > 0 && r.indexAfter(s) == r.node(s).childCount; )
    s--, i--;
  if (i > 0) {
    let o = r.node(s).maybeChild(r.indexAfter(s));
    for (; i > 0; ) {
      if (!o || o.isLeaf)
        return !0;
      o = o.firstChild, i--;
    }
  }
  return !1;
}
function Vq(n, e, t, r) {
  let i = [], s = [], o, a;
  n.doc.nodesBetween(e, t, (l, c, u) => {
    if (!l.isInline)
      return;
    let h = l.marks;
    if (!r.isInSet(h) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), m = Math.min(c + l.nodeSize, t), y = r.addToSet(h);
      for (let b = 0; b < h.length; b++)
        h[b].isInSet(y) || (o && o.to == f && o.mark.eq(h[b]) ? o.to = m : i.push(o = new Ys(f, m, h[b])));
      a && a.to == f ? a.to = m : s.push(a = new Ko(f, m, r));
    }
  }), i.forEach((l) => n.step(l)), s.forEach((l) => n.step(l));
}
function qq(n, e, t, r) {
  let i = [], s = 0;
  n.doc.nodesBetween(e, t, (o, a) => {
    if (!o.isInline)
      return;
    s++;
    let l = null;
    if (r instanceof _1) {
      let c = o.marks, u;
      for (; u = r.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks;
    if (l && l.length) {
      let c = Math.min(a + o.nodeSize, t);
      for (let u = 0; u < l.length; u++) {
        let h = l[u], f;
        for (let m = 0; m < i.length; m++) {
          let y = i[m];
          y.step == s - 1 && h.eq(i[m].style) && (f = y);
        }
        f ? (f.to = c, f.step = s) : i.push({ style: h, from: Math.max(a, e), to: c, step: s });
      }
    }
  }), i.forEach((o) => n.step(new Ys(o.from, o.to, o.style)));
}
function $w(n, e, t, r = t.contentMatch, i = !0) {
  let s = n.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < s.childCount; l++) {
    let c = s.child(l), u = a + c.nodeSize, h = r.matchType(c.type);
    if (!h)
      o.push(new er(a, u, He.empty));
    else {
      r = h;
      for (let f = 0; f < c.marks.length; f++)
        t.allowsMarkType(c.marks[f].type) || n.step(new Ys(a, u, c.marks[f]));
      if (i && c.isText && t.whitespace != "pre") {
        let f, m = /\r?\n|\r/g, y;
        for (; f = m.exec(c.text); )
          y || (y = new He(pe.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new er(a + f.index, a + f.index + f[0].length, y));
      }
    }
    a = u;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(pe.empty, !0);
    n.replace(a, a, new He(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    n.step(o[l]);
}
function $q(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function P1(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), s = n.$from.index(r), o = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(s, o, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !$q(i, s, o))
      break;
  }
  return null;
}
function jq(n, e, t) {
  let { $from: r, $to: i, depth: s } = e, o = r.before(s + 1), a = i.after(s + 1), l = o, c = a, u = pe.empty, h = 0;
  for (let y = s, b = !1; y > t; y--)
    b || r.index(y) > 0 ? (b = !0, u = pe.from(r.node(y).copy(u)), h++) : l--;
  let f = pe.empty, m = 0;
  for (let y = s, b = !1; y > t; y--)
    b || i.after(y + 1) < i.end(y) ? (b = !0, f = pe.from(i.node(y).copy(f)), m++) : c++;
  n.step(new kr(l, c, o, a, new He(u.append(f), h, m), u.size - h, !0));
}
function jw(n, e, t = null, r = n) {
  let i = Wq(n, e), s = i && Uq(r, e);
  return s ? i.map(ox).concat({ type: e, attrs: t }).concat(s.map(ox)) : null;
}
function ox(n) {
  return { type: n, attrs: null };
}
function Wq(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.contentMatchAt(r).findWrapping(e);
  if (!s)
    return null;
  let o = s.length ? s[0] : e;
  return t.canReplaceWith(r, i, o) ? s : null;
}
function Uq(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, s = t.child(r), o = e.contentMatch.findWrapping(s.type);
  if (!o)
    return null;
  let l = (o.length ? o[o.length - 1] : e).contentMatch;
  for (let c = r; l && c < i; c++)
    l = l.matchType(t.child(c).type);
  return !l || !l.validEnd ? null : o;
}
function Kq(n, e, t) {
  let r = pe.empty;
  for (let o = t.length - 1; o >= 0; o--) {
    if (r.size) {
      let a = t[o].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = pe.from(t[o].type.create(t[o].attrs, r));
  }
  let i = e.start, s = e.end;
  n.step(new kr(i, s, i, s, new He(r, 0, 0), t.length, !0));
}
function Gq(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let s = n.steps.length;
  n.doc.nodesBetween(e, t, (o, a) => {
    let l = typeof i == "function" ? i(o) : i;
    if (o.isTextblock && !o.hasMarkup(r, l) && Jq(n.doc, n.mapping.slice(s).map(a), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let m = r.whitespace == "pre", y = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        m && !y ? c = !1 : !m && y && (c = !0);
      }
      c === !1 && YT(n, o, a, s), $w(n, n.mapping.slice(s).map(a, 1), r, void 0, c === null);
      let u = n.mapping.slice(s), h = u.map(a, 1), f = u.map(a + o.nodeSize, 1);
      return n.step(new kr(h, f, h + 1, f - 1, new He(pe.from(r.create(l, null, o.marks)), 0, 0), 1, !0)), c === !0 && JT(n, o, a, s), !1;
    }
  });
}
function JT(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.isText) {
      let o, a = /\r?\n|\r/g;
      for (; o = a.exec(i.text); ) {
        let l = n.mapping.slice(r).map(t + 1 + s + o.index);
        n.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function YT(n, e, t, r) {
  e.forEach((i, s) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + s);
      n.replaceWith(o, o + 1, e.type.schema.text(`
`));
    }
  });
}
function Jq(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function Yq(n, e, t, r, i) {
  let s = n.doc.nodeAt(e);
  if (!s)
    throw new RangeError("No node at given position");
  t || (t = s.type);
  let o = t.create(r, null, i || s.marks);
  if (s.isLeaf)
    return n.replaceWith(e, e + s.nodeSize, o);
  if (!t.validContent(s.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new kr(e, e + s.nodeSize, e + 1, e + s.nodeSize - 1, new He(pe.from(o), 0, 0), 1, !0));
}
function ad(n, e, t = 1, r) {
  let i = n.resolve(e), s = i.depth - t, o = r && r[r.length - 1] || i.parent;
  if (s < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let c = i.depth - 1, u = t - 2; c > s; c--, u--) {
    let h = i.node(c), f = i.index(c);
    if (h.type.spec.isolating)
      return !1;
    let m = h.content.cutByIndex(f, h.childCount), y = r && r[u + 1];
    y && (m = m.replaceChild(0, y.type.create(y.attrs)));
    let b = r && r[u] || h;
    if (!h.canReplace(f + 1, h.childCount) || !b.type.validContent(m))
      return !1;
  }
  let a = i.indexAfter(s), l = r && r[0];
  return i.node(s).canReplaceWith(a, a, l ? l.type : i.node(s + 1).type);
}
function Xq(n, e, t = 1, r) {
  let i = n.doc.resolve(e), s = pe.empty, o = pe.empty;
  for (let a = i.depth, l = i.depth - t, c = t - 1; a > l; a--, c--) {
    s = pe.from(i.node(a).copy(s));
    let u = r && r[c];
    o = pe.from(u ? u.type.create(u.attrs, o) : i.node(a).copy(o));
  }
  n.step(new er(e, e, new He(s.append(o), t, t), !0));
}
function B1(n, e) {
  let t = n.resolve(e), r = t.index();
  return Qq(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function Zq(n, e) {
  e.content.size || n.type.compatibleContent(e.type);
  let t = n.contentMatchAt(n.childCount), { linebreakReplacement: r } = n.type.schema;
  for (let i = 0; i < e.childCount; i++) {
    let s = e.child(i), o = s.type == r ? n.type.schema.nodes.text : s.type;
    if (t = t.matchType(o), !t || !n.type.allowsMarks(s.marks))
      return !1;
  }
  return t.validEnd;
}
function Qq(n, e) {
  return !!(n && e && !n.isLeaf && Zq(n, e));
}
function e$(n, e, t) {
  let r = null, { linebreakReplacement: i } = n.doc.type.schema, s = n.doc.resolve(e - t), o = s.node().type;
  if (i && o.inlineContent) {
    let u = o.whitespace == "pre", h = !!o.contentMatch.matchType(i);
    u && !h ? r = !1 : !u && h && (r = !0);
  }
  let a = n.steps.length;
  if (r === !1) {
    let u = n.doc.resolve(e + t);
    YT(n, u.node(), u.before(), a);
  }
  o.inlineContent && $w(n, e + t - 1, o, s.node().contentMatchAt(s.index()), r == null);
  let l = n.mapping.slice(a), c = l.map(e - t);
  if (n.step(new er(c, l.map(e + t, -1), He.empty, !0)), r === !0) {
    let u = n.doc.resolve(c);
    JT(n, u.node(), u.before(), n.steps.length);
  }
  return n;
}
function t$(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.index(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.before(i + 1);
      if (s > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let s = r.indexAfter(i);
      if (r.node(i).canReplaceWith(s, s, t))
        return r.after(i + 1);
      if (s < r.node(i).childCount)
        return null;
    }
  return null;
}
function n$(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let s = 0; s < t.openStart; s++)
    i = i.firstChild.content;
  for (let s = 1; s <= (t.openStart == 0 && t.size ? 2 : 1); s++)
    for (let o = r.depth; o >= 0; o--) {
      let a = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (a > 0 ? 1 : 0), c = r.node(o), u = !1;
      if (s == 1)
        u = c.canReplace(l, l, i);
      else {
        let h = c.contentMatchAt(l).findWrapping(i.firstChild.type);
        u = h && c.canReplaceWith(l, l, h[0]);
      }
      if (u)
        return a == 0 ? r.pos : a < 0 ? r.before(o + 1) : r.after(o + 1);
    }
  return null;
}
function H1(n, e, t = e, r = He.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), s = n.resolve(t);
  return XT(i, s, r) ? new er(e, t, r) : new r$(i, s, r).fit();
}
function XT(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class r$ {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = pe.empty;
    for (let i = 0; i <= e.depth; i++) {
      let s = e.node(i);
      this.frontier.push({
        type: s.type,
        match: s.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = pe.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let s = this.placed, o = r.depth, a = i.depth;
    for (; o && a && s.childCount == 1; )
      s = s.firstChild.content, o--, a--;
    let l = new He(s, o, a);
    return e > -1 ? new kr(r.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || r.pos != this.$to.pos ? new er(r.pos, i.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let s = t.firstChild;
      if (t.childCount > 1 && (i = 0), s.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = s.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, s = null;
        r ? (s = Cb(this.unplaced.content, r - 1).firstChild, i = s.content) : i = this.unplaced.content;
        let o = i.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, h = null;
          if (t == 1 && (o ? c.matchType(o.type) || (h = c.fillBefore(pe.from(o), !1)) : s && l.compatibleContent(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, inject: h };
          if (t == 2 && o && (u = c.findWrapping(o.type)))
            return { sliceDepth: r, frontierDepth: a, parent: s, wrap: u };
          if (s && c.matchType(s.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Cb(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new He(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Cb(e, t);
    if (i.childCount <= 1 && t > 0) {
      let s = e.size - t <= t + i.size;
      this.unplaced = new He(wf(e, t - 1, 1), t - 1, s ? t - 1 : r);
    } else
      this.unplaced = new He(wf(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: s }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (s)
      for (let b = 0; b < s.length; b++)
        this.openFrontierNode(s[b]);
    let o = this.unplaced, a = r ? r.content : o.content, l = o.openStart - e, c = 0, u = [], { match: h, type: f } = this.frontier[t];
    if (i) {
      for (let b = 0; b < i.childCount; b++)
        u.push(i.child(b));
      h = h.matchFragment(i);
    }
    let m = a.size + e - (o.content.size - o.openEnd);
    for (; c < a.childCount; ) {
      let b = a.child(c), k = h.matchType(b.type);
      if (!k)
        break;
      c++, (c > 1 || l == 0 || b.content.size) && (h = k, u.push(ZT(b.mark(f.allowedMarks(b.marks)), c == 1 ? l : 0, c == a.childCount ? m : -1)));
    }
    let y = c == a.childCount;
    y || (m = -1), this.placed = kf(this.placed, t, pe.from(u)), this.frontier[t].match = h, y && m < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let b = 0, k = a; b < m; b++) {
      let x = k.lastChild;
      this.frontier.push({ type: x.type, match: x.contentMatchAt(x.childCount) }), k = x.content;
    }
    this.unplaced = y ? e == 0 ? He.empty : new He(wf(o.content, e - 1, 1), e - 1, m < 0 ? o.openEnd : e - 1) : new He(wf(o.content, e, c), o.openStart, o.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !Mb(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
      let { match: r, type: i } = this.frontier[t], s = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = Mb(e, t, i, r, s);
      if (o) {
        for (let a = t - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], u = Mb(e, a, c, l, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: t, fit: o, move: s ? e.doc.resolve(e.after(t + 1)) : e };
      }
    }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = kf(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), s = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, s);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = kf(this.placed, this.depth, pe.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(pe.empty, !0);
    t.childCount && (this.placed = kf(this.placed, this.frontier.length, t));
  }
}
function wf(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(wf(n.firstChild.content, e - 1, t)));
}
function kf(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(kf(n.lastChild.content, e - 1, t)));
}
function Cb(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function ZT(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, ZT(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(pe.empty, !0)))), n.copy(r);
}
function Mb(n, e, t, r, i) {
  let s = n.node(e), o = i ? n.indexAfter(e) : n.index(e);
  if (o == s.childCount && !t.compatibleContent(s.type))
    return null;
  let a = r.fillBefore(s.content, !0, o);
  return a && !i$(t, s.content, o) ? a : null;
}
function i$(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function s$(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function o$(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), s = n.doc.resolve(t);
  if (XT(i, s, r))
    return n.step(new er(e, t, r));
  let o = eA(i, n.doc.resolve(t));
  o[o.length - 1] == 0 && o.pop();
  let a = -(i.depth + 1);
  o.unshift(a);
  for (let f = i.depth, m = i.pos - 1; f > 0; f--, m--) {
    let y = i.node(f).type.spec;
    if (y.defining || y.definingAsContext || y.isolating)
      break;
    o.indexOf(f) > -1 ? a = f : i.before(f) == m && o.splice(1, 0, -f);
  }
  let l = o.indexOf(a), c = [], u = r.openStart;
  for (let f = r.content, m = 0; ; m++) {
    let y = f.firstChild;
    if (c.push(y), m == r.openStart)
      break;
    f = y.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let m = c[f], y = s$(m.type);
    if (y && !m.sameMarkup(i.node(Math.abs(a) - 1)))
      u = f;
    else if (y || !m.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let m = (f + u + 1) % (r.openStart + 1), y = c[m];
    if (y)
      for (let b = 0; b < o.length; b++) {
        let k = o[(b + l) % o.length], x = !0;
        k < 0 && (x = !1, k = -k);
        let M = i.node(k - 1), T = i.index(k - 1);
        if (M.canReplaceWith(T, T, y.type, y.marks))
          return n.replace(i.before(k), x ? s.after(k) : t, new He(QT(r.content, 0, r.openStart, m), m, r.openEnd));
      }
  }
  let h = n.steps.length;
  for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > h)); f--) {
    let m = o[f];
    m < 0 || (e = i.before(m), t = s.after(m));
  }
}
function QT(n, e, t, r, i) {
  if (e < t) {
    let s = n.firstChild;
    n = n.replaceChild(0, s.copy(QT(s.content, e + 1, t, r, s)));
  }
  if (e > r) {
    let s = i.contentMatchAt(0), o = s.fillBefore(n).append(n);
    n = o.append(s.matchFragment(o).fillBefore(pe.empty, !0));
  }
  return n;
}
function a$(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = t$(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new He(pe.from(r), 0, 0));
}
function l$(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), s = eA(r, i);
  for (let o = 0; o < s.length; o++) {
    let a = s[o], l = o == s.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return n.delete(r.start(a), i.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1))))
      return n.delete(r.before(a), i.after(a));
  }
  for (let o = 1; o <= r.depth && o <= i.depth; o++)
    if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o && r.start(o - 1) == i.start(o - 1) && r.node(o - 1).canReplace(r.index(o - 1), i.index(o - 1)))
      return n.delete(r.before(o), t);
  n.delete(e, t);
}
function eA(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let s = n.start(i);
    if (s < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (s == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == s - 1) && t.push(i);
  }
  return t;
}
class xu extends xr {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Vn.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let s in t.attrs)
      r[s] = t.attrs[s];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return Vn.fromReplace(e, this.pos, this.pos + 1, new He(pe.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return ki.empty;
  }
  invert(e) {
    return new xu(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new xu(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new xu(t.pos, t.attr, t.value);
  }
}
xr.jsonID("attr", xu);
class $d extends xr {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return Vn.ok(r);
  }
  getMap() {
    return ki.empty;
  }
  invert(e) {
    return new $d(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new $d(t.attr, t.value);
  }
}
xr.jsonID("docAttr", $d);
let hh = class extends Error {
};
hh = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
hh.prototype = Object.create(Error.prototype);
hh.prototype.constructor = hh;
hh.prototype.name = "TransformError";
class tA {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new qd();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new hh(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = He.empty) {
    let i = H1(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new He(pe.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, He.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return o$(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return a$(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return l$(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return jq(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return e$(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return Kq(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return Gq(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return Yq(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new xu(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new $d(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Wa(e, t)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (t instanceof wt)
      t.isInSet(r.marks) && this.step(new Lc(e, t));
    else {
      let i = r.marks, s, o = [];
      for (; s = t.isInSet(i); )
        o.push(new Lc(e, s)), i = s.removeFromSet(i);
      for (let a = o.length - 1; a >= 0; a--)
        this.step(o[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, t = 1, r) {
    return Xq(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return Vq(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return qq(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return $w(this, e, t, r), this;
  }
}
const Tb = /* @__PURE__ */ Object.create(null);
class ht {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new nA(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = He.empty) {
    let r = t.content.lastChild, i = null;
    for (let a = 0; a < t.openEnd; a++)
      i = r, r = r.lastChild;
    let s = e.steps.length, o = this.ranges;
    for (let a = 0; a < o.length; a++) {
      let { $from: l, $to: c } = o[a], u = e.mapping.slice(s);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? He.empty : t), a == 0 && cx(e, s, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let s = 0; s < i.length; s++) {
      let { $from: o, $to: a } = i[s], l = e.mapping.slice(r), c = l.map(o.pos), u = l.map(a.pos);
      s ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), cx(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new Ye(e) : ru(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let s = e.depth - 1; s >= 0; s--) {
      let o = t < 0 ? ru(e.node(0), e.node(s), e.before(s + 1), e.index(s), t, r) : ru(e.node(0), e.node(s), e.after(s + 1), e.index(s) + 1, t, r);
      if (o)
        return o;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new ni(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return ru(e, e, 0, 0, 1) || new ni(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return ru(e, e, e.content.size, e.childCount, -1) || new ni(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Tb[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Tb)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Tb[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Ye.between(this.$anchor, this.$head).getBookmark();
  }
}
ht.prototype.visible = !0;
class nA {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let ax = !1;
function lx(n) {
  !ax && !n.parent.inlineContent && (ax = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class Ye extends ht {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    lx(e), lx(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return ht.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new Ye(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = He.empty) {
    if (super.replace(e, t), t == He.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof Ye && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new z1(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Ye(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let s = ht.findFrom(t, r, !0) || ht.findFrom(t, -r, !0);
      if (s)
        t = s.$head;
      else
        return ht.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (ht.findFrom(e, -r, !0) || ht.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new Ye(e, t);
  }
}
ht.jsonID("text", Ye);
class z1 {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new z1(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Ye.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Qe extends ht {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), s = e.resolve(i);
    return r ? ht.near(s) : new Qe(s);
  }
  content() {
    return new He(pe.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Qe && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new Ww(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Qe(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new Qe(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Qe.prototype.visible = !1;
ht.jsonID("node", Qe);
class Ww {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new z1(r, r) : new Ww(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && Qe.isSelectable(r) ? new Qe(t) : ht.near(t);
  }
}
class ni extends ht {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = He.empty) {
    if (t == He.empty) {
      e.delete(0, e.doc.content.size);
      let r = ht.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ni(e);
  }
  map(e) {
    return new ni(e);
  }
  eq(e) {
    return e instanceof ni;
  }
  getBookmark() {
    return c$;
  }
}
ht.jsonID("all", ni);
const c$ = {
  map() {
    return this;
  },
  resolve(n) {
    return new ni(n);
  }
};
function ru(n, e, t, r, i, s = !1) {
  if (e.inlineContent)
    return Ye.create(n, t);
  for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) {
    let a = e.child(o);
    if (a.isAtom) {
      if (!s && Qe.isSelectable(a))
        return Qe.create(n, t - (i < 0 ? a.nodeSize : 0));
    } else {
      let l = ru(n, a, t + i, i < 0 ? a.childCount : 0, i, s);
      if (l)
        return l;
    }
    t += a.nodeSize * i;
  }
  return null;
}
function cx(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof er || i instanceof kr))
    return;
  let s = n.mapping.maps[r], o;
  s.forEach((a, l, c, u) => {
    o == null && (o = u);
  }), n.setSelection(ht.near(n.doc.resolve(o), t));
}
const ux = 1, Kp = 2, hx = 4;
class u$ extends tA {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | ux) & ~Kp, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & ux) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Kp, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return wt.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Kp) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~Kp, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || wt.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let s = this.storedMarks;
      if (!s) {
        let o = this.doc.resolve(t);
        s = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, s)), this.selection.empty || this.setSelection(ht.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= hx, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & hx) > 0;
  }
}
function fx(n, e) {
  return !e || !n ? n : n.bind(e);
}
class xf {
  constructor(e, t, r) {
    this.name = e, this.init = fx(t.init, r), this.apply = fx(t.apply, r);
  }
}
const h$ = [
  new xf("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new xf("selection", {
    init(n, e) {
      return n.selection || ht.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new xf("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new xf("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Ab {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = h$.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new xf(r.key, r.spec.state, r));
    });
  }
}
class Kl {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let s = !1;
      for (let o = 0; o < this.config.plugins.length; o++) {
        let a = this.config.plugins[o];
        if (a.spec.appendTransaction) {
          let l = i ? i[o].n : 0, c = i ? i[o].state : this, u = l < t.length && a.spec.appendTransaction.call(a, l ? t.slice(l) : t, c, r);
          if (u && r.filterTransaction(u, o)) {
            if (u.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let h = 0; h < this.config.plugins.length; h++)
                i.push(h < o ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(u), r = r.applyInner(u), s = !0;
          }
          i && (i[o] = { state: r, n: t.length });
        }
      }
      if (!s)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Kl(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let s = r[i];
      t[s.name] = s.apply(e, this[s.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new u$(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new Ab(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Kl(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new Ab(this.schema, e.plugins), r = t.fields, i = new Kl(t);
    for (let s = 0; s < r.length; s++) {
      let o = r[s].name;
      i[o] = this.hasOwnProperty(o) ? this[o] : r[s].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], s = i.spec.state;
        s && s.toJSON && (t[r] = s.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Ab(e.schema, e.plugins), s = new Kl(i);
    return i.fields.forEach((o) => {
      if (o.name == "doc")
        s.doc = Qo.fromJSON(e.schema, t.doc);
      else if (o.name == "selection")
        s.selection = ht.fromJSON(s.doc, t.selection);
      else if (o.name == "storedMarks")
        t.storedMarks && (s.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], c = l.spec.state;
            if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, a)) {
              s[o.name] = c.fromJSON.call(l, e, t[a], s);
              return;
            }
          }
        s[o.name] = o.init(e, s);
      }
    }), s;
  }
}
function rA(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = rA(i, e, {})), t[r] = i;
  }
  return t;
}
class mn {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && rA(e.props, this, this.props), this.key = e.key ? e.key.key : iA("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Eb = /* @__PURE__ */ Object.create(null);
function iA(n) {
  return n in Eb ? n + "$" + ++Eb[n] : (Eb[n] = 0, n + "$");
}
class gn {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = iA(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
class ii {
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, t, r = {}) {
    this.match = e, this.match = e, this.handler = typeof t == "string" ? f$(t) : t, this.undoable = r.undoable !== !1, this.inCode = r.inCode || !1, this.inCodeMark = r.inCodeMark !== !1;
  }
}
function f$(n) {
  return function(e, t, r, i) {
    let s = n;
    if (t[1]) {
      let o = t[0].lastIndexOf(t[1]);
      s += t[0].slice(o + t[1].length), r += o;
      let a = r - i;
      a > 0 && (s = t[0].slice(o - a, o) + s, r = i);
    }
    return e.tr.insertText(s, r, i);
  };
}
const d$ = (n, e) => {
  let t = n.plugins;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], s;
    if (i.spec.isInputRules && (s = i.getState(n))) {
      if (e) {
        let o = n.tr, a = s.transform;
        for (let l = a.steps.length - 1; l >= 0; l--)
          o.step(a.steps[l].invert(a.docs[l]));
        if (s.text) {
          let l = o.doc.resolve(s.from).marks();
          o.replaceWith(s.from, s.to, n.schema.text(s.text, l));
        } else
          o.delete(s.from, s.to);
        e(o);
      }
      return !0;
    }
  }
  return !1;
};
new ii(/--$/, "—", { inCodeMark: !1 });
new ii(/\.\.\.$/, "…", { inCodeMark: !1 });
new ii(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“", { inCodeMark: !1 });
new ii(/"$/, "”", { inCodeMark: !1 });
new ii(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘", { inCodeMark: !1 });
new ii(/'$/, "’", { inCodeMark: !1 });
function Uw(n, e, t = null, r) {
  return new ii(n, (i, s, o, a) => {
    let l = t instanceof Function ? t(s) : t, c = i.tr.delete(o, a), u = c.doc.resolve(o), h = u.blockRange(), f = h && jw(h, e, l);
    if (!f)
      return null;
    c.wrap(h, f);
    let m = c.doc.resolve(o - 1).nodeBefore;
    return m && m.type == e && B1(c.doc, o - 1) && (!r || r(s, m)) && c.join(o - 1), c;
  });
}
function Kw(n, e, t = null) {
  return new ii(n, (r, i, s, o) => {
    let a = r.doc.resolve(s), l = t instanceof Function ? t(i) : t;
    return a.node(-1).canReplaceWith(a.index(-1), a.indexAfter(-1), e) ? r.tr.delete(s, o).setBlockType(s, s, e, l) : null;
  });
}
var si = /* @__PURE__ */ ((n) => (n.docTypeError = "docTypeError", n.contextNotFound = "contextNotFound", n.timerNotFound = "timerNotFound", n.ctxCallOutOfScope = "ctxCallOutOfScope", n.createNodeInParserFail = "createNodeInParserFail", n.stackOverFlow = "stackOverFlow", n.parserMatchError = "parserMatchError", n.serializerMatchError = "serializerMatchError", n.getAtomFromSchemaFail = "getAtomFromSchemaFail", n.expectDomTypeError = "expectDomTypeError", n.callCommandBeforeEditorView = "callCommandBeforeEditorView", n.missingRootElement = "missingRootElement", n.missingNodeInSchema = "missingNodeInSchema", n.missingMarkInSchema = "missingMarkInSchema", n.ctxNotBind = "ctxNotBind", n.missingYjsDoc = "missingYjsDoc", n))(si || {});
class Di extends Error {
  constructor(e, t) {
    super(t), this.name = "MilkdownError", this.code = e;
  }
}
const p$ = (n, e) => typeof e == "function" ? "[Function]" : e, F1 = (n) => JSON.stringify(n, p$);
function m$(n) {
  return new Di(
    si.docTypeError,
    `Doc type error, unsupported type: ${F1(n)}`
  );
}
function g$(n) {
  return new Di(
    si.contextNotFound,
    `Context "${n}" not found, do you forget to inject it?`
  );
}
function y$(n) {
  return new Di(
    si.timerNotFound,
    `Timer "${n}" not found, do you forget to record it?`
  );
}
function V1() {
  return new Di(
    si.ctxCallOutOfScope,
    "Should not call a context out of the plugin."
  );
}
function b$(n, e, t) {
  const i = `Cannot create node for ${"name" in n ? n.name : n}`, s = (u) => {
    if (u == null) return "null";
    if (Array.isArray(u))
      return `[${u.map(s).join(", ")}]`;
    if (typeof u == "object")
      return "toJSON" in u && typeof u.toJSON == "function" ? JSON.stringify(u.toJSON()) : "spec" in u ? JSON.stringify(u.spec) : JSON.stringify(u);
    if (typeof u == "string" || typeof u == "number" || typeof u == "boolean")
      return JSON.stringify(u);
    if (typeof u == "function")
      return `[Function: ${u.name || "anonymous"}]`;
    try {
      return String(u);
    } catch {
      return "[Unserializable]";
    }
  }, o = ["[Description]", i], a = ["[Attributes]", e], l = [
    "[Content]",
    (t ?? []).map((u) => u ? typeof u == "object" && "type" in u ? `${u}` : s(u) : "null")
  ], c = [o, a, l].reduce(
    (u, [h, f]) => {
      const m = `${h}: ${s(f)}.`;
      return u.concat(m);
    },
    []
  );
  return new Di(
    si.createNodeInParserFail,
    c.join(`
`)
  );
}
function sA() {
  return new Di(
    si.stackOverFlow,
    "Stack over flow, cannot pop on an empty stack."
  );
}
function v$(n) {
  return new Di(
    si.parserMatchError,
    `Cannot match target parser for node: ${F1(n)}.`
  );
}
function w$(n) {
  return new Di(
    si.serializerMatchError,
    `Cannot match target serializer for node: ${F1(n)}.`
  );
}
function k$(n, e) {
  return new Di(
    si.getAtomFromSchemaFail,
    `Cannot get ${n}: ${e} from schema.`
  );
}
function Ms(n) {
  return new Di(
    si.expectDomTypeError,
    `Expect to be a dom, but get: ${F1(n)}.`
  );
}
function Lb() {
  return new Di(
    si.callCommandBeforeEditorView,
    "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
  );
}
function x$(n) {
  return new Di(
    si.missingNodeInSchema,
    `Missing node in schema, milkdown cannot find "${n}" in schema.`
  );
}
function S$(n) {
  return new Di(
    si.missingMarkInSchema,
    `Missing mark in schema, milkdown cannot find "${n}" in schema.`
  );
}
const il = typeof navigator < "u" ? navigator : null, dx = typeof document < "u" ? document : null, dl = il && il.userAgent || "", Gv = /Edge\/(\d+)/.exec(dl), oA = /MSIE \d/.exec(dl), Jv = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(dl), q1 = !!(oA || Jv || Gv), C$ = oA ? document.documentMode : Jv ? +Jv[1] : Gv ? +Gv[1] : 0, aA = !q1 && /gecko\/(\d+)/i.test(dl), M$ = aA && +(/Firefox\/(\d+)/.exec(dl) || [0, 0])[1], Yv = !q1 && /Chrome\/(\d+)/.exec(dl), T$ = !!Yv, A$ = Yv ? +Yv[1] : 0, lA = !q1 && !!il && /Apple Computer/.test(il.vendor), cA = lA && (/Mobile\/\w+/.test(dl) || !!il && il.maxTouchPoints > 2), E$ = cA || (il ? /Mac/.test(il.platform) : !1), L$ = /Android \d/.test(dl), uA = !!dx && "webkitFontSmoothing" in dx.documentElement.style, O$ = uA ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
var Gp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  android: L$,
  chrome: T$,
  chrome_version: A$,
  gecko: aA,
  gecko_version: M$,
  ie: q1,
  ie_version: C$,
  ios: cA,
  mac: E$,
  safari: lA,
  webkit: uA,
  webkit_version: O$
});
function Ob(n, e, t, r, i, s) {
  if (n.composing) return !1;
  const o = n.state, a = o.doc.resolve(e);
  if (a.parent.type.spec.code) return !1;
  const l = a.parent.textBetween(
    Math.max(0, a.parentOffset - 500),
    a.parentOffset,
    void 0,
    "￼"
  ) + r;
  for (let c of i) {
    const u = c, h = u.match.exec(l), f = h && h[0] && u.handler(o, h, e - (h[0].length - r.length), t);
    if (f)
      return u.undoable !== !1 && f.setMeta(s, { transform: f, from: e, to: t, text: r }), n.dispatch(f), !0;
  }
  return !1;
}
const D$ = new gn("MILKDOWN_CUSTOM_INPUTRULES");
function N$({ rules: n }) {
  const e = new mn({
    key: D$,
    isInputRules: !0,
    state: {
      init() {
        return null;
      },
      apply(t, r) {
        const i = t.getMeta(this);
        return i || (t.selectionSet || t.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(t, r, i, s) {
        return Ob(t, r, i, s, n, e);
      },
      handleDOMEvents: {
        compositionend: (t) => (setTimeout(() => {
          const { $cursor: r } = t.state.selection;
          r && Ob(t, r.pos, r.pos, "", n, e);
        }), !1)
      },
      handleKeyDown(t, r) {
        if (r.key !== "Enter") return !1;
        const { $cursor: i } = t.state.selection;
        return i ? Ob(t, i.pos, i.pos, `
`, n, e) : !1;
      }
    }
  });
  return e;
}
function $0(n, e, t = {}) {
  return new ii(n, (r, i, s, o) => {
    var a, l, c, u;
    const { tr: h } = r, f = i.length;
    let m = i[f - 1], y = i[0], b = [], k = o;
    const x = {
      group: m,
      fullMatch: y,
      start: s,
      end: o
    }, M = (a = t.updateCaptured) == null ? void 0 : a.call(t, x);
    if (Object.assign(x, M), { group: m, fullMatch: y, start: s, end: o } = x, y === null || (m == null ? void 0 : m.trim()) === "") return null;
    if (m) {
      const T = y.search(/\S/), E = s + y.indexOf(m), C = E + m.length;
      b = (l = h.storedMarks) != null ? l : [], C < o && h.delete(C, o), E > s && h.delete(s + T, E), k = s + T + m.length;
      const O = (c = t.getAttr) == null ? void 0 : c.call(t, i);
      h.addMark(s, k, e.create(O)), h.setStoredMarks(b), (u = t.beforeDispatch) == null || u.call(t, { match: i, start: s, end: o, tr: h });
    }
    return h;
  });
}
function I$(n, e, t = {}) {
  return new ii(n, (r, i, s, o) => {
    var a, l, c;
    const { tr: u } = r;
    let h = i[1], f = i[0];
    const m = {
      group: h,
      fullMatch: f,
      start: s,
      end: o
    }, y = (a = t.updateCaptured) == null ? void 0 : a.call(t, m);
    if (Object.assign(m, y), { group: h, fullMatch: f, start: s, end: o } = m, f === null || !h || h.trim() === "") return null;
    const b = (l = t.getAttr) == null ? void 0 : l.call(t, i), k = e.createAndFill(b);
    return k && (u.replaceRangeWith(
      e.isBlock ? u.doc.resolve(s).before() : s,
      o,
      k
    ), (c = t.beforeDispatch) == null || c.call(t, {
      match: [f, h ?? ""],
      start: s,
      end: o,
      tr: u
    })), u;
  });
}
var _$ = Object.defineProperty, R$ = Object.defineProperties, P$ = Object.getOwnPropertyDescriptors, px = Object.getOwnPropertySymbols, B$ = Object.prototype.hasOwnProperty, H$ = Object.prototype.propertyIsEnumerable, mx = (n, e, t) => e in n ? _$(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, z$ = (n, e) => {
  for (var t in e || (e = {}))
    B$.call(e, t) && mx(n, t, e[t]);
  if (px)
    for (var t of px(e))
      H$.call(e, t) && mx(n, t, e[t]);
  return n;
}, F$ = (n, e) => R$(n, P$(e));
function gx(n = 0, e = 0, t = 0) {
  return Math.min(Math.max(n, e), t);
}
function $1(n, e, t) {
  const i = n.state.doc.content.size, s = gx(e, 0, i), o = gx(t, 0, i), a = n.coordsAtPos(s), l = n.coordsAtPos(o, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), h = Math.min(a.left, l.left), f = Math.max(a.right, l.right), m = f - h, y = u - c, x = {
    top: c,
    bottom: u,
    left: h,
    right: f,
    width: m,
    height: y,
    x: h,
    y: c
  };
  return F$(z$({}, x), {
    toJSON: () => x
  });
}
function hA(n) {
  return Object.assign(Object.create(n), n).setTime(Date.now());
}
function V$(n, e) {
  return Array.isArray(n) && n.includes(e.type) || e.type === n;
}
function q$(n) {
  if (n.content.childCount === 1) {
    const e = n.content.firstChild;
    if ((e == null ? void 0 : e.type.name) === "text" && e.marks.length === 0) return e;
    if ((e == null ? void 0 : e.type.name) === "paragraph" && e.childCount === 1) {
      const t = e.firstChild;
      if ((t == null ? void 0 : t.type.name) === "text" && t.marks.length === 0) return t;
    }
  }
  return !1;
}
function eo(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t -= 1) {
      const r = e.node(t);
      if (n(r)) {
        const i = e.before(t), s = e.after(t);
        return {
          from: i,
          to: s,
          node: r
        };
      }
    }
  };
}
function $$(n, e) {
  return eo((t) => t.type === e)(n);
}
function j$(n, e) {
  const t = e.nodes[n];
  if (!t) throw k$("node", n);
  return t;
}
function fA(n) {
  return (e) => {
    for (let t = e.depth; t > 0; t--) {
      const r = e.node(t);
      if (n(r))
        return {
          pos: t > 0 ? e.before(t) : 0,
          start: e.start(t),
          depth: t,
          node: r
        };
    }
  };
}
function W$(n) {
  return (e) => fA(n)(e.$from);
}
function U$(n, e) {
  if (!(n instanceof Qe)) return;
  const { node: t, $from: r } = n;
  if (V$(e, t))
    return {
      node: t,
      pos: r.pos,
      start: r.start(r.depth),
      depth: r.depth
    };
}
const dA = (n, e) => {
  const { selection: t, doc: r } = n;
  if (t instanceof Qe)
    return {
      hasNode: t.node.type === e,
      pos: t.from,
      target: t.node
    };
  const { from: i, to: s } = t;
  let o = !1, a = -1, l = null;
  return r.nodesBetween(i, s, (c, u) => l ? !1 : c.type === e ? (o = !0, a = u, l = c, !1) : !0), {
    hasNode: o,
    pos: a,
    target: l
  };
};
class pA {
  constructor() {
    this.sliceMap = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      if (!t) {
        const r = typeof e == "string" ? e : e.name;
        throw g$(r);
      }
      return t;
    }, this.remove = (e) => {
      const t = typeof e == "string" ? [...this.sliceMap.values()].find((r) => r.type.name === e) : this.sliceMap.get(e.id);
      t && this.sliceMap.delete(t.type.id);
    }, this.has = (e) => typeof e == "string" ? [...this.sliceMap.values()].some((t) => t.type.name === e) : this.sliceMap.has(e.id);
  }
}
var ds, Ho, Du;
class K$ {
  /// @internal
  constructor(e, t, r) {
    Se(this, ds);
    /// @internal
    Se(this, Ho);
    Se(this, Du);
    re(this, ds, []), re(this, Du, () => {
      G(this, ds).forEach((i) => i(G(this, Ho)));
    }), this.set = (i) => {
      re(this, Ho, i), G(this, Du).call(this);
    }, this.get = () => G(this, Ho), this.update = (i) => {
      re(this, Ho, i(G(this, Ho))), G(this, Du).call(this);
    }, this.type = r, re(this, Ho, t), e.set(r.id, this);
  }
  /// Add a watcher for changes in the slice.
  /// Returns a function to remove the watcher.
  on(e) {
    return G(this, ds).push(e), () => {
      re(this, ds, G(this, ds).filter((t) => t !== e));
    };
  }
  /// Add a one-time watcher for changes in the slice.
  /// The watcher will be removed after it is called.
  /// Returns a function to remove the watcher.
  once(e) {
    const t = this.on((r) => {
      e(r), t();
    });
    return t;
  }
  /// Remove a watcher.
  off(e) {
    re(this, ds, G(this, ds).filter((t) => t !== e));
  }
  /// Remove all watchers.
  offAll() {
    re(this, ds, []);
  }
}
ds = new WeakMap(), Ho = new WeakMap(), Du = new WeakMap();
class G$ {
  /// Create a slice type with a default value and a name.
  /// The name should be unique in the container.
  constructor(e, t) {
    this.id = Symbol(`Context-${t}`), this.name = t, this._defaultValue = e, this._typeInfo = () => {
      throw V1();
    };
  }
  /// Create a slice with a container.
  /// You can also pass a value to override the default value.
  create(e, t = this._defaultValue) {
    return new K$(e, t, this);
  }
}
const It = (n, e) => new G$(n, e);
var c0, u0, h0, Ql, Nu, za, Iu, _u, Ru;
class J$ {
  /// Create an inspector with container, clock and metadata.
  constructor(e, t, r) {
    /// @internal
    Se(this, c0);
    /// @internal
    Se(this, u0);
    /// @internal
    Se(this, h0);
    Se(this, Ql);
    Se(this, Nu);
    Se(this, za);
    Se(this, Iu);
    Se(this, _u);
    Se(this, Ru);
    re(this, Ql, /* @__PURE__ */ new Set()), re(this, Nu, /* @__PURE__ */ new Set()), re(this, za, /* @__PURE__ */ new Map()), re(this, Iu, /* @__PURE__ */ new Map()), this.read = () => ({
      metadata: G(this, c0),
      injectedSlices: [...G(this, Ql)].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: G(this, _u).call(this, i)
      })),
      consumedSlices: [...G(this, Nu)].map((i) => ({
        name: typeof i == "string" ? i : i.name,
        value: G(this, _u).call(this, i)
      })),
      recordedTimers: [...G(this, za)].map(
        ([i, { duration: s }]) => ({
          name: i.name,
          duration: s,
          status: G(this, Ru).call(this, i)
        })
      ),
      waitTimers: [...G(this, Iu)].map(([i, { duration: s }]) => ({
        name: i.name,
        duration: s,
        status: G(this, Ru).call(this, i)
      }))
    }), this.onRecord = (i) => {
      G(this, za).set(i, { start: Date.now(), duration: 0 });
    }, this.onClear = (i) => {
      G(this, za).delete(i);
    }, this.onDone = (i) => {
      const s = G(this, za).get(i);
      s && (s.duration = Date.now() - s.start);
    }, this.onWait = (i, s) => {
      const o = Date.now();
      s.finally(() => {
        G(this, Iu).set(i, { duration: Date.now() - o });
      }).catch(console.error);
    }, this.onInject = (i) => {
      G(this, Ql).add(i);
    }, this.onRemove = (i) => {
      G(this, Ql).delete(i);
    }, this.onUse = (i) => {
      G(this, Nu).add(i);
    }, re(this, _u, (i) => G(this, u0).get(i).get()), re(this, Ru, (i) => G(this, h0).get(i).status), re(this, u0, e), re(this, h0, t), re(this, c0, r);
  }
}
c0 = new WeakMap(), u0 = new WeakMap(), h0 = new WeakMap(), Ql = new WeakMap(), Nu = new WeakMap(), za = new WeakMap(), Iu = new WeakMap(), _u = new WeakMap(), Ru = new WeakMap();
var zo, Fo, f0, Pi;
const O6 = class O6 {
  /// Create a ctx object with container and clock.
  constructor(e, t, r) {
    /// @internal
    Se(this, zo);
    /// @internal
    Se(this, Fo);
    /// @internal
    Se(this, f0);
    /// @internal
    Se(this, Pi);
    this.produce = (i) => i && Object.keys(i).length ? new O6(G(this, zo), G(this, Fo), { ...i }) : this, this.inject = (i, s) => {
      var a;
      const o = i.create(G(this, zo).sliceMap);
      return s != null && o.set(s), (a = G(this, Pi)) == null || a.onInject(i), this;
    }, this.remove = (i) => {
      var s;
      return G(this, zo).remove(i), (s = G(this, Pi)) == null || s.onRemove(i), this;
    }, this.record = (i) => {
      var s;
      return i.create(G(this, Fo).store), (s = G(this, Pi)) == null || s.onRecord(i), this;
    }, this.clearTimer = (i) => {
      var s;
      return G(this, Fo).remove(i), (s = G(this, Pi)) == null || s.onClear(i), this;
    }, this.isInjected = (i) => G(this, zo).has(i), this.isRecorded = (i) => G(this, Fo).has(i), this.use = (i) => {
      var s;
      return (s = G(this, Pi)) == null || s.onUse(i), G(this, zo).get(i);
    }, this.get = (i) => this.use(i).get(), this.set = (i, s) => this.use(i).set(s), this.update = (i, s) => this.use(i).update(s), this.timer = (i) => G(this, Fo).get(i), this.done = (i) => {
      var s;
      this.timer(i).done(), (s = G(this, Pi)) == null || s.onDone(i);
    }, this.wait = (i) => {
      var o;
      const s = this.timer(i).start();
      return (o = G(this, Pi)) == null || o.onWait(i, s), s;
    }, this.waitTimers = async (i) => {
      await Promise.all(this.get(i).map((s) => this.wait(s)));
    }, re(this, zo, e), re(this, Fo, t), re(this, f0, r), r && re(this, Pi, new J$(e, t, r));
  }
  /// Get metadata of the ctx.
  get meta() {
    return G(this, f0);
  }
  /// Get the inspector of the ctx.
  get inspector() {
    return G(this, Pi);
  }
};
zo = new WeakMap(), Fo = new WeakMap(), f0 = new WeakMap(), Pi = new WeakMap();
let Xv = O6;
class Y$ {
  constructor() {
    this.store = /* @__PURE__ */ new Map(), this.get = (e) => {
      const t = this.store.get(e.id);
      if (!t) throw y$(e.name);
      return t;
    }, this.remove = (e) => {
      this.store.delete(e.id);
    }, this.has = (e) => this.store.has(e.id);
  }
}
var Pu, Fa, Bu, Vo, Hu, d0;
class X$ {
  /// @internal
  constructor(e, t) {
    Se(this, Pu);
    Se(this, Fa);
    /// @internal
    Se(this, Bu);
    Se(this, Vo);
    Se(this, Hu);
    Se(this, d0);
    re(this, Pu, null), re(this, Fa, null), re(this, Vo, "pending"), this.start = () => (G(this, Pu) ?? re(this, Pu, new Promise((r, i) => {
      re(this, Fa, (s) => {
        s instanceof CustomEvent && s.detail.id === G(this, Bu) && (re(this, Vo, "resolved"), G(this, Hu).call(this), s.stopImmediatePropagation(), r());
      }), G(this, d0).call(this, () => {
        G(this, Vo) === "pending" && re(this, Vo, "rejected"), G(this, Hu).call(this), i(new Error(`Timing ${this.type.name} timeout.`));
      }), re(this, Vo, "pending"), addEventListener(this.type.name, G(this, Fa));
    })), G(this, Pu)), this.done = () => {
      const r = new CustomEvent(this.type.name, {
        detail: { id: G(this, Bu) }
      });
      dispatchEvent(r);
    }, re(this, Hu, () => {
      G(this, Fa) && removeEventListener(this.type.name, G(this, Fa));
    }), re(this, d0, (r) => {
      setTimeout(() => {
        r();
      }, this.type.timeout);
    }), re(this, Bu, Symbol(t.name)), this.type = t, e.set(t.id, this);
  }
  /// The status of the timer.
  /// Can be `pending`, `resolved` or `rejected`.
  get status() {
    return G(this, Vo);
  }
}
Pu = new WeakMap(), Fa = new WeakMap(), Bu = new WeakMap(), Vo = new WeakMap(), Hu = new WeakMap(), d0 = new WeakMap();
class Z$ {
  /// Create a timer type with a name and a timeout.
  /// The name should be unique in the clock.
  constructor(e, t = 3e3) {
    this.create = (r) => new X$(r, this), this.id = Symbol(`Timer-${e}`), this.name = e, this.timeout = t;
  }
}
const pa = (n, e = 3e3) => new Z$(n, e), Q$ = {};
function Gw(n, e) {
  const t = Q$, r = typeof t.includeImageAlt == "boolean" ? t.includeImageAlt : !0, i = typeof t.includeHtml == "boolean" ? t.includeHtml : !0;
  return mA(n, r, i);
}
function mA(n, e, t) {
  if (ej(n)) {
    if ("value" in n)
      return n.type === "html" && !t ? "" : n.value;
    if (e && "alt" in n && n.alt)
      return n.alt;
    if ("children" in n)
      return yx(n.children, e, t);
  }
  return Array.isArray(n) ? yx(n, e, t) : "";
}
function yx(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; )
    r[i] = mA(n[i], e, t);
  return r.join("");
}
function ej(n) {
  return !!(n && typeof n == "object");
}
const bx = document.createElement("i");
function Jw(n) {
  const e = "&" + n + ";";
  bx.innerHTML = e;
  const t = bx.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    t.charCodeAt(t.length - 1) === 59 && n !== "semi" || t === e ? !1 : t
  );
}
function Ti(n, e, t, r) {
  const i = n.length;
  let s = 0, o;
  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(e, t), n.splice(...o);
  else
    for (t && n.splice(e, t); s < r.length; )
      o = r.slice(s, s + 1e4), o.unshift(e, 0), n.splice(...o), s += 1e4, e += 1e4;
}
function Fi(n, e) {
  return n.length > 0 ? (Ti(n, n.length, 0, e), n) : e;
}
const vx = {}.hasOwnProperty;
function gA(n) {
  const e = {};
  let t = -1;
  for (; ++t < n.length; )
    tj(e, n[t]);
  return e;
}
function tj(n, e) {
  let t;
  for (t in e) {
    const i = (vx.call(n, t) ? n[t] : void 0) || (n[t] = {}), s = e[t];
    let o;
    if (s)
      for (o in s) {
        vx.call(i, o) || (i[o] = []);
        const a = s[o];
        nj(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(a) ? a : a ? [a] : []
        );
      }
  }
}
function nj(n, e) {
  let t = -1;
  const r = [];
  for (; ++t < e.length; )
    (e[t].add === "after" ? n : r).push(e[t]);
  Ti(n, 0, 0, r);
}
function yA(n, e) {
  const t = Number.parseInt(n, e);
  return (
    // C0 except for HT, LF, FF, CR, space.
    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of C0, and C1 controls.
    t > 126 && t < 160 || // Lone high surrogates and low surrogates.
    t > 55295 && t < 57344 || // Noncharacters.
    t > 64975 && t < 65008 || /* eslint-disable no-bitwise */
    (t & 65535) === 65535 || (t & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    t > 1114111 ? "�" : String.fromCodePoint(t)
  );
}
function bs(n) {
  return n.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Or = pl(/[A-Za-z]/), ei = pl(/[\dA-Za-z]/), rj = pl(/[#-'*+\--9=?A-Z^-~]/);
function qg(n) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    n !== null && (n < 32 || n === 127)
  );
}
const Zv = pl(/\d/), ij = pl(/[\dA-Fa-f]/), sj = pl(/[!-/:-@[-`{-~]/);
function Xe(n) {
  return n !== null && n < -2;
}
function tn(n) {
  return n !== null && (n < 0 || n === 32);
}
function Lt(n) {
  return n === -2 || n === -1 || n === 32;
}
const j1 = pl(new RegExp("\\p{P}|\\p{S}", "u")), Oc = pl(/\s/);
function pl(n) {
  return e;
  function e(t) {
    return t !== null && t > -1 && n.test(String.fromCharCode(t));
  }
}
function Ct(n, e, t, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let s = 0;
  return o;
  function o(l) {
    return Lt(l) ? (n.enter(t), a(l)) : e(l);
  }
  function a(l) {
    return Lt(l) && s++ < i ? (n.consume(l), a) : (n.exit(t), e(l));
  }
}
const oj = {
  tokenize: aj
};
function aj(n) {
  const e = n.attempt(this.parser.constructs.contentInitial, r, i);
  let t;
  return e;
  function r(a) {
    if (a === null) {
      n.consume(a);
      return;
    }
    return n.enter("lineEnding"), n.consume(a), n.exit("lineEnding"), Ct(n, e, "linePrefix");
  }
  function i(a) {
    return n.enter("paragraph"), s(a);
  }
  function s(a) {
    const l = n.enter("chunkText", {
      contentType: "text",
      previous: t
    });
    return t && (t.next = l), t = l, o(a);
  }
  function o(a) {
    if (a === null) {
      n.exit("chunkText"), n.exit("paragraph"), n.consume(a);
      return;
    }
    return Xe(a) ? (n.consume(a), n.exit("chunkText"), s) : (n.consume(a), o);
  }
}
const lj = {
  tokenize: cj
}, wx = {
  tokenize: uj
};
function cj(n) {
  const e = this, t = [];
  let r = 0, i, s, o;
  return a;
  function a(T) {
    if (r < t.length) {
      const E = t[r];
      return e.containerState = E[1], n.attempt(E[0].continuation, l, c)(T);
    }
    return c(T);
  }
  function l(T) {
    if (r++, e.containerState._closeFlow) {
      e.containerState._closeFlow = void 0, i && M();
      const E = e.events.length;
      let C = E, O;
      for (; C--; )
        if (e.events[C][0] === "exit" && e.events[C][1].type === "chunkFlow") {
          O = e.events[C][1].end;
          break;
        }
      x(r);
      let R = E;
      for (; R < e.events.length; )
        e.events[R][1].end = {
          ...O
        }, R++;
      return Ti(e.events, C + 1, 0, e.events.slice(E)), e.events.length = R, c(T);
    }
    return a(T);
  }
  function c(T) {
    if (r === t.length) {
      if (!i)
        return f(T);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return y(T);
      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return e.containerState = {}, n.check(wx, u, h)(T);
  }
  function u(T) {
    return i && M(), x(r), f(T);
  }
  function h(T) {
    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, y(T);
  }
  function f(T) {
    return e.containerState = {}, n.attempt(wx, m, y)(T);
  }
  function m(T) {
    return r++, t.push([e.currentConstruct, e.containerState]), f(T);
  }
  function y(T) {
    if (T === null) {
      i && M(), x(0), n.consume(T);
      return;
    }
    return i = i || e.parser.flow(e.now()), n.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: s
    }), b(T);
  }
  function b(T) {
    if (T === null) {
      k(n.exit("chunkFlow"), !0), x(0), n.consume(T);
      return;
    }
    return Xe(T) ? (n.consume(T), k(n.exit("chunkFlow")), r = 0, e.interrupt = void 0, a) : (n.consume(T), b);
  }
  function k(T, E) {
    const C = e.sliceStream(T);
    if (E && C.push(null), T.previous = s, s && (s.next = T), s = T, i.defineSkip(T.start), i.write(C), e.parser.lazy[T.start.line]) {
      let O = i.events.length;
      for (; O--; )
        if (
          // The token starts before the line ending…
          i.events[O][1].start.offset < o && // …and either is not ended yet…
          (!i.events[O][1].end || // …or ends after it.
          i.events[O][1].end.offset > o)
        )
          return;
      const R = e.events.length;
      let F = R, H, z;
      for (; F--; )
        if (e.events[F][0] === "exit" && e.events[F][1].type === "chunkFlow") {
          if (H) {
            z = e.events[F][1].end;
            break;
          }
          H = !0;
        }
      for (x(r), O = R; O < e.events.length; )
        e.events[O][1].end = {
          ...z
        }, O++;
      Ti(e.events, F + 1, 0, e.events.slice(R)), e.events.length = O;
    }
  }
  function x(T) {
    let E = t.length;
    for (; E-- > T; ) {
      const C = t[E];
      e.containerState = C[1], C[0].exit.call(e, n);
    }
    t.length = T;
  }
  function M() {
    i.write([null]), s = void 0, i = void 0, e.containerState._closeFlow = void 0;
  }
}
function uj(n, e, t) {
  return Ct(n, n.attempt(this.parser.constructs.document, e, t), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function fh(n) {
  if (n === null || tn(n) || Oc(n))
    return 1;
  if (j1(n))
    return 2;
}
function W1(n, e, t) {
  const r = [];
  let i = -1;
  for (; ++i < n.length; ) {
    const s = n[i].resolveAll;
    s && !r.includes(s) && (e = s(e, t), r.push(s));
  }
  return e;
}
const Qv = {
  name: "attention",
  resolveAll: hj,
  tokenize: fj
};
function hj(n, e) {
  let t = -1, r, i, s, o, a, l, c, u;
  for (; ++t < n.length; )
    if (n[t][0] === "enter" && n[t][1].type === "attentionSequence" && n[t][1]._close) {
      for (r = t; r--; )
        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:
        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {
          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))
            continue;
          l = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;
          const h = {
            ...n[r][1].end
          }, f = {
            ...n[t][1].start
          };
          kx(h, -l), kx(f, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: h,
            end: {
              ...n[r][1].end
            }
          }, a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...n[t][1].start
            },
            end: f
          }, s = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: {
              ...n[r][1].end
            },
            end: {
              ...n[t][1].start
            }
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: {
              ...o.start
            },
            end: {
              ...a.end
            }
          }, n[r][1].end = {
            ...o.start
          }, n[t][1].start = {
            ...a.end
          }, c = [], n[r][1].end.offset - n[r][1].start.offset && (c = Fi(c, [["enter", n[r][1], e], ["exit", n[r][1], e]])), c = Fi(c, [["enter", i, e], ["enter", o, e], ["exit", o, e], ["enter", s, e]]), c = Fi(c, W1(e.parser.constructs.insideSpan.null, n.slice(r + 1, t), e)), c = Fi(c, [["exit", s, e], ["enter", a, e], ["exit", a, e], ["exit", i, e]]), n[t][1].end.offset - n[t][1].start.offset ? (u = 2, c = Fi(c, [["enter", n[t][1], e], ["exit", n[t][1], e]])) : u = 0, Ti(n, r - 1, t - r + 3, c), t = r + c.length - u - 2;
          break;
        }
    }
  for (t = -1; ++t < n.length; )
    n[t][1].type === "attentionSequence" && (n[t][1].type = "data");
  return n;
}
function fj(n, e) {
  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = fh(r);
  let s;
  return o;
  function o(l) {
    return s = l, n.enter("attentionSequence"), a(l);
  }
  function a(l) {
    if (l === s)
      return n.consume(l), a;
    const c = n.exit("attentionSequence"), u = fh(l), h = !u || u === 2 && i || t.includes(l), f = !i || i === 2 && u || t.includes(r);
    return c._open = !!(s === 42 ? h : h && (i || !f)), c._close = !!(s === 42 ? f : f && (u || !h)), e(l);
  }
}
function kx(n, e) {
  n.column += e, n.offset += e, n._bufferIndex += e;
}
const dj = {
  name: "autolink",
  tokenize: pj
};
function pj(n, e, t) {
  let r = 0;
  return i;
  function i(m) {
    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(m), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), s;
  }
  function s(m) {
    return Or(m) ? (n.consume(m), o) : m === 64 ? t(m) : c(m);
  }
  function o(m) {
    return m === 43 || m === 45 || m === 46 || ei(m) ? (r = 1, a(m)) : c(m);
  }
  function a(m) {
    return m === 58 ? (n.consume(m), r = 0, l) : (m === 43 || m === 45 || m === 46 || ei(m)) && r++ < 32 ? (n.consume(m), a) : (r = 0, c(m));
  }
  function l(m) {
    return m === 62 ? (n.exit("autolinkProtocol"), n.enter("autolinkMarker"), n.consume(m), n.exit("autolinkMarker"), n.exit("autolink"), e) : m === null || m === 32 || m === 60 || qg(m) ? t(m) : (n.consume(m), l);
  }
  function c(m) {
    return m === 64 ? (n.consume(m), u) : rj(m) ? (n.consume(m), c) : t(m);
  }
  function u(m) {
    return ei(m) ? h(m) : t(m);
  }
  function h(m) {
    return m === 46 ? (n.consume(m), r = 0, u) : m === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", n.enter("autolinkMarker"), n.consume(m), n.exit("autolinkMarker"), n.exit("autolink"), e) : f(m);
  }
  function f(m) {
    if ((m === 45 || ei(m)) && r++ < 63) {
      const y = m === 45 ? f : h;
      return n.consume(m), y;
    }
    return t(m);
  }
}
const j0 = {
  partial: !0,
  tokenize: mj
};
function mj(n, e, t) {
  return r;
  function r(s) {
    return Lt(s) ? Ct(n, i, "linePrefix")(s) : i(s);
  }
  function i(s) {
    return s === null || Xe(s) ? e(s) : t(s);
  }
}
const bA = {
  continuation: {
    tokenize: yj
  },
  exit: bj,
  name: "blockQuote",
  tokenize: gj
};
function gj(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const a = r.containerState;
      return a.open || (n.enter("blockQuote", {
        _container: !0
      }), a.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), s;
    }
    return t(o);
  }
  function s(o) {
    return Lt(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), e) : (n.exit("blockQuotePrefix"), e(o));
  }
}
function yj(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return Lt(o) ? Ct(n, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : s(o);
  }
  function s(o) {
    return n.attempt(bA, e, t)(o);
  }
}
function bj(n) {
  n.exit("blockQuote");
}
const vA = {
  name: "characterEscape",
  tokenize: vj
};
function vj(n, e, t) {
  return r;
  function r(s) {
    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(s), n.exit("escapeMarker"), i;
  }
  function i(s) {
    return sj(s) ? (n.enter("characterEscapeValue"), n.consume(s), n.exit("characterEscapeValue"), n.exit("characterEscape"), e) : t(s);
  }
}
const wA = {
  name: "characterReference",
  tokenize: wj
};
function wj(n, e, t) {
  const r = this;
  let i = 0, s, o;
  return a;
  function a(h) {
    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), l;
  }
  function l(h) {
    return h === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(h), n.exit("characterReferenceMarkerNumeric"), c) : (n.enter("characterReferenceValue"), s = 31, o = ei, u(h));
  }
  function c(h) {
    return h === 88 || h === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(h), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), s = 6, o = ij, u) : (n.enter("characterReferenceValue"), s = 7, o = Zv, u(h));
  }
  function u(h) {
    if (h === 59 && i) {
      const f = n.exit("characterReferenceValue");
      return o === ei && !Jw(r.sliceSerialize(f)) ? t(h) : (n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), n.exit("characterReference"), e);
    }
    return o(h) && i++ < s ? (n.consume(h), u) : t(h);
  }
}
const xx = {
  partial: !0,
  tokenize: xj
}, Sx = {
  concrete: !0,
  name: "codeFenced",
  tokenize: kj
};
function kj(n, e, t) {
  const r = this, i = {
    partial: !0,
    tokenize: C
  };
  let s = 0, o = 0, a;
  return l;
  function l(O) {
    return c(O);
  }
  function c(O) {
    const R = r.events[r.events.length - 1];
    return s = R && R[1].type === "linePrefix" ? R[2].sliceSerialize(R[1], !0).length : 0, a = O, n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), u(O);
  }
  function u(O) {
    return O === a ? (o++, n.consume(O), u) : o < 3 ? t(O) : (n.exit("codeFencedFenceSequence"), Lt(O) ? Ct(n, h, "whitespace")(O) : h(O));
  }
  function h(O) {
    return O === null || Xe(O) ? (n.exit("codeFencedFence"), r.interrupt ? e(O) : n.check(xx, b, E)(O)) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {
      contentType: "string"
    }), f(O));
  }
  function f(O) {
    return O === null || Xe(O) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), h(O)) : Lt(O) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), Ct(n, m, "whitespace")(O)) : O === 96 && O === a ? t(O) : (n.consume(O), f);
  }
  function m(O) {
    return O === null || Xe(O) ? h(O) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), y(O));
  }
  function y(O) {
    return O === null || Xe(O) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), h(O)) : O === 96 && O === a ? t(O) : (n.consume(O), y);
  }
  function b(O) {
    return n.attempt(i, E, k)(O);
  }
  function k(O) {
    return n.enter("lineEnding"), n.consume(O), n.exit("lineEnding"), x;
  }
  function x(O) {
    return s > 0 && Lt(O) ? Ct(n, M, "linePrefix", s + 1)(O) : M(O);
  }
  function M(O) {
    return O === null || Xe(O) ? n.check(xx, b, E)(O) : (n.enter("codeFlowValue"), T(O));
  }
  function T(O) {
    return O === null || Xe(O) ? (n.exit("codeFlowValue"), M(O)) : (n.consume(O), T);
  }
  function E(O) {
    return n.exit("codeFenced"), e(O);
  }
  function C(O, R, F) {
    let H = 0;
    return z;
    function z(he) {
      return O.enter("lineEnding"), O.consume(he), O.exit("lineEnding"), K;
    }
    function K(he) {
      return O.enter("codeFencedFence"), Lt(he) ? Ct(O, U, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(he) : U(he);
    }
    function U(he) {
      return he === a ? (O.enter("codeFencedFenceSequence"), ae(he)) : F(he);
    }
    function ae(he) {
      return he === a ? (H++, O.consume(he), ae) : H >= o ? (O.exit("codeFencedFenceSequence"), Lt(he) ? Ct(O, ie, "whitespace")(he) : ie(he)) : F(he);
    }
    function ie(he) {
      return he === null || Xe(he) ? (O.exit("codeFencedFence"), R(he)) : F(he);
    }
  }
}
function xj(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? t(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
const Db = {
  name: "codeIndented",
  tokenize: Cj
}, Sj = {
  partial: !0,
  tokenize: Mj
};
function Cj(n, e, t) {
  const r = this;
  return i;
  function i(c) {
    return n.enter("codeIndented"), Ct(n, s, "linePrefix", 5)(c);
  }
  function s(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : t(c);
  }
  function o(c) {
    return c === null ? l(c) : Xe(c) ? n.attempt(Sj, o, l)(c) : (n.enter("codeFlowValue"), a(c));
  }
  function a(c) {
    return c === null || Xe(c) ? (n.exit("codeFlowValue"), o(c)) : (n.consume(c), a);
  }
  function l(c) {
    return n.exit("codeIndented"), e(c);
  }
}
function Mj(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? t(o) : Xe(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : Ct(n, s, "linePrefix", 5)(o);
  }
  function s(o) {
    const a = r.events[r.events.length - 1];
    return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : Xe(o) ? i(o) : t(o);
  }
}
const Tj = {
  name: "codeText",
  previous: Ej,
  resolve: Aj,
  tokenize: Lj
};
function Aj(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "codeTextData") {
        n[t][1].type = "codeTextPadding", n[e][1].type = "codeTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function Ej(n) {
  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Lj(n, e, t) {
  let r = 0, i, s;
  return o;
  function o(h) {
    return n.enter("codeText"), n.enter("codeTextSequence"), a(h);
  }
  function a(h) {
    return h === 96 ? (n.consume(h), r++, a) : (n.exit("codeTextSequence"), l(h));
  }
  function l(h) {
    return h === null ? t(h) : h === 32 ? (n.enter("space"), n.consume(h), n.exit("space"), l) : h === 96 ? (s = n.enter("codeTextSequence"), i = 0, u(h)) : Xe(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), l) : (n.enter("codeTextData"), c(h));
  }
  function c(h) {
    return h === null || h === 32 || h === 96 || Xe(h) ? (n.exit("codeTextData"), l(h)) : (n.consume(h), c);
  }
  function u(h) {
    return h === 96 ? (n.consume(h), i++, u) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), e(h)) : (s.type = "codeTextData", c(h));
  }
}
class Oj {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(e) {
    this.left = e ? [...e] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(e) {
    if (e < 0 || e >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(e, t) {
    const r = t ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(e, r) : e > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(e, t, r) {
    const i = t || 0;
    this.setCursor(Math.trunc(e));
    const s = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && rf(this.left, r), s.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(e) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(e) {
    this.setCursor(Number.POSITIVE_INFINITY), rf(this.left, e);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(e) {
    this.setCursor(0), this.right.push(e);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(e) {
    this.setCursor(0), rf(this.right, e.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(e) {
    if (!(e === this.left.length || e > this.left.length && this.right.length === 0 || e < 0 && this.left.length === 0))
      if (e < this.left.length) {
        const t = this.left.splice(e, Number.POSITIVE_INFINITY);
        rf(this.right, t.reverse());
      } else {
        const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY);
        rf(this.left, t.reverse());
      }
  }
}
function rf(n, e) {
  let t = 0;
  if (e.length < 1e4)
    n.push(...e);
  else
    for (; t < e.length; )
      n.push(...e.slice(t, t + 1e4)), t += 1e4;
}
function kA(n) {
  const e = {};
  let t = -1, r, i, s, o, a, l, c;
  const u = new Oj(n);
  for (; ++t < u.length; ) {
    for (; t in e; )
      t = e[t];
    if (r = u.get(t), t && r[1].type === "chunkFlow" && u.get(t - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, s = 0, s < l.length && l[s][1].type === "lineEndingBlank" && (s += 2), s < l.length && l[s][1].type === "content"))
      for (; ++s < l.length && l[s][1].type !== "content"; )
        l[s][1].type === "chunkText" && (l[s][1]._isInFirstContentOfListItem = !0, s++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(e, Dj(u, t)), t = e[t], c = !0);
    else if (r[1]._container) {
      for (s = t, i = void 0; s--; )
        if (o = u.get(s), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank")
          o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = s);
        else if (!(o[1].type === "linePrefix" || o[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...u.get(i)[1].start
      }, a = u.slice(i, t), a.unshift(r), u.splice(i, t - i + 1, a));
    }
  }
  return Ti(n, 0, Number.POSITIVE_INFINITY, u.slice(0)), !c;
}
function Dj(n, e) {
  const t = n.get(e)[1], r = n.get(e)[2];
  let i = e - 1;
  const s = [];
  let o = t._tokenizer;
  o || (o = r.parser[t.contentType](t.start), t._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0));
  const a = o.events, l = [], c = {};
  let u, h, f = -1, m = t, y = 0, b = 0;
  const k = [b];
  for (; m; ) {
    for (; n.get(++i)[1] !== m; )
      ;
    s.push(i), m._tokenizer || (u = r.sliceStream(m), m.next || u.push(null), h && o.defineSkip(m.start), m._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), m._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = m, m = m.next;
  }
  for (m = t; ++f < a.length; )
    // Find a void token that includes a break.
    a[f][0] === "exit" && a[f - 1][0] === "enter" && a[f][1].type === a[f - 1][1].type && a[f][1].start.line !== a[f][1].end.line && (b = f + 1, k.push(b), m._tokenizer = void 0, m.previous = void 0, m = m.next);
  for (o.events = [], m ? (m._tokenizer = void 0, m.previous = void 0) : k.pop(), f = k.length; f--; ) {
    const x = a.slice(k[f], k[f + 1]), M = s.pop();
    l.push([M, M + x.length - 1]), n.splice(M, 2, x);
  }
  for (l.reverse(), f = -1; ++f < l.length; )
    c[y + l[f][0]] = y + l[f][1], y += l[f][1] - l[f][0] - 1;
  return c;
}
const Nj = {
  resolve: _j,
  tokenize: Rj
}, Ij = {
  partial: !0,
  tokenize: Pj
};
function _j(n) {
  return kA(n), n;
}
function Rj(n, e) {
  let t;
  return r;
  function r(a) {
    return n.enter("content"), t = n.enter("chunkContent", {
      contentType: "content"
    }), i(a);
  }
  function i(a) {
    return a === null ? s(a) : Xe(a) ? n.check(Ij, o, s)(a) : (n.consume(a), i);
  }
  function s(a) {
    return n.exit("chunkContent"), n.exit("content"), e(a);
  }
  function o(a) {
    return n.consume(a), n.exit("chunkContent"), t.next = n.enter("chunkContent", {
      contentType: "content",
      previous: t
    }), t = t.next, i;
  }
}
function Pj(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), Ct(n, s, "linePrefix");
  }
  function s(o) {
    if (o === null || Xe(o))
      return t(o);
    const a = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);
  }
}
function xA(n, e, t, r, i, s, o, a, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return h;
  function h(x) {
    return x === 60 ? (n.enter(r), n.enter(i), n.enter(s), n.consume(x), n.exit(s), f) : x === null || x === 32 || x === 41 || qg(x) ? t(x) : (n.enter(r), n.enter(o), n.enter(a), n.enter("chunkString", {
      contentType: "string"
    }), b(x));
  }
  function f(x) {
    return x === 62 ? (n.enter(s), n.consume(x), n.exit(s), n.exit(i), n.exit(r), e) : (n.enter(a), n.enter("chunkString", {
      contentType: "string"
    }), m(x));
  }
  function m(x) {
    return x === 62 ? (n.exit("chunkString"), n.exit(a), f(x)) : x === null || x === 60 || Xe(x) ? t(x) : (n.consume(x), x === 92 ? y : m);
  }
  function y(x) {
    return x === 60 || x === 62 || x === 92 ? (n.consume(x), m) : m(x);
  }
  function b(x) {
    return !u && (x === null || x === 41 || tn(x)) ? (n.exit("chunkString"), n.exit(a), n.exit(o), n.exit(r), e(x)) : u < c && x === 40 ? (n.consume(x), u++, b) : x === 41 ? (n.consume(x), u--, b) : x === null || x === 32 || x === 40 || qg(x) ? t(x) : (n.consume(x), x === 92 ? k : b);
  }
  function k(x) {
    return x === 40 || x === 41 || x === 92 ? (n.consume(x), b) : b(x);
  }
}
function SA(n, e, t, r, i, s) {
  const o = this;
  let a = 0, l;
  return c;
  function c(m) {
    return n.enter(r), n.enter(i), n.consume(m), n.exit(i), n.enter(s), u;
  }
  function u(m) {
    return a > 999 || m === null || m === 91 || m === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    m === 94 && !a && "_hiddenFootnoteSupport" in o.parser.constructs ? t(m) : m === 93 ? (n.exit(s), n.enter(i), n.consume(m), n.exit(i), n.exit(r), e) : Xe(m) ? (n.enter("lineEnding"), n.consume(m), n.exit("lineEnding"), u) : (n.enter("chunkString", {
      contentType: "string"
    }), h(m));
  }
  function h(m) {
    return m === null || m === 91 || m === 93 || Xe(m) || a++ > 999 ? (n.exit("chunkString"), u(m)) : (n.consume(m), l || (l = !Lt(m)), m === 92 ? f : h);
  }
  function f(m) {
    return m === 91 || m === 92 || m === 93 ? (n.consume(m), a++, h) : h(m);
  }
}
function CA(n, e, t, r, i, s) {
  let o;
  return a;
  function a(f) {
    return f === 34 || f === 39 || f === 40 ? (n.enter(r), n.enter(i), n.consume(f), n.exit(i), o = f === 40 ? 41 : f, l) : t(f);
  }
  function l(f) {
    return f === o ? (n.enter(i), n.consume(f), n.exit(i), n.exit(r), e) : (n.enter(s), c(f));
  }
  function c(f) {
    return f === o ? (n.exit(s), l(o)) : f === null ? t(f) : Xe(f) ? (n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), Ct(n, c, "linePrefix")) : (n.enter("chunkString", {
      contentType: "string"
    }), u(f));
  }
  function u(f) {
    return f === o || f === null || Xe(f) ? (n.exit("chunkString"), c(f)) : (n.consume(f), f === 92 ? h : u);
  }
  function h(f) {
    return f === o || f === 92 ? (n.consume(f), u) : u(f);
  }
}
function ld(n, e) {
  let t;
  return r;
  function r(i) {
    return Xe(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), t = !0, r) : Lt(i) ? Ct(n, r, t ? "linePrefix" : "lineSuffix")(i) : e(i);
  }
}
const Bj = {
  name: "definition",
  tokenize: zj
}, Hj = {
  partial: !0,
  tokenize: Fj
};
function zj(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(m) {
    return n.enter("definition"), o(m);
  }
  function o(m) {
    return SA.call(
      r,
      n,
      a,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(m);
  }
  function a(m) {
    return i = bs(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), m === 58 ? (n.enter("definitionMarker"), n.consume(m), n.exit("definitionMarker"), l) : t(m);
  }
  function l(m) {
    return tn(m) ? ld(n, c)(m) : c(m);
  }
  function c(m) {
    return xA(
      n,
      u,
      // Note: we don’t need to reset the way `markdown-rs` does.
      t,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(m);
  }
  function u(m) {
    return n.attempt(Hj, h, h)(m);
  }
  function h(m) {
    return Lt(m) ? Ct(n, f, "whitespace")(m) : f(m);
  }
  function f(m) {
    return m === null || Xe(m) ? (n.exit("definition"), r.parser.defined.push(i), e(m)) : t(m);
  }
}
function Fj(n, e, t) {
  return r;
  function r(a) {
    return tn(a) ? ld(n, i)(a) : t(a);
  }
  function i(a) {
    return CA(n, s, t, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a);
  }
  function s(a) {
    return Lt(a) ? Ct(n, o, "whitespace")(a) : o(a);
  }
  function o(a) {
    return a === null || Xe(a) ? e(a) : t(a);
  }
}
const Vj = {
  name: "hardBreakEscape",
  tokenize: qj
};
function qj(n, e, t) {
  return r;
  function r(s) {
    return n.enter("hardBreakEscape"), n.consume(s), i;
  }
  function i(s) {
    return Xe(s) ? (n.exit("hardBreakEscape"), e(s)) : t(s);
  }
}
const $j = {
  name: "headingAtx",
  resolve: jj,
  tokenize: Wj
};
function jj(n, e) {
  let t = n.length - 2, r = 3, i, s;
  return n[r][1].type === "whitespace" && (r += 2), t - 2 > r && n[t][1].type === "whitespace" && (t -= 2), n[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {
    type: "atxHeadingText",
    start: n[r][1].start,
    end: n[t][1].end
  }, s = {
    type: "chunkText",
    start: n[r][1].start,
    end: n[t][1].end,
    contentType: "text"
  }, Ti(n, r, t - r + 1, [["enter", i, e], ["enter", s, e], ["exit", s, e], ["exit", i, e]])), n;
}
function Wj(n, e, t) {
  let r = 0;
  return i;
  function i(u) {
    return n.enter("atxHeading"), s(u);
  }
  function s(u) {
    return n.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (n.consume(u), o) : u === null || tn(u) ? (n.exit("atxHeadingSequence"), a(u)) : t(u);
  }
  function a(u) {
    return u === 35 ? (n.enter("atxHeadingSequence"), l(u)) : u === null || Xe(u) ? (n.exit("atxHeading"), e(u)) : Lt(u) ? Ct(n, a, "whitespace")(u) : (n.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (n.consume(u), l) : (n.exit("atxHeadingSequence"), a(u));
  }
  function c(u) {
    return u === null || u === 35 || tn(u) ? (n.exit("atxHeadingText"), a(u)) : (n.consume(u), c);
  }
}
const Uj = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Cx = ["pre", "script", "style", "textarea"], Kj = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Yj,
  tokenize: Xj
}, Gj = {
  partial: !0,
  tokenize: Qj
}, Jj = {
  partial: !0,
  tokenize: Zj
};
function Yj(n) {
  let e = n.length;
  for (; e-- && !(n[e][0] === "enter" && n[e][1].type === "htmlFlow"); )
    ;
  return e > 1 && n[e - 2][1].type === "linePrefix" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;
}
function Xj(n, e, t) {
  const r = this;
  let i, s, o, a, l;
  return c;
  function c(V) {
    return u(V);
  }
  function u(V) {
    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(V), h;
  }
  function h(V) {
    return V === 33 ? (n.consume(V), f) : V === 47 ? (n.consume(V), s = !0, b) : V === 63 ? (n.consume(V), i = 3, r.interrupt ? e : q) : Or(V) ? (n.consume(V), o = String.fromCharCode(V), k) : t(V);
  }
  function f(V) {
    return V === 45 ? (n.consume(V), i = 2, m) : V === 91 ? (n.consume(V), i = 5, a = 0, y) : Or(V) ? (n.consume(V), i = 4, r.interrupt ? e : q) : t(V);
  }
  function m(V) {
    return V === 45 ? (n.consume(V), r.interrupt ? e : q) : t(V);
  }
  function y(V) {
    const _t = "CDATA[";
    return V === _t.charCodeAt(a++) ? (n.consume(V), a === _t.length ? r.interrupt ? e : U : y) : t(V);
  }
  function b(V) {
    return Or(V) ? (n.consume(V), o = String.fromCharCode(V), k) : t(V);
  }
  function k(V) {
    if (V === null || V === 47 || V === 62 || tn(V)) {
      const _t = V === 47, at = o.toLowerCase();
      return !_t && !s && Cx.includes(at) ? (i = 1, r.interrupt ? e(V) : U(V)) : Uj.includes(o.toLowerCase()) ? (i = 6, _t ? (n.consume(V), x) : r.interrupt ? e(V) : U(V)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(V) : s ? M(V) : T(V));
    }
    return V === 45 || ei(V) ? (n.consume(V), o += String.fromCharCode(V), k) : t(V);
  }
  function x(V) {
    return V === 62 ? (n.consume(V), r.interrupt ? e : U) : t(V);
  }
  function M(V) {
    return Lt(V) ? (n.consume(V), M) : z(V);
  }
  function T(V) {
    return V === 47 ? (n.consume(V), z) : V === 58 || V === 95 || Or(V) ? (n.consume(V), E) : Lt(V) ? (n.consume(V), T) : z(V);
  }
  function E(V) {
    return V === 45 || V === 46 || V === 58 || V === 95 || ei(V) ? (n.consume(V), E) : C(V);
  }
  function C(V) {
    return V === 61 ? (n.consume(V), O) : Lt(V) ? (n.consume(V), C) : T(V);
  }
  function O(V) {
    return V === null || V === 60 || V === 61 || V === 62 || V === 96 ? t(V) : V === 34 || V === 39 ? (n.consume(V), l = V, R) : Lt(V) ? (n.consume(V), O) : F(V);
  }
  function R(V) {
    return V === l ? (n.consume(V), l = null, H) : V === null || Xe(V) ? t(V) : (n.consume(V), R);
  }
  function F(V) {
    return V === null || V === 34 || V === 39 || V === 47 || V === 60 || V === 61 || V === 62 || V === 96 || tn(V) ? C(V) : (n.consume(V), F);
  }
  function H(V) {
    return V === 47 || V === 62 || Lt(V) ? T(V) : t(V);
  }
  function z(V) {
    return V === 62 ? (n.consume(V), K) : t(V);
  }
  function K(V) {
    return V === null || Xe(V) ? U(V) : Lt(V) ? (n.consume(V), K) : t(V);
  }
  function U(V) {
    return V === 45 && i === 2 ? (n.consume(V), Ie) : V === 60 && i === 1 ? (n.consume(V), Oe) : V === 62 && i === 4 ? (n.consume(V), Re) : V === 63 && i === 3 ? (n.consume(V), q) : V === 93 && i === 5 ? (n.consume(V), We) : Xe(V) && (i === 6 || i === 7) ? (n.exit("htmlFlowData"), n.check(Gj, J, ae)(V)) : V === null || Xe(V) ? (n.exit("htmlFlowData"), ae(V)) : (n.consume(V), U);
  }
  function ae(V) {
    return n.check(Jj, ie, J)(V);
  }
  function ie(V) {
    return n.enter("lineEnding"), n.consume(V), n.exit("lineEnding"), he;
  }
  function he(V) {
    return V === null || Xe(V) ? ae(V) : (n.enter("htmlFlowData"), U(V));
  }
  function Ie(V) {
    return V === 45 ? (n.consume(V), q) : U(V);
  }
  function Oe(V) {
    return V === 47 ? (n.consume(V), o = "", Ne) : U(V);
  }
  function Ne(V) {
    if (V === 62) {
      const _t = o.toLowerCase();
      return Cx.includes(_t) ? (n.consume(V), Re) : U(V);
    }
    return Or(V) && o.length < 8 ? (n.consume(V), o += String.fromCharCode(V), Ne) : U(V);
  }
  function We(V) {
    return V === 93 ? (n.consume(V), q) : U(V);
  }
  function q(V) {
    return V === 62 ? (n.consume(V), Re) : V === 45 && i === 2 ? (n.consume(V), q) : U(V);
  }
  function Re(V) {
    return V === null || Xe(V) ? (n.exit("htmlFlowData"), J(V)) : (n.consume(V), Re);
  }
  function J(V) {
    return n.exit("htmlFlow"), e(V);
  }
}
function Zj(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return Xe(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s) : t(o);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Qj(n, e, t) {
  return r;
  function r(i) {
    return n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), n.attempt(j0, e, t);
  }
}
const eW = {
  name: "htmlText",
  tokenize: tW
};
function tW(n, e, t) {
  const r = this;
  let i, s, o;
  return a;
  function a(q) {
    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(q), l;
  }
  function l(q) {
    return q === 33 ? (n.consume(q), c) : q === 47 ? (n.consume(q), C) : q === 63 ? (n.consume(q), T) : Or(q) ? (n.consume(q), F) : t(q);
  }
  function c(q) {
    return q === 45 ? (n.consume(q), u) : q === 91 ? (n.consume(q), s = 0, y) : Or(q) ? (n.consume(q), M) : t(q);
  }
  function u(q) {
    return q === 45 ? (n.consume(q), m) : t(q);
  }
  function h(q) {
    return q === null ? t(q) : q === 45 ? (n.consume(q), f) : Xe(q) ? (o = h, Oe(q)) : (n.consume(q), h);
  }
  function f(q) {
    return q === 45 ? (n.consume(q), m) : h(q);
  }
  function m(q) {
    return q === 62 ? Ie(q) : q === 45 ? f(q) : h(q);
  }
  function y(q) {
    const Re = "CDATA[";
    return q === Re.charCodeAt(s++) ? (n.consume(q), s === Re.length ? b : y) : t(q);
  }
  function b(q) {
    return q === null ? t(q) : q === 93 ? (n.consume(q), k) : Xe(q) ? (o = b, Oe(q)) : (n.consume(q), b);
  }
  function k(q) {
    return q === 93 ? (n.consume(q), x) : b(q);
  }
  function x(q) {
    return q === 62 ? Ie(q) : q === 93 ? (n.consume(q), x) : b(q);
  }
  function M(q) {
    return q === null || q === 62 ? Ie(q) : Xe(q) ? (o = M, Oe(q)) : (n.consume(q), M);
  }
  function T(q) {
    return q === null ? t(q) : q === 63 ? (n.consume(q), E) : Xe(q) ? (o = T, Oe(q)) : (n.consume(q), T);
  }
  function E(q) {
    return q === 62 ? Ie(q) : T(q);
  }
  function C(q) {
    return Or(q) ? (n.consume(q), O) : t(q);
  }
  function O(q) {
    return q === 45 || ei(q) ? (n.consume(q), O) : R(q);
  }
  function R(q) {
    return Xe(q) ? (o = R, Oe(q)) : Lt(q) ? (n.consume(q), R) : Ie(q);
  }
  function F(q) {
    return q === 45 || ei(q) ? (n.consume(q), F) : q === 47 || q === 62 || tn(q) ? H(q) : t(q);
  }
  function H(q) {
    return q === 47 ? (n.consume(q), Ie) : q === 58 || q === 95 || Or(q) ? (n.consume(q), z) : Xe(q) ? (o = H, Oe(q)) : Lt(q) ? (n.consume(q), H) : Ie(q);
  }
  function z(q) {
    return q === 45 || q === 46 || q === 58 || q === 95 || ei(q) ? (n.consume(q), z) : K(q);
  }
  function K(q) {
    return q === 61 ? (n.consume(q), U) : Xe(q) ? (o = K, Oe(q)) : Lt(q) ? (n.consume(q), K) : H(q);
  }
  function U(q) {
    return q === null || q === 60 || q === 61 || q === 62 || q === 96 ? t(q) : q === 34 || q === 39 ? (n.consume(q), i = q, ae) : Xe(q) ? (o = U, Oe(q)) : Lt(q) ? (n.consume(q), U) : (n.consume(q), ie);
  }
  function ae(q) {
    return q === i ? (n.consume(q), i = void 0, he) : q === null ? t(q) : Xe(q) ? (o = ae, Oe(q)) : (n.consume(q), ae);
  }
  function ie(q) {
    return q === null || q === 34 || q === 39 || q === 60 || q === 61 || q === 96 ? t(q) : q === 47 || q === 62 || tn(q) ? H(q) : (n.consume(q), ie);
  }
  function he(q) {
    return q === 47 || q === 62 || tn(q) ? H(q) : t(q);
  }
  function Ie(q) {
    return q === 62 ? (n.consume(q), n.exit("htmlTextData"), n.exit("htmlText"), e) : t(q);
  }
  function Oe(q) {
    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(q), n.exit("lineEnding"), Ne;
  }
  function Ne(q) {
    return Lt(q) ? Ct(n, We, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(q) : We(q);
  }
  function We(q) {
    return n.enter("htmlTextData"), o(q);
  }
}
const Yw = {
  name: "labelEnd",
  resolveAll: sW,
  resolveTo: oW,
  tokenize: aW
}, nW = {
  tokenize: lW
}, rW = {
  tokenize: cW
}, iW = {
  tokenize: uW
};
function sW(n) {
  let e = -1;
  const t = [];
  for (; ++e < n.length; ) {
    const r = n[e][1];
    if (t.push(n[e]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", e += i;
    }
  }
  return n.length !== t.length && Ti(n, 0, n.length, t), n;
}
function oW(n, e) {
  let t = n.length, r = 0, i, s, o, a;
  for (; t--; )
    if (i = n[t][1], s) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      n[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (n[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (s = t, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = t);
  const l = {
    type: n[s][1].type === "labelLink" ? "link" : "image",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  }, c = {
    type: "label",
    start: {
      ...n[s][1].start
    },
    end: {
      ...n[o][1].end
    }
  }, u = {
    type: "labelText",
    start: {
      ...n[s + r + 2][1].end
    },
    end: {
      ...n[o - 2][1].start
    }
  };
  return a = [["enter", l, e], ["enter", c, e]], a = Fi(a, n.slice(s + 1, s + r + 3)), a = Fi(a, [["enter", u, e]]), a = Fi(a, W1(e.parser.constructs.insideSpan.null, n.slice(s + r + 4, o - 3), e)), a = Fi(a, [["exit", u, e], n[o - 2], n[o - 1], ["exit", c, e]]), a = Fi(a, n.slice(o + 1)), a = Fi(a, [["exit", l, e]]), Ti(n, s, n.length, a), n;
}
function aW(n, e, t) {
  const r = this;
  let i = r.events.length, s, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      s = r.events[i][1];
      break;
    }
  return a;
  function a(f) {
    return s ? s._inactive ? h(f) : (o = r.parser.defined.includes(bs(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }))), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(f), n.exit("labelMarker"), n.exit("labelEnd"), l) : t(f);
  }
  function l(f) {
    return f === 40 ? n.attempt(nW, u, o ? u : h)(f) : f === 91 ? n.attempt(rW, u, o ? c : h)(f) : o ? u(f) : h(f);
  }
  function c(f) {
    return n.attempt(iW, u, h)(f);
  }
  function u(f) {
    return e(f);
  }
  function h(f) {
    return s._balanced = !0, t(f);
  }
}
function lW(n, e, t) {
  return r;
  function r(h) {
    return n.enter("resource"), n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), i;
  }
  function i(h) {
    return tn(h) ? ld(n, s)(h) : s(h);
  }
  function s(h) {
    return h === 41 ? u(h) : xA(n, o, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(h);
  }
  function o(h) {
    return tn(h) ? ld(n, l)(h) : u(h);
  }
  function a(h) {
    return t(h);
  }
  function l(h) {
    return h === 34 || h === 39 || h === 40 ? CA(n, c, t, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(h) : u(h);
  }
  function c(h) {
    return tn(h) ? ld(n, u)(h) : u(h);
  }
  function u(h) {
    return h === 41 ? (n.enter("resourceMarker"), n.consume(h), n.exit("resourceMarker"), n.exit("resource"), e) : t(h);
  }
}
function cW(n, e, t) {
  const r = this;
  return i;
  function i(a) {
    return SA.call(r, n, s, o, "reference", "referenceMarker", "referenceString")(a);
  }
  function s(a) {
    return r.parser.defined.includes(bs(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? e(a) : t(a);
  }
  function o(a) {
    return t(a);
  }
}
function uW(n, e, t) {
  return r;
  function r(s) {
    return n.enter("reference"), n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), i;
  }
  function i(s) {
    return s === 93 ? (n.enter("referenceMarker"), n.consume(s), n.exit("referenceMarker"), n.exit("reference"), e) : t(s);
  }
}
const hW = {
  name: "labelStartImage",
  resolveAll: Yw.resolveAll,
  tokenize: fW
};
function fW(n, e, t) {
  const r = this;
  return i;
  function i(a) {
    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(a), n.exit("labelImageMarker"), s;
  }
  function s(a) {
    return a === 91 ? (n.enter("labelMarker"), n.consume(a), n.exit("labelMarker"), n.exit("labelImage"), o) : t(a);
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(a) : e(a);
  }
}
const dW = {
  name: "labelStartLink",
  resolveAll: Yw.resolveAll,
  tokenize: pW
};
function pW(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), s;
  }
  function s(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : e(o);
  }
}
const Nb = {
  name: "lineEnding",
  tokenize: mW
};
function mW(n, e) {
  return t;
  function t(r) {
    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), Ct(n, e, "linePrefix");
  }
}
const Pm = {
  name: "thematicBreak",
  tokenize: gW
};
function gW(n, e, t) {
  let r = 0, i;
  return s;
  function s(c) {
    return n.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, a(c);
  }
  function a(c) {
    return c === i ? (n.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || Xe(c)) ? (n.exit("thematicBreak"), e(c)) : t(c);
  }
  function l(c) {
    return c === i ? (n.consume(c), r++, l) : (n.exit("thematicBreakSequence"), Lt(c) ? Ct(n, a, "whitespace")(c) : a(c));
  }
}
const jr = {
  continuation: {
    tokenize: wW
  },
  exit: xW,
  name: "list",
  tokenize: vW
}, yW = {
  partial: !0,
  tokenize: SW
}, bW = {
  partial: !0,
  tokenize: kW
};
function vW(n, e, t) {
  const r = this, i = r.events[r.events.length - 1];
  let s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return a;
  function a(m) {
    const y = r.containerState.type || (m === 42 || m === 43 || m === 45 ? "listUnordered" : "listOrdered");
    if (y === "listUnordered" ? !r.containerState.marker || m === r.containerState.marker : Zv(m)) {
      if (r.containerState.type || (r.containerState.type = y, n.enter(y, {
        _container: !0
      })), y === "listUnordered")
        return n.enter("listItemPrefix"), m === 42 || m === 45 ? n.check(Pm, t, c)(m) : c(m);
      if (!r.interrupt || m === 49)
        return n.enter("listItemPrefix"), n.enter("listItemValue"), l(m);
    }
    return t(m);
  }
  function l(m) {
    return Zv(m) && ++o < 10 ? (n.consume(m), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? m === r.containerState.marker : m === 41 || m === 46) ? (n.exit("listItemValue"), c(m)) : t(m);
  }
  function c(m) {
    return n.enter("listItemMarker"), n.consume(m), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || m, n.check(
      j0,
      // Can’t be empty when interrupting.
      r.interrupt ? t : u,
      n.attempt(yW, f, h)
    );
  }
  function u(m) {
    return r.containerState.initialBlankLine = !0, s++, f(m);
  }
  function h(m) {
    return Lt(m) ? (n.enter("listItemPrefixWhitespace"), n.consume(m), n.exit("listItemPrefixWhitespace"), f) : t(m);
  }
  function f(m) {
    return r.containerState.size = s + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, e(m);
  }
}
function wW(n, e, t) {
  const r = this;
  return r.containerState._closeFlow = void 0, n.check(j0, i, s);
  function i(a) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Ct(n, e, "listItemIndent", r.containerState.size + 1)(a);
  }
  function s(a) {
    return r.containerState.furtherBlankLines || !Lt(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(bW, e, o)(a));
  }
  function o(a) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Ct(n, n.attempt(jr, e, t), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a);
  }
}
function kW(n, e, t) {
  const r = this;
  return Ct(n, i, "listItemIndent", r.containerState.size + 1);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(s) : t(s);
  }
}
function xW(n) {
  n.exit(this.containerState.type);
}
function SW(n, e, t) {
  const r = this;
  return Ct(n, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return !Lt(s) && o && o[1].type === "listItemPrefixWhitespace" ? e(s) : t(s);
  }
}
const Mx = {
  name: "setextUnderline",
  resolveTo: CW,
  tokenize: MW
};
function CW(n, e) {
  let t = n.length, r, i, s;
  for (; t--; )
    if (n[t][0] === "enter") {
      if (n[t][1].type === "content") {
        r = t;
        break;
      }
      n[t][1].type === "paragraph" && (i = t);
    } else
      n[t][1].type === "content" && n.splice(t, 1), !s && n[t][1].type === "definition" && (s = t);
  const o = {
    type: "setextHeading",
    start: {
      ...n[r][1].start
    },
    end: {
      ...n[n.length - 1][1].end
    }
  };
  return n[i][1].type = "setextHeadingText", s ? (n.splice(i, 0, ["enter", o, e]), n.splice(s + 1, 0, ["exit", n[r][1], e]), n[r][1].end = {
    ...n[s][1].end
  }) : n[r][1] = o, n.push(["exit", o, e]), n;
}
function MW(n, e, t) {
  const r = this;
  let i;
  return s;
  function s(c) {
    let u = r.events.length, h;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        h = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || h) ? (n.enter("setextHeadingLine"), i = c, o(c)) : t(c);
  }
  function o(c) {
    return n.enter("setextHeadingLineSequence"), a(c);
  }
  function a(c) {
    return c === i ? (n.consume(c), a) : (n.exit("setextHeadingLineSequence"), Lt(c) ? Ct(n, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || Xe(c) ? (n.exit("setextHeadingLine"), e(c)) : t(c);
  }
}
const TW = {
  tokenize: AW
};
function AW(n) {
  const e = this, t = n.attempt(
    // Try to parse a blank line.
    j0,
    r,
    // Try to parse initial flow (essentially, only code).
    n.attempt(this.parser.constructs.flowInitial, i, Ct(n, n.attempt(this.parser.constructs.flow, i, n.attempt(Nj, i)), "linePrefix"))
  );
  return t;
  function r(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEndingBlank"), n.consume(s), n.exit("lineEndingBlank"), e.currentConstruct = void 0, t;
  }
  function i(s) {
    if (s === null) {
      n.consume(s);
      return;
    }
    return n.enter("lineEnding"), n.consume(s), n.exit("lineEnding"), e.currentConstruct = void 0, t;
  }
}
const EW = {
  resolveAll: TA()
}, LW = MA("string"), OW = MA("text");
function MA(n) {
  return {
    resolveAll: TA(n === "text" ? DW : void 0),
    tokenize: e
  };
  function e(t) {
    const r = this, i = this.parser.constructs[n], s = t.attempt(i, o, a);
    return o;
    function o(u) {
      return c(u) ? s(u) : a(u);
    }
    function a(u) {
      if (u === null) {
        t.consume(u);
        return;
      }
      return t.enter("data"), t.consume(u), l;
    }
    function l(u) {
      return c(u) ? (t.exit("data"), s(u)) : (t.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const h = i[u];
      let f = -1;
      if (h)
        for (; ++f < h.length; ) {
          const m = h[f];
          if (!m.previous || m.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function TA(n) {
  return e;
  function e(t, r) {
    let i = -1, s;
    for (; ++i <= t.length; )
      s === void 0 ? t[i] && t[i][1].type === "data" && (s = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== s + 2 && (t[s][1].end = t[i - 1][1].end, t.splice(s + 2, i - s - 2), i = s + 2), s = void 0);
    return n ? n(t, r) : t;
  }
}
function DW(n, e) {
  let t = 0;
  for (; ++t <= n.length; )
    if ((t === n.length || n[t][1].type === "lineEnding") && n[t - 1][1].type === "data") {
      const r = n[t - 1][1], i = e.sliceStream(r);
      let s = i.length, o = -1, a = 0, l;
      for (; s--; ) {
        const c = i[s];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            a++, o--;
          if (o) break;
          o = -1;
        } else if (c === -2)
          l = !0, a++;
        else if (c !== -1) {
          s++;
          break;
        }
      }
      if (e._contentTypeTextTrailing && t === n.length && (a = 0), a) {
        const c = {
          type: t === n.length || l || a < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: s ? o : r.start._bufferIndex + o,
            _index: r.start._index + s,
            line: r.end.line,
            column: r.end.column - a,
            offset: r.end.offset - a
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...c.start
        }, r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(t, 0, ["enter", c, e], ["exit", c, e]), t += 2);
      }
      t++;
    }
  return n;
}
const NW = {
  42: jr,
  43: jr,
  45: jr,
  48: jr,
  49: jr,
  50: jr,
  51: jr,
  52: jr,
  53: jr,
  54: jr,
  55: jr,
  56: jr,
  57: jr,
  62: bA
}, IW = {
  91: Bj
}, _W = {
  [-2]: Db,
  [-1]: Db,
  32: Db
}, RW = {
  35: $j,
  42: Pm,
  45: [Mx, Pm],
  60: Kj,
  61: Mx,
  95: Pm,
  96: Sx,
  126: Sx
}, PW = {
  38: wA,
  92: vA
}, BW = {
  [-5]: Nb,
  [-4]: Nb,
  [-3]: Nb,
  33: hW,
  38: wA,
  42: Qv,
  60: [dj, eW],
  91: dW,
  92: [Vj, vA],
  93: Yw,
  95: Qv,
  96: Tj
}, HW = {
  null: [Qv, EW]
}, zW = {
  null: [42, 95]
}, FW = {
  null: []
}, VW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: zW,
  contentInitial: IW,
  disable: FW,
  document: NW,
  flow: RW,
  flowInitial: _W,
  insideSpan: HW,
  string: PW,
  text: BW
}, Symbol.toStringTag, { value: "Module" }));
function qW(n, e, t) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: t && t.line || 1,
    column: t && t.column || 1,
    offset: t && t.offset || 0
  };
  const i = {}, s = [];
  let o = [], a = [];
  const l = {
    attempt: R(C),
    check: R(O),
    consume: M,
    enter: T,
    exit: E,
    interrupt: R(O, {
      interrupt: !0
    })
  }, c = {
    code: null,
    containerState: {},
    defineSkip: b,
    events: [],
    now: y,
    parser: n,
    previous: null,
    sliceSerialize: f,
    sliceStream: m,
    write: h
  };
  let u = e.tokenize.call(c, l);
  return e.resolveAll && s.push(e), c;
  function h(K) {
    return o = Fi(o, K), k(), o[o.length - 1] !== null ? [] : (F(e, 0), c.events = W1(s, c.events, c), c.events);
  }
  function f(K, U) {
    return jW(m(K), U);
  }
  function m(K) {
    return $W(o, K);
  }
  function y() {
    const {
      _bufferIndex: K,
      _index: U,
      line: ae,
      column: ie,
      offset: he
    } = r;
    return {
      _bufferIndex: K,
      _index: U,
      line: ae,
      column: ie,
      offset: he
    };
  }
  function b(K) {
    i[K.line] = K.column, z();
  }
  function k() {
    let K;
    for (; r._index < o.length; ) {
      const U = o[r._index];
      if (typeof U == "string")
        for (K = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === K && r._bufferIndex < U.length; )
          x(U.charCodeAt(r._bufferIndex));
      else
        x(U);
    }
  }
  function x(K) {
    u = u(K);
  }
  function M(K) {
    Xe(K) ? (r.line++, r.column = 1, r.offset += K === -3 ? 2 : 1, z()) : K !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = K;
  }
  function T(K, U) {
    const ae = U || {};
    return ae.type = K, ae.start = y(), c.events.push(["enter", ae, c]), a.push(ae), ae;
  }
  function E(K) {
    const U = a.pop();
    return U.end = y(), c.events.push(["exit", U, c]), U;
  }
  function C(K, U) {
    F(K, U.from);
  }
  function O(K, U) {
    U.restore();
  }
  function R(K, U) {
    return ae;
    function ae(ie, he, Ie) {
      let Oe, Ne, We, q;
      return Array.isArray(ie) ? (
        /* c8 ignore next 1 */
        J(ie)
      ) : "tokenize" in ie ? (
        // Looks like a construct.
        J([
          /** @type {Construct} */
          ie
        ])
      ) : Re(ie);
      function Re(mt) {
        return le;
        function le(tt) {
          const xe = tt !== null && mt[tt], ge = tt !== null && mt.null, Ot = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(xe) ? xe : xe ? [xe] : [],
            ...Array.isArray(ge) ? ge : ge ? [ge] : []
          ];
          return J(Ot)(tt);
        }
      }
      function J(mt) {
        return Oe = mt, Ne = 0, mt.length === 0 ? Ie : V(mt[Ne]);
      }
      function V(mt) {
        return le;
        function le(tt) {
          return q = H(), We = mt, mt.partial || (c.currentConstruct = mt), mt.name && c.parser.constructs.disable.null.includes(mt.name) ? at() : mt.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            U ? Object.assign(Object.create(c), U) : c,
            l,
            _t,
            at
          )(tt);
        }
      }
      function _t(mt) {
        return K(We, q), he;
      }
      function at(mt) {
        return q.restore(), ++Ne < Oe.length ? V(Oe[Ne]) : Ie;
      }
    }
  }
  function F(K, U) {
    K.resolveAll && !s.includes(K) && s.push(K), K.resolve && Ti(c.events, U, c.events.length - U, K.resolve(c.events.slice(U), c)), K.resolveTo && (c.events = K.resolveTo(c.events, c));
  }
  function H() {
    const K = y(), U = c.previous, ae = c.currentConstruct, ie = c.events.length, he = Array.from(a);
    return {
      from: ie,
      restore: Ie
    };
    function Ie() {
      r = K, c.previous = U, c.currentConstruct = ae, c.events.length = ie, a = he, z();
    }
  }
  function z() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function $W(n, e) {
  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, s = e.end._bufferIndex;
  let o;
  if (t === i)
    o = [n[t].slice(r, s)];
  else {
    if (o = n.slice(t, i), r > -1) {
      const a = o[0];
      typeof a == "string" ? o[0] = a.slice(r) : o.shift();
    }
    s > 0 && o.push(n[i].slice(0, s));
  }
  return o;
}
function jW(n, e) {
  let t = -1;
  const r = [];
  let i;
  for (; ++t < n.length; ) {
    const s = n[t];
    let o;
    if (typeof s == "string")
      o = s;
    else switch (s) {
      case -5: {
        o = "\r";
        break;
      }
      case -4: {
        o = `
`;
        break;
      }
      case -3: {
        o = `\r
`;
        break;
      }
      case -2: {
        o = e ? " " : "	";
        break;
      }
      case -1: {
        if (!e && i) continue;
        o = " ";
        break;
      }
      default:
        o = String.fromCharCode(s);
    }
    i = s === -2, r.push(o);
  }
  return r.join("");
}
function WW(n) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      gA([VW, ...(n || {}).extensions || []])
    ),
    content: i(oj),
    defined: [],
    document: i(lj),
    flow: i(TW),
    lazy: {},
    string: i(LW),
    text: i(OW)
  };
  return r;
  function i(s) {
    return o;
    function o(a) {
      return qW(r, s, a);
    }
  }
}
function UW(n) {
  for (; !kA(n); )
    ;
  return n;
}
const Tx = /[\0\t\n\r]/g;
function KW() {
  let n = 1, e = "", t = !0, r;
  return i;
  function i(s, o, a) {
    const l = [];
    let c, u, h, f, m;
    for (s = e + (typeof s == "string" ? s.toString() : new TextDecoder(o || void 0).decode(s)), h = 0, e = "", t && (s.charCodeAt(0) === 65279 && h++, t = void 0); h < s.length; ) {
      if (Tx.lastIndex = h, c = Tx.exec(s), f = c && c.index !== void 0 ? c.index : s.length, m = s.charCodeAt(f), !c) {
        e = s.slice(h);
        break;
      }
      if (m === 10 && h === f && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), h < f && (l.push(s.slice(h, f)), n += f - h), m) {
          case 0: {
            l.push(65533), n++;
            break;
          }
          case 9: {
            for (u = Math.ceil(n / 4) * 4, l.push(-2); n++ < u; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), n = 1;
            break;
          }
          default:
            r = !0, n = 1;
        }
      h = f + 1;
    }
    return a && (r && l.push(-5), e && l.push(e), l.push(null)), l;
  }
}
const GW = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function AA(n) {
  return n.replace(GW, JW);
}
function JW(n, e, t) {
  if (e)
    return e;
  if (t.charCodeAt(0) === 35) {
    const i = t.charCodeAt(1), s = i === 120 || i === 88;
    return yA(t.slice(s ? 2 : 1), s ? 16 : 10);
  }
  return Jw(t) || n;
}
function cd(n) {
  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? Ax(n.position) : "start" in n || "end" in n ? Ax(n) : "line" in n || "column" in n ? e4(n) : "";
}
function e4(n) {
  return Ex(n && n.line) + ":" + Ex(n && n.column);
}
function Ax(n) {
  return e4(n && n.start) + "-" + e4(n && n.end);
}
function Ex(n) {
  return n && typeof n == "number" ? n : 1;
}
const EA = {}.hasOwnProperty;
function YW(n, e, t) {
  return typeof e != "string" && (t = e, e = void 0), XW(t)(UW(WW(t).document().write(KW()(n, e, !0))));
}
function XW(n) {
  const e = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: s(Kt),
      autolinkProtocol: H,
      autolinkEmail: H,
      atxHeading: s(Vt),
      blockQuote: s(ge),
      characterEscape: H,
      characterReference: H,
      codeFenced: s(Ot),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: s(Ot, o),
      codeText: s(Ee, o),
      codeTextData: H,
      data: H,
      codeFlowValue: H,
      definition: s(Ft),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: s(ft),
      hardBreakEscape: s(Ue),
      hardBreakTrailing: s(Ue),
      htmlFlow: s(yt, o),
      htmlFlowData: H,
      htmlText: s(yt, o),
      htmlTextData: H,
      image: s(Ut),
      label: o,
      link: s(Kt),
      listItem: s(Ds),
      listItemValue: f,
      listOrdered: s(ci, h),
      listUnordered: s(ci),
      paragraph: s(yo),
      reference: V,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: s(Vt),
      strong: s(Ns),
      thematicBreak: s(kt)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: C,
      autolink: l(),
      autolinkEmail: xe,
      autolinkProtocol: tt,
      blockQuote: l(),
      characterEscapeValue: z,
      characterReferenceMarkerHexadecimal: at,
      characterReferenceMarkerNumeric: at,
      characterReferenceValue: mt,
      characterReference: le,
      codeFenced: l(k),
      codeFencedFence: b,
      codeFencedFenceInfo: m,
      codeFencedFenceMeta: y,
      codeFlowValue: z,
      codeIndented: l(x),
      codeText: l(he),
      codeTextData: z,
      data: z,
      definition: l(),
      definitionDestinationString: E,
      definitionLabelString: M,
      definitionTitleString: T,
      emphasis: l(),
      hardBreakEscape: l(U),
      hardBreakTrailing: l(U),
      htmlFlow: l(ae),
      htmlFlowData: z,
      htmlText: l(ie),
      htmlTextData: z,
      image: l(Oe),
      label: We,
      labelText: Ne,
      lineEnding: K,
      link: l(Ie),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: _t,
      resourceDestinationString: q,
      resourceTitleString: Re,
      resource: J,
      setextHeading: l(F),
      setextHeadingLineSequence: R,
      setextHeadingText: O,
      strong: l(),
      thematicBreak: l()
    }
  };
  LA(e, (n || {}).mdastExtensions || []);
  const t = {};
  return r;
  function r(ne) {
    let Ce = {
      type: "root",
      children: []
    };
    const it = {
      stack: [Ce],
      tokenStack: [],
      config: e,
      enter: a,
      exit: c,
      buffer: o,
      resume: u,
      data: t
    }, dt = [];
    let Dt = -1;
    for (; ++Dt < ne.length; )
      if (ne[Dt][1].type === "listOrdered" || ne[Dt][1].type === "listUnordered")
        if (ne[Dt][0] === "enter")
          dt.push(Dt);
        else {
          const Un = dt.pop();
          Dt = i(ne, Un, Dt);
        }
    for (Dt = -1; ++Dt < ne.length; ) {
      const Un = e[ne[Dt][0]];
      EA.call(Un, ne[Dt][1].type) && Un[ne[Dt][1].type].call(Object.assign({
        sliceSerialize: ne[Dt][2].sliceSerialize
      }, it), ne[Dt][1]);
    }
    if (it.tokenStack.length > 0) {
      const Un = it.tokenStack[it.tokenStack.length - 1];
      (Un[1] || Lx).call(it, void 0, Un[0]);
    }
    for (Ce.position = {
      start: Sa(ne.length > 0 ? ne[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: Sa(ne.length > 0 ? ne[ne.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Dt = -1; ++Dt < e.transforms.length; )
      Ce = e.transforms[Dt](Ce) || Ce;
    return Ce;
  }
  function i(ne, Ce, it) {
    let dt = Ce - 1, Dt = -1, Un = !1, Kn, Cn, Mn, Dn;
    for (; ++dt <= it; ) {
      const Tn = ne[dt];
      switch (Tn[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Tn[0] === "enter" ? Dt++ : Dt--, Dn = void 0;
          break;
        }
        case "lineEndingBlank": {
          Tn[0] === "enter" && (Kn && !Dn && !Dt && !Mn && (Mn = dt), Dn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Dn = void 0;
      }
      if (!Dt && Tn[0] === "enter" && Tn[1].type === "listItemPrefix" || Dt === -1 && Tn[0] === "exit" && (Tn[1].type === "listUnordered" || Tn[1].type === "listOrdered")) {
        if (Kn) {
          let Gt = dt;
          for (Cn = void 0; Gt--; ) {
            const An = ne[Gt];
            if (An[1].type === "lineEnding" || An[1].type === "lineEndingBlank") {
              if (An[0] === "exit") continue;
              Cn && (ne[Cn][1].type = "lineEndingBlank", Un = !0), An[1].type = "lineEnding", Cn = Gt;
            } else if (!(An[1].type === "linePrefix" || An[1].type === "blockQuotePrefix" || An[1].type === "blockQuotePrefixWhitespace" || An[1].type === "blockQuoteMarker" || An[1].type === "listItemIndent")) break;
          }
          Mn && (!Cn || Mn < Cn) && (Kn._spread = !0), Kn.end = Object.assign({}, Cn ? ne[Cn][1].start : Tn[1].end), ne.splice(Cn || dt, 0, ["exit", Kn, Tn[2]]), dt++, it++;
        }
        if (Tn[1].type === "listItemPrefix") {
          const Gt = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Tn[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Kn = Gt, ne.splice(dt, 0, ["enter", Gt, Tn[2]]), dt++, it++, Mn = void 0, Dn = !0;
        }
      }
    }
    return ne[Ce][1]._spread = Un, it;
  }
  function s(ne, Ce) {
    return it;
    function it(dt) {
      a.call(this, ne(dt), dt), Ce && Ce.call(this, dt);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function a(ne, Ce, it) {
    this.stack[this.stack.length - 1].children.push(ne), this.stack.push(ne), this.tokenStack.push([Ce, it || void 0]), ne.position = {
      start: Sa(Ce.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(ne) {
    return Ce;
    function Ce(it) {
      ne && ne.call(this, it), c.call(this, it);
    }
  }
  function c(ne, Ce) {
    const it = this.stack.pop(), dt = this.tokenStack.pop();
    if (dt)
      dt[0].type !== ne.type && (Ce ? Ce.call(this, ne, dt[0]) : (dt[1] || Lx).call(this, ne, dt[0]));
    else throw new Error("Cannot close `" + ne.type + "` (" + cd({
      start: ne.start,
      end: ne.end
    }) + "): it’s not open");
    it.position.end = Sa(ne.end);
  }
  function u() {
    return Gw(this.stack.pop());
  }
  function h() {
    this.data.expectingFirstListItemValue = !0;
  }
  function f(ne) {
    if (this.data.expectingFirstListItemValue) {
      const Ce = this.stack[this.stack.length - 2];
      Ce.start = Number.parseInt(this.sliceSerialize(ne), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function m() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.lang = ne;
  }
  function y() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.meta = ne;
  }
  function b() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function k() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = ne.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function x() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = ne.replace(/(\r?\n|\r)$/g, "");
  }
  function M(ne) {
    const Ce = this.resume(), it = this.stack[this.stack.length - 1];
    it.label = Ce, it.identifier = bs(this.sliceSerialize(ne)).toLowerCase();
  }
  function T() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.title = ne;
  }
  function E() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.url = ne;
  }
  function C(ne) {
    const Ce = this.stack[this.stack.length - 1];
    if (!Ce.depth) {
      const it = this.sliceSerialize(ne).length;
      Ce.depth = it;
    }
  }
  function O() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function R(ne) {
    const Ce = this.stack[this.stack.length - 1];
    Ce.depth = this.sliceSerialize(ne).codePointAt(0) === 61 ? 1 : 2;
  }
  function F() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function H(ne) {
    const it = this.stack[this.stack.length - 1].children;
    let dt = it[it.length - 1];
    (!dt || dt.type !== "text") && (dt = mr(), dt.position = {
      start: Sa(ne.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, it.push(dt)), this.stack.push(dt);
  }
  function z(ne) {
    const Ce = this.stack.pop();
    Ce.value += this.sliceSerialize(ne), Ce.position.end = Sa(ne.end);
  }
  function K(ne) {
    const Ce = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const it = Ce.children[Ce.children.length - 1];
      it.position.end = Sa(ne.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && e.canContainEols.includes(Ce.type) && (H.call(this, ne), z.call(this, ne));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function ae() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = ne;
  }
  function ie() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = ne;
  }
  function he() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.value = ne;
  }
  function Ie() {
    const ne = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ce = this.data.referenceType || "shortcut";
      ne.type += "Reference", ne.referenceType = Ce, delete ne.url, delete ne.title;
    } else
      delete ne.identifier, delete ne.label;
    this.data.referenceType = void 0;
  }
  function Oe() {
    const ne = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Ce = this.data.referenceType || "shortcut";
      ne.type += "Reference", ne.referenceType = Ce, delete ne.url, delete ne.title;
    } else
      delete ne.identifier, delete ne.label;
    this.data.referenceType = void 0;
  }
  function Ne(ne) {
    const Ce = this.sliceSerialize(ne), it = this.stack[this.stack.length - 2];
    it.label = AA(Ce), it.identifier = bs(Ce).toLowerCase();
  }
  function We() {
    const ne = this.stack[this.stack.length - 1], Ce = this.resume(), it = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, it.type === "link") {
      const dt = ne.children;
      it.children = dt;
    } else
      it.alt = Ce;
  }
  function q() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.url = ne;
  }
  function Re() {
    const ne = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.title = ne;
  }
  function J() {
    this.data.inReference = void 0;
  }
  function V() {
    this.data.referenceType = "collapsed";
  }
  function _t(ne) {
    const Ce = this.resume(), it = this.stack[this.stack.length - 1];
    it.label = Ce, it.identifier = bs(this.sliceSerialize(ne)).toLowerCase(), this.data.referenceType = "full";
  }
  function at(ne) {
    this.data.characterReferenceType = ne.type;
  }
  function mt(ne) {
    const Ce = this.sliceSerialize(ne), it = this.data.characterReferenceType;
    let dt;
    it ? (dt = yA(Ce, it === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : dt = Jw(Ce);
    const Dt = this.stack[this.stack.length - 1];
    Dt.value += dt;
  }
  function le(ne) {
    const Ce = this.stack.pop();
    Ce.position.end = Sa(ne.end);
  }
  function tt(ne) {
    z.call(this, ne);
    const Ce = this.stack[this.stack.length - 1];
    Ce.url = this.sliceSerialize(ne);
  }
  function xe(ne) {
    z.call(this, ne);
    const Ce = this.stack[this.stack.length - 1];
    Ce.url = "mailto:" + this.sliceSerialize(ne);
  }
  function ge() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ot() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Ee() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ft() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ft() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Vt() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ue() {
    return {
      type: "break"
    };
  }
  function yt() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ut() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Kt() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function ci(ne) {
    return {
      type: "list",
      ordered: ne.type === "listOrdered",
      start: null,
      spread: ne._spread,
      children: []
    };
  }
  function Ds(ne) {
    return {
      type: "listItem",
      spread: ne._spread,
      checked: null,
      children: []
    };
  }
  function yo() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ns() {
    return {
      type: "strong",
      children: []
    };
  }
  function mr() {
    return {
      type: "text",
      value: ""
    };
  }
  function kt() {
    return {
      type: "thematicBreak"
    };
  }
}
function Sa(n) {
  return {
    line: n.line,
    column: n.column,
    offset: n.offset
  };
}
function LA(n, e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t];
    Array.isArray(r) ? LA(n, r) : ZW(n, r);
  }
}
function ZW(n, e) {
  let t;
  for (t in e)
    if (EA.call(e, t))
      switch (t) {
        case "canContainEols": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "transforms": {
          const r = e[t];
          r && n[t].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = e[t];
          r && Object.assign(n[t], r);
          break;
        }
      }
}
function Lx(n, e) {
  throw n ? new Error("Cannot close `" + n.type + "` (" + cd({
    start: n.start,
    end: n.end
  }) + "): a different token (`" + e.type + "`, " + cd({
    start: e.start,
    end: e.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + e.type + "`, " + cd({
    start: e.start,
    end: e.end
  }) + ") is still open");
}
function t4(n) {
  const e = this;
  e.parser = t;
  function t(r) {
    return YW(r, {
      ...e.data("settings"),
      ...n,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("micromarkExtensions") || [],
      mdastExtensions: e.data("fromMarkdownExtensions") || []
    });
  }
}
const Ox = {}.hasOwnProperty;
function QW(n, e) {
  const t = e || {};
  function r(i, ...s) {
    let o = r.invalid;
    const a = r.handlers;
    if (i && Ox.call(i, n)) {
      const l = String(i[n]);
      o = Ox.call(a, l) ? a[l] : r.unknown;
    }
    if (o)
      return o.call(this, i, ...s);
  }
  return r.handlers = t.handlers || {}, r.invalid = t.invalid, r.unknown = t.unknown, r;
}
const eU = {}.hasOwnProperty;
function OA(n, e) {
  let t = -1, r;
  if (e.extensions)
    for (; ++t < e.extensions.length; )
      OA(n, e.extensions[t]);
  for (r in e)
    if (eU.call(e, r))
      switch (r) {
        case "extensions":
          break;
        /* c8 ignore next 4 */
        case "unsafe": {
          Dx(n[r], e[r]);
          break;
        }
        case "join": {
          Dx(n[r], e[r]);
          break;
        }
        case "handlers": {
          tU(n[r], e[r]);
          break;
        }
        default:
          n.options[r] = e[r];
      }
  return n;
}
function Dx(n, e) {
  e && n.push(...e);
}
function tU(n, e) {
  e && Object.assign(n, e);
}
function nU(n, e, t, r) {
  const i = t.enter("blockquote"), s = t.createTracker(r);
  s.move("> "), s.shift(2);
  const o = t.indentLines(
    t.containerFlow(n, s.current()),
    rU
  );
  return i(), o;
}
function rU(n, e, t) {
  return ">" + (t ? "" : " ") + n;
}
function DA(n, e) {
  return Nx(n, e.inConstruct, !0) && !Nx(n, e.notInConstruct, !1);
}
function Nx(n, e, t) {
  if (typeof e == "string" && (e = [e]), !e || e.length === 0)
    return t;
  let r = -1;
  for (; ++r < e.length; )
    if (n.includes(e[r]))
      return !0;
  return !1;
}
function Ix(n, e, t, r) {
  let i = -1;
  for (; ++i < t.unsafe.length; )
    if (t.unsafe[i].character === `
` && DA(t.stack, t.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function NA(n, e) {
  const t = String(n);
  let r = t.indexOf(e), i = r, s = 0, o = 0;
  if (typeof e != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++s > o && (o = s) : s = 1, i = r + e.length, r = t.indexOf(e, i);
  return o;
}
function n4(n, e) {
  return !!(e.options.fences === !1 && n.value && // If there’s no info…
  !n.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(n.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(n.value));
}
function iU(n) {
  const e = n.options.fence || "`";
  if (e !== "`" && e !== "~")
    throw new Error(
      "Cannot serialize code with `" + e + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return e;
}
function sU(n, e, t, r) {
  const i = iU(t), s = n.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (n4(n, t)) {
    const h = t.enter("codeIndented"), f = t.indentLines(s, oU);
    return h(), f;
  }
  const a = t.createTracker(r), l = i.repeat(Math.max(NA(s, i) + 1, 3)), c = t.enter("codeFenced");
  let u = a.move(l);
  if (n.lang) {
    const h = t.enter(`codeFencedLang${o}`);
    u += a.move(
      t.safe(n.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  if (n.lang && n.meta) {
    const h = t.enter(`codeFencedMeta${o}`);
    u += a.move(" "), u += a.move(
      t.safe(n.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...a.current()
      })
    ), h();
  }
  return u += a.move(`
`), s && (u += a.move(s + `
`)), u += a.move(l), c(), u;
}
function oU(n, e, t) {
  return (t ? "" : "    ") + n;
}
function Xw(n) {
  const e = n.options.quote || '"';
  if (e !== '"' && e !== "'")
    throw new Error(
      "Cannot serialize title with `" + e + "` for `options.quote`, expected `\"`, or `'`"
    );
  return e;
}
function aU(n, e, t, r) {
  const i = Xw(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("definition");
  let a = t.enter("label");
  const l = t.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    t.safe(t.associationId(n), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), a(), // If there’s no url, or…
  !n.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (a = t.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    t.safe(n.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = t.enter("destinationRaw"), c += l.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : `
`,
      ...l.current()
    })
  )), a(), n.title && (a = t.enter(`title${s}`), c += l.move(" " + i), c += l.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), a()), o(), c;
}
function lU(n) {
  const e = n.options.emphasis || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + e + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return e;
}
function sl(n) {
  return "&#x" + n.toString(16).toUpperCase() + ";";
}
function $g(n, e, t) {
  const r = fh(n), i = fh(e);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    t === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
IA.peek = cU;
function IA(n, e, t, r) {
  const i = lU(t), s = t.enter("emphasis"), o = t.createTracker(r), a = o.move(i);
  let l = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = $g(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (l = sl(c) + l.slice(1));
  const h = l.charCodeAt(l.length - 1), f = $g(r.after.charCodeAt(0), h, i);
  f.inside && (l = l.slice(0, -1) + sl(h));
  const m = o.move(i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, a + l + m;
}
function cU(n, e, t) {
  return t.options.emphasis || "*";
}
const U1 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(n) {
    if (n == null)
      return dU;
    if (typeof n == "function")
      return K1(n);
    if (typeof n == "object")
      return Array.isArray(n) ? uU(n) : hU(n);
    if (typeof n == "string")
      return fU(n);
    throw new Error("Expected function, string, or object as test");
  }
);
function uU(n) {
  const e = [];
  let t = -1;
  for (; ++t < n.length; )
    e[t] = U1(n[t]);
  return K1(r);
  function r(...i) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, i)) return !0;
    return !1;
  }
}
function hU(n) {
  const e = (
    /** @type {Record<string, unknown>} */
    n
  );
  return K1(t);
  function t(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in n)
      if (i[s] !== e[s]) return !1;
    return !0;
  }
}
function fU(n) {
  return K1(e);
  function e(t) {
    return t && t.type === n;
  }
}
function K1(n) {
  return e;
  function e(t, r, i) {
    return !!(pU(t) && n.call(
      this,
      t,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function dU() {
  return !0;
}
function pU(n) {
  return n !== null && typeof n == "object" && "type" in n;
}
const _A = [], mU = !0, r4 = !1, i4 = "skip";
function Zw(n, e, t, r) {
  let i;
  typeof e == "function" && typeof t != "function" ? (r = t, t = e) : i = e;
  const s = U1(i), o = r ? -1 : 1;
  a(n, void 0, [])();
  function a(l, c, u) {
    const h = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof h.type == "string") {
      const m = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(f, "name", {
        value: "node (" + (l.type + (m ? "<" + m + ">" : "")) + ")"
      });
    }
    return f;
    function f() {
      let m = _A, y, b, k;
      if ((!e || s(l, c, u[u.length - 1] || void 0)) && (m = gU(t(l, u)), m[0] === r4))
        return m;
      if ("children" in l && l.children) {
        const x = (
          /** @type {UnistParent} */
          l
        );
        if (x.children && m[0] !== i4)
          for (b = (r ? x.children.length : -1) + o, k = u.concat(x); b > -1 && b < x.children.length; ) {
            const M = x.children[b];
            if (y = a(M, b, k)(), y[0] === r4)
              return y;
            b = typeof y[1] == "number" ? y[1] : b + o;
          }
      }
      return m;
    }
  }
}
function gU(n) {
  return Array.isArray(n) ? n : typeof n == "number" ? [mU, n] : n == null ? _A : [n];
}
function ml(n, e, t, r) {
  let i, s, o;
  typeof e == "function" && typeof t != "function" ? (s = void 0, o = e, i = t) : (s = e, o = t, i = r), Zw(n, s, a, i);
  function a(l, c) {
    const u = c[c.length - 1], h = u ? u.children.indexOf(l) : void 0;
    return o(l, h, u);
  }
}
function RA(n, e) {
  let t = !1;
  return ml(n, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return t = !0, r4;
  }), !!((!n.depth || n.depth < 3) && Gw(n) && (e.options.setext || t));
}
function yU(n, e, t, r) {
  const i = Math.max(Math.min(6, n.depth || 1), 1), s = t.createTracker(r);
  if (RA(n, t)) {
    const u = t.enter("headingSetext"), h = t.enter("phrasing"), f = t.containerPhrasing(n, {
      ...s.current(),
      before: `
`,
      after: `
`
    });
    return h(), u(), f + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      f.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(f.lastIndexOf("\r"), f.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), a = t.enter("headingAtx"), l = t.enter("phrasing");
  s.move(o + " ");
  let c = t.containerPhrasing(n, {
    before: "# ",
    after: `
`,
    ...s.current()
  });
  return /^[\t ]/.test(c) && (c = sl(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, t.options.closeAtx && (c += " " + o), l(), a(), c;
}
PA.peek = bU;
function PA(n) {
  return n.value || "";
}
function bU() {
  return "<";
}
BA.peek = vU;
function BA(n, e, t, r) {
  const i = Xw(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.enter("image");
  let a = t.enter("label");
  const l = t.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    t.safe(n.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), a(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (a = t.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    t.safe(n.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (a = t.enter("destinationRaw"), c += l.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...l.current()
    })
  )), a(), n.title && (a = t.enter(`title${s}`), c += l.move(" " + i), c += l.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), a()), c += l.move(")"), o(), c;
}
function vU() {
  return "!";
}
HA.peek = wU;
function HA(n, e, t, r) {
  const i = n.referenceType, s = t.enter("imageReference");
  let o = t.enter("label");
  const a = t.createTracker(r);
  let l = a.move("![");
  const c = t.safe(n.alt, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? l += a.move(h + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function wU() {
  return "!";
}
zA.peek = kU;
function zA(n, e, t) {
  let r = n.value || "", i = "`", s = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++s < t.unsafe.length; ) {
    const o = t.unsafe[s], a = t.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; l = a.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function kU() {
  return "`";
}
function FA(n, e) {
  const t = Gw(n);
  return !!(!e.options.resourceLink && // If there’s a url…
  n.url && // And there’s a no title…
  !n.title && // And the content of `node` is a single text node…
  n.children && n.children.length === 1 && n.children[0].type === "text" && // And if the url is the same as the content…
  (t === n.url || "mailto:" + t === n.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(n.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(n.url));
}
VA.peek = xU;
function VA(n, e, t, r) {
  const i = Xw(t), s = i === '"' ? "Quote" : "Apostrophe", o = t.createTracker(r);
  let a, l;
  if (FA(n, t)) {
    const u = t.stack;
    t.stack = [], a = t.enter("autolink");
    let h = o.move("<");
    return h += o.move(
      t.containerPhrasing(n, {
        before: h,
        after: ">",
        ...o.current()
      })
    ), h += o.move(">"), a(), t.stack = u, h;
  }
  a = t.enter("link"), l = t.enter("label");
  let c = o.move("[");
  return c += o.move(
    t.containerPhrasing(n, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), l(), // If there’s no url but there is a title…
  !n.url && n.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(n.url) ? (l = t.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    t.safe(n.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (l = t.enter("destinationRaw"), c += o.move(
    t.safe(n.url, {
      before: c,
      after: n.title ? " " : ")",
      ...o.current()
    })
  )), l(), n.title && (l = t.enter(`title${s}`), c += o.move(" " + i), c += o.move(
    t.safe(n.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), l()), c += o.move(")"), a(), c;
}
function xU(n, e, t) {
  return FA(n, t) ? "<" : "[";
}
qA.peek = SU;
function qA(n, e, t, r) {
  const i = n.referenceType, s = t.enter("linkReference");
  let o = t.enter("label");
  const a = t.createTracker(r);
  let l = a.move("[");
  const c = t.containerPhrasing(n, {
    before: l,
    after: "]",
    ...a.current()
  });
  l += a.move(c + "]["), o();
  const u = t.stack;
  t.stack = [], o = t.enter("reference");
  const h = t.safe(t.associationId(n), {
    before: l,
    after: "]",
    ...a.current()
  });
  return o(), t.stack = u, s(), i === "full" || !c || c !== h ? l += a.move(h + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += a.move("]"), l;
}
function SU() {
  return "[";
}
function Qw(n) {
  const e = n.options.bullet || "*";
  if (e !== "*" && e !== "+" && e !== "-")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return e;
}
function CU(n) {
  const e = Qw(n), t = n.options.bulletOther;
  if (!t)
    return e === "*" ? "-" : "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (t === e)
    throw new Error(
      "Expected `bullet` (`" + e + "`) and `bulletOther` (`" + t + "`) to be different"
    );
  return t;
}
function MU(n) {
  const e = n.options.bulletOrdered || ".";
  if (e !== "." && e !== ")")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return e;
}
function $A(n) {
  const e = n.options.rule || "*";
  if (e !== "*" && e !== "-" && e !== "_")
    throw new Error(
      "Cannot serialize rules with `" + e + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return e;
}
function TU(n, e, t, r) {
  const i = t.enter("list"), s = t.bulletCurrent;
  let o = n.ordered ? MU(t) : Qw(t);
  const a = n.ordered ? o === "." ? ")" : "." : CU(t);
  let l = e && t.bulletLastUsed ? o === t.bulletLastUsed : !1;
  if (!n.ordered) {
    const u = n.children ? n.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      t.stack[t.stack.length - 1] === "list" && t.stack[t.stack.length - 2] === "listItem" && t.stack[t.stack.length - 3] === "list" && t.stack[t.stack.length - 4] === "listItem" && // That are each the first child.
      t.indexStack[t.indexStack.length - 1] === 0 && t.indexStack[t.indexStack.length - 2] === 0 && t.indexStack[t.indexStack.length - 3] === 0 && (l = !0), $A(t) === o && u
    ) {
      let h = -1;
      for (; ++h < n.children.length; ) {
        const f = n.children[h];
        if (f && f.type === "listItem" && f.children && f.children[0] && f.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = a), t.bulletCurrent = o;
  const c = t.containerFlow(n, r);
  return t.bulletLastUsed = o, t.bulletCurrent = s, i(), c;
}
function AU(n) {
  const e = n.options.listItemIndent || "one";
  if (e !== "tab" && e !== "one" && e !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + e + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return e;
}
function EU(n, e, t, r) {
  const i = AU(t);
  let s = t.bulletCurrent || Qw(t);
  e && e.type === "list" && e.ordered && (s = (typeof e.start == "number" && e.start > -1 ? e.start : 1) + (t.options.incrementListMarker === !1 ? 0 : e.children.indexOf(n)) + s);
  let o = s.length + 1;
  (i === "tab" || i === "mixed" && (e && e.type === "list" && e.spread || n.spread)) && (o = Math.ceil(o / 4) * 4);
  const a = t.createTracker(r);
  a.move(s + " ".repeat(o - s.length)), a.shift(o);
  const l = t.enter("listItem"), c = t.indentLines(
    t.containerFlow(n, a.current()),
    u
  );
  return l(), c;
  function u(h, f, m) {
    return f ? (m ? "" : " ".repeat(o)) + h : (m ? s : s + " ".repeat(o - s.length)) + h;
  }
}
function LU(n, e, t, r) {
  const i = t.enter("paragraph"), s = t.enter("phrasing"), o = t.containerPhrasing(n, r);
  return s(), i(), o;
}
const OU = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  U1([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function DU(n, e, t, r) {
  return (n.children.some(function(o) {
    return OU(o);
  }) ? t.containerPhrasing : t.containerFlow).call(t, n, r);
}
function NU(n) {
  const e = n.options.strong || "*";
  if (e !== "*" && e !== "_")
    throw new Error(
      "Cannot serialize strong with `" + e + "` for `options.strong`, expected `*`, or `_`"
    );
  return e;
}
jA.peek = IU;
function jA(n, e, t, r) {
  const i = NU(t), s = t.enter("strong"), o = t.createTracker(r), a = o.move(i + i);
  let l = o.move(
    t.containerPhrasing(n, {
      after: i,
      before: a,
      ...o.current()
    })
  );
  const c = l.charCodeAt(0), u = $g(
    r.before.charCodeAt(r.before.length - 1),
    c,
    i
  );
  u.inside && (l = sl(c) + l.slice(1));
  const h = l.charCodeAt(l.length - 1), f = $g(r.after.charCodeAt(0), h, i);
  f.inside && (l = l.slice(0, -1) + sl(h));
  const m = o.move(i + i);
  return s(), t.attentionEncodeSurroundingInfo = {
    after: f.outside,
    before: u.outside
  }, a + l + m;
}
function IU(n, e, t) {
  return t.options.strong || "*";
}
function _U(n, e, t, r) {
  return t.safe(n.value, r);
}
function RU(n) {
  const e = n.options.ruleRepetition || 3;
  if (e < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + e + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return e;
}
function PU(n, e, t) {
  const r = ($A(t) + (t.options.ruleSpaces ? " " : "")).repeat(RU(t));
  return t.options.ruleSpaces ? r.slice(0, -1) : r;
}
const e5 = {
  blockquote: nU,
  break: Ix,
  code: sU,
  definition: aU,
  emphasis: IA,
  hardBreak: Ix,
  heading: yU,
  html: PA,
  image: BA,
  imageReference: HA,
  inlineCode: zA,
  link: VA,
  linkReference: qA,
  list: TU,
  listItem: EU,
  paragraph: LU,
  root: DU,
  strong: jA,
  text: _U,
  thematicBreak: PU
}, BU = [HU];
function HU(n, e, t, r) {
  if (e.type === "code" && n4(e, r) && (n.type === "list" || n.type === e.type && n4(n, r)))
    return !1;
  if ("spread" in t && typeof t.spread == "boolean")
    return n.type === "paragraph" && // Two paragraphs.
    (n.type === e.type || e.type === "definition" || // Paragraph followed by a setext heading.
    e.type === "heading" && RA(e, r)) ? void 0 : t.spread ? 1 : 0;
}
const Ol = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
], zU = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: `
`,
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: Ol
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: !0, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: `(?:[\r
]|$)` },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: Ol
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: !0, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: !0, character: "*", after: `(?:[ 	\r
*])` },
  { character: "*", inConstruct: "phrasing", notInConstruct: Ol },
  // A plus sign could start a list item.
  { atBreak: !0, character: "+", after: `(?:[ 	\r
])` },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: !0, character: "-", after: `(?:[ 	\r
-])` },
  // A dot could start a list item.
  { atBreak: !0, before: "\\d+", character: ".", after: `(?:[ 	\r
]|$)` },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: Ol
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: !0, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: !0, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: !0, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: Ol },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: !0, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: Ol },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: !0, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: Ol },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: !0, character: "~" }
];
function FU(n) {
  return n.label || !n.identifier ? n.label || "" : AA(n.identifier);
}
function VU(n) {
  if (!n._compiled) {
    const e = (n.atBreak ? "[\\r\\n][\\t ]*" : "") + (n.before ? "(?:" + n.before + ")" : "");
    n._compiled = new RegExp(
      (e ? "(" + e + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(n.character) ? "\\" : "") + n.character + (n.after ? "(?:" + n.after + ")" : ""),
      "g"
    );
  }
  return n._compiled;
}
function qU(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = [];
  let o = -1, a = t.before, l;
  r.push(-1);
  let c = e.createTracker(t);
  for (; ++o < i.length; ) {
    const u = i[o];
    let h;
    if (r[r.length - 1] = o, o + 1 < i.length) {
      let y = e.handle.handlers[i[o + 1].type];
      y && y.peek && (y = y.peek), h = y ? y(i[o + 1], n, e, {
        before: "",
        after: "",
        ...c.current()
      }).charAt(0) : "";
    } else
      h = t.after;
    s.length > 0 && (a === "\r" || a === `
`) && u.type === "html" && (s[s.length - 1] = s[s.length - 1].replace(
      /(\r?\n|\r)$/,
      " "
    ), a = " ", c = e.createTracker(t), c.move(s.join("")));
    let f = e.handle(u, n, e, {
      ...c.current(),
      after: h,
      before: a
    });
    l && l === f.slice(0, 1) && (f = sl(l.charCodeAt(0)) + f.slice(1));
    const m = e.attentionEncodeSurroundingInfo;
    e.attentionEncodeSurroundingInfo = void 0, l = void 0, m && (s.length > 0 && m.before && a === s[s.length - 1].slice(-1) && (s[s.length - 1] = s[s.length - 1].slice(0, -1) + sl(a.charCodeAt(0))), m.after && (l = h)), c.move(f), s.push(f), a = f.slice(-1);
  }
  return r.pop(), s.join("");
}
function $U(n, e, t) {
  const r = e.indexStack, i = n.children || [], s = e.createTracker(t), o = [];
  let a = -1;
  for (r.push(-1); ++a < i.length; ) {
    const l = i[a];
    r[r.length - 1] = a, o.push(
      s.move(
        e.handle(l, n, e, {
          before: `
`,
          after: `
`,
          ...s.current()
        })
      )
    ), l.type !== "list" && (e.bulletLastUsed = void 0), a < i.length - 1 && o.push(
      s.move(jU(l, i[a + 1], n, e))
    );
  }
  return r.pop(), o.join("");
}
function jU(n, e, t, r) {
  let i = r.join.length;
  for (; i--; ) {
    const s = r.join[i](n, e, t, r);
    if (s === !0 || s === 1)
      break;
    if (typeof s == "number")
      return `
`.repeat(1 + s);
    if (s === !1)
      return `

<!---->

`;
  }
  return `

`;
}
const WU = /\r?\n|\r/g;
function UU(n, e) {
  const t = [];
  let r = 0, i = 0, s;
  for (; s = WU.exec(n); )
    o(n.slice(r, s.index)), t.push(s[0]), r = s.index + s[0].length, i++;
  return o(n.slice(r)), t.join("");
  function o(a) {
    t.push(e(a, i, !a));
  }
}
function KU(n, e, t) {
  const r = (t.before || "") + (e || "") + (t.after || ""), i = [], s = [], o = {};
  let a = -1;
  for (; ++a < n.unsafe.length; ) {
    const u = n.unsafe[a];
    if (!DA(n.stack, u))
      continue;
    const h = n.compilePattern(u);
    let f;
    for (; f = h.exec(r); ) {
      const m = "before" in u || !!u.atBreak, y = "after" in u, b = f.index + (m ? f[1].length : 0);
      i.includes(b) ? (o[b].before && !m && (o[b].before = !1), o[b].after && !y && (o[b].after = !1)) : (i.push(b), o[b] = { before: m, after: y });
    }
  }
  i.sort(GU);
  let l = t.before ? t.before.length : 0;
  const c = r.length - (t.after ? t.after.length : 0);
  for (a = -1; ++a < i.length; ) {
    const u = i[a];
    u < l || u >= c || u + 1 < c && i[a + 1] === u + 1 && o[u].after && !o[u + 1].before && !o[u + 1].after || i[a - 1] === u - 1 && o[u].before && !o[u - 1].before && !o[u - 1].after || (l !== u && s.push(_x(r.slice(l, u), "\\")), l = u, /[!-/:-@[-`{-~]/.test(r.charAt(u)) && (!t.encode || !t.encode.includes(r.charAt(u))) ? s.push("\\") : (s.push(sl(r.charCodeAt(u))), l++));
  }
  return s.push(_x(r.slice(l, c), t.after)), s.join("");
}
function GU(n, e) {
  return n - e;
}
function _x(n, e) {
  const t = /\\(?=[!-/:-@[-`{-~])/g, r = [], i = [], s = n + e;
  let o = -1, a = 0, l;
  for (; l = t.exec(s); )
    r.push(l.index);
  for (; ++o < r.length; )
    a !== r[o] && i.push(n.slice(a, r[o])), i.push("\\"), a = r[o];
  return i.push(n.slice(a)), i.join("");
}
function JU(n) {
  const e = n || {}, t = e.now || {};
  let r = e.lineShift || 0, i = t.line || 1, s = t.column || 1;
  return { move: l, current: o, shift: a };
  function o() {
    return { now: { line: i, column: s }, lineShift: r };
  }
  function a(c) {
    r += c;
  }
  function l(c) {
    const u = c || "", h = u.split(/\r?\n|\r/g), f = h[h.length - 1];
    return i += h.length - 1, s = h.length === 1 ? s + f.length : 1 + f.length + r, u;
  }
}
function YU(n, e) {
  const t = e || {}, r = {
    associationId: FU,
    containerPhrasing: eK,
    containerFlow: tK,
    createTracker: JU,
    compilePattern: VU,
    enter: s,
    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined
    // here.
    handlers: { ...e5 },
    // @ts-expect-error: add `handle` in a second.
    handle: void 0,
    indentLines: UU,
    indexStack: [],
    join: [...BU],
    options: {},
    safe: nK,
    stack: [],
    unsafe: [...zU]
  };
  OA(r, t), r.options.tightDefinitions && r.join.push(QU), r.handle = QW("type", {
    invalid: XU,
    unknown: ZU,
    handlers: r.handlers
  });
  let i = r.handle(n, void 0, r, {
    before: `
`,
    after: `
`,
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  return i && i.charCodeAt(i.length - 1) !== 10 && i.charCodeAt(i.length - 1) !== 13 && (i += `
`), i;
  function s(o) {
    return r.stack.push(o), a;
    function a() {
      r.stack.pop();
    }
  }
}
function XU(n) {
  throw new Error("Cannot handle value `" + n + "`, expected node");
}
function ZU(n) {
  const e = (
    /** @type {Nodes} */
    n
  );
  throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function QU(n, e) {
  if (n.type === "definition" && n.type === e.type)
    return 0;
}
function eK(n, e) {
  return qU(n, this, e);
}
function tK(n, e) {
  return $U(n, this, e);
}
function nK(n, e) {
  return KU(this, n, e);
}
function s4(n) {
  const e = this;
  e.compiler = t;
  function t(r) {
    return YU(r, {
      ...e.data("settings"),
      ...n,
      // Note: this option is not in the readme.
      // The goal is for it to be set by plugins on `data` instead of being
      // passed by users.
      extensions: e.data("toMarkdownExtensions") || []
    });
  }
}
function Rx(n) {
  if (n)
    throw n;
}
var Ib, Px;
function rK() {
  if (Px) return Ib;
  Px = 1;
  var n = Object.prototype.hasOwnProperty, e = Object.prototype.toString, t = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : e.call(c) === "[object Array]";
  }, s = function(c) {
    if (!c || e.call(c) !== "[object Object]")
      return !1;
    var u = n.call(c, "constructor"), h = c.constructor && c.constructor.prototype && n.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !u && !h)
      return !1;
    var f;
    for (f in c)
      ;
    return typeof f > "u" || n.call(c, f);
  }, o = function(c, u) {
    t && u.name === "__proto__" ? t(c, u.name, {
      enumerable: !0,
      configurable: !0,
      value: u.newValue,
      writable: !0
    }) : c[u.name] = u.newValue;
  }, a = function(c, u) {
    if (u === "__proto__")
      if (n.call(c, u)) {
        if (r)
          return r(c, u).value;
      } else return;
    return c[u];
  };
  return Ib = function l() {
    var c, u, h, f, m, y, b = arguments[0], k = 1, x = arguments.length, M = !1;
    for (typeof b == "boolean" && (M = b, b = arguments[1] || {}, k = 2), (b == null || typeof b != "object" && typeof b != "function") && (b = {}); k < x; ++k)
      if (c = arguments[k], c != null)
        for (u in c)
          h = a(b, u), f = a(c, u), b !== f && (M && f && (s(f) || (m = i(f))) ? (m ? (m = !1, y = h && i(h) ? h : []) : y = h && s(h) ? h : {}, o(b, { name: u, newValue: l(M, y, f) })) : typeof f < "u" && o(b, { name: u, newValue: f }));
    return b;
  }, Ib;
}
var iK = rK();
const _b = /* @__PURE__ */ QC(iK);
function o4(n) {
  if (typeof n != "object" || n === null)
    return !1;
  const e = Object.getPrototypeOf(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}
function sK() {
  const n = [], e = { run: t, use: r };
  return e;
  function t(...i) {
    let s = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    a(null, ...i);
    function a(l, ...c) {
      const u = n[++s];
      let h = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++h < i.length; )
        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);
      i = c, u ? oK(u, a)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return n.push(i), e;
  }
}
function oK(n, e) {
  let t;
  return r;
  function r(...o) {
    const a = n.length > o.length;
    let l;
    a && o.push(i);
    try {
      l = n.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (a && t)
        throw u;
      return i(u);
    }
    a || (l && l.then && typeof l.then == "function" ? l.then(s, i) : l instanceof Error ? i(l) : s(l));
  }
  function i(o, ...a) {
    t || (t = !0, e(o, ...a));
  }
  function s(o) {
    i(null, o);
  }
}
class oi extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, t, r) {
    super(), typeof t == "string" && (r = t, t = void 0);
    let i = "", s = {}, o = !1;
    if (t && ("line" in t && "column" in t ? s = { place: t } : "start" in t && "end" in t ? s = { place: t } : "type" in t ? s = {
      ancestors: [t],
      place: t.position
    } : s = { ...t }), typeof e == "string" ? i = e : !s.cause && e && (o = !0, i = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? s.ruleId = r : (s.source = r.slice(0, l), s.ruleId = r.slice(l + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const l = s.ancestors[s.ancestors.length - 1];
      l && (s.place = l.position);
    }
    const a = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = a ? a.line : void 0, this.name = cd(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = o && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0;
  }
}
oi.prototype.file = "";
oi.prototype.name = "";
oi.prototype.reason = "";
oi.prototype.message = "";
oi.prototype.stack = "";
oi.prototype.column = void 0;
oi.prototype.line = void 0;
oi.prototype.ancestors = void 0;
oi.prototype.cause = void 0;
oi.prototype.fatal = void 0;
oi.prototype.place = void 0;
oi.prototype.ruleId = void 0;
oi.prototype.source = void 0;
const qs = { basename: aK, dirname: lK, extname: cK, join: uK, sep: "/" };
function aK(n, e) {
  if (e !== void 0 && typeof e != "string")
    throw new TypeError('"ext" argument must be a string');
  W0(n);
  let t = 0, r = -1, i = n.length, s;
  if (e === void 0 || e.length === 0 || e.length > n.length) {
    for (; i--; )
      if (n.codePointAt(i) === 47) {
        if (s) {
          t = i + 1;
          break;
        }
      } else r < 0 && (s = !0, r = i + 1);
    return r < 0 ? "" : n.slice(t, r);
  }
  if (e === n)
    return "";
  let o = -1, a = e.length - 1;
  for (; i--; )
    if (n.codePointAt(i) === 47) {
      if (s) {
        t = i + 1;
        break;
      }
    } else
      o < 0 && (s = !0, o = i + 1), a > -1 && (n.codePointAt(i) === e.codePointAt(a--) ? a < 0 && (r = i) : (a = -1, r = o));
  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);
}
function lK(n) {
  if (W0(n), n.length === 0)
    return ".";
  let e = -1, t = n.length, r;
  for (; --t; )
    if (n.codePointAt(t) === 47) {
      if (r) {
        e = t;
        break;
      }
    } else r || (r = !0);
  return e < 0 ? n.codePointAt(0) === 47 ? "/" : "." : e === 1 && n.codePointAt(0) === 47 ? "//" : n.slice(0, e);
}
function cK(n) {
  W0(n);
  let e = n.length, t = -1, r = 0, i = -1, s = 0, o;
  for (; e--; ) {
    const a = n.codePointAt(e);
    if (a === 47) {
      if (o) {
        r = e + 1;
        break;
      }
      continue;
    }
    t < 0 && (o = !0, t = e + 1), a === 46 ? i < 0 ? i = e : s !== 1 && (s = 1) : i > -1 && (s = -1);
  }
  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.
  s === 0 || // The (right-most) trimmed path component is exactly `..`.
  s === 1 && i === t - 1 && i === r + 1 ? "" : n.slice(i, t);
}
function uK(...n) {
  let e = -1, t;
  for (; ++e < n.length; )
    W0(n[e]), n[e] && (t = t === void 0 ? n[e] : t + "/" + n[e]);
  return t === void 0 ? "." : hK(t);
}
function hK(n) {
  W0(n);
  const e = n.codePointAt(0) === 47;
  let t = fK(n, !e);
  return t.length === 0 && !e && (t = "."), t.length > 0 && n.codePointAt(n.length - 1) === 47 && (t += "/"), e ? "/" + t : t;
}
function fK(n, e) {
  let t = "", r = 0, i = -1, s = 0, o = -1, a, l;
  for (; ++o <= n.length; ) {
    if (o < n.length)
      a = n.codePointAt(o);
    else {
      if (a === 47)
        break;
      a = 47;
    }
    if (a === 47) {
      if (!(i === o - 1 || s === 1)) if (i !== o - 1 && s === 2) {
        if (t.length < 2 || r !== 2 || t.codePointAt(t.length - 1) !== 46 || t.codePointAt(t.length - 2) !== 46) {
          if (t.length > 2) {
            if (l = t.lastIndexOf("/"), l !== t.length - 1) {
              l < 0 ? (t = "", r = 0) : (t = t.slice(0, l), r = t.length - 1 - t.lastIndexOf("/")), i = o, s = 0;
              continue;
            }
          } else if (t.length > 0) {
            t = "", r = 0, i = o, s = 0;
            continue;
          }
        }
        e && (t = t.length > 0 ? t + "/.." : "..", r = 2);
      } else
        t.length > 0 ? t += "/" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;
      i = o, s = 0;
    } else a === 46 && s > -1 ? s++ : s = -1;
  }
  return t;
}
function W0(n) {
  if (typeof n != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(n)
    );
}
const dK = { cwd: pK };
function pK() {
  return "/";
}
function a4(n) {
  return !!(n !== null && typeof n == "object" && "href" in n && n.href && "protocol" in n && n.protocol && // @ts-expect-error: indexing is fine.
  n.auth === void 0);
}
function mK(n) {
  if (typeof n == "string")
    n = new URL(n);
  else if (!a4(n)) {
    const e = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + n + "`"
    );
    throw e.code = "ERR_INVALID_ARG_TYPE", e;
  }
  if (n.protocol !== "file:") {
    const e = new TypeError("The URL must be of scheme file");
    throw e.code = "ERR_INVALID_URL_SCHEME", e;
  }
  return gK(n);
}
function gK(n) {
  if (n.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const e = n.pathname;
  let t = -1;
  for (; ++t < e.length; )
    if (e.codePointAt(t) === 37 && e.codePointAt(t + 1) === 50) {
      const r = e.codePointAt(t + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(e);
}
const Rb = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class yK {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(e) {
    let t;
    e ? a4(e) ? t = { path: e } : typeof e == "string" || bK(e) ? t = { value: e } : t = e : t = {}, this.cwd = "cwd" in t ? "" : dK.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Rb.length; ) {
      const s = Rb[r];
      s in t && t[s] !== void 0 && t[s] !== null && (this[s] = s === "history" ? [...t[s]] : t[s]);
    }
    let i;
    for (i in t)
      Rb.includes(i) || (this[i] = t[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? qs.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(e) {
    Bb(e, "basename"), Pb(e, "basename"), this.path = qs.join(this.dirname || "", e);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? qs.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(e) {
    Bx(this.basename, "dirname"), this.path = qs.join(e || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? qs.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(e) {
    if (Pb(e, "extname"), Bx(this.dirname, "extname"), e) {
      if (e.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (e.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = qs.join(this.dirname, this.stem + (e || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(e) {
    a4(e) && (e = mK(e)), Bb(e, "path"), this.path !== e && this.history.push(e);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? qs.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(e) {
    Bb(e, "stem"), Pb(e, "stem"), this.path = qs.join(this.dirname || "", e + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(e, t, r) {
    const i = this.message(e, t, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(e, t, r) {
    const i = this.message(e, t, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(e, t, r) {
    const i = new oi(
      // @ts-expect-error: the overloads are fine.
      e,
      t,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(e) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(e || void 0).decode(this.value);
  }
}
function Pb(n, e) {
  if (n && n.includes(qs.sep))
    throw new Error(
      "`" + e + "` cannot be a path: did not expect `" + qs.sep + "`"
    );
}
function Bb(n, e) {
  if (!n)
    throw new Error("`" + e + "` cannot be empty");
}
function Bx(n, e) {
  if (!n)
    throw new Error("Setting `" + e + "` requires `path` to be set too");
}
function bK(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
const vK = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(n) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[n], s = function() {
      return i.apply(s, arguments);
    };
    return Object.setPrototypeOf(s, r), s;
  }
), wK = {}.hasOwnProperty;
class t5 extends vK {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = sK();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const e = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new t5()
    );
    let t = -1;
    for (; ++t < this.attachers.length; ) {
      const r = this.attachers[t];
      e.use(...r);
    }
    return e.data(_b(!0, {}, this.namespace)), e;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(e, t) {
    return typeof e == "string" ? arguments.length === 2 ? (Fb("data", this.frozen), this.namespace[e] = t, this) : wK.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Fb("data", this.frozen), this.namespace = e, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const e = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [t, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = t.call(e, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(e) {
    this.freeze();
    const t = Jp(e), r = this.parser || this.Parser;
    return Hb("parse", r), r(String(t), t);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(e, t) {
    const r = this;
    return this.freeze(), Hb("process", this.parser || this.Parser), zb("process", this.compiler || this.Compiler), t ? i(void 0, t) : new Promise(i);
    function i(s, o) {
      const a = Jp(e), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(a)
      );
      r.run(l, a, function(u, h, f) {
        if (u || !h || !f)
          return c(u);
        const m = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          h
        ), y = r.stringify(m, f);
        xK(y) ? f.value = y : f.result = y, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          f
        );
      });
      function c(u, h) {
        u || !h ? o(u) : s ? s(h) : t(void 0, h);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(e) {
    let t = !1, r;
    return this.freeze(), Hb("processSync", this.parser || this.Parser), zb("processSync", this.compiler || this.Compiler), this.process(e, i), zx("processSync", "process", t), r;
    function i(s, o) {
      t = !0, Rx(s), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(e, t, r) {
    Hx(e), this.freeze();
    const i = this.transformers;
    return !r && typeof t == "function" && (r = t, t = void 0), r ? s(void 0, r) : new Promise(s);
    function s(o, a) {
      const l = Jp(t);
      i.run(e, l, c);
      function c(u, h, f) {
        const m = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          h || e
        );
        u ? a(u) : o ? o(m) : r(void 0, m, f);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(e, t) {
    let r = !1, i;
    return this.run(e, t, s), zx("runSync", "run", r), i;
    function s(o, a) {
      Rx(o), i = a, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(e, t) {
    this.freeze();
    const r = Jp(t), i = this.compiler || this.Compiler;
    return zb("stringify", i), Hx(e), i(e, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(e, ...t) {
    const r = this.attachers, i = this.namespace;
    if (Fb("use", this.frozen), e != null) if (typeof e == "function")
      l(e, t);
    else if (typeof e == "object")
      Array.isArray(e) ? a(e) : o(e);
    else
      throw new TypeError("Expected usable value, not `" + e + "`");
    return this;
    function s(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...h] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, h);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      a(c.plugins), c.settings && (i.settings = _b(!0, i.settings, c.settings));
    }
    function a(c) {
      let u = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++u < c.length; ) {
          const h = c[u];
          s(h);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let h = -1, f = -1;
      for (; ++h < r.length; )
        if (r[h][0] === c) {
          f = h;
          break;
        }
      if (f === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [m, ...y] = u;
        const b = r[f][1];
        o4(b) && o4(m) && (m = _b(!0, b, m)), r[f] = [c, m, ...y];
      }
    }
  }
}
const l4 = new t5().freeze();
function Hb(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `parser`");
}
function zb(n, e) {
  if (typeof e != "function")
    throw new TypeError("Cannot `" + n + "` without `compiler`");
}
function Fb(n, e) {
  if (e)
    throw new Error(
      "Cannot call `" + n + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Hx(n) {
  if (!o4(n) || typeof n.type != "string")
    throw new TypeError("Expected node, got `" + n + "`");
}
function zx(n, e, t) {
  if (!t)
    throw new Error(
      "`" + n + "` finished async. Use `" + e + "` instead"
    );
}
function Jp(n) {
  return kK(n) ? n : new yK(n);
}
function kK(n) {
  return !!(n && typeof n == "object" && "message" in n && "messages" in n);
}
function xK(n) {
  return typeof n == "string" || SK(n);
}
function SK(n) {
  return !!(n && typeof n == "object" && "byteLength" in n && "byteOffset" in n);
}
var WA = (n) => {
  throw TypeError(n);
}, UA = (n, e, t) => e.has(n) || WA("Cannot " + t), St = (n, e, t) => (UA(n, e, "read from private field"), t ? t.call(n) : e.get(n)), zn = (n, e, t) => e.has(n) ? WA("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), fn = (n, e, t, r) => (UA(n, e, "write to private field"), e.set(n, t), t), Fs, Sf, Bm, Hm, zm, Cf, Mf, Oo, Tf, Fm, Vm, Af, qm, Ef, $m, jm, iu, Hl, Wm, Lf;
class KA {
}
class GA {
  constructor() {
    this.elements = [], this.size = () => this.elements.length, this.top = () => this.elements.at(-1), this.push = (e) => {
      var t;
      (t = this.top()) == null || t.push(e);
    }, this.open = (e) => {
      this.elements.push(e);
    }, this.close = () => {
      const e = this.elements.pop();
      if (!e) throw sA();
      return e;
    };
  }
}
class n5 extends KA {
  constructor(e, t, r) {
    super(), this.type = e, this.content = t, this.attrs = r;
  }
  push(e, ...t) {
    this.content.push(e, ...t);
  }
  pop() {
    return this.content.pop();
  }
  static create(e, t, r) {
    return new n5(e, t, r);
  }
}
const c4 = class extends GA {
  /// @internal
  constructor(e) {
    super(), zn(this, Fs), zn(this, Sf), zn(this, Bm), zn(this, Hm), zn(this, zm), zn(this, Cf), zn(this, Mf), fn(this, Fs, wt.none), fn(this, Sf, (t) => t.isText), fn(this, Bm, (t, r) => {
      if (St(this, Sf).call(this, t) && St(this, Sf).call(this, r) && wt.sameSet(t.marks, r.marks))
        return this.schema.text(t.text + r.text, t.marks);
    }), fn(this, Hm, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.parseMarkdown.match(t));
      if (!r) throw v$(t);
      return r;
    }), fn(this, zm, (t) => {
      const r = St(this, Hm).call(this, t);
      r.spec.parseMarkdown.runner(this, t, r);
    }), this.injectRoot = (t, r, i) => (this.openNode(r, i), this.next(t.children), this), this.openNode = (t, r) => (this.open(n5.create(t, [], r)), this), fn(this, Cf, () => {
      fn(this, Fs, wt.none);
      const t = this.close();
      return St(this, Mf).call(this, t.type, t.attrs, t.content);
    }), this.closeNode = () => {
      try {
        St(this, Cf).call(this);
      } catch (t) {
        console.error(t);
      }
      return this;
    }, fn(this, Mf, (t, r, i) => {
      const s = t.createAndFill(r, i, St(this, Fs));
      if (!s) throw b$(t, r, i);
      return this.push(s), s;
    }), this.addNode = (t, r, i) => {
      try {
        St(this, Mf).call(this, t, r, i);
      } catch (s) {
        console.error(s);
      }
      return this;
    }, this.openMark = (t, r) => {
      const i = t.create(r);
      return fn(this, Fs, i.addToSet(St(this, Fs))), this;
    }, this.closeMark = (t) => (fn(this, Fs, t.removeFromSet(St(this, Fs))), this), this.addText = (t) => {
      try {
        const r = this.top();
        if (!r) throw sA();
        const i = r.pop(), s = this.schema.text(t, St(this, Fs));
        if (!i)
          return r.push(s), this;
        const o = St(this, Bm).call(this, i, s);
        return o ? (r.push(o), this) : (r.push(i, s), this);
      } catch (r) {
        return console.error(r), this;
      }
    }, this.build = () => {
      let t;
      do
        t = St(this, Cf).call(this);
      while (this.size());
      return t;
    }, this.next = (t = []) => ([t].flat().forEach((r) => St(this, zm).call(this, r)), this), this.toDoc = () => this.build(), this.run = (t, r) => {
      const i = t.runSync(
        t.parse(r),
        r
      );
      return this.next(i), this;
    }, this.schema = e;
  }
};
Fs = /* @__PURE__ */ new WeakMap();
Sf = /* @__PURE__ */ new WeakMap();
Bm = /* @__PURE__ */ new WeakMap();
Hm = /* @__PURE__ */ new WeakMap();
zm = /* @__PURE__ */ new WeakMap();
Cf = /* @__PURE__ */ new WeakMap();
Mf = /* @__PURE__ */ new WeakMap();
c4.create = (n, e) => {
  const t = new c4(n);
  return (r) => (t.run(e, r), t.toDoc());
};
let CK = c4;
const u4 = class extends KA {
  constructor(e, t, r, i = {}) {
    super(), this.type = e, this.children = t, this.value = r, this.props = i, this.push = (s, ...o) => {
      this.children || (this.children = []), this.children.push(s, ...o);
    }, this.pop = () => {
      var s;
      return (s = this.children) == null ? void 0 : s.pop();
    };
  }
};
u4.create = (n, e, t, r = {}) => new u4(n, e, t, r);
let Fx = u4;
const MK = (n) => Object.prototype.hasOwnProperty.call(n, "size"), h4 = class extends GA {
  /// @internal
  constructor(e) {
    super(), zn(this, Oo), zn(this, Tf), zn(this, Fm), zn(this, Vm), zn(this, Af), zn(this, qm), zn(this, Ef), zn(this, $m), zn(this, jm), zn(this, iu), zn(this, Hl), zn(this, Wm), zn(this, Lf), fn(this, Oo, wt.none), fn(this, Tf, (t) => {
      const r = Object.values({
        ...this.schema.nodes,
        ...this.schema.marks
      }).find((i) => i.spec.toMarkdown.match(t));
      if (!r) throw w$(t.type);
      return r;
    }), fn(this, Fm, (t) => St(this, Tf).call(this, t).spec.toMarkdown.runner(this, t)), fn(this, Vm, (t, r) => St(this, Tf).call(this, t).spec.toMarkdown.runner(this, t, r)), fn(this, Af, (t) => {
      const { marks: r } = t, i = (a) => a.type.spec.priority ?? 50;
      [...r].sort((a, l) => i(a) - i(l)).every((a) => !St(this, Vm).call(this, a, t)) && St(this, Fm).call(this, t), r.forEach((a) => St(this, Lf).call(this, a));
    }), fn(this, qm, (t, r) => {
      var l;
      if (t.type === r || ((l = t.children) == null ? void 0 : l.length) !== 1) return t;
      const i = (c) => {
        var h;
        if (c.type === r) return c;
        if (((h = c.children) == null ? void 0 : h.length) !== 1) return null;
        const [u] = c.children;
        return u ? i(u) : null;
      }, s = i(t);
      if (!s) return t;
      const o = s.children ? [...s.children] : void 0, a = { ...t, children: o };
      return a.children = o, s.children = [a], s;
    }), fn(this, Ef, (t) => {
      const { children: r } = t;
      return r && (t.children = r.reduce((i, s, o) => {
        if (o === 0) return [s];
        const a = i.at(-1);
        if (a && a.isMark && s.isMark) {
          s = St(this, qm).call(this, s, a.type);
          const { children: l, ...c } = s, { children: u, ...h } = a;
          if (s.type === a.type && l && u && JSON.stringify(c) === JSON.stringify(h)) {
            const f = {
              ...h,
              children: [...u, ...l]
            };
            return i.slice(0, -1).concat(St(this, Ef).call(this, f));
          }
        }
        return i.concat(s);
      }, [])), t;
    }), fn(this, $m, (t) => {
      const r = {
        ...t.props,
        type: t.type
      };
      return t.children && (r.children = t.children), t.value && (r.value = t.value), r;
    }), this.openNode = (t, r, i) => (this.open(Fx.create(t, void 0, r, i)), this), fn(this, jm, (t, r) => {
      let i = "", s = "";
      const o = t.children;
      let a = -1, l = -1;
      const c = (h) => {
        h && h.forEach((f, m) => {
          f.type === "text" && f.value && (a < 0 && (a = m), l = m);
        });
      };
      if (o) {
        c(o);
        const h = o == null ? void 0 : o[l], f = o == null ? void 0 : o[a];
        if (h && h.value.endsWith(" ")) {
          const m = h.value, y = m.trimEnd();
          s = m.slice(y.length), h.value = y;
        }
        if (f && f.value.startsWith(" ")) {
          const m = f.value, y = m.trimStart();
          i = m.slice(0, m.length - y.length), f.value = y;
        }
      }
      i.length && St(this, Hl).call(this, "text", void 0, i);
      const u = r();
      return s.length && St(this, Hl).call(this, "text", void 0, s), u;
    }), fn(this, iu, (t = !1) => {
      const r = this.close(), i = () => St(this, Hl).call(this, r.type, r.children, r.value, r.props);
      return t ? St(this, jm).call(this, r, i) : i();
    }), this.closeNode = () => (St(this, iu).call(this), this), fn(this, Hl, (t, r, i, s) => {
      const o = Fx.create(t, r, i, s), a = St(this, Ef).call(this, St(this, $m).call(this, o));
      return this.push(a), a;
    }), this.addNode = (t, r, i, s) => (St(this, Hl).call(this, t, r, i, s), this), fn(this, Wm, (t, r, i, s) => t.isInSet(St(this, Oo)) ? this : (fn(this, Oo, t.addToSet(St(this, Oo))), this.openNode(r, i, { ...s, isMark: !0 }))), fn(this, Lf, (t) => {
      t.isInSet(St(this, Oo)) && (fn(this, Oo, t.type.removeFromSet(St(this, Oo))), St(this, iu).call(this, !0));
    }), this.withMark = (t, r, i, s) => (St(this, Wm).call(this, t, r, i, s), this), this.closeMark = (t) => (St(this, Lf).call(this, t), this), this.build = () => {
      let t = null;
      do
        t = St(this, iu).call(this);
      while (this.size());
      return t;
    }, this.next = (t) => MK(t) ? (t.forEach((r) => {
      St(this, Af).call(this, r);
    }), this) : (St(this, Af).call(this, t), this), this.toString = (t) => t.stringify(this.build()), this.run = (t) => (this.next(t), this), this.schema = e;
  }
};
Oo = /* @__PURE__ */ new WeakMap();
Tf = /* @__PURE__ */ new WeakMap();
Fm = /* @__PURE__ */ new WeakMap();
Vm = /* @__PURE__ */ new WeakMap();
Af = /* @__PURE__ */ new WeakMap();
qm = /* @__PURE__ */ new WeakMap();
Ef = /* @__PURE__ */ new WeakMap();
$m = /* @__PURE__ */ new WeakMap();
jm = /* @__PURE__ */ new WeakMap();
iu = /* @__PURE__ */ new WeakMap();
Hl = /* @__PURE__ */ new WeakMap();
Wm = /* @__PURE__ */ new WeakMap();
Lf = /* @__PURE__ */ new WeakMap();
h4.create = (n, e) => {
  const t = new h4(n);
  return (r) => (t.run(r), t.toString(e));
};
let TK = h4;
const r5 = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function JA(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const YA = (n, e, t) => {
  let r = JA(n, t);
  if (!r)
    return !1;
  let i = i5(r);
  if (!i) {
    let o = r.blockRange(), a = o && P1(o);
    return a == null ? !1 : (e && e(n.tr.lift(o, a).scrollIntoView()), !0);
  }
  let s = i.nodeBefore;
  if (eE(n, i, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (dh(s, "end") || Qe.isSelectable(s)))
    for (let o = r.depth; ; o--) {
      let a = H1(n.doc, r.before(o), r.after(o), He.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = n.tr.step(a);
          l.setSelection(dh(s, "end") ? ht.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : Qe.create(l.doc, i.pos - s.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (o == 1 || r.node(o - 1).childCount > 1)
        break;
    }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - s.nodeSize, i.pos).scrollIntoView()), !0) : !1;
}, AK = (n, e, t) => {
  let r = JA(n, t);
  if (!r)
    return !1;
  let i = i5(r);
  return i ? EK(n, i, e) : !1;
};
function EK(n, e, t) {
  let r = e.nodeBefore, i = r, s = e.pos - 1;
  for (; !i.isTextblock; s--) {
    if (i.type.spec.isolating)
      return !1;
    let u = i.lastChild;
    if (!u)
      return !1;
    i = u;
  }
  let o = e.nodeAfter, a = o, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let u = a.firstChild;
    if (!u)
      return !1;
    a = u;
  }
  let c = H1(n.doc, s, l, He.empty);
  if (!c || c.from != s || c instanceof er && c.slice.size >= l - s)
    return !1;
  if (t) {
    let u = n.tr.step(c);
    u.setSelection(Ye.create(u.doc, s)), t(u.scrollIntoView());
  }
  return !0;
}
function dh(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const XA = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    s = i5(r);
  }
  let o = s && s.nodeBefore;
  return !o || !Qe.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(Qe.create(n.doc, s.pos - o.nodeSize)).scrollIntoView()), !0);
};
function i5(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function LK(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const OK = (n, e, t) => {
  let r = LK(n, t);
  if (!r)
    return !1;
  let i = ZA(r);
  if (!i)
    return !1;
  let s = i.nodeAfter;
  if (eE(n, i, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (dh(s, "start") || Qe.isSelectable(s))) {
    let o = H1(n.doc, r.before(), r.after(), He.empty);
    if (o && o.slice.size < o.to - o.from) {
      if (e) {
        let a = n.tr.step(o);
        a.setSelection(dh(s, "start") ? ht.findFrom(a.doc.resolve(a.mapping.map(i.pos)), 1) : Qe.create(a.doc, a.mapping.map(i.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return s.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + s.nodeSize).scrollIntoView()), !0) : !1;
}, DK = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, s = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    s = ZA(r);
  }
  let o = s && s.nodeAfter;
  return !o || !Qe.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(Qe.create(n.doc, s.pos)).scrollIntoView()), !0);
};
function ZA(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const NK = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function s5(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const QA = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), s = t.indexAfter(-1), o = s5(i.contentMatchAt(s));
  if (!o || !i.canReplaceWith(s, s, o))
    return !1;
  if (e) {
    let a = t.after(), l = n.tr.replaceWith(a, a, o.createAndFill());
    l.setSelection(ht.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, IK = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof ni || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let s = s5(i.parent.contentMatchAt(i.indexAfter()));
  if (!s || !s.isTextblock)
    return !1;
  if (e) {
    let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, a = n.tr.insert(o, s.createAndFill());
    a.setSelection(Ye.create(a.doc, o + 1)), e(a.scrollIntoView());
  }
  return !0;
}, _K = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let s = t.before();
    if (ad(n.doc, s))
      return e && e(n.tr.split(s).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && P1(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function RK(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof Qe && e.selection.node.isBlock)
      return !r.parentOffset || !ad(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let s = [], o, a, l = !1, c = !1;
    for (let m = r.depth; ; m--)
      if (r.node(m).isBlock) {
        l = r.end(m) == r.pos + (r.depth - m), c = r.start(m) == r.pos - (r.depth - m), a = s5(r.node(m - 1).contentMatchAt(r.indexAfter(m - 1))), s.unshift(l && a ? { type: a } : null), o = m;
        break;
      } else {
        if (m == 1)
          return !1;
        s.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof Ye || e.selection instanceof ni) && u.deleteSelection();
    let h = u.mapping.map(r.pos), f = ad(u.doc, h, s.length, s);
    if (f || (s[0] = a ? { type: a } : null, f = ad(u.doc, h, s.length, s)), !f)
      return !1;
    if (u.split(h, s.length, s), !l && c && r.node(o).type != a) {
      let m = u.mapping.map(r.before(o)), y = u.doc.resolve(m);
      a && r.node(o - 1).canReplaceWith(y.index(), y.index() + 1, a) && u.setNodeMarkup(u.mapping.map(r.before(o)), a);
    }
    return t && t(u.scrollIntoView()), !0;
  };
}
const PK = RK(), BK = (n, e) => (e && e(n.tr.setSelection(new ni(n.doc))), !0);
function HK(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, s = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(s - 1, s) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(s, s + 1) || !(i.isTextblock || B1(n.doc, e.pos)) ? !1 : (t && t(n.tr.join(e.pos).scrollIntoView()), !0);
}
function eE(n, e, t, r) {
  let i = e.nodeBefore, s = e.nodeAfter, o, a, l = i.type.spec.isolating || s.type.spec.isolating;
  if (!l && HK(n, e, t))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (o = (a = i.contentMatchAt(i.childCount)).findWrapping(s.type)) && a.matchType(o[0] || s.type).validEnd) {
    if (t) {
      let m = e.pos + s.nodeSize, y = pe.empty;
      for (let x = o.length - 1; x >= 0; x--)
        y = pe.from(o[x].create(null, y));
      y = pe.from(i.copy(y));
      let b = n.tr.step(new kr(e.pos - 1, m, e.pos, m, new He(y, 1, 0), o.length, !0)), k = b.doc.resolve(m + 2 * o.length);
      k.nodeAfter && k.nodeAfter.type == i.type && B1(b.doc, k.pos) && b.join(k.pos), t(b.scrollIntoView());
    }
    return !0;
  }
  let u = s.type.spec.isolating || r > 0 && l ? null : ht.findFrom(e, 1), h = u && u.$from.blockRange(u.$to), f = h && P1(h);
  if (f != null && f >= e.depth)
    return t && t(n.tr.lift(h, f).scrollIntoView()), !0;
  if (c && dh(s, "start", !0) && dh(i, "end")) {
    let m = i, y = [];
    for (; y.push(m), !m.isTextblock; )
      m = m.lastChild;
    let b = s, k = 1;
    for (; !b.isTextblock; b = b.firstChild)
      k++;
    if (m.canReplace(m.childCount, m.childCount, b.content)) {
      if (t) {
        let x = pe.empty;
        for (let T = y.length - 1; T >= 0; T--)
          x = pe.from(y[T].copy(x));
        let M = n.tr.step(new kr(e.pos - y.length, e.pos + s.nodeSize, e.pos + k, e.pos + s.nodeSize - k, new He(x, y.length, 0), 0, !0));
        t(M.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function tE(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, s = i.depth;
    for (; i.node(s).isInline; ) {
      if (!s)
        return !1;
      s--;
    }
    return i.node(s).isTextblock ? (t && t(e.tr.setSelection(Ye.create(e.doc, n < 0 ? i.start(s) : i.end(s)))), !0) : !1;
  };
}
const zK = tE(-1), FK = tE(1);
function o5(n, e = null) {
  return function(t, r) {
    let { $from: i, $to: s } = t.selection, o = i.blockRange(s), a = o && jw(o, n, e);
    return a ? (r && r(t.tr.wrap(o, a).scrollIntoView()), !0) : !1;
  };
}
function jd(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let s = 0; s < t.selection.ranges.length && !i; s++) {
      let { $from: { pos: o }, $to: { pos: a } } = t.selection.ranges[s];
      t.doc.nodesBetween(o, a, (l, c) => {
        if (i)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(n, e)))
          if (l.type == n)
            i = !0;
          else {
            let u = t.doc.resolve(c), h = u.index();
            i = u.parent.canReplaceWith(h, h + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let s = t.tr;
      for (let o = 0; o < t.selection.ranges.length; o++) {
        let { $from: { pos: a }, $to: { pos: l } } = t.selection.ranges[o];
        s.setBlockType(a, l, n, e);
      }
      r(s.scrollIntoView());
    }
    return !0;
  };
}
function VK(n, e, t, r) {
  for (let i = 0; i < e.length; i++) {
    let { $from: s, $to: o } = e[i], a = s.depth == 0 ? n.inlineContent && n.type.allowsMarkType(t) : !1;
    if (n.nodesBetween(s.pos, o.pos, (l, c) => {
      if (a)
        return !1;
      a = l.inlineContent && l.type.allowsMarkType(t);
    }), a)
      return !0;
  }
  return !1;
}
function G1(n, e = null, t) {
  return function(r, i) {
    let { empty: s, $cursor: o, ranges: a } = r.selection;
    if (s && !o || !VK(r.doc, a, n))
      return !1;
    if (i)
      if (o)
        n.isInSet(r.storedMarks || o.marks()) ? i(r.tr.removeStoredMark(n)) : i(r.tr.addStoredMark(n.create(e)));
      else {
        let l, c = r.tr;
        l = !a.some((u) => r.doc.rangeHasMark(u.$from.pos, u.$to.pos, n));
        for (let u = 0; u < a.length; u++) {
          let { $from: h, $to: f } = a[u];
          if (!l)
            c.removeMark(h.pos, f.pos, n);
          else {
            let m = h.pos, y = f.pos, b = h.nodeAfter, k = f.nodeBefore, x = b && b.isText ? /^\s*/.exec(b.text)[0].length : 0, M = k && k.isText ? /\s*$/.exec(k.text)[0].length : 0;
            m + x < y && (m += x, y -= M), c.addMark(m, y, n.create(e));
          }
        }
        i(c.scrollIntoView());
      }
    return !0;
  };
}
function Oh(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
let Vb = Oh(r5, YA, XA), Vx = Oh(r5, OK, DK);
const Po = {
  Enter: Oh(NK, IK, _K, PK),
  "Mod-Enter": QA,
  Backspace: Vb,
  "Mod-Backspace": Vb,
  "Shift-Backspace": Vb,
  Delete: Vx,
  "Mod-Delete": Vx,
  "Mod-a": BK
}, nE = {
  "Ctrl-h": Po.Backspace,
  "Alt-Backspace": Po["Mod-Backspace"],
  "Ctrl-d": Po.Delete,
  "Ctrl-Alt-Backspace": Po["Mod-Delete"],
  "Alt-Delete": Po["Mod-Delete"],
  "Alt-d": Po["Mod-Delete"],
  "Ctrl-a": zK,
  "Ctrl-e": FK
};
for (let n in Po)
  nE[n] = Po[n];
const qK = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, $K = qK ? nE : Po, jK = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), WK = typeof navigator < "u" && /Win/.test(navigator.platform);
function UK(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, s, o;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      o = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      i = !0;
    else if (/^s(hift)?$/i.test(l))
      s = !0;
    else if (/^mod$/i.test(l))
      jK ? o = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), s && (t = "Shift-" + t), t;
}
function KK(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[UK(t)] = n[t];
  return e;
}
function qb(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function rE(n) {
  return new mn({ props: { handleKeyDown: a5(n) } });
}
function a5(n) {
  let e = KK(n);
  return function(t, r) {
    let i = $9(r), s, o = e[qb(i, r)];
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let a = e[qb(i, r, !1)];
        if (a && a(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(WK && r.ctrlKey && r.altKey) && (s = ia[r.keyCode]) && s != i) {
        let a = e[qb(s, r)];
        if (a && a(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const ur = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, ph = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let f4 = null;
const Ro = function(n, e, t) {
  let r = f4 || (f4 = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, GK = function() {
  f4 = null;
}, Dc = function(n, e, t, r) {
  return t && (qx(n, e, t, r, -1) || qx(n, e, t, r, 1));
}, JK = /^(img|br|input|textarea|hr)$/i;
function qx(n, e, t, r, i) {
  for (var s; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Vi(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || U0(n) || JK.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = ur(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      let o = n.childNodes[e + (i < 0 ? -1 : 0)];
      if (o.nodeType == 1 && o.contentEditable == "false")
        if (!((s = o.pmViewDesc) === null || s === void 0) && s.ignoreForSelection)
          e += i;
        else
          return !1;
      else
        n = o, e = i < 0 ? Vi(n) : 0;
    } else
      return !1;
  }
}
function Vi(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function YK(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e - 1], e = Vi(n);
    } else if (n.parentNode && !U0(n))
      e = ur(n), n = n.parentNode;
    else
      return null;
  }
}
function XK(n, e) {
  for (; ; ) {
    if (n.nodeType == 3 && e < n.nodeValue.length)
      return n;
    if (n.nodeType == 1 && e < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[e], e = 0;
    } else if (n.parentNode && !U0(n))
      e = ur(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
function ZK(n, e, t) {
  for (let r = e == 0, i = e == Vi(n); r || i; ) {
    if (n == t)
      return !0;
    let s = ur(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && s == 0, i = i && s == Vi(n);
  }
}
function U0(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const J1 = function(n) {
  return n.focusNode && Dc(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function jl(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function QK(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function eG(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: Math.min(Vi(r.offsetNode), r.offset) };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: Math.min(Vi(r.startContainer), r.startOffset) };
  }
}
const io = typeof navigator < "u" ? navigator : null, $x = typeof document < "u" ? document : null, gl = io && io.userAgent || "", d4 = /Edge\/(\d+)/.exec(gl), iE = /MSIE \d/.exec(gl), p4 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(gl), ri = !!(iE || p4 || d4), Ja = iE ? document.documentMode : p4 ? +p4[1] : d4 ? +d4[1] : 0, Gi = !ri && /gecko\/(\d+)/i.test(gl);
Gi && +(/Firefox\/(\d+)/.exec(gl) || [0, 0])[1];
const m4 = !ri && /Chrome\/(\d+)/.exec(gl), vr = !!m4, sE = m4 ? +m4[1] : 0, Rr = !ri && !!io && /Apple Computer/.test(io.vendor), mh = Rr && (/Mobile\/\w+/.test(gl) || !!io && io.maxTouchPoints > 2), Hi = mh || (io ? /Mac/.test(io.platform) : !1), tG = io ? /Win/.test(io.platform) : !1, Go = /Android \d/.test(gl), K0 = !!$x && "webkitFontSmoothing" in $x.documentElement.style, nG = K0 ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function rG(n) {
  let e = n.defaultView && n.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function Ao(n, e) {
  return typeof n == "number" ? n : n[e];
}
function iG(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function jx(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, s = n.dom.ownerDocument;
  for (let o = t || n.dom; o; ) {
    if (o.nodeType != 1) {
      o = ph(o);
      continue;
    }
    let a = o, l = a == s.body, c = l ? rG(s) : iG(a), u = 0, h = 0;
    if (e.top < c.top + Ao(r, "top") ? h = -(c.top - e.top + Ao(i, "top")) : e.bottom > c.bottom - Ao(r, "bottom") && (h = e.bottom - e.top > c.bottom - c.top ? e.top + Ao(i, "top") - c.top : e.bottom - c.bottom + Ao(i, "bottom")), e.left < c.left + Ao(r, "left") ? u = -(c.left - e.left + Ao(i, "left")) : e.right > c.right - Ao(r, "right") && (u = e.right - c.right + Ao(i, "right")), u || h)
      if (l)
        s.defaultView.scrollBy(u, h);
      else {
        let m = a.scrollLeft, y = a.scrollTop;
        h && (a.scrollTop += h), u && (a.scrollLeft += u);
        let b = a.scrollLeft - m, k = a.scrollTop - y;
        e = { left: e.left - b, top: e.top - k, right: e.right - b, bottom: e.bottom - k };
      }
    let f = l ? "fixed" : getComputedStyle(o).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    o = f == "absolute" ? o.offsetParent : ph(o);
  }
}
function sG(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let s = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) {
    let a = n.root.elementFromPoint(s, o);
    if (!a || a == n.dom || !n.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= t - 20) {
      r = a, i = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: oE(n.dom) };
}
function oE(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = ph(r))
    ;
  return e;
}
function oG({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  aE(t, r == 0 ? 0 : r - e);
}
function aE(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: s } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != s && (r.scrollLeft = s);
  }
}
let Zc = null;
function aG(n) {
  if (n.setActive)
    return n.setActive();
  if (Zc)
    return n.focus(Zc);
  let e = oE(n);
  n.focus(Zc == null ? {
    get preventScroll() {
      return Zc = { preventScroll: !0 }, !0;
    }
  } : void 0), Zc || (Zc = !1, aE(e, 0));
}
function lE(n, e) {
  let t, r = 2e8, i, s = 0, o = e.top, a = e.top, l, c;
  for (let u = n.firstChild, h = 0; u; u = u.nextSibling, h++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Ro(u).getClientRects();
    else
      continue;
    for (let m = 0; m < f.length; m++) {
      let y = f[m];
      if (y.top <= o && y.bottom >= a) {
        o = Math.max(y.bottom, o), a = Math.min(y.top, a);
        let b = y.left > e.left ? y.left - e.left : y.right < e.left ? e.left - y.right : 0;
        if (b < r) {
          t = u, r = b, i = b && t.nodeType == 3 ? {
            left: y.right < e.left ? y.right : y.left,
            top: e.top
          } : e, u.nodeType == 1 && b && (s = h + (e.left >= (y.left + y.right) / 2 ? 1 : 0));
          continue;
        }
      } else y.top > e.top && !l && y.left <= e.left && y.right >= e.left && (l = u, c = { left: Math.max(y.left, Math.min(y.right, e.left)), top: y.top });
      !t && (e.left >= y.right && e.top >= y.top || e.left >= y.left && e.top >= y.bottom) && (s = h + 1);
    }
  }
  return !t && l && (t = l, i = c, r = 0), t && t.nodeType == 3 ? lG(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: s } : lE(t, i);
}
function lG(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let s = Aa(r, 1);
    if (s.top != s.bottom && l5(e, s))
      return { node: n, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function l5(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function cG(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function uG(n, e, t) {
  let { node: r, offset: i } = lE(e, t), s = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let o = r.getBoundingClientRect();
    s = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, s);
}
function hG(n, e, t, r) {
  let i = -1;
  for (let s = e, o = !1; s != n.dom; ) {
    let a = n.docView.nearestDesc(s, !0), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) && (!o && l.left > r.left || l.top > r.top ? i = a.posBefore : (!o && l.right < r.left || l.bottom < r.top) && (i = a.posAfter), o = !0), !a.contentDOM && i < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    s = a.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function cE(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), s = i; ; ) {
      let o = n.childNodes[s];
      if (o.nodeType == 1) {
        let a = o.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (l5(e, c))
            return cE(o, e, c);
        }
      }
      if ((s = (s + 1) % r) == i)
        break;
    }
  return n;
}
function fG(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, s = eG(t, e.left, e.top);
  s && ({ node: r, offset: i } = s);
  let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), a;
  if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) {
    let c = n.dom.getBoundingClientRect();
    if (!l5(e, c) || (o = cE(n.dom, e, c), !o))
      return null;
  }
  if (Rr)
    for (let c = o; r && c; c = ph(c))
      c.draggable && (r = void 0);
  if (o = cG(o, e), r) {
    if (Gi && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let u = r.childNodes[i], h;
      u.nodeName == "IMG" && (h = u.getBoundingClientRect()).right <= e.left && h.bottom > e.top && i++;
    }
    let c;
    K0 && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (a = hG(n, r, i, e));
  }
  a == null && (a = uG(n, o, e));
  let l = n.docView.nearestDesc(o, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function Wx(n) {
  return n.top < n.bottom || n.left < n.right;
}
function Aa(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (Wx(r))
      return r;
  }
  return Array.prototype.find.call(t, Wx) || n.getBoundingClientRect();
}
const dG = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function uE(n, e, t) {
  let { node: r, offset: i, atom: s } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = K0 || Gi;
  if (r.nodeType == 3)
    if (o && (dG.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let l = Aa(Ro(r, i, i), t);
      if (Gi && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let c = Aa(Ro(r, i - 1, i - 1), -1);
        if (c.top == l.top) {
          let u = Aa(Ro(r, i, i + 1), -1);
          if (u.top != l.top)
            return sf(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = i, c = i, u = t < 0 ? 1 : -1;
      return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (l--, u = 1) : t < 0 ? l-- : c++, sf(Aa(Ro(r, l, c), u), u < 0);
    }
  if (!n.state.doc.resolve(e - (s || 0)).parent.inlineContent) {
    if (s == null && i && (t < 0 || i == Vi(r))) {
      let l = r.childNodes[i - 1];
      if (l.nodeType == 1)
        return $b(l.getBoundingClientRect(), !1);
    }
    if (s == null && i < Vi(r)) {
      let l = r.childNodes[i];
      if (l.nodeType == 1)
        return $b(l.getBoundingClientRect(), !0);
    }
    return $b(r.getBoundingClientRect(), t >= 0);
  }
  if (s == null && i && (t < 0 || i == Vi(r))) {
    let l = r.childNodes[i - 1], c = l.nodeType == 3 ? Ro(l, Vi(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return sf(Aa(c, 1), !1);
  }
  if (s == null && i < Vi(r)) {
    let l = r.childNodes[i];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? Ro(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return sf(Aa(c, -1), !0);
  }
  return sf(Aa(r.nodeType == 3 ? Ro(r) : r, -t), t >= 0);
}
function sf(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function $b(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function hE(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function pG(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return hE(n, e, () => {
    let { node: s } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let a = n.docView.nearestDesc(s, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        s = a.contentDOM || a.dom;
        break;
      }
      s = a.dom.parentNode;
    }
    let o = uE(n, i.pos, 1);
    for (let a = s.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = Ro(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const mG = /[\u0590-\u08ac]/;
function gG(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, s = !i, o = i == r.parent.content.size, a = n.domSelection();
  return a ? !mG.test(r.parent.textContent) || !a.modify ? t == "left" || t == "backward" ? s : o : hE(n, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: h } = n.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", t, "character");
    let m = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: y, focusOffset: b } = n.domSelectionRange(), k = y && !m.contains(y.nodeType == 1 ? y : y.parentNode) || l == y && c == b;
    try {
      a.collapse(u, h), l && (l != u || c != h) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), k;
  }) : r.pos == r.start() || r.pos == r.end();
}
let Ux = null, Kx = null, Gx = !1;
function yG(n, e, t) {
  return Ux == e && Kx == t ? Gx : (Ux = e, Kx = t, Gx = t == "up" || t == "down" ? pG(n, e, t) : gG(n, e, t));
}
const Ji = 0, Jx = 1, Gl = 2, so = 3;
class G0 {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = Ji, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.previousSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.previousSibling;
        return s ? this.posBeforeChild(o) + o.size : this.posAtStart;
      } else {
        let s, o;
        if (e == this.contentDOM)
          s = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          s = e.nextSibling;
        }
        for (; s && !((o = s.pmViewDesc) && o.parent == this); )
          s = s.nextSibling;
        return s ? this.posBeforeChild(o) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > ur(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !1;
            break;
          }
          if (s.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let s = e; ; s = s.parentNode) {
          if (s == this.dom) {
            i = !0;
            break;
          }
          if (s.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let s = this.getDesc(i), o;
      if (s && (!t || s.node))
        if (r && (o = s.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e))
          r = !1;
        else
          return s;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let s = this.getDesc(i);
      if (s)
        return s.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], s = r + i.size;
      if (r == e && s != r) {
        for (; !i.border && i.children.length; )
          for (let o = 0; o < i.children.length; o++) {
            let a = i.children[o];
            if (a.size) {
              i = a;
              break;
            }
          }
        return i;
      }
      if (e < s)
        return i.descAt(e - r - i.border);
      r = s;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let s = 0; r < this.children.length; r++) {
      let o = this.children[r], a = s + o.size;
      if (a > e || o instanceof dE) {
        i = e - s;
        break;
      }
      s = a;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let s; r && !(s = this.children[r - 1]).size && s instanceof fE && s.side >= 0; r--)
      ;
    if (t <= 0) {
      let s, o = !0;
      for (; s = r ? this.children[r - 1] : null, !(!s || s.dom.parentNode == this.contentDOM); r--, o = !1)
        ;
      return s && t && o && !s.border && !s.domAtom ? s.domFromPos(s.size, t) : { node: this.contentDOM, offset: s ? ur(s.dom) + 1 : 0 };
    } else {
      let s, o = !0;
      for (; s = r < this.children.length ? this.children[r] : null, !(!s || s.dom.parentNode == this.contentDOM); r++, o = !1)
        ;
      return s && o && !s.border && !s.domAtom ? s.domFromPos(0, t) : { node: this.contentDOM, offset: s ? ur(s.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, s = -1;
    for (let o = r, a = 0; ; a++) {
      let l = this.children[a], c = o + l.size;
      if (i == -1 && e <= c) {
        let u = o + l.border;
        if (e >= u && t <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, t, u);
        e = o;
        for (let h = a; h > 0; h--) {
          let f = this.children[h - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            i = ur(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (c > t || a == this.children.length - 1)) {
        t = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let h = this.children[u];
          if (h.size && h.dom.parentNode == this.contentDOM && !h.emptyChildAt(-1)) {
            s = ur(h.dom);
            break;
          }
          t += h.size;
        }
        s == -1 && (s = this.contentDOM.childNodes.length);
        break;
      }
      o = c;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: s };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let s = Math.min(e, t), o = Math.max(e, t);
    for (let m = 0, y = 0; m < this.children.length; m++) {
      let b = this.children[m], k = y + b.size;
      if (s > y && o < k)
        return b.setSelection(e - y - b.border, t - y - b.border, r, i);
      y = k;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = t == e ? a : this.domFromPos(t, t ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), h = !1;
    if ((Gi || Rr) && e == t) {
      let { node: m, offset: y } = a;
      if (m.nodeType == 3) {
        if (h = !!(y && m.nodeValue[y - 1] == `
`), h && y == m.nodeValue.length)
          for (let b = m, k; b; b = b.parentNode) {
            if (k = b.nextSibling) {
              k.nodeName == "BR" && (a = l = { node: k.parentNode, offset: ur(k) + 1 });
              break;
            }
            let x = b.pmViewDesc;
            if (x && x.node && x.node.isBlock)
              break;
          }
      } else {
        let b = m.childNodes[y - 1];
        h = b && (b.nodeName == "BR" || b.contentEditable == "false");
      }
    }
    if (Gi && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let m = u.focusNode.childNodes[u.focusOffset];
      m && m.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && Rr) && Dc(a.node, a.offset, u.anchorNode, u.anchorOffset) && Dc(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == t) && !(h && Gi)) {
      c.collapse(a.node, a.offset);
      try {
        e != t && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > t) {
        let y = a;
        a = l, l = y;
      }
      let m = document.createRange();
      m.setEnd(l.node, l.offset), m.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(m);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let s = this.children[i], o = r + s.size;
      if (r == o ? e <= o && t >= r : e < o && t > r) {
        let a = r + s.border, l = o - s.border;
        if (e >= a && t <= l) {
          this.dirty = e == r || t == o ? Gl : Jx, e == a && t == l && (s.contentLost || s.dom.parentNode != this.contentDOM) ? s.dirty = so : s.markDirty(e - a, t - a);
          return;
        } else
          s.dirty = s.dom == s.contentDOM && s.dom.parentNode == this.contentDOM && !s.children.length ? Gl : so;
      }
      r = o;
    }
    this.dirty = Gl;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? Gl : Jx;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class fE extends G0 {
  constructor(e, t, r, i) {
    let s, o = t.type.toDOM;
    if (typeof o == "function" && (o = o(r, () => {
      if (!s)
        return i;
      if (s.parent)
        return s.parent.posBeforeChild(s);
    })), !t.type.spec.raw) {
      if (o.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(o), o = a;
      }
      o.contentEditable = "false", o.classList.add("ProseMirror-widget");
    }
    super(e, [], o, null), this.widget = t, this.widget = t, s = this;
  }
  matchesWidget(e) {
    return this.dirty == Ji && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class bG extends G0 {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Nc extends G0 {
  constructor(e, t, r, i, s) {
    super(e, [], r, i), this.mark = t, this.spec = s;
  }
  static create(e, t, r, i) {
    let s = i.nodeViews[t.type.name], o = s && s(t, i, r);
    return (!o || !o.dom) && (o = Bc.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new Nc(e, t, o.dom, o.contentDOM || o.dom, o);
  }
  parseRule() {
    return this.dirty & so || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != so && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != Ji) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = Ji;
    }
  }
  slice(e, t, r) {
    let i = Nc.create(this.parent, this.mark, !0, r), s = this.children, o = this.size;
    t < o && (s = y4(s, t, o, r)), e > 0 && (s = y4(s, 0, e, r));
    for (let a = 0; a < s.length; a++)
      s[a].parent = i;
    return i.children = s, i;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Ya extends G0 {
  constructor(e, t, r, i, s, o, a, l, c) {
    super(e, [], s, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, s, o) {
    let a = s.nodeViews[t.type.name], l, c = a && a(t, s, () => {
      if (!l)
        return o;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, i), u = c && c.dom, h = c && c.contentDOM;
    if (t.isText) {
      if (!u)
        u = document.createTextNode(t.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: h } = Bc.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs));
    !h && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = gE(u, r, t), c ? l = new vG(e, t, r, i, u, h || null, f, c, s, o + 1) : t.isText ? new Y1(e, t, r, i, u, f, s) : new Ya(e, t, r, i, u, h || null, f, s, o + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => pe.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == Ji && e.eq(this.node) && jg(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, s = e.composing ? this.localCompositionInfo(e, t) : null, o = s && s.pos > -1 ? s : null, a = s && s.pos < 0, l = new kG(this, o && o.node, e);
    CG(this.node, this.innerDeco, (c, u, h) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !h && l.syncToMarks(u == this.node.childCount ? wt.none : this.node.child(u).marks, r, e), l.placeWidget(c, e, i);
    }, (c, u, h, f) => {
      l.syncToMarks(c.marks, r, e);
      let m;
      l.findNodeMatch(c, u, h, f) || a && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (m = l.findIndexWithChild(s.node)) > -1 && l.updateNodeAt(c, u, h, m, e) || l.updateNextNode(c, u, h, e, f, i) || l.addNode(c, u, h, e, i), i += c.nodeSize;
    }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Gl) && (o && this.protectLocalComposition(e, o), pE(this.contentDOM, this.children, e), mh && MG(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof Ye) || r < t || i > t + this.node.content.size)
      return null;
    let s = e.input.compositionNode;
    if (!s || !this.dom.contains(s.parentNode))
      return null;
    if (this.node.inlineContent) {
      let o = s.nodeValue, a = TG(this.node.content, o, r - t, i - t);
      return a < 0 ? null : { node: s, pos: a, text: o };
    } else
      return { node: s, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let s = t;
    for (; s.parentNode != this.contentDOM; s = s.parentNode) {
      for (; s.previousSibling; )
        s.parentNode.removeChild(s.previousSibling);
      for (; s.nextSibling; )
        s.parentNode.removeChild(s.nextSibling);
      s.pmViewDesc && (s.pmViewDesc = void 0);
    }
    let o = new bG(this, s, t, i);
    e.input.compositionNodes.push(o), this.children = y4(this.children, r, r + i.length, e, o);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == so || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = Ji;
  }
  updateOuterDeco(e) {
    if (jg(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = mE(this.dom, this.nodeDOM, g4(this.outerDeco, this.node, t), g4(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function Yx(n, e, t, r, i) {
  gE(r, e, n);
  let s = new Ya(void 0, n, e, t, r, r, r, i, 0);
  return s.contentDOM && s.updateChildren(i, 0), s;
}
class Y1 extends Ya {
  constructor(e, t, r, i, s, o, a) {
    super(e, t, r, i, s, null, o, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == so || this.dirty != Ji && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != Ji || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = Ji, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), s = document.createTextNode(i.text);
    return new Y1(this.parent, i, this.outerDeco, this.innerDeco, s, s, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = so);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class dE extends G0 {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Ji && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class vG extends Ya {
  constructor(e, t, r, i, s, o, a, l, c, u) {
    super(e, t, r, i, s, o, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == so)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let s = this.spec.update(e, t, r);
      return s && this.updateInner(e, t, r, i), s;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r.root) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function pE(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let s = 0; s < e.length; s++) {
    let o = e[s], a = o.dom;
    if (a.parentNode == n) {
      for (; a != r; )
        r = Xx(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(a, r);
    if (o instanceof Nc) {
      let l = r ? r.previousSibling : n.lastChild;
      pE(o.contentDOM, o.children, t), r = l ? l.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = Xx(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const ud = function(n) {
  n && (this.nodeName = n);
};
ud.prototype = /* @__PURE__ */ Object.create(null);
const Jl = [new ud()];
function g4(n, e, t) {
  if (n.length == 0)
    return Jl;
  let r = t ? Jl[0] : new ud(), i = [r];
  for (let s = 0; s < n.length; s++) {
    let o = n[s].type.attrs;
    if (o) {
      o.nodeName && i.push(r = new ud(o.nodeName));
      for (let a in o) {
        let l = o[a];
        l != null && (t && i.length == 1 && i.push(r = new ud(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return i;
}
function mE(n, e, t, r) {
  if (t == Jl && r == Jl)
    return e;
  let i = e;
  for (let s = 0; s < r.length; s++) {
    let o = r[s], a = t[s];
    if (s) {
      let l;
      a && a.nodeName == o.nodeName && i != n && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(i), a = Jl[0]), i = l;
    }
    wG(i, a || Jl[0], o);
  }
  return i;
}
function wG(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let s = 0; s < r.length; s++)
      i.indexOf(r[s]) == -1 && n.classList.remove(r[s]);
    for (let s = 0; s < i.length; s++)
      r.indexOf(i[s]) == -1 && n.classList.add(i[s]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function gE(n, e, t) {
  return mE(n, n, Jl, g4(e, t, n.nodeType != 1));
}
function jg(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function Xx(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class kG {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = xG(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, s = this.stack.length >> 1, o = Math.min(s, e.length);
    for (; i < o && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = Ji, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let a = -1;
      for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) {
        let c = this.top.children[l];
        if (c.matchesMark(e[s]) && !this.isLocked(c.dom)) {
          a = l;
          break;
        }
      }
      if (a > -1)
        a > this.index && (this.changed = !0, this.destroyBetween(this.index, a)), this.top = this.top.children[this.index];
      else {
        let l = Nc.create(this.top, e[s], t, r);
        this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let s = -1, o;
    if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r))
      s = this.top.children.indexOf(o, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) {
          s = a;
          break;
        }
      }
    return s < 0 ? !1 : (this.destroyBetween(this.index, s), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, s) {
    let o = this.top.children[i];
    return o.dirty == so && o.dom == o.contentDOM && (o.dirty = Gl), o.update(e, t, r, s) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, s, o) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof Ya) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != s)
          return !1;
        let u = l.dom, h, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != so && jg(t, l.outerDeco));
        if (!f && l.update(e, t, r, i))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (h = this.recreateWrapper(l, e, t, r, i, o)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = h, h.contentDOM && (h.dirty = Gl, h.updateChildren(i, o + 1), h.dirty = Ji), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, s, o) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !jg(r, e.outerDeco) || !i.eq(e.innerDeco))
      return null;
    let a = Ya.create(this.top, t, r, i, s, o);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, s) {
    let o = Ya.create(this.top, e, t, r, i, s);
    o.contentDOM && o.updateChildren(i, s + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let s = new fE(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, s), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Nc; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof Y1) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Rr || vr) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new dE(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function xG(n, e) {
  let t = e, r = t.children.length, i = n.childCount, s = /* @__PURE__ */ new Map(), o = [];
  e: for (; i > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let c = t.children[r - 1];
        if (c instanceof Nc)
          t = c, r = c.children.length;
        else {
          a = c, r--;
          break;
        }
      } else {
        if (t == e)
          break e;
        r = t.parent.children.indexOf(t), t = t.parent;
      }
    let l = a.node;
    if (l) {
      if (l != n.child(i - 1))
        break;
      --i, s.set(a, i), o.push(a);
    }
  }
  return { index: i, matched: s, matches: o.reverse() };
}
function SG(n, e) {
  return n.type.side - e.type.side;
}
function CG(n, e, t, r) {
  let i = e.locals(n), s = 0;
  if (i.length == 0) {
    for (let c = 0; c < n.childCount; c++) {
      let u = n.child(c);
      r(u, i, e.forChild(s, u), c), s += u.nodeSize;
    }
    return;
  }
  let o = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, h;
    for (; o < i.length && i[o].to == s; ) {
      let k = i[o++];
      k.widget && (u ? (h || (h = [u])).push(k) : u = k);
    }
    if (u)
      if (h) {
        h.sort(SG);
        for (let k = 0; k < h.length; k++)
          t(h[k], c, !!l);
      } else
        t(u, c, !!l);
    let f, m;
    if (l)
      m = -1, f = l, l = null;
    else if (c < n.childCount)
      m = c, f = n.child(c++);
    else
      break;
    for (let k = 0; k < a.length; k++)
      a[k].to <= s && a.splice(k--, 1);
    for (; o < i.length && i[o].from <= s && i[o].to > s; )
      a.push(i[o++]);
    let y = s + f.nodeSize;
    if (f.isText) {
      let k = y;
      o < i.length && i[o].from < k && (k = i[o].from);
      for (let x = 0; x < a.length; x++)
        a[x].to < k && (k = a[x].to);
      k < y && (l = f.cut(k - s), f = f.cut(0, k - s), y = k, m = -1);
    } else
      for (; o < i.length && i[o].to < y; )
        o++;
    let b = f.isInline && !f.isLeaf ? a.filter((k) => !k.inline) : a.slice();
    r(f, b, e.forChild(s, f), m), s = y;
  }
}
function MG(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function TG(n, e, t, r) {
  for (let i = 0, s = 0; i < n.childCount && s <= r; ) {
    let o = n.child(i++), a = s;
    if (s += o.nodeSize, !o.isText)
      continue;
    let l = o.text;
    for (; i < n.childCount; ) {
      let c = n.child(i++);
      if (s += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (s >= t) {
      if (s >= r && l.slice(r - e.length - a, r - a) == e)
        return r - e.length;
      let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= t)
        return a + c;
      if (t == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function y4(n, e, t, r, i) {
  let s = [];
  for (let o = 0, a = 0; o < n.length; o++) {
    let l = n[o], c = a, u = a += l.size;
    c >= t || u <= e ? s.push(l) : (c < e && s.push(l.slice(0, e - c, r)), i && (s.push(i), i = void 0), u > t && s.push(l.slice(t - c, l.size, r)));
  }
  return s;
}
function c5(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), s = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (o < 0)
    return null;
  let a = r.resolve(o), l, c;
  if (J1(t)) {
    for (l = o; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && Qe.isSelectable(h) && i.parent && !(h.isInline && ZK(t.focusNode, t.focusOffset, i.dom))) {
      let f = i.posBefore;
      c = new Qe(o == f ? a : r.resolve(f));
    }
  } else {
    if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) {
      let h = o, f = o;
      for (let m = 0; m < t.rangeCount; m++) {
        let y = t.getRangeAt(m);
        h = Math.min(h, n.docView.posFromDOM(y.startContainer, y.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(y.endContainer, y.endOffset, -1));
      }
      if (h < 0)
        return null;
      [l, o] = f == n.state.selection.anchor ? [f, h] : [h, f], a = r.resolve(o);
    } else
      l = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = r.resolve(l);
  if (!c) {
    let h = e == "pointer" || n.state.selection.head < a.pos && !s ? 1 : -1;
    c = u5(n, u, a, h);
  }
  return c;
}
function yE(n) {
  return n.editable ? n.hasFocus() : vE(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function ea(n, e = !1) {
  let t = n.state.selection;
  if (bE(n, t), !!yE(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && vr) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && Dc(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      EG(n);
    else {
      let { anchor: r, head: i } = t, s, o;
      Zx && !(t instanceof Ye) && (t.$from.parent.inlineContent || (s = Qx(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = Qx(n, t.to))), n.docView.setSelection(r, i, n, e), Zx && (s && e8(s), o && e8(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && AG(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const Zx = Rr || vr && sE < 63;
function Qx(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, s = r ? t.childNodes[r - 1] : null;
  if (Rr && i && i.contentEditable == "false")
    return jb(i);
  if ((!i || i.contentEditable == "false") && (!s || s.contentEditable == "false")) {
    if (i)
      return jb(i);
    if (s)
      return jb(s);
  }
}
function jb(n) {
  return n.contentEditable = "true", Rr && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function e8(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function AG(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!yE(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function EG(n) {
  let e = n.domSelection();
  if (!e)
    return;
  let t = n.cursorWrapper.dom, r = t.nodeName == "IMG";
  r ? e.collapse(t.parentNode, ur(t) + 1) : e.collapse(t, 0), !r && !n.state.selection.visible && ri && Ja <= 11 && (t.disabled = !0, t.disabled = !1);
}
function bE(n, e) {
  if (e instanceof Qe) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (t8(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    t8(n);
}
function t8(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function u5(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Ye.between(e, t, r);
}
function n8(n) {
  return n.editable && !n.hasFocus() ? !1 : vE(n);
}
function vE(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function LG(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return Dc(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function b4(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), s = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return s && ht.findFrom(s, e);
}
function Ia(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function r8(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ye)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!s || s.isText || !s.isLeaf)
        return !1;
      let o = n.state.doc.resolve(i.pos + s.nodeSize * (e < 0 ? -1 : 1));
      return Ia(n, new Ye(r.$anchor, o));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = b4(n.state, e);
        return i && i instanceof Qe ? Ia(n, i) : !1;
      } else if (!(Hi && t.indexOf("m") > -1)) {
        let i = r.$head, s = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o;
        if (!s || s.isText)
          return !1;
        let a = e < 0 ? i.pos - s.nodeSize : i.pos;
        return s.isAtom || (o = n.docView.descAt(a)) && !o.contentDOM ? Qe.isSelectable(s) ? Ia(n, new Qe(e < 0 ? n.state.doc.resolve(i.pos - s.nodeSize) : i)) : K0 ? Ia(n, new Ye(n.state.doc.resolve(e < 0 ? a : a + s.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof Qe && r.node.isInline)
      return Ia(n, new Ye(e > 0 ? r.$to : r.$from));
    {
      let i = b4(n.state, e);
      return i ? Ia(n, i) : !1;
    }
  }
}
function Wg(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function hd(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function Qc(n, e) {
  return e < 0 ? OG(n) : DG(n);
}
function OG(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, s, o = !1;
  for (Gi && t.nodeType == 1 && r < Wg(t) && hd(t.childNodes[r], -1) && (o = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let a = t.childNodes[r - 1];
        if (hd(a, -1))
          i = t, s = --r;
        else if (a.nodeType == 3)
          t = a, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (wE(t))
        break;
      {
        let a = t.previousSibling;
        for (; a && hd(a, -1); )
          i = t.parentNode, s = ur(a), a = a.previousSibling;
        if (a)
          t = a, r = Wg(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  o ? v4(n, t, r) : i && v4(n, i, s);
}
function DG(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = Wg(t), s, o;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let a = t.childNodes[r];
      if (hd(a, 1))
        s = t, o = ++r;
      else
        break;
    } else {
      if (wE(t))
        break;
      {
        let a = t.nextSibling;
        for (; a && hd(a, 1); )
          s = a.parentNode, o = ur(a) + 1, a = a.nextSibling;
        if (a)
          t = a, r = 0, i = Wg(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  s && v4(n, s, o);
}
function wE(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function NG(n, e) {
  for (; n && e == n.childNodes.length && !U0(n); )
    e = ur(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function IG(n, e) {
  for (; n && !e && !U0(n); )
    e = ur(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function v4(n, e, t) {
  if (e.nodeType != 3) {
    let s, o;
    (o = NG(e, t)) ? (e = o, t = 0) : (s = IG(e, t)) && (e = s, t = s.nodeValue.length);
  }
  let r = n.domSelection();
  if (!r)
    return;
  if (J1(r)) {
    let s = document.createRange();
    s.setEnd(e, t), s.setStart(e, t), r.removeAllRanges(), r.addRange(s);
  } else r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && ea(n);
  }, 50);
}
function i8(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(vr || tG) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let s = n.coordsAtPos(e - 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let s = n.coordsAtPos(e + 1), o = (s.top + s.bottom) / 2;
      if (o > i.top && o < i.bottom && Math.abs(s.left - i.left) > 1)
        return s.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function s8(n, e, t) {
  let r = n.state.selection;
  if (r instanceof Ye && !r.empty || t.indexOf("s") > -1 || Hi && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: s } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let o = b4(n.state, e);
    if (o && o instanceof Qe)
      return Ia(n, o);
  }
  if (!i.parent.inlineContent) {
    let o = e < 0 ? i : s, a = r instanceof ni ? ht.near(o, e) : ht.findFrom(o, e);
    return a ? Ia(n, a) : !1;
  }
  return !1;
}
function o8(n, e) {
  if (!(n.state.selection instanceof Ye))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let s = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (s && !s.isText) {
    let o = n.state.tr;
    return e < 0 ? o.delete(t.pos - s.nodeSize, t.pos) : o.delete(t.pos, t.pos + s.nodeSize), n.dispatch(o), !0;
  }
  return !1;
}
function a8(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function _G(n) {
  if (!Rr || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    a8(n, r, "true"), setTimeout(() => a8(n, r, "false"), 20);
  }
  return !1;
}
function RG(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function PG(n, e) {
  let t = e.keyCode, r = RG(e);
  if (t == 8 || Hi && t == 72 && r == "c")
    return o8(n, -1) || Qc(n, -1);
  if (t == 46 && !e.shiftKey || Hi && t == 68 && r == "c")
    return o8(n, 1) || Qc(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || Hi && t == 66 && r == "c") {
    let i = t == 37 ? i8(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return r8(n, i, r) || Qc(n, i);
  } else if (t == 39 || Hi && t == 70 && r == "c") {
    let i = t == 39 ? i8(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return r8(n, i, r) || Qc(n, i);
  } else {
    if (t == 38 || Hi && t == 80 && r == "c")
      return s8(n, -1, r) || Qc(n, -1);
    if (t == 40 || Hi && t == 78 && r == "c")
      return _G(n) || s8(n, 1, r) || Qc(n, 1);
    if (r == (Hi ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function h5(n, e) {
  n.someProp("transformCopied", (m) => {
    e = m(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: s } = e;
  for (; i > 1 && s > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, s--;
    let m = r.firstChild;
    t.push(m.type.name, m.attrs != m.type.defaultAttrs ? m.attrs : null), r = m.content;
  }
  let o = n.someProp("clipboardSerializer") || Bc.fromSchema(n.state.schema), a = TE(), l = a.createElement("div");
  l.appendChild(o.serializeFragment(r, { document: a }));
  let c = l.firstChild, u, h = 0;
  for (; c && c.nodeType == 1 && (u = ME[c.nodeName.toLowerCase()]); ) {
    for (let m = u.length - 1; m >= 0; m--) {
      let y = a.createElement(u[m]);
      for (; l.firstChild; )
        y.appendChild(l.firstChild);
      l.appendChild(y), h++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${s}${h ? ` -${h}` : ""} ${JSON.stringify(t)}`);
  let f = n.someProp("clipboardTextSerializer", (m) => m(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function kE(n, e, t, r, i) {
  let s = i.parent.type.spec.code, o, a;
  if (!t && !e)
    return null;
  let l = !!e && (r || s || !t);
  if (l) {
    if (n.someProp("transformPastedText", (f) => {
      e = f(e, s || r, n);
    }), s)
      return a = new He(pe.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), n.someProp("transformPasted", (f) => {
        a = f(a, n, !0);
      }), a;
    let h = n.someProp("clipboardTextParser", (f) => f(e, i, r, n));
    if (h)
      a = h;
    else {
      let f = i.marks(), { schema: m } = n.state, y = Bc.fromSchema(m);
      o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((b) => {
        let k = o.appendChild(document.createElement("p"));
        b && k.appendChild(y.serializeNode(m.text(b, f)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (h) => {
      t = h(t, n);
    }), o = FG(t), K0 && VG(o);
  let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let h = +u[3]; h > 0; h--) {
      let f = o.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      o = f;
    }
  if (a || (a = (n.someProp("clipboardParser") || n.someProp("domParser") || R1.fromSchema(n.state.schema)).parseSlice(o, {
    preserveWhitespace: !!(l || u),
    context: i,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !BG.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = qG(l8(a, +u[1], +u[2]), u[4]);
  else if (a = He.maxOpen(HG(a.content, i), !0), a.openStart || a.openEnd) {
    let h = 0, f = 0;
    for (let m = a.content.firstChild; h < a.openStart && !m.type.spec.isolating; h++, m = m.firstChild)
      ;
    for (let m = a.content.lastChild; f < a.openEnd && !m.type.spec.isolating; f++, m = m.lastChild)
      ;
    a = l8(a, h, f);
  }
  return n.someProp("transformPasted", (h) => {
    a = h(a, n, l);
  }), a;
}
const BG = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function HG(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), s, o = [];
    if (n.forEach((a) => {
      if (!o)
        return;
      let l = i.findWrapping(a.type), c;
      if (!l)
        return o = null;
      if (c = o.length && s.length && SE(l, s, a, o[o.length - 1], 0))
        o[o.length - 1] = c;
      else {
        o.length && (o[o.length - 1] = CE(o[o.length - 1], s.length));
        let u = xE(a, l);
        o.push(u), i = i.matchType(u.type), s = l;
      }
    }), o)
      return pe.from(o);
  }
  return n;
}
function xE(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, pe.from(n));
  return n;
}
function SE(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let s = SE(n, e, t, r.lastChild, i + 1);
    if (s)
      return r.copy(r.content.replaceChild(r.childCount - 1, s));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(pe.from(xE(t, n, i + 1))));
  }
}
function CE(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, CE(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(pe.empty, !0);
  return n.copy(t.append(r));
}
function w4(n, e, t, r, i, s) {
  let o = e < 0 ? n.firstChild : n.lastChild, a = o.content;
  return n.childCount > 1 && (s = 0), i < r - 1 && (a = w4(a, e, t, r, i + 1, s)), i >= t && (a = e < 0 ? o.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(o.contentMatchAt(o.childCount).fillBefore(pe.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(a));
}
function l8(n, e, t) {
  return e < n.openStart && (n = new He(w4(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new He(w4(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const ME = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let c8 = null;
function TE() {
  return c8 || (c8 = document.implementation.createHTMLDocument("title"));
}
let Wb = null;
function zG(n) {
  let e = window.trustedTypes;
  return e ? (Wb || (Wb = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (t) => t })), Wb.createHTML(n)) : n;
}
function FG(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = TE().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && ME[r[1].toLowerCase()]) && (n = i.map((s) => "<" + s + ">").join("") + n + i.map((s) => "</" + s + ">").reverse().join("")), t.innerHTML = zG(n), i)
    for (let s = 0; s < i.length; s++)
      t = t.querySelector(i[s]) || t;
  return t;
}
function VG(n) {
  let e = n.querySelectorAll(vr ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function qG(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: s, openEnd: o } = n;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = t.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    i = pe.from(l.create(r[a + 1], i)), s++, o++;
  }
  return new He(i, s, o);
}
const Pr = {}, Br = {}, $G = { touchstart: !0, touchmove: !0 };
class jG {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function WG(n) {
  for (let e in Pr) {
    let t = Pr[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      KG(n, r) && !f5(n, r) && (n.editable || !(r.type in Br)) && t(n, r);
    }, $G[e] ? { passive: !0 } : void 0);
  }
  Rr && n.dom.addEventListener("input", () => null), k4(n);
}
function Ua(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function UG(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function k4(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => f5(n, r));
  });
}
function f5(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function KG(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function GG(n, e) {
  !f5(n, e) && Pr[e.type] && (n.editable || !(e.type in Br)) && Pr[e.type](n, e);
}
Br.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !EE(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(Go && vr && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), mh && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, jl(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else n.someProp("handleKeyDown", (r) => r(n, t)) || PG(n, t) ? t.preventDefault() : Ua(n, "key");
};
Br.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
Br.keypress = (n, e) => {
  let t = e;
  if (EE(n, t) || !t.charCode || t.ctrlKey && !t.altKey || Hi && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof Ye) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode), s = () => n.state.tr.insertText(i).scrollIntoView();
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i, s)) && n.dispatch(s()), t.preventDefault();
  }
};
function X1(n) {
  return { left: n.clientX, top: n.clientY };
}
function JG(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function d5(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let s = n.state.doc.resolve(r);
  for (let o = s.depth + 1; o > 0; o--)
    if (n.someProp(e, (a) => o > s.depth ? a(n, t, s.nodeAfter, s.before(o), i, !0) : a(n, t, s.node(o), s.before(o), i, !1)))
      return !0;
  return !1;
}
function Su(n, e, t) {
  if (n.focused || n.focus(), n.state.selection.eq(e))
    return;
  let r = n.state.tr.setSelection(e);
  r.setMeta("pointer", !0), n.dispatch(r);
}
function YG(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && Qe.isSelectable(r) ? (Su(n, new Qe(t)), !0) : !1;
}
function XG(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof Qe && (r = t.node);
  let s = n.state.doc.resolve(e);
  for (let o = s.depth + 1; o > 0; o--) {
    let a = o > s.depth ? s.nodeAfter : s.node(o);
    if (Qe.isSelectable(a)) {
      r && t.$from.depth > 0 && o >= t.$from.depth && s.before(t.$from.depth + 1) == t.$from.pos ? i = s.before(t.$from.depth) : i = s.before(o);
      break;
    }
  }
  return i != null ? (Su(n, Qe.create(n.state.doc, i)), !0) : !1;
}
function ZG(n, e, t, r, i) {
  return d5(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (s) => s(n, e, r)) || (i ? XG(n, t) : YG(n, t));
}
function QG(n, e, t, r) {
  return d5(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function eJ(n, e, t, r) {
  return d5(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || tJ(n, t, r);
}
function tJ(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (Su(n, Ye.create(r, 0, r.content.size)), !0) : !1;
  let i = r.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let o = s > i.depth ? i.nodeAfter : i.node(s), a = i.before(s);
    if (o.inlineContent)
      Su(n, Ye.create(r, a + 1, a + 1 + o.content.size));
    else if (Qe.isSelectable(o))
      Su(n, Qe.create(r, a));
    else
      continue;
    return !0;
  }
}
function p5(n) {
  return Ug(n);
}
const AE = Hi ? "metaKey" : "ctrlKey";
Pr.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = p5(n), i = Date.now(), s = "singleClick";
  i - n.input.lastClick.time < 500 && JG(t, n.input.lastClick) && !t[AE] && n.input.lastClick.button == t.button && (n.input.lastClick.type == "singleClick" ? s = "doubleClick" : n.input.lastClick.type == "doubleClick" && (s = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: s, button: t.button };
  let o = n.posAtCoords(X1(t));
  o && (s == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new nJ(n, o, t, !!r)) : (s == "doubleClick" ? QG : eJ)(n, o.pos, o.inside, t) ? t.preventDefault() : Ua(n, "pointer"));
};
class nJ {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[AE], this.allowDefault = r.shiftKey;
    let s, o;
    if (t.inside > -1)
      s = e.state.doc.nodeAt(t.inside), o = t.inside;
    else {
      let u = e.state.doc.resolve(t.pos);
      s = u.parent, o = u.depth ? u.before() : 0;
    }
    const a = i ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.nodeDOM.nodeType == 1 ? l.nodeDOM : null;
    let { selection: c } = e.state;
    (r.button == 0 && s.type.spec.draggable && s.type.spec.selectable !== !1 || c instanceof Qe && c.from <= o && c.to > o) && (this.mightDrag = {
      node: s,
      pos: o,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Gi && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Ua(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => ea(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(X1(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Ua(this.view, "pointer") : ZG(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    Rr && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    vr && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Su(this.view, ht.near(this.view.state.doc.resolve(t.pos))), e.preventDefault()) : Ua(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Ua(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Pr.touchstart = (n) => {
  n.input.lastTouch = Date.now(), p5(n), Ua(n, "pointer");
};
Pr.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Ua(n, "pointer");
};
Pr.contextmenu = (n) => p5(n);
function EE(n, e) {
  return n.composing ? !0 : Rr && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const rJ = Go ? 5e3 : -1;
Br.compositionstart = Br.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$to;
    if (e.selection instanceof Ye && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), Ug(n, !0), n.markCursor = null;
    else if (Ug(n, !e.selection.empty), Gi && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, s = r.focusOffset; i && i.nodeType == 1 && s != 0; ) {
        let o = s < 0 ? i.lastChild : i.childNodes[s - 1];
        if (!o)
          break;
        if (o.nodeType == 3) {
          let a = n.domSelection();
          a && a.collapse(o, o.nodeValue.length);
          break;
        } else
          i = o, s = -1;
      }
    }
    n.input.composing = !0;
  }
  LE(n, rJ);
};
Br.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, LE(n, 20));
};
function LE(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => Ug(n), e));
}
function OE(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = sJ()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function iJ(n) {
  let e = n.domSelectionRange();
  if (!e.focusNode)
    return null;
  let t = YK(e.focusNode, e.focusOffset), r = XK(e.focusNode, e.focusOffset);
  if (t && r && t != r) {
    let i = r.pmViewDesc, s = n.domObserver.lastChangedTextNode;
    if (t == s || r == s)
      return s;
    if (!i || !i.isText(r.nodeValue))
      return r;
    if (n.input.compositionNode == r) {
      let o = t.pmViewDesc;
      if (!(!o || !o.isText(t.nodeValue)))
        return r;
    }
  }
  return t || r;
}
function sJ() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function Ug(n, e = !1) {
  if (!(Go && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), OE(n), e || n.docView && n.docView.dirty) {
      let t = c5(n), r = n.state.selection;
      return t && !t.eq(r) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function oJ(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const Wd = ri && Ja < 15 || mh && nG < 604;
Pr.copy = Br.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let s = Wd ? null : t.clipboardData, o = r.content(), { dom: a, text: l } = h5(n, o);
  s ? (t.preventDefault(), s.clearData(), s.setData("text/html", a.innerHTML), s.setData("text/plain", l)) : oJ(n, a), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function aJ(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function lJ(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? Ud(n, r.value, null, i, e) : Ud(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function Ud(n, e, t, r, i) {
  let s = kE(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (l) => l(n, i, s || He.empty)))
    return !0;
  if (!s)
    return !1;
  let o = aJ(s), a = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(s);
  return n.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function DE(n) {
  let e = n.getData("text/plain") || n.getData("Text");
  if (e)
    return e;
  let t = n.getData("text/uri-list");
  return t ? t.replace(/\r?\n/g, " ") : "";
}
Br.paste = (n, e) => {
  let t = e;
  if (n.composing && !Go)
    return;
  let r = Wd ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && Ud(n, DE(r), r.getData("text/html"), i, t) ? t.preventDefault() : lJ(n, t);
};
class NE {
  constructor(e, t, r) {
    this.slice = e, this.move = t, this.node = r;
  }
}
const cJ = Hi ? "altKey" : "ctrlKey";
function IE(n, e) {
  let t = n.someProp("dragCopies", (r) => !r(e));
  return t ?? !e[cJ];
}
Pr.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, s = i.empty ? null : n.posAtCoords(X1(t)), o;
  if (!(s && s.pos >= i.from && s.pos <= (i instanceof Qe ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      o = Qe.create(n.state.doc, r.mightDrag.pos);
    else if (t.target && t.target.nodeType == 1) {
      let h = n.docView.nearestDesc(t.target, !0);
      h && h.node.type.spec.draggable && h != n.docView && (o = Qe.create(n.state.doc, h.posBefore));
    }
  }
  let a = (o || n.state.selection).content(), { dom: l, text: c, slice: u } = h5(n, a);
  (!t.dataTransfer.files.length || !vr || sE > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Wd ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Wd || t.dataTransfer.setData("text/plain", c), n.dragging = new NE(u, IE(n, t), o);
};
Pr.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
Br.dragover = Br.dragenter = (n, e) => e.preventDefault();
Br.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(X1(t));
  if (!i)
    return;
  let s = n.state.doc.resolve(i.pos), o = r && r.slice;
  o ? n.someProp("transformPasted", (y) => {
    o = y(o, n, !1);
  }) : o = kE(n, DE(t.dataTransfer), Wd ? null : t.dataTransfer.getData("text/html"), !1, s);
  let a = !!(r && IE(n, t));
  if (n.someProp("handleDrop", (y) => y(n, t, o || He.empty, a))) {
    t.preventDefault();
    return;
  }
  if (!o)
    return;
  t.preventDefault();
  let l = o ? n$(n.state.doc, s.pos, o) : s.pos;
  l == null && (l = s.pos);
  let c = n.state.tr;
  if (a) {
    let { node: y } = r;
    y ? y.replace(c) : c.deleteSelection();
  }
  let u = c.mapping.map(l), h = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc;
  if (h ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f))
    return;
  let m = c.doc.resolve(u);
  if (h && Qe.isSelectable(o.content.firstChild) && m.nodeAfter && m.nodeAfter.sameMarkup(o.content.firstChild))
    c.setSelection(new Qe(m));
  else {
    let y = c.mapping.map(l);
    c.mapping.maps[c.mapping.maps.length - 1].forEach((b, k, x, M) => y = M), c.setSelection(u5(n, m, c.doc.resolve(y)));
  }
  n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
};
Pr.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && ea(n);
  }, 20));
};
Pr.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
Pr.beforeinput = (n, e) => {
  if (vr && Go && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (s) => s(n, jl(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in Br)
  Pr[n] = Br[n];
function Kd(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class Kg {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || pc, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: s, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return o ? null : new qn(s - r, s - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof Kg && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Kd(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Xa {
  constructor(e, t) {
    this.attrs = e, this.spec = t || pc;
  }
  map(e, t, r, i) {
    let s = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return s >= o ? null : new qn(s, o, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof Xa && Kd(this.attrs, e.attrs) && Kd(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Xa;
  }
  destroy() {
  }
}
class m5 {
  constructor(e, t) {
    this.attrs = e, this.spec = t || pc;
  }
  map(e, t, r, i) {
    let s = e.mapResult(t.from + i, 1);
    if (s.deleted)
      return null;
    let o = e.mapResult(t.to + i, -1);
    return o.deleted || o.pos <= s.pos ? null : new qn(s.pos - r, o.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), s;
    return i == t.from && !(s = e.child(r)).isText && i + s.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof m5 && Kd(this.attrs, e.attrs) && Kd(this.spec, e.spec);
  }
  destroy() {
  }
}
class qn {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new qn(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new qn(e, e, new Kg(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new qn(e, t, new Xa(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new qn(e, t, new m5(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Xa;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof Kg;
  }
}
const su = [], pc = {};
class Qt {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : su, this.children = t.length ? t : su;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? Gg(t, e, 0, pc) : gr;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, s) {
    for (let o = 0; o < this.local.length; o++) {
      let a = this.local[o];
      a.from <= t && a.to >= e && (!s || s(a.spec)) && r.push(a.copy(a.from + i, a.to + i));
    }
    for (let o = 0; o < this.children.length; o += 3)
      if (this.children[o] < t && this.children[o + 1] > e) {
        let a = this.children[o] + 1;
        this.children[o + 2].findInner(e - a, t - a, r, i + a, s);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == gr || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || pc);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, s) {
    let o;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, i);
      l && l.type.valid(t, l) ? (o || (o = [])).push(l) : s.onRemove && s.onRemove(this.local[a].spec);
    }
    return this.children.length ? uJ(this.children, o || [], e, t, r, i, s) : o ? new Qt(o.sort(mc), su) : gr;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == gr ? Qt.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, s = 0;
    e.forEach((a, l) => {
      let c = l + r, u;
      if (u = RE(t, a, c)) {
        for (i || (i = this.children.slice()); s < i.length && i[s] < l; )
          s += 3;
        i[s] == l ? i[s + 2] = i[s + 2].addInner(a, u, c + 1) : i.splice(s, 0, l, l + a.nodeSize, Gg(u, a, c + 1, pc)), s += 3;
      }
    });
    let o = _E(s ? PE(t) : t, -r);
    for (let a = 0; a < o.length; a++)
      o[a].type.valid(e, o[a]) || o.splice(a--, 1);
    return new Qt(o.length ? this.local.concat(o).sort(mc) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == gr ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let s = 0; s < r.length; s += 3) {
      let o, a = r[s] + t, l = r[s + 1] + t;
      for (let u = 0, h; u < e.length; u++)
        (h = e[u]) && h.from > a && h.to < l && (e[u] = null, (o || (o = [])).push(h));
      if (!o)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[s + 2].removeInner(o, a + 1);
      c != gr ? r[s + 2] = c : (r.splice(s, 3), s -= 3);
    }
    if (i.length) {
      for (let s = 0, o; s < e.length; s++)
        if (o = e[s])
          for (let a = 0; a < i.length; a++)
            i[a].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(a--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Qt(i, r) : gr;
  }
  forChild(e, t) {
    if (this == gr)
      return this;
    if (t.isLeaf)
      return Qt.empty;
    let r, i;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let s = e + 1, o = s + t.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < o && l.to > s && l.type instanceof Xa) {
        let c = Math.max(s, l.from) - s, u = Math.min(o, l.to) - s;
        c < u && (i || (i = [])).push(l.copy(c, u));
      }
    }
    if (i) {
      let a = new Qt(i.sort(mc), su);
      return r ? new Ba([a, r]) : a;
    }
    return r || gr;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Qt) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return g5(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == gr)
      return su;
    if (e.inlineContent || !this.local.some(Xa.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Xa || t.push(this.local[r]);
    return t;
  }
  forEachSet(e) {
    e(this);
  }
}
Qt.empty = new Qt([], []);
Qt.removeOverlap = g5;
const gr = Qt.empty;
class Ba {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, pc));
    return Ba.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Qt.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].forChild(e, t);
      s != gr && (s instanceof Ba ? r = r.concat(s.members) : r.push(s));
    }
    return Ba.from(r);
  }
  eq(e) {
    if (!(e instanceof Ba) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let s = this.members[i].localsInner(e);
      if (s.length)
        if (!t)
          t = s;
        else {
          r && (t = t.slice(), r = !1);
          for (let o = 0; o < s.length; o++)
            t.push(s[o]);
        }
    }
    return t ? g5(r ? t : t.sort(mc)) : su;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return gr;
      case 1:
        return e[0];
      default:
        return new Ba(e.every((t) => t instanceof Qt) ? e : e.reduce((t, r) => t.concat(r instanceof Qt ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let t = 0; t < this.members.length; t++)
      this.members[t].forEachSet(e);
  }
}
function uJ(n, e, t, r, i, s, o) {
  let a = n.slice();
  for (let c = 0, u = s; c < t.maps.length; c++) {
    let h = 0;
    t.maps[c].forEach((f, m, y, b) => {
      let k = b - y - (m - f);
      for (let x = 0; x < a.length; x += 3) {
        let M = a[x + 1];
        if (M < 0 || f > M + u - h)
          continue;
        let T = a[x] + u - h;
        m >= T ? a[x + 1] = f <= T ? -2 : -1 : f >= u && k && (a[x] += k, a[x + 1] += k);
      }
      h += k;
    }), u = t.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = t.map(n[c] + s), h = u - i;
      if (h < 0 || h >= r.content.size) {
        l = !0;
        continue;
      }
      let f = t.map(n[c + 1] + s, -1), m = f - i, { index: y, offset: b } = r.content.findIndex(h), k = r.maybeChild(y);
      if (k && b == h && b + k.nodeSize == m) {
        let x = a[c + 2].mapInner(t, k, u + 1, n[c] + s + 1, o);
        x != gr ? (a[c] = h, a[c + 1] = m, a[c + 2] = x) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = hJ(a, n, e, t, i, s, o), u = Gg(c, r, 0, o);
    e = u.local;
    for (let h = 0; h < a.length; h += 3)
      a[h + 1] < 0 && (a.splice(h, 3), h -= 3);
    for (let h = 0, f = 0; h < u.children.length; h += 3) {
      let m = u.children[h];
      for (; f < a.length && a[f] < m; )
        f += 3;
      a.splice(f, 0, u.children[h], u.children[h + 1], u.children[h + 2]);
    }
  }
  return new Qt(e.sort(mc), a);
}
function _E(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new qn(i.from + e, i.to + e, i.type));
  }
  return t;
}
function hJ(n, e, t, r, i, s, o) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let h = l.local[u].map(r, i, c);
      h ? t.push(h) : o.onRemove && o.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < n.length; l += 3)
    n[l + 1] == -1 && a(n[l + 2], e[l] + s + 1);
  return t;
}
function RE(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let s = 0, o; s < n.length; s++)
    (o = n[s]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[s] = null);
  return i;
}
function PE(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function Gg(n, e, t, r) {
  let i = [], s = !1;
  e.forEach((a, l) => {
    let c = RE(n, a, l + t);
    if (c) {
      s = !0;
      let u = Gg(c, a, t + l + 1, r);
      u != gr && i.push(l, l + a.nodeSize, u);
    }
  });
  let o = _E(s ? PE(n) : n, -t).sort(mc);
  for (let a = 0; a < o.length; a++)
    o[a].type.valid(e, o[a]) || (r.onRemove && r.onRemove(o[a].spec), o.splice(a--, 1));
  return o.length || i.length ? new Qt(o, i) : gr;
}
function mc(n, e) {
  return n.from - e.from || n.to - e.to;
}
function g5(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let s = e[i];
        if (s.from == r.from) {
          s.to != r.to && (e == n && (e = n.slice()), e[i] = s.copy(s.from, r.to), u8(e, i + 1, s.copy(r.to, s.to)));
          continue;
        } else {
          s.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, s.from), u8(e, i, r.copy(s.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function u8(n, e, t) {
  for (; e < n.length && mc(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function Ub(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != gr && e.push(r);
  }), n.cursorWrapper && e.push(Qt.create(n.state.doc, [n.cursorWrapper.deco])), Ba.from(e);
}
const fJ = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, dJ = ri && Ja <= 11;
class pJ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class mJ {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new pJ(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      ri && Ja <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), dJ && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, fJ)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (n8(this.view)) {
      if (this.suppressingSelectionUpdates)
        return ea(this.view);
      if (ri && Ja <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Dc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let s = e.focusNode; s; s = ph(s))
      t.add(s);
    for (let s = e.anchorNode; s; s = ph(s))
      if (t.has(s)) {
        r = s;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && n8(e) && !this.ignoreSelectionChange(r), s = -1, o = -1, a = !1, l = [];
    if (e.editable)
      for (let u = 0; u < t.length; u++) {
        let h = this.registerMutation(t[u], l);
        h && (s = s < 0 ? h.from : Math.min(h.from, s), o = o < 0 ? h.to : Math.max(h.to, o), h.typeOver && (a = !0));
      }
    if (Gi && l.length) {
      let u = l.filter((h) => h.nodeName == "BR");
      if (u.length == 2) {
        let [h, f] = u;
        h.parentNode && h.parentNode.parentNode == f.parentNode ? f.remove() : h.remove();
      } else {
        let { focusNode: h } = this.currentSelection;
        for (let f of u) {
          let m = f.parentNode;
          m && m.nodeName == "LI" && (!h || bJ(e, h) != m) && f.remove();
        }
      }
    }
    let c = null;
    s < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && J1(r) && (c = c5(e)) && c.eq(ht.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, ea(e), this.currentSelection.set(r), e.scrollToSelection()) : (s > -1 || i) && (s > -1 && (e.docView.markDirty(s, o), gJ(e)), this.handleDOMChange(s, o, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || ea(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let h = e.addedNodes[u];
        t.push(h), h.nodeType == 3 && (this.lastChangedTextNode = h);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, s = e.nextSibling;
      if (ri && Ja <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: h, nextSibling: f } = e.addedNodes[u];
          (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) && (i = h), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (s = f);
        }
      let o = i && i.parentNode == e.target ? ur(i) + 1 : 0, a = r.localPosFromDOM(e.target, o, -1), l = s && s.parentNode == e.target ? ur(s) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let h8 = /* @__PURE__ */ new WeakMap(), f8 = !1;
function gJ(n) {
  if (!h8.has(n) && (h8.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = Gi, f8)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), f8 = !0;
  }
}
function d8(n, e) {
  let t = e.startContainer, r = e.startOffset, i = e.endContainer, s = e.endOffset, o = n.domAtPos(n.state.selection.anchor);
  return Dc(o.node, o.offset, i, s) && ([t, r, i, s] = [i, s, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: s };
}
function yJ(n, e) {
  if (e.getComposedRanges) {
    let i = e.getComposedRanges(n.root)[0];
    if (i)
      return d8(n, i);
  }
  let t;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0];
  }
  return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? d8(n, t) : null;
}
function bJ(n, e) {
  for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) {
    let r = n.docView.nearestDesc(t, !0);
    if (r && r.node.isBlock)
      return t;
  }
  return null;
}
function vJ(n, e, t) {
  let { node: r, fromOffset: i, toOffset: s, from: o, to: a } = n.docView.parseRange(e, t), l = n.domSelectionRange(), c, u = l.anchorNode;
  if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], J1(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), vr && n.input.lastKeyCode === 8)
    for (let k = s; k > i; k--) {
      let x = r.childNodes[k - 1], M = x.pmViewDesc;
      if (x.nodeName == "BR" && !M) {
        s = k;
        break;
      }
      if (!M || M.size)
        break;
    }
  let h = n.state.doc, f = n.someProp("domParser") || R1.fromSchema(n.state.schema), m = h.resolve(o), y = null, b = f.parse(r, {
    topNode: m.parent,
    topMatch: m.parent.contentMatchAt(m.index()),
    topOpen: !0,
    from: i,
    to: s,
    preserveWhitespace: m.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: wJ,
    context: m
  });
  if (c && c[0].pos != null) {
    let k = c[0].pos, x = c[1] && c[1].pos;
    x == null && (x = k), y = { anchor: k + o, head: x + o };
  }
  return { doc: b, sel: y, from: o, to: a };
}
function wJ(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (Rr && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || Rr && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const kJ = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function xJ(n, e, t, r, i) {
  let s = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let R = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, F = c5(n, R);
    if (F && !n.state.selection.eq(F)) {
      if (vr && Go && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (z) => z(n, jl(13, "Enter"))))
        return;
      let H = n.state.tr.setSelection(F);
      R == "pointer" ? H.setMeta("pointer", !0) : R == "key" && H.scrollIntoView(), s && H.setMeta("composition", s), n.dispatch(H);
    }
    return;
  }
  let o = n.state.doc.resolve(e), a = o.sharedDepth(t);
  e = o.before(a + 1), t = n.state.doc.resolve(t).after(a + 1);
  let l = n.state.selection, c = vJ(n, e, t), u = n.state.doc, h = u.slice(c.from, c.to), f, m;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, m = "end") : (f = n.state.selection.from, m = "start"), n.input.lastKeyCode = null;
  let y = MJ(h.content, c.doc.content, c.from, f, m);
  if (y && n.input.domChangeCount++, (mh && n.input.lastIOSEnter > Date.now() - 225 || Go) && i.some((R) => R.nodeType == 1 && !kJ.test(R.nodeName)) && (!y || y.endA >= y.endB) && n.someProp("handleKeyDown", (R) => R(n, jl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!y)
    if (r && l instanceof Ye && !l.empty && l.$head.sameParent(l.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head))
      y = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let R = p8(n, n.state.doc, c.sel);
        if (R && !R.eq(n.state.selection)) {
          let F = n.state.tr.setSelection(R);
          s && F.setMeta("composition", s), n.dispatch(F);
        }
      }
      return;
    }
  n.state.selection.from < n.state.selection.to && y.start == y.endB && n.state.selection instanceof Ye && (y.start > n.state.selection.from && y.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? y.start = n.state.selection.from : y.endA < n.state.selection.to && y.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (y.endB += n.state.selection.to - y.endA, y.endA = n.state.selection.to)), ri && Ja <= 11 && y.endB == y.start + 1 && y.endA == y.start && y.start > c.from && c.doc.textBetween(y.start - c.from - 1, y.start - c.from + 1) == "  " && (y.start--, y.endA--, y.endB--);
  let b = c.doc.resolveNoCache(y.start - c.from), k = c.doc.resolveNoCache(y.endB - c.from), x = u.resolve(y.start), M = b.sameParent(k) && b.parent.inlineContent && x.end() >= y.endA;
  if ((mh && n.input.lastIOSEnter > Date.now() - 225 && (!M || i.some((R) => R.nodeName == "DIV" || R.nodeName == "P")) || !M && b.pos < c.doc.content.size && (!b.sameParent(k) || !b.parent.inlineContent) && b.pos < k.pos && !/\S/.test(c.doc.textBetween(b.pos, k.pos, "", ""))) && n.someProp("handleKeyDown", (R) => R(n, jl(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > y.start && CJ(u, y.start, y.endA, b, k) && n.someProp("handleKeyDown", (R) => R(n, jl(8, "Backspace")))) {
    Go && vr && n.domObserver.suppressSelectionUpdates();
    return;
  }
  vr && y.endB == y.start && (n.input.lastChromeDelete = Date.now()), Go && !M && b.start() != k.start() && k.parentOffset == 0 && b.depth == k.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == y.endA && (y.endB -= 2, k = c.doc.resolveNoCache(y.endB - c.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(R) {
      return R(n, jl(13, "Enter"));
    });
  }, 20));
  let T = y.start, E = y.endA, C = (R) => {
    let F = R || n.state.tr.replace(T, E, c.doc.slice(y.start - c.from, y.endB - c.from));
    if (c.sel) {
      let H = p8(n, F.doc, c.sel);
      H && !(vr && n.composing && H.empty && (y.start != y.endB || n.input.lastChromeDelete < Date.now() - 100) && (H.head == T || H.head == F.mapping.map(E) - 1) || ri && H.empty && H.head == T) && F.setSelection(H);
    }
    return s && F.setMeta("composition", s), F.scrollIntoView();
  }, O;
  if (M) {
    if (b.pos == k.pos) {
      ri && Ja <= 11 && b.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => ea(n), 20));
      let R = C(n.state.tr.delete(T, E)), F = u.resolve(y.start).marksAcross(u.resolve(y.endA));
      F && R.ensureMarks(F), n.dispatch(R);
    } else if (
      // Adding or removing a mark
      y.endA == y.endB && (O = SJ(b.parent.content.cut(b.parentOffset, k.parentOffset), x.parent.content.cut(x.parentOffset, y.endA - x.start())))
    ) {
      let R = C(n.state.tr);
      O.type == "add" ? R.addMark(T, E, O.mark) : R.removeMark(T, E, O.mark), n.dispatch(R);
    } else if (b.parent.child(b.index()).isText && b.index() == k.index() - (k.textOffset ? 0 : 1)) {
      let R = b.parent.textBetween(b.parentOffset, k.parentOffset), F = () => C(n.state.tr.insertText(R, T, E));
      n.someProp("handleTextInput", (H) => H(n, T, E, R, F)) || n.dispatch(F());
    }
  } else
    n.dispatch(C());
}
function p8(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : u5(n, e.resolve(t.anchor), e.resolve(t.head));
}
function SJ(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, s = r, o, a, l;
  for (let u = 0; u < r.length; u++)
    i = r[u].removeFromSet(i);
  for (let u = 0; u < t.length; u++)
    s = t[u].removeFromSet(s);
  if (i.length == 1 && s.length == 0)
    a = i[0], o = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (i.length == 0 && s.length == 1)
    a = s[0], o = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (pe.from(c).eq(n))
    return { mark: a, type: o };
}
function CJ(n, e, t, r, i) {
  if (
    // The content must have shrunk
    t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Kb(r, !0, !1) < i.pos
  )
    return !1;
  let s = n.resolve(e);
  if (!r.parent.isTextblock) {
    let a = s.nodeAfter;
    return a != null && t == e + a.nodeSize;
  }
  if (s.parentOffset < s.parent.content.size || !s.parent.isTextblock)
    return !1;
  let o = n.resolve(Kb(s, !0, !0));
  return !o.parent.isTextblock || o.pos > t || Kb(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content);
}
function Kb(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let s = n.node(r).maybeChild(n.indexAfter(r));
    for (; s && !s.isLeaf; )
      s = s.firstChild, i++;
  }
  return i;
}
function MJ(n, e, t, r, i) {
  let s = n.findDiffStart(e, t);
  if (s == null)
    return null;
  let { a: o, b: a } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    r -= o + l - s;
  }
  if (o < s && n.size < e.size) {
    let l = r <= s && r >= o ? s - r : 0;
    s -= l, s && s < e.size && m8(e.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), a = s + (a - o), o = s;
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0;
    s -= l, s && s < n.size && m8(n.textBetween(s - 1, s + 1)) && (s += l ? 1 : -1), o = s + (o - a), a = s;
  }
  return { start: s, endA: o, endB: a };
}
function m8(n) {
  if (n.length != 2)
    return !1;
  let e = n.charCodeAt(0), t = n.charCodeAt(1);
  return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319;
}
class y5 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new jG(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(w8), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = b8(this), y8(this), this.nodeViews = v8(this), this.docView = Yx(this.state.doc, g8(this), Ub(this), this.dom, this), this.domObserver = new mJ(this, (r, i, s, o) => xJ(this, r, i, s, o)), this.domObserver.start(), WG(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && k4(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(w8), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    var r;
    let i = this.state, s = !1, o = !1;
    e.storedMarks && this.composing && (OE(this), o = !0), this.state = e;
    let a = i.plugins != e.plugins || this._props.plugins != t.plugins;
    if (a || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let m = v8(this);
      AJ(m, this.nodeViews) && (this.nodeViews = m, s = !0);
    }
    (a || t.handleDOMEvents != this._props.handleDOMEvents) && k4(this), this.editable = b8(this), y8(this);
    let l = Ub(this), c = g8(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", h = s || !this.docView.matchesNode(e.doc, c, l);
    (h || !e.selection.eq(i.selection)) && (o = !0);
    let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && sG(this);
    if (o) {
      this.domObserver.stop();
      let m = h && (ri || vr) && !this.composing && !i.selection.empty && !e.selection.empty && TJ(i.selection, e.selection);
      if (h) {
        let y = vr ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = iJ(this)), (s || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = Yx(e.doc, c, l, this.dom, this)), y && !this.trackWrites && (m = !0);
      }
      m || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && LG(this)) ? ea(this, m) : (bE(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && oG(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (t) => t(this))) if (this.state.selection instanceof Qe) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && jx(this, t.getBoundingClientRect(), e);
      } else
        jx(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, t) {
    let r = e.node, i = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      i = r.from;
    else {
      let s = r.from + (this.state.doc.content.size - t.doc.content.size);
      (s > 0 && this.state.doc.nodeAt(s)) == r.node && (i = s);
    }
    this.dragging = new NE(e.slice, e.move, i < 0 ? void 0 : Qe.create(this.state.doc, i));
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let o = 0; o < this.directPlugins.length; o++) {
      let a = this.directPlugins[o].props[e];
      if (a != null && (i = t ? t(a) : a))
        return i;
    }
    let s = this.state.plugins;
    if (s)
      for (let o = 0; o < s.length; o++) {
        let a = s[o].props[e];
        if (a != null && (i = t ? t(a) : a))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ri) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && aG(this.dom), ea(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return fG(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return uE(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return yG(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return Ud(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return Ud(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return h5(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (UG(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Ub(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, GK());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return GG(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? Rr && this.root.nodeType === 11 && QK(this.dom.ownerDocument) == this.dom && yJ(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
y5.prototype.dispatch = function(n) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, n) : this.updateState(this.state.apply(n));
};
function g8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [qn.node(0, n.state.doc.content.size, e)];
}
function y8(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: qn.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function b8(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function TJ(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function v8(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function AJ(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function w8(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
function yl(n, e) {
  return n.meta = {
    package: "@milkdown/core",
    group: "System",
    ...e
  }, n;
}
const BE = {
  text: (n, e, t, r) => {
    const i = n.value;
    return /^[^*_\\]*\s+$/.test(i) ? i : t.safe(i, { ...r, encode: [] });
  },
  strong: (n, e, t, r) => {
    const i = n.marker || t.options.strong || "*", s = t.enter("strong"), o = t.createTracker(r);
    let a = o.move(i + i);
    return a += o.move(
      t.containerPhrasing(n, {
        before: a,
        after: i,
        ...o.current()
      })
    ), a += o.move(i + i), s(), a;
  },
  emphasis: (n, e, t, r) => {
    const i = n.marker || t.options.emphasis || "*", s = t.enter("emphasis"), o = t.createTracker(r);
    let a = o.move(i);
    return a += o.move(
      t.containerPhrasing(n, {
        before: a,
        after: i,
        ...o.current()
      })
    ), a += o.move(i), s(), a;
  }
}, on = It({}, "editorView"), Of = It({}, "editorState"), Gb = It([], "initTimer"), x4 = It({}, "editor"), Gd = It([], "inputRules"), ol = It([], "prosePlugins"), Jd = It(
  [],
  "remarkPlugins"
), Yd = It([], "nodeView"), Xd = It([], "markView"), gc = It(
  l4().use(t4).use(s4),
  "remark"
), fd = It(
  {
    handlers: BE,
    encode: []
  },
  "remarkStringifyOptions"
), Um = pa("ConfigReady");
function EJ(n) {
  const e = (t) => (t.record(Um), async () => (await n(t), t.done(Um), () => {
    t.clearTimer(Um);
  }));
  return yl(e, {
    displayName: "Config"
  }), e;
}
const yc = pa("InitReady");
function LJ(n) {
  const e = (t) => (t.inject(x4, n).inject(ol, []).inject(Jd, []).inject(Gd, []).inject(Yd, []).inject(Xd, []).inject(fd, {
    handlers: BE,
    encode: []
  }).inject(gc, l4().use(t4).use(s4)).inject(Gb, [Um]).record(yc), async () => {
    await t.waitTimers(Gb);
    const r = t.get(fd);
    return t.set(
      gc,
      l4().use(t4).use(s4, r)
    ), t.done(yc), () => {
      t.remove(x4).remove(ol).remove(Jd).remove(Gd).remove(Yd).remove(Xd).remove(fd).remove(gc).remove(Gb).clearTimer(yc);
    };
  });
  return yl(e, {
    displayName: "Init"
  }), e;
}
const Yi = pa("SchemaReady"), Jb = It([], "schemaTimer"), to = It({}, "schema"), dd = It([], "nodes"), pd = It([], "marks");
function k8(n) {
  var e;
  return {
    ...n,
    parseDOM: (e = n.parseDOM) == null ? void 0 : e.map((t) => ({ priority: n.priority, ...t }))
  };
}
const HE = (n) => (n.inject(to, {}).inject(dd, []).inject(pd, []).inject(Jb, [yc]).record(Yi), async () => {
  await n.waitTimers(Jb);
  const e = n.get(gc), r = n.get(Jd).reduce(
    (a, l) => a.use(l.plugin, l.options),
    e
  );
  n.set(gc, r);
  const i = Object.fromEntries(
    n.get(dd).map(([a, l]) => [a, k8(l)])
  ), s = Object.fromEntries(
    n.get(pd).map(([a, l]) => [a, k8(l)])
  ), o = new VT({ nodes: i, marks: s });
  return n.set(to, o), n.done(Yi), () => {
    n.remove(to).remove(dd).remove(pd).remove(Jb).clearTimer(Yi);
  };
});
yl(HE, {
  displayName: "Schema"
});
var ec, Bi;
class zE {
  constructor() {
    Se(this, ec);
    Se(this, Bi);
    re(this, ec, new pA()), re(this, Bi, null), this.setCtx = (e) => {
      re(this, Bi, e);
    }, this.chain = () => {
      if (G(this, Bi) == null) throw Lb();
      const e = G(this, Bi), t = [], r = this.get.bind(this), i = {
        run: () => {
          const o = Oh(...t), a = e.get(on);
          return o(a.state, a.dispatch, a);
        },
        inline: (o) => (t.push(o), i),
        pipe: s.bind(this)
      };
      function s(o, a) {
        const l = r(o);
        return t.push(l(a)), i;
      }
      return i;
    };
  }
  get ctx() {
    return G(this, Bi);
  }
  /// Register a command into the manager.
  create(e, t) {
    const r = e.create(G(this, ec).sliceMap);
    return r.set(t), r;
  }
  get(e) {
    return G(this, ec).get(e).get();
  }
  remove(e) {
    return G(this, ec).remove(e);
  }
  call(e, t) {
    if (G(this, Bi) == null) throw Lb();
    const i = this.get(e)(t), s = G(this, Bi).get(on);
    return i(s.state, s.dispatch, s);
  }
  /// Call an inline command.
  inline(e) {
    if (G(this, Bi) == null) throw Lb();
    const t = G(this, Bi).get(on);
    return e(t.state, t.dispatch, t);
  }
}
ec = new WeakMap(), Bi = new WeakMap();
function OJ(n = "cmdKey") {
  return It(() => () => !1, n);
}
const je = It(new zE(), "commands"), Yb = It([Yi], "commandsTimer"), md = pa("CommandsReady"), FE = (n) => {
  const e = new zE();
  return e.setCtx(n), n.inject(je, e).inject(Yb, [Yi]).record(md), async () => (await n.waitTimers(Yb), n.done(md), () => {
    n.remove(je).remove(Yb).clearTimer(md);
  });
};
yl(FE, {
  displayName: "Commands"
});
function DJ(n) {
  const e = Oh(
    d$,
    r5,
    AK,
    XA
  );
  return n.Backspace = e, n;
}
var tc, Wr;
class VE {
  constructor() {
    Se(this, tc);
    Se(this, Wr);
    re(this, tc, null), re(this, Wr, []), this.setCtx = (e) => {
      re(this, tc, e);
    }, this.add = (e) => (G(this, Wr).push(e), () => {
      re(this, Wr, G(this, Wr).filter((t) => t !== e));
    }), this.addObjectKeymap = (e) => {
      const t = [];
      return Object.entries(e).forEach(([r, i]) => {
        if (typeof i == "function") {
          const s = {
            key: r,
            onRun: () => i
          };
          G(this, Wr).push(s), t.push(() => {
            re(this, Wr, G(this, Wr).filter((o) => o !== s));
          });
        } else
          G(this, Wr).push(i), t.push(() => {
            re(this, Wr, G(this, Wr).filter((s) => s !== i));
          });
      }), () => {
        t.forEach((r) => r());
      };
    }, this.addBaseKeymap = () => {
      const e = DJ($K);
      return this.addObjectKeymap(e);
    }, this.build = () => {
      const e = {};
      return G(this, Wr).forEach((r) => {
        e[r.key] = [...e[r.key] || [], r];
      }), Object.fromEntries(
        Object.entries(e).map(([r, i]) => {
          const s = i.sort(
            (a, l) => (l.priority ?? 50) - (a.priority ?? 50)
          );
          return [r, (a, l, c) => {
            const u = G(this, tc);
            if (u == null) throw V1();
            const h = s.map((m) => m.onRun(u));
            return Oh(...h)(a, l, c);
          }];
        })
      );
    };
  }
  get ctx() {
    return G(this, tc);
  }
}
tc = new WeakMap(), Wr = new WeakMap();
const Jg = It(new VE(), "keymap"), Xb = It([Yi], "keymapTimer"), gd = pa("KeymapReady"), NJ = (n) => {
  const e = new VE();
  return e.setCtx(n), n.inject(Jg, e).inject(Xb, [Yi]).record(gd), async () => (await n.waitTimers(Xb), n.done(gd), () => {
    n.remove(Jg).remove(Xb).clearTimer(gd);
  });
}, Km = pa("ParserReady"), qE = () => {
  throw V1();
}, yd = It(qE, "parser"), Zb = It([], "parserTimer"), $E = (n) => (n.inject(yd, qE).inject(Zb, [Yi]).record(Km), async () => {
  await n.waitTimers(Zb);
  const e = n.get(gc), t = n.get(to);
  return n.set(yd, CK.create(t, e)), n.done(Km), () => {
    n.remove(yd).remove(Zb).clearTimer(Km);
  };
});
yl($E, {
  displayName: "Parser"
});
const bd = pa("SerializerReady"), Qb = It(
  [],
  "serializerTimer"
), jE = () => {
  throw V1();
}, Cu = It(
  jE,
  "serializer"
), WE = (n) => (n.inject(Cu, jE).inject(Qb, [Yi]).record(bd), async () => {
  await n.waitTimers(Qb);
  const e = n.get(gc), t = n.get(to);
  return n.set(Cu, TK.create(t, e)), n.done(bd), () => {
    n.remove(Cu).remove(Qb).clearTimer(bd);
  };
});
yl(WE, {
  displayName: "Serializer"
});
const Gm = It("", "defaultValue"), e2 = It(
  (n) => n,
  "stateOptions"
), t2 = It(
  [],
  "editorStateTimer"
), Jm = pa("EditorStateReady");
function IJ(n, e, t) {
  if (typeof n == "string") return e(n);
  if (n.type === "html")
    return R1.fromSchema(t).parse(n.dom);
  if (n.type === "json")
    return Qo.fromJSON(t, n.value);
  throw m$(n);
}
const _J = new gn("MILKDOWN_STATE_TRACKER"), UE = (n) => (n.inject(Gm, "").inject(Of, {}).inject(e2, (e) => e).inject(t2, [
  Km,
  bd,
  md,
  gd
]).record(Jm), async () => {
  await n.waitTimers(t2);
  const e = n.get(to), t = n.get(yd), r = n.get(Gd), i = n.get(e2), s = n.get(ol), o = n.get(Gm), a = IJ(o, t, e), l = n.get(Jg), c = l.addBaseKeymap(), u = [
    ...s,
    new mn({
      key: _J,
      state: {
        init: () => {
        },
        apply: (m, y, b, k) => {
          n.set(Of, k);
        }
      }
    }),
    N$({ rules: r }),
    rE(l.build())
  ];
  n.set(ol, u);
  const h = i({
    schema: e,
    doc: a,
    plugins: u
  }), f = Kl.create(h);
  return n.set(Of, f), n.done(Jm), () => {
    c(), n.remove(Gm).remove(Of).remove(e2).remove(t2).clearTimer(Jm);
  };
});
yl(UE, {
  displayName: "EditorState"
});
const Ym = pa("EditorViewReady"), n2 = It(
  [],
  "editorViewTimer"
), vd = It(
  {},
  "editorViewOptions"
), Xm = It(null, "root"), S4 = It(null, "rootDOM"), C4 = It(
  {},
  "rootAttrs"
);
function RJ(n, e) {
  const t = document.createElement("div");
  t.className = "milkdown", n.appendChild(t), e.set(S4, t);
  const r = e.get(C4);
  return Object.entries(r).forEach(
    ([i, s]) => t.setAttribute(i, s)
  ), t;
}
function PJ(n) {
  n.classList.add("editor"), n.setAttribute("role", "textbox");
}
const BJ = new gn("MILKDOWN_VIEW_CLEAR"), KE = (n) => (n.inject(Xm, document.body).inject(on, {}).inject(vd, {}).inject(S4, null).inject(C4, {}).inject(n2, [Jm]).record(Ym), async () => {
  await n.wait(yc);
  const e = n.get(Xm) || document.body, t = typeof e == "string" ? document.querySelector(e) : e;
  n.update(ol, (l) => [
    new mn({
      key: BJ,
      view: (c) => {
        const u = t ? RJ(t, n) : void 0;
        return (() => {
          if (u && t) {
            const f = c.dom;
            t.replaceChild(u, f), u.appendChild(f);
          }
        })(), {
          destroy: () => {
            u != null && u.parentNode && (u == null || u.parentNode.replaceChild(c.dom, u)), u == null || u.remove();
          }
        };
      }
    }),
    ...l
  ]), await n.waitTimers(n2);
  const r = n.get(Of), i = n.get(vd), s = Object.fromEntries(n.get(Yd)), o = Object.fromEntries(n.get(Xd)), a = new y5(t, {
    state: r,
    nodeViews: s,
    markViews: o,
    ...i
  });
  return PJ(a.dom), n.set(on, a), n.done(Ym), () => {
    a == null || a.destroy(), n.remove(Xm).remove(on).remove(vd).remove(S4).remove(C4).remove(n2).clearTimer(Ym);
  };
});
yl(KE, {
  displayName: "EditorView"
});
var Yg = /* @__PURE__ */ ((n) => (n.Idle = "Idle", n.OnCreate = "OnCreate", n.Created = "Created", n.OnDestroy = "OnDestroy", n.Destroyed = "Destroyed", n))(Yg || {}), nc, bi, qo, zu, p0, m0, Ur, $o, rc, g0, ic, Fu, y0, Va, Vu;
const D6 = class D6 {
  constructor() {
    Se(this, nc);
    Se(this, bi);
    Se(this, qo);
    Se(this, zu);
    Se(this, p0);
    Se(this, m0);
    Se(this, Ur);
    Se(this, $o);
    Se(this, rc);
    Se(this, g0);
    Se(this, ic);
    Se(this, Fu);
    Se(this, y0);
    Se(this, Va);
    Se(this, Vu);
    re(this, nc, !1), re(this, bi, "Idle"), re(this, qo, []), re(this, zu, () => {
    }), re(this, p0, new pA()), re(this, m0, new Y$()), re(this, Ur, /* @__PURE__ */ new Map()), re(this, $o, /* @__PURE__ */ new Map()), re(this, rc, new Xv(G(this, p0), G(this, m0))), re(this, g0, () => {
      const e = EJ(async (r) => {
        await Promise.all(G(this, qo).map((i) => i(r)));
      }), t = [
        HE,
        $E,
        WE,
        FE,
        NJ,
        UE,
        KE,
        LJ(this),
        e
      ];
      G(this, ic).call(this, t, G(this, $o));
    }), re(this, ic, (e, t) => {
      e.forEach((r) => {
        const i = G(this, rc).produce(
          G(this, nc) ? r.meta : void 0
        ), s = r(i);
        t.set(r, { ctx: i, handler: s, cleanup: void 0 });
      });
    }), re(this, Fu, (e, t = !1) => Promise.all(
      [e].flat().map((r) => {
        const i = G(this, Ur).get(r), s = i == null ? void 0 : i.cleanup;
        return t ? G(this, Ur).delete(r) : G(this, Ur).set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        }), typeof s == "function" ? s() : s;
      })
    )), re(this, y0, async () => {
      await Promise.all(
        [...G(this, $o).entries()].map(([e, { cleanup: t }]) => typeof t == "function" ? t() : t)
      ), G(this, $o).clear();
    }), re(this, Va, (e) => {
      re(this, bi, e), G(this, zu).call(this, e);
    }), re(this, Vu, (e) => [...e.entries()].map(async ([t, r]) => {
      const { ctx: i, handler: s } = r;
      if (!s) return;
      const o = await s();
      e.set(t, { ctx: i, handler: s, cleanup: o });
    })), this.enableInspector = (e = !0) => (re(this, nc, e), this), this.onStatusChange = (e) => (re(this, zu, e), this), this.config = (e) => (G(this, qo).push(e), this), this.removeConfig = (e) => (re(this, qo, G(this, qo).filter((t) => t !== e)), this), this.use = (e) => {
      const t = [e].flat();
      return t.flat().forEach((r) => {
        G(this, Ur).set(r, {
          ctx: void 0,
          handler: void 0,
          cleanup: void 0
        });
      }), G(this, bi) === "Created" && G(this, ic).call(this, t, G(this, Ur)), this;
    }, this.remove = async (e) => G(this, bi) === "OnCreate" ? (console.warn(
      "[Milkdown]: You are trying to remove plugins when the editor is creating, this is not recommended, please check your code."
    ), new Promise((t) => {
      setTimeout(() => {
        t(this.remove(e));
      }, 50);
    })) : (await G(this, Fu).call(this, [e].flat(), !0), this), this.create = async () => G(this, bi) === "OnCreate" ? this : (G(this, bi) === "Created" && await this.destroy(), G(this, Va).call(this, "OnCreate"), G(this, g0).call(this), G(this, ic).call(this, [...G(this, Ur).keys()], G(this, Ur)), await Promise.all(
      [
        G(this, Vu).call(this, G(this, $o)),
        G(this, Vu).call(this, G(this, Ur))
      ].flat()
    ), G(this, Va).call(this, "Created"), this), this.destroy = async (e = !1) => G(this, bi) === "Destroyed" || G(this, bi) === "OnDestroy" ? this : G(this, bi) === "OnCreate" ? new Promise((t) => {
      setTimeout(() => {
        t(this.destroy(e));
      }, 50);
    }) : (e && re(this, qo, []), G(this, Va).call(this, "OnDestroy"), await G(this, Fu).call(this, [...G(this, Ur).keys()], e), await G(this, y0).call(this), G(this, Va).call(this, "Destroyed"), this), this.action = (e) => e(G(this, rc)), this.inspect = () => G(this, nc) ? [...G(this, $o).values(), ...G(this, Ur).values()].map(({ ctx: e }) => {
      var t;
      return (t = e == null ? void 0 : e.inspector) == null ? void 0 : t.read();
    }).filter((e) => !!e) : (console.warn(
      "[Milkdown]: You are trying to collect inspection when inspector is disabled, please enable inspector by `editor.enableInspector()` first."
    ), []);
  }
  /// Create a new editor instance.
  static make() {
    return new D6();
  }
  /// Get the ctx of the editor.
  get ctx() {
    return G(this, rc);
  }
  /// Get the status of the editor.
  get status() {
    return G(this, bi);
  }
};
nc = new WeakMap(), bi = new WeakMap(), qo = new WeakMap(), zu = new WeakMap(), p0 = new WeakMap(), m0 = new WeakMap(), Ur = new WeakMap(), $o = new WeakMap(), rc = new WeakMap(), g0 = new WeakMap(), ic = new WeakMap(), Fu = new WeakMap(), y0 = new WeakMap(), Va = new WeakMap(), Vu = new WeakMap();
let M4 = D6, HJ = (n) => crypto.getRandomValues(new Uint8Array(n)), zJ = (n, e, t) => {
  let r = (2 << Math.log2(n.length - 1)) - 1, i = -~(1.6 * r * e / n.length);
  return (s = e) => {
    let o = "";
    for (; ; ) {
      let a = t(i), l = i | 0;
      for (; l--; )
        if (o += n[a[l] & r] || "", o.length >= s) return o;
    }
  };
}, b5 = (n, e = 21) => zJ(n, e | 0, HJ);
b5("abcedfghicklmn", 10);
function ct(n, e) {
  const t = OJ(n), r = (i) => async () => {
    r.key = t, await i.wait(md);
    const s = e(i);
    return i.get(je).create(t, s), r.run = (o) => i.get(je).call(n, o), () => {
      i.get(je).remove(t);
    };
  };
  return r;
}
function Sr(n) {
  const e = (t) => async () => {
    await t.wait(Yi);
    const r = n(t);
    return t.update(Gd, (i) => [...i, r]), e.inputRule = r, () => {
      t.update(Gd, (i) => i.filter((s) => s !== r));
    };
  };
  return e;
}
function FJ(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(pd, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(pd, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(to).marks[n];
    if (!i) throw S$(n);
    return i;
  }, t;
}
function v5(n, e) {
  const t = (r) => async () => {
    const i = e(r);
    return r.update(dd, (s) => [
      ...s.filter((o) => o[0] !== n),
      [n, i]
    ]), t.id = n, t.schema = i, () => {
      r.update(dd, (s) => s.filter(([o]) => o !== n));
    };
  };
  return t.type = (r) => {
    const i = r.get(to).nodes[n];
    if (!i) throw x$(n);
    return i;
  }, t;
}
function jn(n) {
  let e;
  const t = (r) => async () => (await r.wait(Yi), e = n(r), r.update(ol, (i) => [...i, e]), () => {
    r.update(ol, (i) => i.filter((s) => s !== e));
  });
  return t.plugin = () => e, t.key = () => e.spec.key, t;
}
function GE(n) {
  const e = (t) => async () => {
    await t.wait(gd);
    const r = t.get(Jg), i = n(t), s = r.addObjectKeymap(i);
    return e.keymap = i, () => {
      s();
    };
  };
  return e;
}
function J0(n, e) {
  const t = (r) => async () => {
    await r.wait(Yi);
    const i = e(r);
    return n.type(r) instanceof Vg ? r.update(Yd, (s) => [
      ...s,
      [n.id, i]
    ]) : r.update(Xd, (s) => [
      ...s,
      [n.id, i]
    ]), t.view = i, t.type = n, () => {
      n.type(r) instanceof Vg ? r.update(Yd, (s) => s.filter((o) => o[0] !== n.id)) : r.update(Xd, (s) => s.filter((o) => o[0] !== n.id));
    };
  };
  return t;
}
function Wt(n, e) {
  const t = It(n, e), r = (i) => (i.inject(t), () => () => {
    i.remove(t);
  });
  return r.key = t, r;
}
function Rn(n, e) {
  const t = Wt(e, n), r = v5(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.node = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return Rn(n, o);
  }, i;
}
function Dh(n, e) {
  const t = Wt(e, n), r = FJ(n, (s) => s.get(t.key)(s)), i = [t, r];
  return i.id = r.id, i.mark = r, i.type = (s) => r.type(s), i.ctx = t, i.key = t.key, i.extendSchema = (s) => {
    const o = s(e);
    return Dh(n, o);
  }, i;
}
function ai(n, e) {
  const t = Object.fromEntries(
    Object.entries(e).map(
      ([o, { shortcuts: a, priority: l }]) => [o, { shortcuts: a, priority: l }]
    )
  ), r = Wt(t, `${n}Keymap`), i = GE((o) => {
    const a = o.get(r.key), l = Object.entries(e).flatMap(
      ([c, { command: u }]) => {
        const h = a[c], f = [h.shortcuts].flat(), m = h.priority;
        return f.map(
          (y) => [
            y,
            {
              key: y,
              onRun: u,
              priority: m
            }
          ]
        );
      }
    );
    return Object.fromEntries(l);
  }), s = [r, i];
  return s.ctx = r, s.shortcuts = i, s.key = r.key, s.keymap = i.keymap, s;
}
const Ts = (n, e = () => ({})) => Wt(e, `${n}Attr`), Y0 = (n, e = () => ({})) => Wt(e, `${n}Attr`);
function co(n, e, t) {
  const r = Wt({}, n), i = (o) => async () => {
    await o.wait(yc);
    const l = {
      plugin: e(o),
      options: o.get(r.key)
    };
    return o.update(Jd, (c) => [...c, l]), () => {
      o.update(Jd, (c) => c.filter((u) => u !== l));
    };
  }, s = [r, i];
  return s.id = n, s.plugin = i, s.options = r, s;
}
function VJ(n) {
  return (e) => {
    const t = e.get(on);
    return e.get(to), e.get(Cu)(t.state.doc);
  };
}
const T4 = Math.min, Mu = Math.max, Xg = Math.round, no = (n) => ({
  x: n,
  y: n
}), qJ = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, $J = {
  start: "end",
  end: "start"
};
function x8(n, e, t) {
  return Mu(n, T4(e, t));
}
function Z1(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Ic(n) {
  return n.split("-")[0];
}
function Q1(n) {
  return n.split("-")[1];
}
function JE(n) {
  return n === "x" ? "y" : "x";
}
function YE(n) {
  return n === "y" ? "height" : "width";
}
const jJ = /* @__PURE__ */ new Set(["top", "bottom"]);
function Ka(n) {
  return jJ.has(Ic(n)) ? "y" : "x";
}
function XE(n) {
  return JE(Ka(n));
}
function WJ(n, e, t) {
  t === void 0 && (t = !1);
  const r = Q1(n), i = XE(n), s = YE(i);
  let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (o = Zg(o)), [o, Zg(o)];
}
function UJ(n) {
  const e = Zg(n);
  return [A4(n), e, A4(e)];
}
function A4(n) {
  return n.replace(/start|end/g, (e) => $J[e]);
}
const S8 = ["left", "right"], C8 = ["right", "left"], KJ = ["top", "bottom"], GJ = ["bottom", "top"];
function JJ(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? C8 : S8 : e ? S8 : C8;
    case "left":
    case "right":
      return e ? KJ : GJ;
    default:
      return [];
  }
}
function YJ(n, e, t, r) {
  const i = Q1(n);
  let s = JJ(Ic(n), t === "start", r);
  return i && (s = s.map((o) => o + "-" + i), e && (s = s.concat(s.map(A4)))), s;
}
function Zg(n) {
  return n.replace(/left|right|bottom|top/g, (e) => qJ[e]);
}
function XJ(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function ZJ(n) {
  return typeof n != "number" ? XJ(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function Qg(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function M8(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = Ka(e), o = XE(e), a = YE(o), l = Ic(e), c = s === "y", u = r.x + r.width / 2 - i.width / 2, h = r.y + r.height / 2 - i.height / 2, f = r[a] / 2 - i[a] / 2;
  let m;
  switch (l) {
    case "top":
      m = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      m = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      m = {
        x: r.x + r.width,
        y: h
      };
      break;
    case "left":
      m = {
        x: r.x - i.width,
        y: h
      };
      break;
    default:
      m = {
        x: r.x,
        y: r.y
      };
  }
  switch (Q1(e)) {
    case "start":
      m[o] -= f * (t && c ? -1 : 1);
      break;
    case "end":
      m[o] += f * (t && c ? -1 : 1);
      break;
  }
  return m;
}
const QJ = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: o
  } = t, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: u,
    y: h
  } = M8(c, r, l), f = r, m = {}, y = 0;
  for (let b = 0; b < a.length; b++) {
    const {
      name: k,
      fn: x
    } = a[b], {
      x: M,
      y: T,
      data: E,
      reset: C
    } = await x({
      x: u,
      y: h,
      initialPlacement: r,
      placement: f,
      strategy: i,
      middlewareData: m,
      rects: c,
      platform: o,
      elements: {
        reference: n,
        floating: e
      }
    });
    u = M ?? u, h = T ?? h, m = {
      ...m,
      [k]: {
        ...m[k],
        ...E
      }
    }, C && y <= 50 && (y++, typeof C == "object" && (C.placement && (f = C.placement), C.rects && (c = C.rects === !0 ? await o.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : C.rects), {
      x: u,
      y: h
    } = M8(c, f, l)), b = -1);
  }
  return {
    x: u,
    y: h,
    placement: f,
    strategy: i,
    middlewareData: m
  };
};
async function ZE(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: o,
    elements: a,
    strategy: l
  } = n, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: h = "floating",
    altBoundary: f = !1,
    padding: m = 0
  } = Z1(e, n), y = ZJ(m), k = a[f ? h === "floating" ? "reference" : "floating" : h], x = Qg(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(k))) == null || t ? k : k.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), M = h === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, T = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), E = await (s.isElement == null ? void 0 : s.isElement(T)) ? await (s.getScale == null ? void 0 : s.getScale(T)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = Qg(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: M,
    offsetParent: T,
    strategy: l
  }) : M);
  return {
    top: (x.top - C.top + y.top) / E.y,
    bottom: (C.bottom - x.bottom + y.bottom) / E.y,
    left: (x.left - C.left + y.left) / E.x,
    right: (C.right - x.right + y.right) / E.x
  };
}
const eY = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: s,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: h = !0,
        fallbackPlacements: f,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: y = "none",
        flipAlignment: b = !0,
        ...k
      } = Z1(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const x = Ic(i), M = Ka(a), T = Ic(a) === a, E = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), C = f || (T || !b ? [Zg(a)] : UJ(a)), O = y !== "none";
      !f && O && C.push(...YJ(a, b, y, E));
      const R = [a, ...C], F = await ZE(e, k), H = [];
      let z = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (u && H.push(F[x]), h) {
        const ie = WJ(i, o, E);
        H.push(F[ie[0]], F[ie[1]]);
      }
      if (z = [...z, {
        placement: i,
        overflows: H
      }], !H.every((ie) => ie <= 0)) {
        var K, U;
        const ie = (((K = s.flip) == null ? void 0 : K.index) || 0) + 1, he = R[ie];
        if (he && (!(h === "alignment" ? M !== Ka(he) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        z.every((Ne) => Ka(Ne.placement) === M ? Ne.overflows[0] > 0 : !0)))
          return {
            data: {
              index: ie,
              overflows: z
            },
            reset: {
              placement: he
            }
          };
        let Ie = (U = z.filter((Oe) => Oe.overflows[0] <= 0).sort((Oe, Ne) => Oe.overflows[1] - Ne.overflows[1])[0]) == null ? void 0 : U.placement;
        if (!Ie)
          switch (m) {
            case "bestFit": {
              var ae;
              const Oe = (ae = z.filter((Ne) => {
                if (O) {
                  const We = Ka(Ne.placement);
                  return We === M || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  We === "y";
                }
                return !0;
              }).map((Ne) => [Ne.placement, Ne.overflows.filter((We) => We > 0).reduce((We, q) => We + q, 0)]).sort((Ne, We) => Ne[1] - We[1])[0]) == null ? void 0 : ae[0];
              Oe && (Ie = Oe);
              break;
            }
            case "initialPlacement":
              Ie = a;
              break;
          }
        if (i !== Ie)
          return {
            reset: {
              placement: Ie
            }
          };
      }
      return {};
    }
  };
}, tY = /* @__PURE__ */ new Set(["left", "top"]);
async function nY(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = Ic(t), a = Q1(t), l = Ka(t) === "y", c = tY.has(o) ? -1 : 1, u = s && l ? -1 : 1, h = Z1(e, n);
  let {
    mainAxis: f,
    crossAxis: m,
    alignmentAxis: y
  } = typeof h == "number" ? {
    mainAxis: h,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: h.mainAxis || 0,
    crossAxis: h.crossAxis || 0,
    alignmentAxis: h.alignmentAxis
  };
  return a && typeof y == "number" && (m = a === "end" ? y * -1 : y), l ? {
    x: m * u,
    y: f * c
  } : {
    x: f * c,
    y: m * u
  };
}
const rY = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: s,
        placement: o,
        middlewareData: a
      } = e, l = await nY(e, n);
      return o === ((t = a.offset) == null ? void 0 : t.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: i + l.x,
        y: s + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, iY = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: o = !1,
        limiter: a = {
          fn: (k) => {
            let {
              x,
              y: M
            } = k;
            return {
              x,
              y: M
            };
          }
        },
        ...l
      } = Z1(n, e), c = {
        x: t,
        y: r
      }, u = await ZE(e, l), h = Ka(Ic(i)), f = JE(h);
      let m = c[f], y = c[h];
      if (s) {
        const k = f === "y" ? "top" : "left", x = f === "y" ? "bottom" : "right", M = m + u[k], T = m - u[x];
        m = x8(M, m, T);
      }
      if (o) {
        const k = h === "y" ? "top" : "left", x = h === "y" ? "bottom" : "right", M = y + u[k], T = y - u[x];
        y = x8(M, y, T);
      }
      const b = a.fn({
        ...e,
        [f]: m,
        [h]: y
      });
      return {
        ...b,
        data: {
          x: b.x - t,
          y: b.y - r,
          enabled: {
            [f]: s,
            [h]: o
          }
        }
      };
    }
  };
};
function ey() {
  return typeof window < "u";
}
function Nh(n) {
  return QE(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Ai(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function ma(n) {
  var e;
  return (e = (QE(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function QE(n) {
  return ey() ? n instanceof Node || n instanceof Ai(n).Node : !1;
}
function xs(n) {
  return ey() ? n instanceof Element || n instanceof Ai(n).Element : !1;
}
function oo(n) {
  return ey() ? n instanceof HTMLElement || n instanceof Ai(n).HTMLElement : !1;
}
function T8(n) {
  return !ey() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof Ai(n).ShadowRoot;
}
const sY = /* @__PURE__ */ new Set(["inline", "contents"]);
function X0(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = Ss(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !sY.has(i);
}
const oY = /* @__PURE__ */ new Set(["table", "td", "th"]);
function aY(n) {
  return oY.has(Nh(n));
}
const lY = [":popover-open", ":modal"];
function ty(n) {
  return lY.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const cY = ["transform", "translate", "scale", "rotate", "perspective"], uY = ["transform", "translate", "scale", "rotate", "perspective", "filter"], hY = ["paint", "layout", "strict", "content"];
function w5(n) {
  const e = k5(), t = xs(n) ? Ss(n) : n;
  return cY.some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || uY.some((r) => (t.willChange || "").includes(r)) || hY.some((r) => (t.contain || "").includes(r));
}
function fY(n) {
  let e = al(n);
  for (; oo(e) && !gh(e); ) {
    if (w5(e))
      return e;
    if (ty(e))
      return null;
    e = al(e);
  }
  return null;
}
function k5() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const dY = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function gh(n) {
  return dY.has(Nh(n));
}
function Ss(n) {
  return Ai(n).getComputedStyle(n);
}
function ny(n) {
  return xs(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function al(n) {
  if (Nh(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    T8(n) && n.host || // Fallback.
    ma(n)
  );
  return T8(e) ? e.host : e;
}
function eL(n) {
  const e = al(n);
  return gh(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : oo(e) && X0(e) ? e : eL(e);
}
function tL(n, e, t) {
  var r;
  e === void 0 && (e = []);
  const i = eL(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = Ai(i);
  return s ? (E4(o), e.concat(o, o.visualViewport || [], X0(i) ? i : [], [])) : e.concat(i, tL(i, []));
}
function E4(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function nL(n) {
  const e = Ss(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = oo(n), s = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, a = Xg(t) !== s || Xg(r) !== o;
  return a && (t = s, r = o), {
    width: t,
    height: r,
    $: a
  };
}
function rL(n) {
  return xs(n) ? n : n.contextElement;
}
function Tu(n) {
  const e = rL(n);
  if (!oo(e))
    return no(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = nL(e);
  let o = (s ? Xg(t.width) : t.width) / r, a = (s ? Xg(t.height) : t.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
const pY = /* @__PURE__ */ no(0);
function iL(n) {
  const e = Ai(n);
  return !k5() || !e.visualViewport ? pY : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function mY(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== Ai(n) ? !1 : e;
}
function Zd(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), s = rL(n);
  let o = no(1);
  e && (r ? xs(r) && (o = Tu(r)) : o = Tu(n));
  const a = mY(s, t, r) ? iL(s) : no(0);
  let l = (i.left + a.x) / o.x, c = (i.top + a.y) / o.y, u = i.width / o.x, h = i.height / o.y;
  if (s) {
    const f = Ai(s), m = r && xs(r) ? Ai(r) : r;
    let y = f, b = E4(y);
    for (; b && r && m !== y; ) {
      const k = Tu(b), x = b.getBoundingClientRect(), M = Ss(b), T = x.left + (b.clientLeft + parseFloat(M.paddingLeft)) * k.x, E = x.top + (b.clientTop + parseFloat(M.paddingTop)) * k.y;
      l *= k.x, c *= k.y, u *= k.x, h *= k.y, l += T, c += E, y = Ai(b), b = E4(y);
    }
  }
  return Qg({
    width: u,
    height: h,
    x: l,
    y: c
  });
}
function ry(n, e) {
  const t = ny(n).scrollLeft;
  return e ? e.left + t : Zd(ma(n)).left + t;
}
function sL(n, e) {
  const t = n.getBoundingClientRect(), r = t.left + e.scrollLeft - ry(n, t), i = t.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function gY(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", o = ma(r), a = e ? ty(e.floating) : !1;
  if (r === o || a && s)
    return t;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = no(1);
  const u = no(0), h = oo(r);
  if ((h || !h && !s) && ((Nh(r) !== "body" || X0(o)) && (l = ny(r)), oo(r))) {
    const m = Zd(r);
    c = Tu(r), u.x = m.x + r.clientLeft, u.y = m.y + r.clientTop;
  }
  const f = o && !h && !s ? sL(o, l) : no(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: t.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function yY(n) {
  return Array.from(n.getClientRects());
}
function bY(n) {
  const e = ma(n), t = ny(n), r = n.ownerDocument.body, i = Mu(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = Mu(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + ry(n);
  const a = -t.scrollTop;
  return Ss(r).direction === "rtl" && (o += Mu(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: o,
    y: a
  };
}
const A8 = 25;
function vY(n, e) {
  const t = Ai(n), r = ma(n), i = t.visualViewport;
  let s = r.clientWidth, o = r.clientHeight, a = 0, l = 0;
  if (i) {
    s = i.width, o = i.height;
    const u = k5();
    (!u || u && e === "fixed") && (a = i.offsetLeft, l = i.offsetTop);
  }
  const c = ry(r);
  if (c <= 0) {
    const u = r.ownerDocument, h = u.body, f = getComputedStyle(h), m = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, y = Math.abs(r.clientWidth - h.clientWidth - m);
    y <= A8 && (s -= y);
  } else c <= A8 && (s += c);
  return {
    width: s,
    height: o,
    x: a,
    y: l
  };
}
const wY = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function kY(n, e) {
  const t = Zd(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, s = oo(n) ? Tu(n) : no(1), o = n.clientWidth * s.x, a = n.clientHeight * s.y, l = i * s.x, c = r * s.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function E8(n, e, t) {
  let r;
  if (e === "viewport")
    r = vY(n, t);
  else if (e === "document")
    r = bY(ma(n));
  else if (xs(e))
    r = kY(e, t);
  else {
    const i = iL(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return Qg(r);
}
function oL(n, e) {
  const t = al(n);
  return t === e || !xs(t) || gh(t) ? !1 : Ss(t).position === "fixed" || oL(t, e);
}
function xY(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = tL(n, []).filter((a) => xs(a) && Nh(a) !== "body"), i = null;
  const s = Ss(n).position === "fixed";
  let o = s ? al(n) : n;
  for (; xs(o) && !gh(o); ) {
    const a = Ss(o), l = w5(o);
    !l && a.position === "fixed" && (i = null), (s ? !l && !i : !l && a.position === "static" && !!i && wY.has(i.position) || X0(o) && !l && oL(n, o)) ? r = r.filter((u) => u !== o) : i = a, o = al(o);
  }
  return e.set(n, r), r;
}
function SY(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const o = [...t === "clippingAncestors" ? ty(e) ? [] : xY(e, this._c) : [].concat(t), r], a = o[0], l = o.reduce((c, u) => {
    const h = E8(e, u, i);
    return c.top = Mu(h.top, c.top), c.right = T4(h.right, c.right), c.bottom = T4(h.bottom, c.bottom), c.left = Mu(h.left, c.left), c;
  }, E8(e, a, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function CY(n) {
  const {
    width: e,
    height: t
  } = nL(n);
  return {
    width: e,
    height: t
  };
}
function MY(n, e, t) {
  const r = oo(e), i = ma(e), s = t === "fixed", o = Zd(n, !0, s, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = no(0);
  function c() {
    l.x = ry(i);
  }
  if (r || !r && !s)
    if ((Nh(e) !== "body" || X0(i)) && (a = ny(e)), r) {
      const m = Zd(e, !0, s, e);
      l.x = m.x + e.clientLeft, l.y = m.y + e.clientTop;
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? sL(i, a) : no(0), h = o.left + a.scrollLeft - l.x - u.x, f = o.top + a.scrollTop - l.y - u.y;
  return {
    x: h,
    y: f,
    width: o.width,
    height: o.height
  };
}
function r2(n) {
  return Ss(n).position === "static";
}
function L8(n, e) {
  if (!oo(n) || Ss(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return ma(n) === t && (t = t.ownerDocument.body), t;
}
function aL(n, e) {
  const t = Ai(n);
  if (ty(n))
    return t;
  if (!oo(n)) {
    let i = al(n);
    for (; i && !gh(i); ) {
      if (xs(i) && !r2(i))
        return i;
      i = al(i);
    }
    return t;
  }
  let r = L8(n, e);
  for (; r && aY(r) && r2(r); )
    r = L8(r, e);
  return r && gh(r) && r2(r) && !w5(r) ? t : r || fY(n) || t;
}
const TY = async function(n) {
  const e = this.getOffsetParent || aL, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: MY(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function AY(n) {
  return Ss(n).direction === "rtl";
}
const EY = {
  convertOffsetParentRelativeRectToViewportRelativeRect: gY,
  getDocumentElement: ma,
  getClippingRect: SY,
  getOffsetParent: aL,
  getElementRects: TY,
  getClientRects: yY,
  getDimensions: CY,
  getScale: Tu,
  isElement: xs,
  isRTL: AY
}, ll = rY, O8 = iY, e1 = eY, Cs = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: EY,
    ...t
  }, s = {
    ...i.platform,
    _c: r
  };
  return QJ(n, e, {
    ...i,
    platform: s
  });
};
function Z0(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-block",
      ...e
    }
  }), n;
}
const LY = (n) => !eo((t) => t.type.name === "table")(n), iy = Wt(
  { filterNodes: LY },
  "blockConfig"
);
Z0(iy, {
  displayName: "Ctx<blockConfig>"
});
function OY(n, e, t) {
  var i;
  if (!n.dom.parentElement) return null;
  try {
    const s = (i = n.posAtCoords({
      left: e.x,
      top: e.y
    })) == null ? void 0 : i.inside;
    if (s == null || s < 0) return null;
    let o = n.state.doc.resolve(s), a = n.state.doc.nodeAt(s), l = n.nodeDOM(s);
    const c = (h) => {
      const f = o.depth >= 1 && o.index(o.depth) === 0;
      if (!(h || f)) return;
      const y = o.before(o.depth);
      a = n.state.doc.nodeAt(y), l = n.nodeDOM(y), o = n.state.doc.resolve(y), t(o, a) || c(!0);
    }, u = t(o, a);
    return c(!u), !l || !a ? null : { node: a, $pos: o, el: l };
  } catch {
    return null;
  }
}
const D8 = Gp.ie && Gp.ie_version < 15 || Gp.ios && Gp.webkit_version < 604, N8 = 20;
var qu, b0, sc, ps, $u, ms, Yo, lL, Df, oc, ac, v0, ju, Wu, Uu, w0, lc;
class DY {
  constructor() {
    Se(this, Yo);
    /// @internal
    Se(this, qu);
    Se(this, b0);
    Se(this, sc);
    Se(this, ps);
    Se(this, $u);
    Se(this, ms);
    /// @internal
    Se(this, oc);
    Se(this, ac);
    Se(this, v0);
    Se(this, ju);
    Se(this, Wu);
    Se(this, Uu);
    Se(this, w0);
    Se(this, lc);
    re(this, b0, () => {
      if (!G(this, ps)) return null;
      const e = G(this, ps), t = G(this, Yo, Df);
      if (t && Qe.isSelectable(e.node)) {
        const r = Qe.create(
          t.state.doc,
          e.$pos.pos
        );
        return t.dispatch(t.state.tr.setSelection(r)), t.focus(), re(this, sc, r), r;
      }
      return null;
    }), re(this, sc, null), re(this, ps, null), re(this, $u, void 0), re(this, ms, !1), re(this, ac, () => {
      var e;
      (e = G(this, oc)) == null || e.call(this, { type: "hide" }), re(this, ps, null);
    }), re(this, v0, (e) => {
      var t;
      re(this, ps, e), (t = G(this, oc)) == null || t.call(this, { type: "show", active: e });
    }), this.bind = (e, t) => {
      re(this, qu, e), re(this, oc, t);
    }, this.addEvent = (e) => {
      e.addEventListener("mousedown", G(this, ju)), e.addEventListener("mouseup", G(this, Wu)), e.addEventListener("dragstart", G(this, Uu));
    }, this.removeEvent = (e) => {
      e.removeEventListener("mousedown", G(this, ju)), e.removeEventListener("mouseup", G(this, Wu)), e.removeEventListener("dragstart", G(this, Uu));
    }, this.unBind = () => {
      re(this, oc, void 0);
    }, re(this, ju, () => {
      var e;
      re(this, $u, (e = G(this, ps)) == null ? void 0 : e.el.getBoundingClientRect()), G(this, b0).call(this);
    }), re(this, Wu, () => {
      if (!G(this, ms)) {
        requestAnimationFrame(() => {
          var e;
          G(this, $u) && ((e = G(this, Yo, Df)) == null || e.focus());
        });
        return;
      }
      re(this, ms, !1), re(this, sc, null);
    }), re(this, Uu, (e) => {
      var i;
      re(this, ms, !0);
      const t = G(this, Yo, Df);
      if (!t) return;
      t.dom.dataset.dragging = "true";
      const r = G(this, sc);
      if (e.dataTransfer && r) {
        const s = r.content();
        e.dataTransfer.effectAllowed = "copyMove";
        const { dom: o, text: a } = t.serializeForClipboard(s);
        e.dataTransfer.clearData(), e.dataTransfer.setData(
          D8 ? "Text" : "text/html",
          o.innerHTML
        ), D8 || e.dataTransfer.setData("text/plain", a);
        const l = (i = G(this, ps)) == null ? void 0 : i.el;
        l && e.dataTransfer.setDragImage(l, 0, 0), t.dragging = {
          slice: s,
          move: !0
        };
      }
    }), this.keydownCallback = (e) => (G(this, ac).call(this), re(this, ms, !1), e.dom.dataset.dragging = "false", !1), re(this, w0, T1((e, t) => {
      if (!e.editable) return;
      const r = e.dom.getBoundingClientRect(), i = r.left + r.width / 2;
      if (!(e.root.elementFromPoint(i, t.clientY) instanceof Element)) {
        G(this, ac).call(this);
        return;
      }
      const o = G(this, Yo, lL);
      if (!o) return;
      const a = OY(
        e,
        { x: i, y: t.clientY },
        o
      );
      if (!a) {
        G(this, ac).call(this);
        return;
      }
      G(this, v0).call(this, a);
    }, 200)), this.mousemoveCallback = (e, t) => (e.composing || !e.editable || G(this, w0).call(this, e, t), !1), this.dragoverCallback = (e, t) => {
      var r;
      if (G(this, ms)) {
        const i = (r = G(this, Yo, Df)) == null ? void 0 : r.dom.parentElement;
        if (!i) return !1;
        const s = i.scrollHeight > i.clientHeight, o = i.getBoundingClientRect();
        if (s) {
          if (i.scrollTop > 0 && Math.abs(t.y - o.y) < N8) {
            const c = i.scrollTop > 10 ? i.scrollTop - 10 : 0;
            return i.scrollTop = c, !1;
          }
          const a = Math.round(e.dom.getBoundingClientRect().height);
          if (Math.round(i.scrollTop + o.height) < a && Math.abs(t.y - (o.height + o.y)) < N8) {
            const c = i.scrollTop + 10;
            return i.scrollTop = c, !1;
          }
        }
      }
      return !1;
    }, this.dragenterCallback = (e) => {
      e.dragging && (re(this, ms, !0), e.dom.dataset.dragging = "true");
    }, this.dragleaveCallback = (e, t) => {
      const r = t.clientX, i = t.clientY;
      (r < 0 || i < 0 || r > window.innerWidth || i > window.innerHeight) && (re(this, ps, null), G(this, lc).call(this, e));
    }, this.dropCallback = (e) => (G(this, lc).call(this, e), !1), this.dragendCallback = (e) => {
      G(this, lc).call(this, e);
    }, re(this, lc, (e) => {
      re(this, ms, !1), e.dom.dataset.dragging = "false";
    });
  }
}
qu = new WeakMap(), b0 = new WeakMap(), sc = new WeakMap(), ps = new WeakMap(), $u = new WeakMap(), ms = new WeakMap(), Yo = new WeakSet(), lL = function() {
  var e;
  try {
    return (e = G(this, qu)) == null ? void 0 : e.get(iy.key).filterNodes;
  } catch {
    return;
  }
}, Df = function() {
  var e;
  return (e = G(this, qu)) == null ? void 0 : e.get(on);
}, oc = new WeakMap(), ac = new WeakMap(), v0 = new WeakMap(), ju = new WeakMap(), Wu = new WeakMap(), Uu = new WeakMap(), w0 = new WeakMap(), lc = new WeakMap();
const x5 = Wt(() => new DY(), "blockService"), sy = Wt(
  {},
  "blockServiceInstance"
);
Z0(x5, {
  displayName: "Ctx<blockService>"
});
Z0(sy, {
  displayName: "Ctx<blockServiceInstance>"
});
const oy = Wt({}, "blockSpec");
Z0(oy, {
  displayName: "Ctx<blockSpec>"
});
const S5 = jn((n) => {
  const e = new gn("MILKDOWN_BLOCK"), r = n.get(x5.key)();
  n.set(sy.key, r);
  const i = n.get(oy.key);
  return new mn({
    key: e,
    ...i,
    props: {
      ...i.props,
      handleDOMEvents: {
        drop: (s) => r.dropCallback(s),
        pointermove: (s, o) => r.mousemoveCallback(s, o),
        keydown: (s) => r.keydownCallback(s),
        dragover: (s, o) => r.dragoverCallback(s, o),
        dragleave: (s, o) => r.dragleaveCallback(s, o),
        dragenter: (s) => r.dragenterCallback(s),
        dragend: (s) => r.dragendCallback(s)
      }
    }
  });
});
Z0(S5, {
  displayName: "Prose<block>"
});
var Kr, jo, cc, uc, k0, Ku, x0, S0, Gu, Ju, Yu, b1, cL;
class NY {
  constructor(e) {
    Se(this, b1);
    /// @internal
    Se(this, Kr);
    /// @internal
    Se(this, jo);
    /// @internal
    Se(this, cc);
    Se(this, uc);
    /// @internal
    Se(this, k0);
    Se(this, Ku);
    /// @internal
    Se(this, x0);
    /// @internal
    Se(this, S0);
    /// @internal
    Se(this, Gu);
    /// @internal
    Se(this, Ju);
    /// @internal
    Se(this, Yu);
    re(this, uc, null), re(this, Ku, !1), this.update = () => {
      requestAnimationFrame(() => {
        if (!G(this, Ku))
          try {
            Cp(this, b1, cL).call(this), re(this, Ku, !0);
          } catch {
          }
      });
    }, this.destroy = () => {
      var t, r;
      (t = G(this, cc)) == null || t.unBind(), (r = G(this, cc)) == null || r.removeEvent(G(this, Kr)), G(this, Kr).remove();
    }, this.show = (t) => {
      const r = t.el, i = G(this, jo).get(on).dom, s = {
        ctx: G(this, jo),
        active: t,
        editorDom: i,
        blockDom: G(this, Kr)
      }, o = {
        contextElement: r,
        getBoundingClientRect: () => G(this, Ju) ? G(this, Ju).call(this, s) : r.getBoundingClientRect()
      }, a = [e1()];
      if (G(this, Gu)) {
        const l = G(this, Gu).call(this, s), c = ll(l);
        a.push(c);
      }
      Cs(o, G(this, Kr), {
        placement: G(this, Yu) ? G(this, Yu).call(this, s) : "left",
        middleware: [...a, ...G(this, x0)],
        ...G(this, S0)
      }).then(({ x: l, y: c }) => {
        Object.assign(G(this, Kr).style, {
          left: `${l}px`,
          top: `${c}px`
        }), G(this, Kr).dataset.show = "true";
      }).catch(console.error);
    }, this.hide = () => {
      G(this, Kr).dataset.show = "false";
    }, re(this, jo, e.ctx), re(this, Kr, e.content), re(this, Gu, e.getOffset), re(this, Ju, e.getPosition), re(this, Yu, e.getPlacement), re(this, x0, e.middleware ?? []), re(this, S0, e.floatingUIOptions ?? {}), re(this, k0, e.root), this.hide();
  }
  /// The context of current active node.
  get active() {
    return G(this, uc);
  }
}
Kr = new WeakMap(), jo = new WeakMap(), cc = new WeakMap(), uc = new WeakMap(), k0 = new WeakMap(), Ku = new WeakMap(), x0 = new WeakMap(), S0 = new WeakMap(), Gu = new WeakMap(), Ju = new WeakMap(), Yu = new WeakMap(), b1 = new WeakSet(), /// @internal
cL = function() {
  const e = G(this, jo).get(on);
  (G(this, k0) ?? e.dom.parentElement ?? document.body).appendChild(G(this, Kr));
  const r = G(this, jo).get(sy.key);
  r.bind(G(this, jo), (i) => {
    i.type === "hide" ? (this.hide(), re(this, uc, null)) : i.type === "show" && (this.show(i.active), re(this, uc, i.active));
  }), re(this, cc, r), G(this, cc).addEvent(G(this, Kr)), G(this, Kr).draggable = !0;
};
const ay = [
  oy,
  iy,
  x5,
  sy,
  S5
];
ay.key = oy.key;
ay.pluginKey = S5.key;
function IY(n, e) {
  return function(t, r) {
    let { $from: i, $to: s, node: o } = t.selection;
    if (o && o.isBlock || i.depth < 2 || !i.sameParent(s))
      return !1;
    let a = i.node(-1);
    if (a.type != n)
      return !1;
    if (i.parent.content.size == 0 && i.node(-1).childCount == i.indexAfter(-1)) {
      if (i.depth == 3 || i.node(-3).type != n || i.index(-2) != i.node(-2).childCount - 1)
        return !1;
      if (r) {
        let h = pe.empty, f = i.index(-1) ? 1 : i.index(-2) ? 2 : 3;
        for (let x = i.depth - f; x >= i.depth - 3; x--)
          h = pe.from(i.node(x).copy(h));
        let m = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3;
        h = h.append(pe.from(n.createAndFill()));
        let y = i.before(i.depth - (f - 1)), b = t.tr.replace(y, i.after(-m), new He(h, 4 - f, 0)), k = -1;
        b.doc.nodesBetween(y, b.doc.content.size, (x, M) => {
          if (k > -1)
            return !1;
          x.isTextblock && x.content.size == 0 && (k = M + 1);
        }), k > -1 && b.setSelection(ht.near(b.doc.resolve(k))), r(b.scrollIntoView());
      }
      return !0;
    }
    let l = s.pos == i.end() ? a.contentMatchAt(0).defaultType : null, c = t.tr.delete(i.pos, s.pos), u = l ? [null, { type: l }] : void 0;
    return ad(c.doc, i.pos, 2, u) ? (r && r(c.split(i.pos, 2, u).scrollIntoView()), !0) : !1;
  };
}
function _Y(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (o) => o.childCount > 0 && o.firstChild.type == n);
    return s ? t ? r.node(s.depth - 1).type == n ? RY(e, t, n, s) : PY(e, t, s) : !0 : !1;
  };
}
function RY(n, e, t, r) {
  let i = n.tr, s = r.end, o = r.$to.end(r.depth);
  s < o && (i.step(new kr(s - 1, o, s, o, new He(pe.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new NT(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth));
  const a = P1(r);
  if (a == null)
    return !1;
  i.lift(r, a);
  let l = i.doc.resolve(i.mapping.map(s, -1) - 1);
  return B1(i.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && i.join(l.pos), e(i.scrollIntoView()), !0;
}
function PY(n, e, t) {
  let r = n.tr, i = t.parent;
  for (let m = t.end, y = t.endIndex - 1, b = t.startIndex; y > b; y--)
    m -= i.child(y).nodeSize, r.delete(m - 1, m + 1);
  let s = r.doc.resolve(t.start), o = s.nodeAfter;
  if (r.mapping.map(t.end) != t.start + s.nodeAfter.nodeSize)
    return !1;
  let a = t.startIndex == 0, l = t.endIndex == i.childCount, c = s.node(-1), u = s.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, o.content.append(l ? pe.empty : pe.from(i))))
    return !1;
  let h = s.pos, f = h + o.nodeSize;
  return r.step(new kr(h - (a ? 1 : 0), f + (l ? 1 : 0), h + 1, f - 1, new He((a ? pe.empty : pe.from(i.copy(pe.empty))).append(l ? pe.empty : pe.from(i.copy(pe.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function BY(n) {
  return function(e, t) {
    let { $from: r, $to: i } = e.selection, s = r.blockRange(i, (c) => c.childCount > 0 && c.firstChild.type == n);
    if (!s)
      return !1;
    let o = s.startIndex;
    if (o == 0)
      return !1;
    let a = s.parent, l = a.child(o - 1);
    if (l.type != n)
      return !1;
    if (t) {
      let c = l.lastChild && l.lastChild.type == a.type, u = pe.from(c ? n.create() : null), h = new He(pe.from(n.create(null, pe.from(a.type.create(null, u)))), c ? 3 : 1, 0), f = s.start, m = s.end;
      t(e.tr.step(new kr(f - (c ? 3 : 1), m, f, m, h, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
function HY(n) {
  const e = /* @__PURE__ */ new Map();
  if (!n || !n.type)
    throw new Error("mdast-util-definitions expected node");
  return ml(n, "definition", function(r) {
    const i = I8(r.identifier);
    i && !e.get(i) && e.set(i, r);
  }), t;
  function t(r) {
    const i = I8(r);
    return e.get(i);
  }
}
function I8(n) {
  return String(n || "").toUpperCase();
}
function zY() {
  return function(n) {
    const e = HY(n);
    ml(n, function(t, r, i) {
      if (t.type === "definition" && i !== void 0 && typeof r == "number")
        return i.children.splice(r, 1), [i4, r];
      if (t.type === "imageReference" || t.type === "linkReference") {
        const s = e(t.identifier);
        if (s && i && typeof r == "number")
          return i.children[r] = t.type === "imageReference" ? { type: "image", url: s.url, title: s.title, alt: t.alt } : {
            type: "link",
            url: s.url,
            title: s.title,
            children: t.children
          }, [i4, r];
      }
    });
  };
}
function uL(n, e) {
  var i;
  if (!(e.childCount >= 1 && ((i = e.lastChild) == null ? void 0 : i.type.name) === "hardbreak")) {
    n.next(e.content);
    return;
  }
  const r = [];
  e.content.forEach((s, o, a) => {
    a !== e.childCount - 1 && r.push(s);
  }), n.next(pe.fromArray(r));
}
function oe(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-commonmark",
      ...e
    }
  }), n;
}
const C5 = Y0("emphasis");
oe(C5, {
  displayName: "Attr<emphasis>",
  group: "Emphasis"
});
const Hc = Dh("emphasis", (n) => ({
  attrs: {
    marker: {
      default: n.get(fd).emphasis || "*",
      validate: "string"
    }
  },
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    { style: "font-style", getAttrs: (e) => e === "italic" }
  ],
  toDOM: (e) => ["em", n.get(C5.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "emphasis",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "emphasis",
    runner: (e, t) => {
      e.withMark(t, "emphasis", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
oe(Hc.mark, {
  displayName: "MarkSchema<emphasis>",
  group: "Emphasis"
});
oe(Hc.ctx, {
  displayName: "MarkSchemaCtx<emphasis>",
  group: "Emphasis"
});
const ly = ct("ToggleEmphasis", (n) => () => G1(Hc.type(n)));
oe(ly, {
  displayName: "Command<toggleEmphasisCommand>",
  group: "Emphasis"
});
const hL = Sr((n) => $0(/(?:^|[^*])\*([^*]+)\*$/, Hc.type(n), {
  getAttr: () => ({
    marker: "*"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("*") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
oe(hL, {
  displayName: "InputRule<emphasis>|Star",
  group: "Emphasis"
});
const fL = Sr((n) => $0(/\b_(?![_\s])(.*?[^_\s])_\b/, Hc.type(n), {
  getAttr: () => ({
    marker: "_"
  }),
  updateCaptured: ({ fullMatch: e, start: t }) => e.startsWith("_") ? {} : { fullMatch: e.slice(1), start: t + 1 }
}));
oe(fL, {
  displayName: "InputRule<emphasis>|Underscore",
  group: "Emphasis"
});
const M5 = ai("emphasisKeymap", {
  ToggleEmphasis: {
    shortcuts: "Mod-i",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(ly.key);
    }
  }
});
oe(M5.ctx, {
  displayName: "KeymapCtx<emphasis>",
  group: "Emphasis"
});
oe(M5.shortcuts, {
  displayName: "Keymap<emphasis>",
  group: "Emphasis"
});
const T5 = Y0("strong");
oe(T5, {
  displayName: "Attr<strong>",
  group: "Strong"
});
const Ih = Dh("strong", (n) => ({
  attrs: {
    marker: {
      default: n.get(fd).strong || "*",
      validate: "string"
    }
  },
  parseDOM: [
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: (e) => e.style.fontWeight != "normal" && null
    },
    { tag: "strong" },
    { style: "font-style", getAttrs: (e) => e === "bold" },
    { style: "font-weight=400", clearMark: (e) => e.type.name == "strong" },
    {
      style: "font-weight",
      getAttrs: (e) => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null
    }
  ],
  toDOM: (e) => ["strong", n.get(T5.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "strong",
    runner: (e, t, r) => {
      e.openMark(r, { marker: t.marker }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strong",
    runner: (e, t) => {
      e.withMark(t, "strong", void 0, {
        marker: t.attrs.marker
      });
    }
  }
}));
oe(Ih.mark, {
  displayName: "MarkSchema<strong>",
  group: "Strong"
});
oe(Ih.ctx, {
  displayName: "MarkSchemaCtx<strong>",
  group: "Strong"
});
const cy = ct("ToggleStrong", (n) => () => G1(Ih.type(n)));
oe(cy, {
  displayName: "Command<toggleStrongCommand>",
  group: "Strong"
});
const dL = Sr((n) => $0(
  new RegExp("(?<![\\w:/])(?:\\*\\*|__)([^*_]+?)(?:\\*\\*|__)(?![\\w/])$"),
  Ih.type(n),
  {
    getAttr: (e) => ({
      marker: e[0].startsWith("*") ? "*" : "_"
    })
  }
));
oe(dL, {
  displayName: "InputRule<strong>",
  group: "Strong"
});
const A5 = ai("strongKeymap", {
  ToggleBold: {
    shortcuts: ["Mod-b"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(cy.key);
    }
  }
});
oe(A5.ctx, {
  displayName: "KeymapCtx<strong>",
  group: "Strong"
});
oe(A5.shortcuts, {
  displayName: "Keymap<strong>",
  group: "Strong"
});
const E5 = Y0("inlineCode");
oe(E5, {
  displayName: "Attr<inlineCode>",
  group: "InlineCode"
});
const Jo = Dh("inlineCode", (n) => ({
  priority: 100,
  code: !0,
  parseDOM: [{ tag: "code" }],
  toDOM: (e) => ["code", n.get(E5.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "inlineCode",
    runner: (e, t, r) => {
      e.openMark(r), e.addText(t.value), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "inlineCode",
    runner: (e, t, r) => {
      e.withMark(t, "inlineCode", r.text || "");
    }
  }
}));
oe(Jo.mark, {
  displayName: "MarkSchema<inlineCode>",
  group: "InlineCode"
});
oe(Jo.ctx, {
  displayName: "MarkSchemaCtx<inlineCode>",
  group: "InlineCode"
});
const uy = ct(
  "ToggleInlineCode",
  (n) => () => (e, t) => {
    const { selection: r, tr: i } = e;
    if (r.empty) return !1;
    const { from: s, to: o } = r;
    return e.doc.rangeHasMark(s, o, Jo.type(n)) ? (t == null || t(i.removeMark(s, o, Jo.type(n))), !0) : (Object.keys(e.schema.marks).filter(
      (c) => c !== Jo.type.name
    ).map((c) => e.schema.marks[c]).forEach((c) => {
      i.removeMark(s, o, c);
    }), t == null || t(i.addMark(s, o, Jo.type(n).create())), !0);
  }
);
oe(uy, {
  displayName: "Command<toggleInlineCodeCommand>",
  group: "InlineCode"
});
const pL = Sr((n) => $0(/(?:`)([^`]+)(?:`)$/, Jo.type(n)));
oe(pL, {
  displayName: "InputRule<inlineCodeInputRule>",
  group: "InlineCode"
});
const L5 = ai("inlineCodeKeymap", {
  ToggleInlineCode: {
    shortcuts: "Mod-e",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(uy.key);
    }
  }
});
oe(L5.ctx, {
  displayName: "KeymapCtx<inlineCode>",
  group: "InlineCode"
});
oe(L5.shortcuts, {
  displayName: "Keymap<inlineCode>",
  group: "InlineCode"
});
const O5 = Y0("link");
oe(O5, {
  displayName: "Attr<link>",
  group: "Link"
});
const vs = Dh("link", (n) => ({
  attrs: {
    href: { validate: "string" },
    title: { default: null, validate: "string|null" }
  },
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ms(e);
        return {
          href: e.getAttribute("href"),
          title: e.getAttribute("title")
        };
      }
    }
  ],
  toDOM: (e) => ["a", { ...n.get(O5.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: (e) => e.type === "link",
    runner: (e, t, r) => {
      const i = t.url, s = t.title;
      e.openMark(r, { href: i, title: s }), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "link",
    runner: (e, t) => {
      e.withMark(t, "link", void 0, {
        title: t.attrs.title,
        url: t.attrs.href
      });
    }
  }
}));
oe(vs.mark, {
  displayName: "MarkSchema<link>",
  group: "Link"
});
const mL = ct(
  "ToggleLink",
  (n) => (e = {}) => G1(vs.type(n), e)
);
oe(mL, {
  displayName: "Command<toggleLinkCommand>",
  group: "Link"
});
const gL = ct(
  "UpdateLink",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !1;
    let i, s = -1;
    const { selection: o } = t, { from: a, to: l } = o;
    if (t.doc.nodesBetween(a, a === l ? l + 1 : l, (y, b) => {
      if (vs.type(n).isInSet(y.marks))
        return i = y, s = b, !1;
    }), !i) return !1;
    const c = i.marks.find(({ type: y }) => y === vs.type(n));
    if (!c) return !1;
    const u = s, h = s + i.nodeSize, { tr: f } = t, m = vs.type(n).create({ ...c.attrs, ...e });
    return m ? (r(
      f.removeMark(u, h, c).addMark(u, h, m).setSelection(new Ye(f.selection.$anchor)).scrollIntoView()
    ), !0) : !1;
  }
);
oe(gL, {
  displayName: "Command<updateLinkCommand>",
  group: "Link"
});
const yL = v5("doc", () => ({
  content: "block+",
  parseMarkdown: {
    match: ({ type: n }) => n === "root",
    runner: (n, e, t) => {
      n.injectRoot(e, t);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "doc",
    runner: (n, e) => {
      n.openNode("root"), n.next(e.content);
    }
  }
}));
oe(yL, {
  displayName: "NodeSchema<doc>",
  group: "Doc"
});
function FY(n) {
  return Zw(
    n,
    (e) => {
      var t;
      return e.type === "html" && ["<br />", "<br>", "<br >", "<br/>"].includes(
        (t = e.value) == null ? void 0 : t.trim()
      );
    },
    (e, t) => {
      if (!t.length) return;
      const r = t[t.length - 1];
      if (!r) return;
      const i = r.children.indexOf(e);
      i !== -1 && r.children.splice(i, 1);
    },
    !0
  );
}
const hy = co(
  "remark-preserve-empty-line",
  () => () => FY
);
oe(hy.plugin, {
  displayName: "Remark<remarkPreserveEmptyLine>",
  group: "Remark"
});
oe(hy.options, {
  displayName: "RemarkConfig<remarkPreserveEmptyLine>",
  group: "Remark"
});
const D5 = Ts("paragraph");
oe(D5, {
  displayName: "Attr<paragraph>",
  group: "Paragraph"
});
const uo = Rn("paragraph", (n) => ({
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p" }],
  toDOM: (e) => ["p", n.get(D5.key)(e), 0],
  parseMarkdown: {
    match: (e) => e.type === "paragraph",
    runner: (e, t, r) => {
      e.openNode(r), t.children ? e.next(t.children) : e.addText(t.value || ""), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "paragraph",
    runner: (e, t) => {
      var s;
      const i = (s = n.get(on).state) == null ? void 0 : s.doc.lastChild;
      e.openNode("paragraph"), (!t.content || t.content.size === 0) && t !== i && VY(n) ? e.addNode("html", void 0, "<br />") : uL(e, t), e.closeNode();
    }
  }
}));
function VY(n) {
  let e = !1;
  try {
    n.get(hy.id), e = !0;
  } catch {
    e = !1;
  }
  return e;
}
oe(uo.node, {
  displayName: "NodeSchema<paragraph>",
  group: "Paragraph"
});
oe(uo.ctx, {
  displayName: "NodeSchemaCtx<paragraph>",
  group: "Paragraph"
});
const N5 = ct(
  "TurnIntoText",
  (n) => () => jd(uo.type(n))
);
oe(N5, {
  displayName: "Command<turnIntoTextCommand>",
  group: "Paragraph"
});
const I5 = ai("paragraphKeymap", {
  TurnIntoText: {
    shortcuts: "Mod-Alt-0",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(N5.key);
    }
  }
});
oe(I5.ctx, {
  displayName: "KeymapCtx<paragraph>",
  group: "Paragraph"
});
oe(I5.shortcuts, {
  displayName: "Keymap<paragraph>",
  group: "Paragraph"
});
const qY = Array(6).fill(0).map((n, e) => e + 1);
function $Y(n) {
  return n.textContent.toLowerCase().trim().replace(/\s+/g, "-");
}
const fy = Wt(
  $Y,
  "headingIdGenerator"
);
oe(fy, {
  displayName: "Ctx<HeadingIdGenerator>",
  group: "Heading"
});
const _5 = Ts("heading");
oe(_5, {
  displayName: "Attr<heading>",
  group: "Heading"
});
const wi = Rn("heading", (n) => {
  const e = n.get(fy.key);
  return {
    content: "inline*",
    group: "block",
    defining: !0,
    attrs: {
      id: {
        default: "",
        validate: "string"
      },
      level: {
        default: 1,
        validate: "number"
      }
    },
    parseDOM: qY.map((t) => ({
      tag: `h${t}`,
      getAttrs: (r) => {
        if (!(r instanceof HTMLElement)) throw Ms(r);
        return { level: t, id: r.id };
      }
    })),
    toDOM: (t) => [
      `h${t.attrs.level}`,
      {
        ...n.get(_5.key)(t),
        id: t.attrs.id || e(t)
      },
      0
    ],
    parseMarkdown: {
      match: ({ type: t }) => t === "heading",
      runner: (t, r, i) => {
        const s = r.depth;
        t.openNode(i, { level: s }), t.next(r.children), t.closeNode();
      }
    },
    toMarkdown: {
      match: (t) => t.type.name === "heading",
      runner: (t, r) => {
        t.openNode("heading", void 0, { depth: r.attrs.level }), uL(t, r), t.closeNode();
      }
    }
  };
});
oe(wi.node, {
  displayName: "NodeSchema<heading>",
  group: "Heading"
});
oe(wi.ctx, {
  displayName: "NodeSchemaCtx<heading>",
  group: "Heading"
});
const bL = Sr((n) => Kw(
  /^(?<hashes>#+)\s$/,
  wi.type(n),
  (e) => {
    var o, a;
    const t = ((a = (o = e.groups) == null ? void 0 : o.hashes) == null ? void 0 : a.length) || 0, r = n.get(on), { $from: i } = r.state.selection, s = i.node();
    if (s.type.name === "heading") {
      let l = Number(s.attrs.level) + Number(t);
      return l > 6 && (l = 6), { level: l };
    }
    return { level: t };
  }
));
oe(bL, {
  displayName: "InputRule<wrapInHeadingInputRule>",
  group: "Heading"
});
const _a = ct("WrapInHeading", (n) => (e) => (e ?? (e = 1), e < 1 ? jd(uo.type(n)) : jd(wi.type(n), { level: e })));
oe(_a, {
  displayName: "Command<wrapInHeadingCommand>",
  group: "Heading"
});
const R5 = ct(
  "DowngradeHeading",
  (n) => () => (e, t, r) => {
    const { $from: i } = e.selection, s = i.node();
    if (s.type !== wi.type(n) || !e.selection.empty || i.parentOffset !== 0)
      return !1;
    const o = s.attrs.level - 1;
    return o ? (t == null || t(
      e.tr.setNodeMarkup(e.selection.$from.before(), void 0, {
        ...s.attrs,
        level: o
      })
    ), !0) : jd(uo.type(n))(e, t, r);
  }
);
oe(R5, {
  displayName: "Command<downgradeHeadingCommand>",
  group: "Heading"
});
const P5 = ai("headingKeymap", {
  TurnIntoH1: {
    shortcuts: "Mod-Alt-1",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(_a.key, 1);
    }
  },
  TurnIntoH2: {
    shortcuts: "Mod-Alt-2",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(_a.key, 2);
    }
  },
  TurnIntoH3: {
    shortcuts: "Mod-Alt-3",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(_a.key, 3);
    }
  },
  TurnIntoH4: {
    shortcuts: "Mod-Alt-4",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(_a.key, 4);
    }
  },
  TurnIntoH5: {
    shortcuts: "Mod-Alt-5",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(_a.key, 5);
    }
  },
  TurnIntoH6: {
    shortcuts: "Mod-Alt-6",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(_a.key, 6);
    }
  },
  DowngradeHeading: {
    shortcuts: ["Delete", "Backspace"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(R5.key);
    }
  }
});
oe(P5.ctx, {
  displayName: "KeymapCtx<heading>",
  group: "Heading"
});
oe(P5.shortcuts, {
  displayName: "Keymap<heading>",
  group: "Heading"
});
const B5 = Ts("blockquote");
oe(B5, {
  displayName: "Attr<blockquote>",
  group: "Blockquote"
});
const _h = Rn(
  "blockquote",
  (n) => ({
    content: "block+",
    group: "block",
    defining: !0,
    parseDOM: [{ tag: "blockquote" }],
    toDOM: (e) => ["blockquote", n.get(B5.key)(e), 0],
    parseMarkdown: {
      match: ({ type: e }) => e === "blockquote",
      runner: (e, t, r) => {
        e.openNode(r).next(t.children).closeNode();
      }
    },
    toMarkdown: {
      match: (e) => e.type.name === "blockquote",
      runner: (e, t) => {
        e.openNode("blockquote").next(t.content).closeNode();
      }
    }
  })
);
oe(_h.node, {
  displayName: "NodeSchema<blockquote>",
  group: "Blockquote"
});
oe(_h.ctx, {
  displayName: "NodeSchemaCtx<blockquote>",
  group: "Blockquote"
});
const vL = Sr(
  (n) => Uw(/^\s*>\s$/, _h.type(n))
);
oe(vL, {
  displayName: "InputRule<wrapInBlockquoteInputRule>",
  group: "Blockquote"
});
const H5 = ct(
  "WrapInBlockquote",
  (n) => () => o5(_h.type(n))
);
oe(H5, {
  displayName: "Command<wrapInBlockquoteCommand>",
  group: "Blockquote"
});
const z5 = ai("blockquoteKeymap", {
  WrapInBlockquote: {
    shortcuts: "Mod-Shift-b",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(H5.key);
    }
  }
});
oe(z5.ctx, {
  displayName: "KeymapCtx<blockquote>",
  group: "Blockquote"
});
oe(z5.shortcuts, {
  displayName: "Keymap<blockquote>",
  group: "Blockquote"
});
const F5 = Ts("codeBlock", () => ({
  pre: {},
  code: {}
}));
oe(F5, {
  displayName: "Attr<codeBlock>",
  group: "CodeBlock"
});
const ao = Rn("code_block", (n) => ({
  content: "text*",
  group: "block",
  marks: "",
  defining: !0,
  code: !0,
  attrs: {
    language: {
      default: "",
      validate: "string"
    }
  },
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ms(e);
        return { language: e.dataset.language };
      }
    }
  ],
  toDOM: (e) => {
    const t = n.get(F5.key)(e), r = e.attrs.language, i = r && r.length > 0 ? { "data-language": r } : void 0;
    return [
      "pre",
      {
        ...t.pre,
        ...i
      },
      ["code", t.code, 0]
    ];
  },
  parseMarkdown: {
    match: ({ type: e }) => e === "code",
    runner: (e, t, r) => {
      const i = t.lang ?? "", s = t.value;
      e.openNode(r, { language: i }), s && e.addText(s), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "code_block",
    runner: (e, t) => {
      var r;
      e.addNode("code", void 0, ((r = t.content.firstChild) == null ? void 0 : r.text) || "", {
        lang: t.attrs.language
      });
    }
  }
}));
oe(ao.node, {
  displayName: "NodeSchema<codeBlock>",
  group: "CodeBlock"
});
oe(ao.ctx, {
  displayName: "NodeSchemaCtx<codeBlock>",
  group: "CodeBlock"
});
const wL = Sr(
  (n) => Kw(
    /^```(?<language>[a-z]*)?[\s\n]$/,
    ao.type(n),
    (e) => {
      var t;
      return {
        language: ((t = e.groups) == null ? void 0 : t.language) ?? ""
      };
    }
  )
);
oe(wL, {
  displayName: "InputRule<createCodeBlockInputRule>",
  group: "CodeBlock"
});
const V5 = ct(
  "CreateCodeBlock",
  (n) => (e = "") => jd(ao.type(n), { language: e })
);
oe(V5, {
  displayName: "Command<createCodeBlockCommand>",
  group: "CodeBlock"
});
const jY = ct(
  "UpdateCodeBlockLanguage",
  () => ({ pos: n, language: e } = {
    pos: -1,
    language: ""
  }) => (t, r) => n >= 0 ? (r == null || r(t.tr.setNodeAttribute(n, "language", e)), !0) : !1
);
oe(jY, {
  displayName: "Command<updateCodeBlockLanguageCommand>",
  group: "CodeBlock"
});
const q5 = ai("codeBlockKeymap", {
  CreateCodeBlock: {
    shortcuts: "Mod-Alt-c",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(V5.key);
    }
  }
});
oe(q5.ctx, {
  displayName: "KeymapCtx<codeBlock>",
  group: "CodeBlock"
});
oe(q5.shortcuts, {
  displayName: "Keymap<codeBlock>",
  group: "CodeBlock"
});
const $5 = Ts("image");
oe($5, {
  displayName: "Attr<image>",
  group: "Image"
});
const zc = Rn("image", (n) => ({
  inline: !0,
  group: "inline",
  selectable: !0,
  draggable: !0,
  marks: "",
  atom: !0,
  defining: !0,
  isolating: !0,
  attrs: {
    src: { default: "", validate: "string" },
    alt: { default: "", validate: "string" },
    title: { default: "", validate: "string" }
  },
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ms(e);
        return {
          src: e.getAttribute("src") || "",
          alt: e.getAttribute("alt") || "",
          title: e.getAttribute("title") || e.getAttribute("alt") || ""
        };
      }
    }
  ],
  toDOM: (e) => ["img", { ...n.get($5.key)(e), ...e.attrs }],
  parseMarkdown: {
    match: ({ type: e }) => e === "image",
    runner: (e, t, r) => {
      const i = t.url, s = t.alt, o = t.title;
      e.addNode(r, {
        src: i,
        alt: s,
        title: o
      });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "image",
    runner: (e, t) => {
      e.addNode("image", void 0, void 0, {
        title: t.attrs.title,
        url: t.attrs.src,
        alt: t.attrs.alt
      });
    }
  }
}));
oe(zc.node, {
  displayName: "NodeSchema<image>",
  group: "Image"
});
oe(zc.ctx, {
  displayName: "NodeSchemaCtx<image>",
  group: "Image"
});
const kL = ct(
  "InsertImage",
  (n) => (e = {}) => (t, r) => {
    if (!r) return !0;
    const { src: i = "", alt: s = "", title: o = "" } = e, a = zc.type(n).create({ src: i, alt: s, title: o });
    return a && r(t.tr.replaceSelectionWith(a).scrollIntoView()), !0;
  }
);
oe(kL, {
  displayName: "Command<insertImageCommand>",
  group: "Image"
});
const xL = ct(
  "UpdateImage",
  (n) => (e = {}) => (t, r) => {
    const i = U$(
      t.selection,
      zc.type(n)
    );
    if (!i) return !1;
    const { node: s, pos: o } = i, a = { ...s.attrs }, { src: l, alt: c, title: u } = e;
    return l !== void 0 && (a.src = l), c !== void 0 && (a.alt = c), u !== void 0 && (a.title = u), r == null || r(
      t.tr.setNodeMarkup(o, void 0, a).scrollIntoView()
    ), !0;
  }
);
oe(xL, {
  displayName: "Command<updateImageCommand>",
  group: "Image"
});
const WY = Sr(
  (n) => new ii(
    /!\[(?<alt>.*?)]\((?<filename>.*?)\s*(?="|\))"?(?<title>[^"]+)?"?\)/,
    (e, t, r, i) => {
      const [s, o, a = "", l] = t;
      return s ? e.tr.replaceWith(
        r,
        i,
        zc.type(n).create({ src: a, alt: o, title: l })
      ) : null;
    }
  )
);
oe(WY, {
  displayName: "InputRule<insertImageInputRule>",
  group: "Image"
});
const t1 = Ts("hardbreak", (n) => ({
  "data-type": "hardbreak",
  "data-is-inline": n.attrs.isInline
}));
oe(t1, {
  displayName: "Attr<hardbreak>",
  group: "Hardbreak"
});
const bc = Rn("hardbreak", (n) => ({
  inline: !0,
  group: "inline",
  attrs: {
    isInline: {
      default: !1,
      validate: "boolean"
    }
  },
  selectable: !1,
  parseDOM: [
    { tag: "br" },
    {
      tag: 'span[data-type="hardbreak"]',
      getAttrs: () => ({ isInline: !0 })
    }
  ],
  toDOM: (e) => e.attrs.isInline ? ["span", n.get(t1.key)(e), " "] : ["br", n.get(t1.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "break",
    runner: (e, t, r) => {
      var i;
      e.addNode(r, {
        isInline: !!((i = t.data) != null && i.isInline)
      });
    }
  },
  leafText: () => `
`,
  toMarkdown: {
    match: (e) => e.type.name === "hardbreak",
    runner: (e, t) => {
      t.attrs.isInline ? e.addNode("text", void 0, `
`) : e.addNode("break");
    }
  }
}));
oe(bc.node, {
  displayName: "NodeSchema<hardbreak>",
  group: "Hardbreak"
});
oe(bc.ctx, {
  displayName: "NodeSchemaCtx<hardbreak>",
  group: "Hardbreak"
});
const j5 = ct(
  "InsertHardbreak",
  (n) => () => (e, t) => {
    var s;
    const { selection: r, tr: i } = e;
    if (!(r instanceof Ye)) return !1;
    if (r.empty) {
      const o = r.$from.node();
      if (o.childCount > 0 && ((s = o.lastChild) == null ? void 0 : s.type.name) === "hardbreak")
        return t == null || t(
          i.replaceRangeWith(
            r.to - 1,
            r.to,
            e.schema.node("paragraph")
          ).setSelection(ht.near(i.doc.resolve(r.to))).scrollIntoView()
        ), !0;
    }
    return t == null || t(
      i.setMeta("hardbreak", !0).replaceSelectionWith(bc.type(n).create()).scrollIntoView()
    ), !0;
  }
);
oe(j5, {
  displayName: "Command<insertHardbreakCommand>",
  group: "Hardbreak"
});
const W5 = ai("hardbreakKeymap", {
  InsertHardbreak: {
    shortcuts: "Shift-Enter",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(j5.key);
    }
  }
});
oe(W5.ctx, {
  displayName: "KeymapCtx<hardbreak>",
  group: "Hardbreak"
});
oe(W5.shortcuts, {
  displayName: "Keymap<hardbreak>",
  group: "Hardbreak"
});
const U5 = Ts("hr");
oe(U5, {
  displayName: "Attr<hr>",
  group: "Hr"
});
const Rh = Rn("hr", (n) => ({
  group: "block",
  parseDOM: [{ tag: "hr" }],
  toDOM: (e) => ["hr", n.get(U5.key)(e)],
  parseMarkdown: {
    match: ({ type: e }) => e === "thematicBreak",
    runner: (e, t, r) => {
      e.addNode(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "hr",
    runner: (e) => {
      e.addNode("thematicBreak");
    }
  }
}));
oe(Rh.node, {
  displayName: "NodeSchema<hr>",
  group: "Hr"
});
oe(Rh.ctx, {
  displayName: "NodeSchemaCtx<hr>",
  group: "Hr"
});
const SL = Sr(
  (n) => new ii(/^(?:---|___\s|\*\*\*\s)$/, (e, t, r, i) => {
    const { tr: s } = e;
    return t[0] && s.replaceWith(r - 1, i, Rh.type(n).create()), s;
  })
);
oe(SL, {
  displayName: "InputRule<insertHrInputRule>",
  group: "Hr"
});
const CL = ct(
  "InsertHr",
  (n) => () => (e, t) => {
    if (!t) return !0;
    const r = uo.node.type(n).create(), { tr: i, selection: s } = e, { from: o } = s, a = Rh.type(n).create();
    if (!a) return !0;
    const l = i.replaceSelectionWith(a).insert(o, r), c = ht.findFrom(l.doc.resolve(o), 1, !0);
    return c && t(l.setSelection(c).scrollIntoView()), !0;
  }
);
oe(CL, {
  displayName: "Command<insertHrCommand>",
  group: "Hr"
});
const K5 = Ts("bulletList");
oe(K5, {
  displayName: "Attr<bulletList>",
  group: "BulletList"
});
const Fc = Rn("bullet_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ms(e);
        return {
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "ul",
    {
      ...n.get(K5.key)(e),
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "false";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "bullet_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !1,
        spread: t.attrs.spread
      }).next(t.content).closeNode();
    }
  }
}));
oe(Fc.node, {
  displayName: "NodeSchema<bulletList>",
  group: "BulletList"
});
oe(Fc.ctx, {
  displayName: "NodeSchemaCtx<bulletList>",
  group: "BulletList"
});
const ML = Sr(
  (n) => Uw(/^\s*([-+*])\s$/, Fc.type(n))
);
oe(ML, {
  displayName: "InputRule<wrapInBulletListInputRule>",
  group: "BulletList"
});
const G5 = ct(
  "WrapInBulletList",
  (n) => () => o5(Fc.type(n))
);
oe(G5, {
  displayName: "Command<wrapInBulletListCommand>",
  group: "BulletList"
});
const J5 = ai("bulletListKeymap", {
  WrapInBulletList: {
    shortcuts: "Mod-Alt-8",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(G5.key);
    }
  }
});
oe(J5.ctx, {
  displayName: "KeymapCtx<bulletListKeymap>",
  group: "BulletList"
});
oe(J5.shortcuts, {
  displayName: "Keymap<bulletListKeymap>",
  group: "BulletList"
});
const Y5 = Ts("orderedList");
oe(Y5, {
  displayName: "Attr<orderedList>",
  group: "OrderedList"
});
const Vc = Rn("ordered_list", (n) => ({
  content: "listItem+",
  group: "block",
  attrs: {
    order: {
      default: 1,
      validate: "number"
    },
    spread: {
      default: !1,
      validate: "boolean"
    }
  },
  parseDOM: [
    {
      tag: "ol",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ms(e);
        return {
          spread: e.dataset.spread,
          order: e.hasAttribute("start") ? Number(e.getAttribute("start")) : 1
        };
      }
    }
  ],
  toDOM: (e) => [
    "ol",
    {
      ...n.get(Y5.key)(e),
      ...e.attrs.order === 1 ? {} : e.attrs.order,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e, ordered: t }) => e === "list" && !!t,
    runner: (e, t, r) => {
      const i = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { spread: i }).next(t.children).closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "ordered_list",
    runner: (e, t) => {
      e.openNode("list", void 0, {
        ordered: !0,
        start: 1,
        spread: t.attrs.spread === "true"
      }), e.next(t.content), e.closeNode();
    }
  }
}));
oe(Vc.node, {
  displayName: "NodeSchema<orderedList>",
  group: "OrderedList"
});
oe(Vc.ctx, {
  displayName: "NodeSchemaCtx<orderedList>",
  group: "OrderedList"
});
const TL = Sr(
  (n) => Uw(
    /^\s*(\d+)\.\s$/,
    Vc.type(n),
    (e) => ({ order: Number(e[1]) }),
    (e, t) => t.childCount + t.attrs.order === Number(e[1])
  )
);
oe(TL, {
  displayName: "InputRule<wrapInOrderedListInputRule>",
  group: "OrderedList"
});
const X5 = ct(
  "WrapInOrderedList",
  (n) => () => o5(Vc.type(n))
);
oe(X5, {
  displayName: "Command<wrapInOrderedListCommand>",
  group: "OrderedList"
});
const Z5 = ai("orderedListKeymap", {
  WrapInOrderedList: {
    shortcuts: "Mod-Alt-7",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(X5.key);
    }
  }
});
oe(Z5.ctx, {
  displayName: "KeymapCtx<orderedList>",
  group: "OrderedList"
});
oe(Z5.shortcuts, {
  displayName: "Keymap<orderedList>",
  group: "OrderedList"
});
const Q5 = Ts("listItem");
oe(Q5, {
  displayName: "Attr<listItem>",
  group: "ListItem"
});
const As = Rn("list_item", (n) => ({
  group: "listItem",
  content: "paragraph block*",
  attrs: {
    label: {
      default: "•",
      validate: "string"
    },
    listType: {
      default: "bullet",
      validate: "string"
    },
    spread: {
      default: !0,
      validate: "boolean"
    }
  },
  defining: !0,
  parseDOM: [
    {
      tag: "li",
      getAttrs: (e) => {
        if (!(e instanceof HTMLElement)) throw Ms(e);
        return {
          label: e.dataset.label,
          listType: e.dataset.listType,
          spread: e.dataset.spread === "true"
        };
      }
    }
  ],
  toDOM: (e) => [
    "li",
    {
      ...n.get(Q5.key)(e),
      "data-label": e.attrs.label,
      "data-list-type": e.attrs.listType,
      "data-spread": e.attrs.spread
    },
    0
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "listItem",
    runner: (e, t, r) => {
      const i = t.label != null ? `${t.label}.` : "•", s = t.label != null ? "ordered" : "bullet", o = t.spread != null ? `${t.spread}` : "true";
      e.openNode(r, { label: i, listType: s, spread: o }), e.next(t.children), e.closeNode();
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "list_item",
    runner: (e, t) => {
      e.openNode("listItem", void 0, {
        spread: t.attrs.spread
      }), e.next(t.content), e.closeNode();
    }
  }
}));
oe(As.node, {
  displayName: "NodeSchema<listItem>",
  group: "ListItem"
});
oe(As.ctx, {
  displayName: "NodeSchemaCtx<listItem>",
  group: "ListItem"
});
const e3 = ct(
  "SinkListItem",
  (n) => () => BY(As.type(n))
);
oe(e3, {
  displayName: "Command<sinkListItemCommand>",
  group: "ListItem"
});
const t3 = ct(
  "LiftListItem",
  (n) => () => _Y(As.type(n))
);
oe(t3, {
  displayName: "Command<liftListItemCommand>",
  group: "ListItem"
});
const n3 = ct(
  "SplitListItem",
  (n) => () => IY(As.type(n))
);
oe(n3, {
  displayName: "Command<splitListItemCommand>",
  group: "ListItem"
});
function UY(n) {
  return (e, t, r) => {
    const { selection: i } = e;
    if (!(i instanceof Ye)) return !1;
    const { empty: s, $from: o } = i;
    return !s || o.parentOffset !== 0 || o.node(-1).type !== As.type(n) ? !1 : YA(e, t, r);
  };
}
const r3 = ct(
  "LiftFirstListItem",
  (n) => () => UY(n)
);
oe(r3, {
  displayName: "Command<liftFirstListItemCommand>",
  group: "ListItem"
});
const i3 = ai("listItemKeymap", {
  NextListItem: {
    shortcuts: "Enter",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(n3.key);
    }
  },
  SinkListItem: {
    shortcuts: ["Tab", "Mod-]"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(e3.key);
    }
  },
  LiftListItem: {
    shortcuts: ["Shift-Tab", "Mod-["],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(t3.key);
    }
  },
  LiftFirstListItem: {
    shortcuts: ["Backspace", "Delete"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(r3.key);
    }
  }
});
oe(i3.ctx, {
  displayName: "KeymapCtx<listItem>",
  group: "ListItem"
});
oe(i3.shortcuts, {
  displayName: "Keymap<listItem>",
  group: "ListItem"
});
const AL = v5("text", () => ({
  group: "inline",
  parseMarkdown: {
    match: ({ type: n }) => n === "text",
    runner: (n, e) => {
      n.addText(e.value);
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "text",
    runner: (n, e) => {
      n.addNode("text", void 0, e.text);
    }
  }
}));
oe(AL, {
  displayName: "NodeSchema<text>",
  group: "Text"
});
const s3 = Ts("html");
oe(s3, {
  displayName: "Attr<html>",
  group: "Html"
});
const o3 = Rn("html", (n) => ({
  atom: !0,
  group: "inline",
  inline: !0,
  attrs: {
    value: {
      default: "",
      validate: "string"
    }
  },
  toDOM: (e) => {
    const t = document.createElement("span"), r = {
      ...n.get(s3.key)(e),
      "data-value": e.attrs.value,
      "data-type": "html"
    };
    return t.textContent = e.attrs.value, ["span", r, e.attrs.value];
  },
  parseDOM: [
    {
      tag: 'span[data-type="html"]',
      getAttrs: (e) => ({
        value: e.dataset.value ?? ""
      })
    }
  ],
  parseMarkdown: {
    match: ({ type: e }) => e === "html",
    runner: (e, t, r) => {
      e.addNode(r, { value: t.value });
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "html",
    runner: (e, t) => {
      e.addNode("html", void 0, t.attrs.value);
    }
  }
}));
oe(o3.node, {
  displayName: "NodeSchema<html>",
  group: "Html"
});
oe(o3.ctx, {
  displayName: "NodeSchemaCtx<html>",
  group: "Html"
});
const KY = [
  yL,
  D5,
  uo,
  fy,
  _5,
  wi,
  t1,
  bc,
  B5,
  _h,
  F5,
  ao,
  U5,
  Rh,
  $5,
  zc,
  K5,
  Fc,
  Y5,
  Vc,
  Q5,
  As,
  C5,
  Hc,
  T5,
  Ih,
  E5,
  Jo,
  O5,
  vs,
  s3,
  o3,
  AL
].flat(), GY = [
  vL,
  ML,
  TL,
  wL,
  SL,
  bL
].flat(), JY = [
  hL,
  fL,
  pL,
  dL
], ou = ct(
  "IsMarkSelected",
  () => (n) => (e) => {
    if (!n) return !1;
    const { doc: t, selection: r } = e;
    return t.rangeHasMark(r.from, r.to, n);
  }
), EL = ct(
  "IsNoteSelected",
  () => (n) => (e) => n ? dA(e, n).hasNode : !1
), or = ct(
  "ClearTextInCurrentBlock",
  () => () => (n, e) => {
    let t = n.tr;
    const { $from: r, $to: i } = t.selection, { pos: s } = r, { pos: o } = i, a = s - r.node().content.size;
    return a < 0 ? !1 : (t = t.deleteRange(a, o), e == null || e(t), !0);
  }
), Do = ct(
  "SetBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr, { from: o, to: a } = s.selection;
    try {
      s.setBlockType(o, a, r, i);
    } catch {
      return !1;
    }
    return t == null || t(s), !0;
  }
), Nf = ct(
  "WrapInBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    let s = e.tr;
    try {
      const { $from: o, $to: a } = s.selection, l = o.blockRange(a), c = l && jw(l, r, i);
      if (!c) return !1;
      s = s.wrap(l, c);
    } catch {
      return !1;
    }
    return t == null || t(s), !0;
  }
), If = ct(
  "AddBlockType",
  () => (n) => (e, t) => {
    const { nodeType: r, attrs: i = null } = n ?? {};
    if (!r) return !1;
    const s = e.tr;
    try {
      const o = r instanceof Qo ? r : r.createAndFill(i);
      if (!o) return !1;
      s.replaceSelectionWith(o);
    } catch {
      return !1;
    }
    return t == null || t(s), !0;
  }
), LL = ct(
  "SelectTextNearPos",
  () => (n) => (e, t) => {
    const { pos: r } = n ?? {};
    if (r == null) return !1;
    const i = (o, a, l) => Math.min(Math.max(o, a), l), s = e.tr;
    try {
      const o = e.doc.resolve(i(r, 0, e.doc.content.size));
      s.setSelection(Ye.near(o));
    } catch {
      return !1;
    }
    return t == null || t(s.scrollIntoView()), !0;
  }
), YY = [
  N5,
  H5,
  _a,
  R5,
  V5,
  j5,
  CL,
  kL,
  xL,
  X5,
  G5,
  e3,
  n3,
  t3,
  r3,
  ly,
  uy,
  cy,
  mL,
  gL,
  ou,
  EL,
  or,
  Do,
  Nf,
  If,
  LL
], XY = [
  z5,
  q5,
  W5,
  P5,
  i3,
  Z5,
  J5,
  I5,
  M5,
  L5,
  A5
].flat(), a3 = co(
  "remarkAddOrderInList",
  () => () => (n) => {
    ml(n, "list", (e) => {
      if (e.ordered) {
        const t = e.start ?? 1;
        e.children.forEach((r, i) => {
          r.label = i + t;
        });
      }
    });
  }
);
oe(a3.plugin, {
  displayName: "Remark<remarkAddOrderInListPlugin>",
  group: "Remark"
});
oe(a3.options, {
  displayName: "RemarkConfig<remarkAddOrderInListPlugin>",
  group: "Remark"
});
const l3 = co(
  "remarkLineBreak",
  () => () => (n) => {
    const e = /[\t ]*(?:\r?\n|\r)/g;
    ml(
      n,
      "text",
      (t, r, i) => {
        if (!t.value || typeof t.value != "string") return;
        const s = [];
        let o = 0;
        e.lastIndex = 0;
        let a = e.exec(t.value);
        for (; a; ) {
          const c = a.index;
          o !== c && s.push({
            type: "text",
            value: t.value.slice(o, c)
          }), s.push({ type: "break", data: { isInline: !0 } }), o = c + a[0].length, a = e.exec(t.value);
        }
        if (s.length > 0 && i && typeof r == "number")
          return o < t.value.length && s.push({ type: "text", value: t.value.slice(o) }), i.children.splice(r, 1, ...s), r + s.length;
      }
    );
  }
);
oe(l3.plugin, {
  displayName: "Remark<remarkLineBreak>",
  group: "Remark"
});
oe(l3.options, {
  displayName: "RemarkConfig<remarkLineBreak>",
  group: "Remark"
});
const c3 = co(
  "remarkInlineLink",
  () => zY
);
oe(c3.plugin, {
  displayName: "Remark<remarkInlineLinkPlugin>",
  group: "Remark"
});
oe(c3.options, {
  displayName: "RemarkConfig<remarkInlineLinkPlugin>",
  group: "Remark"
});
const ZY = (n) => !!n.children, QY = (n) => n.type === "html";
function eX(n, e) {
  return t(n, 0, null)[0];
  function t(r, i, s) {
    if (ZY(r)) {
      const o = [];
      for (let a = 0, l = r.children.length; a < l; a++) {
        const c = r.children[a];
        if (c) {
          const u = t(c, a, r);
          if (u)
            for (let h = 0, f = u.length; h < f; h++) {
              const m = u[h];
              m && o.push(m);
            }
        }
      }
      r.children = o;
    }
    return e(r, i, s);
  }
}
const tX = ["root", "blockquote", "listItem"], u3 = co(
  "remarkHTMLTransformer",
  () => () => (n) => {
    eX(n, (e, t, r) => QY(e) ? (r && tX.includes(r.type) && (e.children = [{ ...e }], delete e.value, e.type = "paragraph"), [e]) : [e]);
  }
);
oe(u3.plugin, {
  displayName: "Remark<remarkHtmlTransformer>",
  group: "Remark"
});
oe(u3.options, {
  displayName: "RemarkConfig<remarkHtmlTransformer>",
  group: "Remark"
});
const h3 = co(
  "remarkMarker",
  () => () => (n, e) => {
    const t = (r) => e.value.charAt(r.position.start.offset);
    ml(
      n,
      (r) => ["strong", "emphasis"].includes(r.type),
      (r) => {
        r.marker = t(r);
      }
    );
  }
);
oe(h3.plugin, {
  displayName: "Remark<remarkMarker>",
  group: "Remark"
});
oe(h3.options, {
  displayName: "RemarkConfig<remarkMarker>",
  group: "Remark"
});
const OL = jn(() => {
  let n = !1;
  const e = new gn(
    "MILKDOWN_INLINE_NODES_CURSOR"
  ), t = new mn({
    key: e,
    state: {
      init() {
        return !1;
      },
      apply(r) {
        if (!r.selection.empty) return !1;
        const i = r.selection.$from, s = i.nodeBefore, o = i.nodeAfter;
        return !!(s && o && s.isInline && !s.isText && o.isInline && !o.isText);
      }
    },
    props: {
      handleDOMEvents: {
        compositionend: (r, i) => n ? (n = !1, requestAnimationFrame(() => {
          if (t.getState(r.state)) {
            const o = r.state.selection.from;
            i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o));
          }
        }), !0) : !1,
        compositionstart: (r) => (t.getState(r.state) && (n = !0), !1),
        beforeinput: (r, i) => {
          if (t.getState(r.state) && i instanceof InputEvent && i.data && !n) {
            const o = r.state.selection.from;
            return i.preventDefault(), r.dispatch(r.state.tr.insertText(i.data || "", o)), !0;
          }
          return !1;
        }
      },
      decorations(r) {
        if (t.getState(r)) {
          const o = r.selection.$from.pos, a = document.createElement("span"), l = qn.widget(o, a, {
            side: -1
          }), c = document.createElement("span"), u = qn.widget(o, c);
          return setTimeout(() => {
            a.contentEditable = "true", c.contentEditable = "true";
          }), Qt.create(r.doc, [l, u]);
        }
        return Qt.empty;
      }
    }
  });
  return t;
});
oe(OL, {
  displayName: "Prose<inlineNodesCursorPlugin>",
  group: "Prose"
});
const DL = jn((n) => new mn({
  key: new gn("MILKDOWN_HARDBREAK_MARKS"),
  appendTransaction: (e, t, r) => {
    if (!e.length) return;
    const [i] = e;
    if (!i) return;
    const [s] = i.steps;
    if (i.getMeta("hardbreak")) {
      if (!(s instanceof er)) return;
      const { from: l } = s;
      return r.tr.setNodeMarkup(
        l,
        bc.type(n),
        void 0,
        []
      );
    }
    if (s instanceof Ko) {
      let l = r.tr;
      const { from: c, to: u } = s;
      return r.doc.nodesBetween(c, u, (h, f) => {
        h.type === bc.type(n) && (l = l.setNodeMarkup(
          f,
          bc.type(n),
          void 0,
          []
        ));
      }), l;
    }
  }
}));
oe(DL, {
  displayName: "Prose<hardbreakClearMarkPlugin>",
  group: "Prose"
});
const f3 = Wt(
  ["table", "code_block"],
  "hardbreakFilterNodes"
);
oe(f3, {
  displayName: "Ctx<hardbreakFilterNodes>",
  group: "Prose"
});
const NL = jn((n) => {
  const e = n.get(f3.key);
  return new mn({
    key: new gn("MILKDOWN_HARDBREAK_FILTER"),
    filterTransaction: (t, r) => {
      const i = t.getMeta("hardbreak"), [s] = t.steps;
      if (i && s) {
        const { from: o } = s, a = r.doc.resolve(o);
        let l = a.depth, c = !0;
        for (; l > 0; )
          e.includes(a.node(l).type.name) && (c = !1), l--;
        return c;
      }
      return !0;
    }
  });
});
oe(NL, {
  displayName: "Prose<hardbreakFilterPlugin>",
  group: "Prose"
});
const IL = jn((n) => {
  const e = new gn("MILKDOWN_HEADING_ID"), t = (r) => {
    if (r.composing) return;
    const i = n.get(fy.key), s = r.state.tr.setMeta("addToHistory", !1);
    let o = !1;
    const a = {};
    r.state.doc.descendants((l, c) => {
      if (l.type === wi.type(n)) {
        if (l.textContent.trim().length === 0) return;
        const u = l.attrs;
        let h = i(l);
        a[h] ? (a[h] += 1, h += `-#${a[h]}`) : a[h] = 1, u.id !== h && (o = !0, s.setMeta(e, !0).setNodeMarkup(c, void 0, {
          ...u,
          id: h
        }));
      }
    }), o && r.dispatch(s);
  };
  return new mn({
    key: e,
    view: (r) => (t(r), {
      update: (i, s) => {
        i.state.doc.eq(s.doc) || t(i);
      }
    })
  });
});
oe(IL, {
  displayName: "Prose<syncHeadingIdPlugin>",
  group: "Prose"
});
const _L = jn((n) => {
  const e = (t, r, i) => {
    if (!i.selection || t.some(
      (h) => h.getMeta("addToHistory") === !1 || !h.isGeneric
    ))
      return null;
    const s = Vc.type(n), o = Fc.type(n), a = As.type(n), l = (h, f) => {
      let m = !1;
      const y = `${f + 1}.`;
      return h.label !== y && (h.label = y, m = !0), m;
    };
    let c = i.tr, u = !1;
    return i.doc.descendants(
      (h, f, m, y) => {
        if (h.type === o) {
          const b = h.maybeChild(0);
          (b == null ? void 0 : b.type) === a && b.attrs.listType === "ordered" && (u = !0, c.setNodeMarkup(f, s, { spread: "true" }), h.descendants(
            (k, x, M, T) => {
              if (k.type === a) {
                const E = { ...k.attrs };
                l(E, T) && (c = c.setNodeMarkup(x, void 0, E));
              }
              return !1;
            }
          ));
        } else if (h.type === a && (m == null ? void 0 : m.type) === s) {
          const b = { ...h.attrs };
          let k = !1;
          b.listType !== "ordered" && (b.listType = "ordered", k = !0), (m == null ? void 0 : m.maybeChild(0)) && (k = l(b, y)), k && (c = c.setNodeMarkup(f, void 0, b), u = !0);
        }
      }
    ), u ? c.setMeta("addToHistory", !1) : null;
  };
  return new mn({
    key: new gn("MILKDOWN_KEEP_LIST_ORDER"),
    appendTransaction: e
  });
});
oe(_L, {
  displayName: "Prose<syncListOrderPlugin>",
  group: "Prose"
});
const nX = [
  DL,
  f3,
  NL,
  OL,
  a3,
  c3,
  l3,
  u3,
  h3,
  hy,
  IL,
  _L
].flat(), rX = [
  KY,
  GY,
  JY,
  YY,
  XY,
  nX
].flat();
function iX(n) {
  const e = Wt(
    {},
    `${n}_SLASH_SPEC`
  ), t = jn((i) => {
    const s = i.get(e.key);
    return new mn({
      key: new gn(`${n}_SLASH`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${n}`
  }, r;
}
var Xu, C0, M0, T0, A0, hc, E0, Zu, L0, O0, v1, RL;
class sX {
  constructor(e) {
    Se(this, v1);
    Se(this, Xu);
    /// @internal
    Se(this, C0);
    /// @internal
    Se(this, M0);
    /// @internal
    Se(this, T0);
    /// @internal
    Se(this, A0);
    /// @internal
    Se(this, hc);
    /// @internal
    Se(this, E0);
    /// @internal
    Se(this, Zu);
    /// The offset to get the block. Default is 0.
    Se(this, L0);
    Se(this, O0);
    re(this, Xu, !1), this.onShow = () => {
    }, this.onHide = () => {
    }, re(this, O0, (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: a } = i, { ranges: l } = o, c = Math.min(...l.map((m) => m.$from.pos)), u = Math.max(...l.map((m) => m.$to.pos)), h = r && r.doc.eq(a) && r.selection.eq(o);
      if (G(this, Xu) || ((G(this, T0) ?? t.dom.parentElement ?? document.body).appendChild(this.element), re(this, Xu, !0)), s || h) return;
      if (!G(this, E0).call(this, t, r)) {
        this.hide();
        return;
      }
      Cs({
        getBoundingClientRect: () => $1(t, c, u)
      }, this.element, {
        placement: "bottom-start",
        middleware: [e1(), ll(G(this, L0)), ...G(this, C0)],
        ...G(this, M0)
      }).then(({ x: m, y }) => {
        Object.assign(this.element.style, {
          left: `${m}px`,
          top: `${y}px`
        });
      }).catch(console.error), this.show();
    }), this.update = (t, r) => {
      G(this, Zu).call(this, t, r);
    }, this.getContent = (t, r = (i) => i.type.name === "paragraph") => {
      const { selection: i } = t.state, { empty: s, $from: o } = i, a = t.state.selection instanceof Ye;
      if (typeof document > "u") return;
      const l = this.element.contains(document.activeElement), c = !t.hasFocus() && !l, u = !t.editable, f = !W$(r)(t.state.selection);
      if (!(c || u || !s || !a || f))
        return o.parent.textBetween(
          Math.max(0, o.parentOffset - 500),
          o.parentOffset,
          void 0,
          "￼"
        );
    }, this.destroy = () => {
      G(this, Zu).cancel();
    }, this.show = () => {
      this.element.dataset.show = "true", this.onShow();
    }, this.hide = () => {
      this.element.dataset.show = "false", this.onHide();
    }, this.element = e.content, re(this, A0, e.debounce ?? 200), re(this, E0, e.shouldShow ?? Cp(this, v1, RL)), re(this, hc, e.trigger ?? "/"), re(this, L0, e.offset), re(this, C0, e.middleware ?? []), re(this, M0, e.floatingUIOptions ?? {}), re(this, T0, e.root), re(this, Zu, M1(G(this, O0), G(this, A0)));
  }
}
Xu = new WeakMap(), C0 = new WeakMap(), M0 = new WeakMap(), T0 = new WeakMap(), A0 = new WeakMap(), hc = new WeakMap(), E0 = new WeakMap(), Zu = new WeakMap(), L0 = new WeakMap(), O0 = new WeakMap(), v1 = new WeakSet(), /// @internal
RL = function(e) {
  const t = this.getContent(e);
  if (!t) return !1;
  const r = t.at(-1);
  return r ? Array.isArray(G(this, hc)) ? G(this, hc).includes(r) : G(this, hc) === r : !1;
};
function PL(n) {
  var e, t, r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object") if (Array.isArray(n)) {
    var i = n.length;
    for (e = 0; e < i; e++) n[e] && (t = PL(n[e])) && (r && (r += " "), r += t);
  } else for (t in n) n[t] && (r && (r += " "), r += t);
  return r;
}
function pr() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++) (n = arguments[t]) && (e = PL(n)) && (r && (r += " "), r += e);
  return r;
}
/*! @license DOMPurify 3.2.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.7/LICENSE */
const {
  entries: BL,
  setPrototypeOf: _8,
  isFrozen: oX,
  getPrototypeOf: aX,
  getOwnPropertyDescriptor: lX
} = Object;
let {
  freeze: Hr,
  seal: Zi,
  create: HL
} = Object, {
  apply: L4,
  construct: O4
} = typeof Reflect < "u" && Reflect;
Hr || (Hr = function(e) {
  return e;
});
Zi || (Zi = function(e) {
  return e;
});
L4 || (L4 = function(e, t) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), s = 2; s < r; s++)
    i[s - 2] = arguments[s];
  return e.apply(t, i);
});
O4 || (O4 = function(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    r[i - 1] = arguments[i];
  return new e(...r);
});
const Yp = zr(Array.prototype.forEach), cX = zr(Array.prototype.lastIndexOf), R8 = zr(Array.prototype.pop), of = zr(Array.prototype.push), uX = zr(Array.prototype.splice), Zm = zr(String.prototype.toLowerCase), i2 = zr(String.prototype.toString), s2 = zr(String.prototype.match), af = zr(String.prototype.replace), hX = zr(String.prototype.indexOf), fX = zr(String.prototype.trim), fs = zr(Object.prototype.hasOwnProperty), Er = zr(RegExp.prototype.test), lf = dX(TypeError);
function zr(n) {
  return function(e) {
    e instanceof RegExp && (e.lastIndex = 0);
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return L4(n, e, r);
  };
}
function dX(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    return O4(n, t);
  };
}
function Et(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Zm;
  _8 && _8(n, null);
  let r = e.length;
  for (; r--; ) {
    let i = e[r];
    if (typeof i == "string") {
      const s = t(i);
      s !== i && (oX(e) || (e[r] = s), i = s);
    }
    n[i] = !0;
  }
  return n;
}
function pX(n) {
  for (let e = 0; e < n.length; e++)
    fs(n, e) || (n[e] = null);
  return n;
}
function No(n) {
  const e = HL(null);
  for (const [t, r] of BL(n))
    fs(n, t) && (Array.isArray(r) ? e[t] = pX(r) : r && typeof r == "object" && r.constructor === Object ? e[t] = No(r) : e[t] = r);
  return e;
}
function cf(n, e) {
  for (; n !== null; ) {
    const r = lX(n, e);
    if (r) {
      if (r.get)
        return zr(r.get);
      if (typeof r.value == "function")
        return zr(r.value);
    }
    n = aX(n);
  }
  function t() {
    return null;
  }
  return t;
}
const P8 = Hr(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), o2 = Hr(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "slot", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), a2 = Hr(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), mX = Hr(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), l2 = Hr(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), gX = Hr(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), B8 = Hr(["#text"]), H8 = Hr(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), c2 = Hr(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), z8 = Hr(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Xp = Hr(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), yX = Zi(/\{\{[\w\W]*|[\w\W]*\}\}/gm), bX = Zi(/<%[\w\W]*|[\w\W]*%>/gm), vX = Zi(/\$\{[\w\W]*/gm), wX = Zi(/^data-[\-\w.\u00B7-\uFFFF]+$/), kX = Zi(/^aria-[\-\w]+$/), zL = Zi(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), xX = Zi(/^(?:\w+script|data):/i), SX = Zi(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), FL = Zi(/^html$/i), CX = Zi(/^[a-z][.\w]*(-[.\w]+)+$/i);
var F8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ARIA_ATTR: kX,
  ATTR_WHITESPACE: SX,
  CUSTOM_ELEMENT: CX,
  DATA_ATTR: wX,
  DOCTYPE_NAME: FL,
  ERB_EXPR: bX,
  IS_ALLOWED_URI: zL,
  IS_SCRIPT_OR_DATA: xX,
  MUSTACHE_EXPR: yX,
  TMPLIT_EXPR: vX
});
const uf = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, MX = function() {
  return typeof window > "u" ? null : window;
}, TX = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let r = null;
  const i = "data-tt-policy-suffix";
  t && t.hasAttribute(i) && (r = t.getAttribute(i));
  const s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML(o) {
        return o;
      },
      createScriptURL(o) {
        return o;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
}, V8 = function() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function VL() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : MX();
  const e = (Ke) => VL(Ke);
  if (e.version = "3.2.7", e.removed = [], !n || !n.document || n.document.nodeType !== uf.document || !n.Element)
    return e.isSupported = !1, e;
  let {
    document: t
  } = n;
  const r = t, i = r.currentScript, {
    DocumentFragment: s,
    HTMLTemplateElement: o,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: u = n.NamedNodeMap || n.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: f,
    trustedTypes: m
  } = n, y = l.prototype, b = cf(y, "cloneNode"), k = cf(y, "remove"), x = cf(y, "nextSibling"), M = cf(y, "childNodes"), T = cf(y, "parentNode");
  if (typeof o == "function") {
    const Ke = t.createElement("template");
    Ke.content && Ke.content.ownerDocument && (t = Ke.content.ownerDocument);
  }
  let E, C = "";
  const {
    implementation: O,
    createNodeIterator: R,
    createDocumentFragment: F,
    getElementsByTagName: H
  } = t, {
    importNode: z
  } = r;
  let K = V8();
  e.isSupported = typeof BL == "function" && typeof T == "function" && O && O.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: U,
    ERB_EXPR: ae,
    TMPLIT_EXPR: ie,
    DATA_ATTR: he,
    ARIA_ATTR: Ie,
    IS_SCRIPT_OR_DATA: Oe,
    ATTR_WHITESPACE: Ne,
    CUSTOM_ELEMENT: We
  } = F8;
  let {
    IS_ALLOWED_URI: q
  } = F8, Re = null;
  const J = Et({}, [...P8, ...o2, ...a2, ...l2, ...B8]);
  let V = null;
  const _t = Et({}, [...H8, ...c2, ...z8, ...Xp]);
  let at = Object.seal(HL(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), mt = null, le = null, tt = !0, xe = !0, ge = !1, Ot = !0, Ee = !1, Ft = !0, ft = !1, Vt = !1, Ue = !1, yt = !1, Ut = !1, Kt = !1, ci = !0, Ds = !1;
  const yo = "user-content-";
  let Ns = !0, mr = !1, kt = {}, ne = null;
  const Ce = Et({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let it = null;
  const dt = Et({}, ["audio", "video", "img", "source", "image", "track"]);
  let Dt = null;
  const Un = Et({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Kn = "http://www.w3.org/1998/Math/MathML", Cn = "http://www.w3.org/2000/svg", Mn = "http://www.w3.org/1999/xhtml";
  let Dn = Mn, Tn = !1, Gt = null;
  const An = Et({}, [Kn, Cn, Mn], i2);
  let Pn = Et({}, ["mi", "mo", "mn", "ms", "mtext"]), Is = Et({}, ["annotation-xml"]);
  const ss = Et({}, ["title", "style", "font", "a", "script"]);
  let Mr = null;
  const ir = ["application/xhtml+xml", "text/html"], _s = "text/html";
  let cn = null, as = null;
  const Tr = t.createElement("form"), Gn = function(Y) {
    return Y instanceof RegExp || Y instanceof Function;
  }, ui = function() {
    let Y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(as && as === Y)) {
      if ((!Y || typeof Y != "object") && (Y = {}), Y = No(Y), Mr = // eslint-disable-next-line unicorn/prefer-includes
      ir.indexOf(Y.PARSER_MEDIA_TYPE) === -1 ? _s : Y.PARSER_MEDIA_TYPE, cn = Mr === "application/xhtml+xml" ? i2 : Zm, Re = fs(Y, "ALLOWED_TAGS") ? Et({}, Y.ALLOWED_TAGS, cn) : J, V = fs(Y, "ALLOWED_ATTR") ? Et({}, Y.ALLOWED_ATTR, cn) : _t, Gt = fs(Y, "ALLOWED_NAMESPACES") ? Et({}, Y.ALLOWED_NAMESPACES, i2) : An, Dt = fs(Y, "ADD_URI_SAFE_ATTR") ? Et(No(Un), Y.ADD_URI_SAFE_ATTR, cn) : Un, it = fs(Y, "ADD_DATA_URI_TAGS") ? Et(No(dt), Y.ADD_DATA_URI_TAGS, cn) : dt, ne = fs(Y, "FORBID_CONTENTS") ? Et({}, Y.FORBID_CONTENTS, cn) : Ce, mt = fs(Y, "FORBID_TAGS") ? Et({}, Y.FORBID_TAGS, cn) : No({}), le = fs(Y, "FORBID_ATTR") ? Et({}, Y.FORBID_ATTR, cn) : No({}), kt = fs(Y, "USE_PROFILES") ? Y.USE_PROFILES : !1, tt = Y.ALLOW_ARIA_ATTR !== !1, xe = Y.ALLOW_DATA_ATTR !== !1, ge = Y.ALLOW_UNKNOWN_PROTOCOLS || !1, Ot = Y.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ee = Y.SAFE_FOR_TEMPLATES || !1, Ft = Y.SAFE_FOR_XML !== !1, ft = Y.WHOLE_DOCUMENT || !1, yt = Y.RETURN_DOM || !1, Ut = Y.RETURN_DOM_FRAGMENT || !1, Kt = Y.RETURN_TRUSTED_TYPE || !1, Ue = Y.FORCE_BODY || !1, ci = Y.SANITIZE_DOM !== !1, Ds = Y.SANITIZE_NAMED_PROPS || !1, Ns = Y.KEEP_CONTENT !== !1, mr = Y.IN_PLACE || !1, q = Y.ALLOWED_URI_REGEXP || zL, Dn = Y.NAMESPACE || Mn, Pn = Y.MATHML_TEXT_INTEGRATION_POINTS || Pn, Is = Y.HTML_INTEGRATION_POINTS || Is, at = Y.CUSTOM_ELEMENT_HANDLING || {}, Y.CUSTOM_ELEMENT_HANDLING && Gn(Y.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (at.tagNameCheck = Y.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Y.CUSTOM_ELEMENT_HANDLING && Gn(Y.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (at.attributeNameCheck = Y.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Y.CUSTOM_ELEMENT_HANDLING && typeof Y.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (at.allowCustomizedBuiltInElements = Y.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ee && (xe = !1), Ut && (yt = !0), kt && (Re = Et({}, B8), V = [], kt.html === !0 && (Et(Re, P8), Et(V, H8)), kt.svg === !0 && (Et(Re, o2), Et(V, c2), Et(V, Xp)), kt.svgFilters === !0 && (Et(Re, a2), Et(V, c2), Et(V, Xp)), kt.mathMl === !0 && (Et(Re, l2), Et(V, z8), Et(V, Xp))), Y.ADD_TAGS && (Re === J && (Re = No(Re)), Et(Re, Y.ADD_TAGS, cn)), Y.ADD_ATTR && (V === _t && (V = No(V)), Et(V, Y.ADD_ATTR, cn)), Y.ADD_URI_SAFE_ATTR && Et(Dt, Y.ADD_URI_SAFE_ATTR, cn), Y.FORBID_CONTENTS && (ne === Ce && (ne = No(ne)), Et(ne, Y.FORBID_CONTENTS, cn)), Ns && (Re["#text"] = !0), ft && Et(Re, ["html", "head", "body"]), Re.table && (Et(Re, ["tbody"]), delete mt.tbody), Y.TRUSTED_TYPES_POLICY) {
        if (typeof Y.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw lf('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof Y.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw lf('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        E = Y.TRUSTED_TYPES_POLICY, C = E.createHTML("");
      } else
        E === void 0 && (E = TX(m, i)), E !== null && typeof C == "string" && (C = E.createHTML(""));
      Hr && Hr(Y), as = Y;
    }
  }, ba = Et({}, [...o2, ...a2, ...mX]), kl = Et({}, [...l2, ...gX]), Wc = function(Y) {
    let be = T(Y);
    (!be || !be.tagName) && (be = {
      namespaceURI: Dn,
      tagName: "template"
    });
    const Ve = Zm(Y.tagName), qt = Zm(be.tagName);
    return Gt[Y.namespaceURI] ? Y.namespaceURI === Cn ? be.namespaceURI === Mn ? Ve === "svg" : be.namespaceURI === Kn ? Ve === "svg" && (qt === "annotation-xml" || Pn[qt]) : !!ba[Ve] : Y.namespaceURI === Kn ? be.namespaceURI === Mn ? Ve === "math" : be.namespaceURI === Cn ? Ve === "math" && Is[qt] : !!kl[Ve] : Y.namespaceURI === Mn ? be.namespaceURI === Cn && !Is[qt] || be.namespaceURI === Kn && !Pn[qt] ? !1 : !kl[Ve] && (ss[Ve] || !ba[Ve]) : !!(Mr === "application/xhtml+xml" && Gt[Y.namespaceURI]) : !1;
  }, Tt = function(Y) {
    of(e.removed, {
      element: Y
    });
    try {
      T(Y).removeChild(Y);
    } catch {
      k(Y);
    }
  }, Ii = function(Y, be) {
    try {
      of(e.removed, {
        attribute: be.getAttributeNode(Y),
        from: be
      });
    } catch {
      of(e.removed, {
        attribute: null,
        from: be
      });
    }
    if (be.removeAttribute(Y), Y === "is")
      if (yt || Ut)
        try {
          Tt(be);
        } catch {
        }
      else
        try {
          be.setAttribute(Y, "");
        } catch {
        }
  }, hi = function(Y) {
    let be = null, Ve = null;
    if (Ue)
      Y = "<remove></remove>" + Y;
    else {
      const gt = s2(Y, /^[\r\n\t ]+/);
      Ve = gt && gt[0];
    }
    Mr === "application/xhtml+xml" && Dn === Mn && (Y = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Y + "</body></html>");
    const qt = E ? E.createHTML(Y) : Y;
    if (Dn === Mn)
      try {
        be = new f().parseFromString(qt, Mr);
      } catch {
      }
    if (!be || !be.documentElement) {
      be = O.createDocument(Dn, "template", null);
      try {
        be.documentElement.innerHTML = Tn ? C : qt;
      } catch {
      }
    }
    const Nn = be.body || be.documentElement;
    return Y && Ve && Nn.insertBefore(t.createTextNode(Ve), Nn.childNodes[0] || null), Dn === Mn ? H.call(be, ft ? "html" : "body")[0] : ft ? be.documentElement : Nn;
  }, xl = function(Y) {
    return R.call(
      Y.ownerDocument || Y,
      Y,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, _i = function(Y) {
    return Y instanceof h && (typeof Y.nodeName != "string" || typeof Y.textContent != "string" || typeof Y.removeChild != "function" || !(Y.attributes instanceof u) || typeof Y.removeAttribute != "function" || typeof Y.setAttribute != "function" || typeof Y.namespaceURI != "string" || typeof Y.insertBefore != "function" || typeof Y.hasChildNodes != "function");
  }, bo = function(Y) {
    return typeof a == "function" && Y instanceof a;
  };
  function Ar(Ke, Y, be) {
    Yp(Ke, (Ve) => {
      Ve.call(e, Y, be, as);
    });
  }
  const vo = function(Y) {
    let be = null;
    if (Ar(K.beforeSanitizeElements, Y, null), _i(Y))
      return Tt(Y), !0;
    const Ve = cn(Y.nodeName);
    if (Ar(K.uponSanitizeElement, Y, {
      tagName: Ve,
      allowedTags: Re
    }), Ft && Y.hasChildNodes() && !bo(Y.firstElementChild) && Er(/<[/\w!]/g, Y.innerHTML) && Er(/<[/\w!]/g, Y.textContent) || Y.nodeType === uf.progressingInstruction || Ft && Y.nodeType === uf.comment && Er(/<[/\w]/g, Y.data))
      return Tt(Y), !0;
    if (!Re[Ve] || mt[Ve]) {
      if (!mt[Ve] && ko(Ve) && (at.tagNameCheck instanceof RegExp && Er(at.tagNameCheck, Ve) || at.tagNameCheck instanceof Function && at.tagNameCheck(Ve)))
        return !1;
      if (Ns && !ne[Ve]) {
        const qt = T(Y) || Y.parentNode, Nn = M(Y) || Y.childNodes;
        if (Nn && qt) {
          const gt = Nn.length;
          for (let Bn = gt - 1; Bn >= 0; --Bn) {
            const Vr = b(Nn[Bn], !0);
            Vr.__removalCount = (Y.__removalCount || 0) + 1, qt.insertBefore(Vr, x(Y));
          }
        }
      }
      return Tt(Y), !0;
    }
    return Y instanceof l && !Wc(Y) || (Ve === "noscript" || Ve === "noembed" || Ve === "noframes") && Er(/<\/no(script|embed|frames)/i, Y.innerHTML) ? (Tt(Y), !0) : (Ee && Y.nodeType === uf.text && (be = Y.textContent, Yp([U, ae, ie], (qt) => {
      be = af(be, qt, " ");
    }), Y.textContent !== be && (of(e.removed, {
      element: Y.cloneNode()
    }), Y.textContent = be)), Ar(K.afterSanitizeElements, Y, null), !1);
  }, wo = function(Y, be, Ve) {
    if (ci && (be === "id" || be === "name") && (Ve in t || Ve in Tr))
      return !1;
    if (!(xe && !le[be] && Er(he, be))) {
      if (!(tt && Er(Ie, be))) {
        if (!V[be] || le[be]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(ko(Y) && (at.tagNameCheck instanceof RegExp && Er(at.tagNameCheck, Y) || at.tagNameCheck instanceof Function && at.tagNameCheck(Y)) && (at.attributeNameCheck instanceof RegExp && Er(at.attributeNameCheck, be) || at.attributeNameCheck instanceof Function && at.attributeNameCheck(be, Y)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            be === "is" && at.allowCustomizedBuiltInElements && (at.tagNameCheck instanceof RegExp && Er(at.tagNameCheck, Ve) || at.tagNameCheck instanceof Function && at.tagNameCheck(Ve)))
          ) return !1;
        } else if (!Dt[be]) {
          if (!Er(q, af(Ve, Ne, ""))) {
            if (!((be === "src" || be === "xlink:href" || be === "href") && Y !== "script" && hX(Ve, "data:") === 0 && it[Y])) {
              if (!(ge && !Er(Oe, af(Ve, Ne, "")))) {
                if (Ve)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ko = function(Y) {
    return Y !== "annotation-xml" && s2(Y, We);
  }, xo = function(Y) {
    Ar(K.beforeSanitizeAttributes, Y, null);
    const {
      attributes: be
    } = Y;
    if (!be || _i(Y))
      return;
    const Ve = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: V,
      forceKeepAttr: void 0
    };
    let qt = be.length;
    for (; qt--; ) {
      const Nn = be[qt], {
        name: gt,
        namespaceURI: Bn,
        value: Vr
      } = Nn, Ri = cn(gt), So = Vr;
      let En = gt === "value" ? So : fX(So);
      if (Ve.attrName = Ri, Ve.attrValue = En, Ve.keepAttr = !0, Ve.forceKeepAttr = void 0, Ar(K.uponSanitizeAttribute, Y, Ve), En = Ve.attrValue, Ds && (Ri === "id" || Ri === "name") && (Ii(gt, Y), En = yo + En), Ft && Er(/((--!?|])>)|<\/(style|title|textarea)/i, En)) {
        Ii(gt, Y);
        continue;
      }
      if (Ri === "attributename" && s2(En, "href")) {
        Ii(gt, Y);
        continue;
      }
      if (Ve.forceKeepAttr)
        continue;
      if (!Ve.keepAttr) {
        Ii(gt, Y);
        continue;
      }
      if (!Ot && Er(/\/>/i, En)) {
        Ii(gt, Y);
        continue;
      }
      Ee && Yp([U, ae, ie], (Cl) => {
        En = af(En, Cl, " ");
      });
      const Sl = cn(Y.nodeName);
      if (!wo(Sl, Ri, En)) {
        Ii(gt, Y);
        continue;
      }
      if (E && typeof m == "object" && typeof m.getAttributeType == "function" && !Bn)
        switch (m.getAttributeType(Sl, Ri)) {
          case "TrustedHTML": {
            En = E.createHTML(En);
            break;
          }
          case "TrustedScriptURL": {
            En = E.createScriptURL(En);
            break;
          }
        }
      if (En !== So)
        try {
          Bn ? Y.setAttributeNS(Bn, gt, En) : Y.setAttribute(gt, En), _i(Y) ? Tt(Y) : R8(e.removed);
        } catch {
          Ii(gt, Y);
        }
    }
    Ar(K.afterSanitizeAttributes, Y, null);
  }, un = function Ke(Y) {
    let be = null;
    const Ve = xl(Y);
    for (Ar(K.beforeSanitizeShadowDOM, Y, null); be = Ve.nextNode(); )
      Ar(K.uponSanitizeShadowNode, be, null), vo(be), xo(be), be.content instanceof s && Ke(be.content);
    Ar(K.afterSanitizeShadowDOM, Y, null);
  };
  return e.sanitize = function(Ke) {
    let Y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, be = null, Ve = null, qt = null, Nn = null;
    if (Tn = !Ke, Tn && (Ke = "<!-->"), typeof Ke != "string" && !bo(Ke))
      if (typeof Ke.toString == "function") {
        if (Ke = Ke.toString(), typeof Ke != "string")
          throw lf("dirty is not a string, aborting");
      } else
        throw lf("toString is not a function");
    if (!e.isSupported)
      return Ke;
    if (Vt || ui(Y), e.removed = [], typeof Ke == "string" && (mr = !1), mr) {
      if (Ke.nodeName) {
        const Vr = cn(Ke.nodeName);
        if (!Re[Vr] || mt[Vr])
          throw lf("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Ke instanceof a)
      be = hi("<!---->"), Ve = be.ownerDocument.importNode(Ke, !0), Ve.nodeType === uf.element && Ve.nodeName === "BODY" || Ve.nodeName === "HTML" ? be = Ve : be.appendChild(Ve);
    else {
      if (!yt && !Ee && !ft && // eslint-disable-next-line unicorn/prefer-includes
      Ke.indexOf("<") === -1)
        return E && Kt ? E.createHTML(Ke) : Ke;
      if (be = hi(Ke), !be)
        return yt ? null : Kt ? C : "";
    }
    be && Ue && Tt(be.firstChild);
    const gt = xl(mr ? Ke : be);
    for (; qt = gt.nextNode(); )
      vo(qt), xo(qt), qt.content instanceof s && un(qt.content);
    if (mr)
      return Ke;
    if (yt) {
      if (Ut)
        for (Nn = F.call(be.ownerDocument); be.firstChild; )
          Nn.appendChild(be.firstChild);
      else
        Nn = be;
      return (V.shadowroot || V.shadowrootmode) && (Nn = z.call(r, Nn, !0)), Nn;
    }
    let Bn = ft ? be.outerHTML : be.innerHTML;
    return ft && Re["!doctype"] && be.ownerDocument && be.ownerDocument.doctype && be.ownerDocument.doctype.name && Er(FL, be.ownerDocument.doctype.name) && (Bn = "<!DOCTYPE " + be.ownerDocument.doctype.name + `>
` + Bn), Ee && Yp([U, ae, ie], (Vr) => {
      Bn = af(Bn, Vr, " ");
    }), E && Kt ? E.createHTML(Bn) : Bn;
  }, e.setConfig = function() {
    let Ke = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ui(Ke), Vt = !0;
  }, e.clearConfig = function() {
    as = null, Vt = !1;
  }, e.isValidAttribute = function(Ke, Y, be) {
    as || ui({});
    const Ve = cn(Ke), qt = cn(Y);
    return wo(Ve, qt, be);
  }, e.addHook = function(Ke, Y) {
    typeof Y == "function" && of(K[Ke], Y);
  }, e.removeHook = function(Ke, Y) {
    if (Y !== void 0) {
      const be = cX(K[Ke], Y);
      return be === -1 ? void 0 : uX(K[Ke], be, 1)[0];
    }
    return R8(K[Ke]);
  }, e.removeHooks = function(Ke) {
    K[Ke] = [];
  }, e.removeAllHooks = function() {
    K = V8();
  }, e;
}
var Es = VL();
function yh({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
yh.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var AX = Object.defineProperty, q8 = Object.getOwnPropertySymbols, EX = Object.prototype.hasOwnProperty, LX = Object.prototype.propertyIsEnumerable, $8 = (n, e, t) => e in n ? AX(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, OX = (n, e) => {
  for (var t in e || (e = {}))
    EX.call(e, t) && $8(n, t, e[t]);
  if (q8)
    for (var t of q8(e))
      LX.call(e, t) && $8(n, t, e[t]);
  return n;
};
function Q0(n, e) {
  return Object.assign(n, {
    meta: OX({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const DX = {
  imageIcon: "🌌",
  captionIcon: "💬",
  uploadButton: "Upload file",
  confirmButton: "Confirm ⏎",
  uploadPlaceholderText: "or paste the image link ...",
  captionPlaceholderText: "Image caption",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, dy = Wt(
  DX,
  "imageBlockConfigCtx"
);
Q0(dy, {
  displayName: "Config<image-block>",
  group: "ImageBlock"
});
function NX(n) {
  return ml(
    n,
    "paragraph",
    (e, t, r) => {
      var i, s;
      if (((i = e.children) == null ? void 0 : i.length) !== 1) return;
      const o = (s = e.children) == null ? void 0 : s[0];
      if (!o || o.type !== "image") return;
      const { url: a, alt: l, title: c } = o, u = {
        type: "image-block",
        url: a,
        alt: l,
        title: c
      };
      r.children.splice(t, 1, u);
    }
  );
}
const d3 = co(
  "remark-image-block",
  () => () => NX
);
Q0(d3.plugin, {
  displayName: "Remark<remarkImageBlock>",
  group: "ImageBlock"
});
Q0(d3.options, {
  displayName: "RemarkConfig<remarkImageBlock>",
  group: "ImageBlock"
});
var IX = Object.defineProperty, j8 = Object.getOwnPropertySymbols, _X = Object.prototype.hasOwnProperty, RX = Object.prototype.propertyIsEnumerable, W8 = (n, e, t) => e in n ? IX(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, PX = (n, e) => {
  for (var t in e || (e = {}))
    _X.call(e, t) && W8(n, t, e[t]);
  if (j8)
    for (var t of j8(e))
      RX.call(e, t) && W8(n, t, e[t]);
  return n;
};
const D4 = "image-block", py = Rn("image-block", () => ({
  inline: !1,
  group: "block",
  selectable: !0,
  draggable: !0,
  isolating: !0,
  marks: "",
  atom: !0,
  priority: 100,
  attrs: {
    src: { default: "", validate: "string" },
    caption: { default: "", validate: "string" },
    ratio: { default: 1, validate: "number" }
  },
  parseDOM: [
    {
      tag: `img[data-type="${D4}"]`,
      getAttrs: (n) => {
        var e;
        if (!(n instanceof HTMLElement)) throw Ms(n);
        return {
          src: n.getAttribute("src") || "",
          caption: n.getAttribute("caption") || "",
          ratio: Number((e = n.getAttribute("ratio")) != null ? e : 1)
        };
      }
    }
  ],
  toDOM: (n) => ["img", PX({ "data-type": D4 }, n.attrs)],
  parseMarkdown: {
    match: ({ type: n }) => n === "image-block",
    runner: (n, e, t) => {
      const r = e.url, i = e.title;
      let s = Number(e.alt || 1);
      (Number.isNaN(s) || s === 0) && (s = 1), n.addNode(t, {
        src: r,
        caption: i,
        ratio: s
      });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "image-block",
    runner: (n, e) => {
      n.openNode("paragraph"), n.addNode("image", void 0, void 0, {
        title: e.attrs.caption,
        url: e.attrs.src,
        alt: `${Number.parseFloat(e.attrs.ratio).toFixed(2)}`
      }), n.closeNode();
    }
  }
}));
Q0(py.node, {
  displayName: "NodeSchema<image-block>",
  group: "ImageBlock"
});
function wd({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
wd.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const BX = b5("abcdefg", 8), HX = Xn({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: a,
    className: l
  }) {
    var c, u;
    const h = Be(!1), f = Be(), m = Be((c = e.value) != null ? c : ""), y = Be(BX()), b = Be(((u = e.value) == null ? void 0 : u.length) !== 0), k = (E) => {
      const O = E.target.value;
      b.value = O.length !== 0, m.value = O;
    }, x = (E) => {
      var C, O;
      E.key === "Enter" && t((O = (C = f.value) == null ? void 0 : C.value) != null ? O : "");
    }, M = () => {
      var E, C;
      t((C = (E = f.value) == null ? void 0 : E.value) != null ? C : "");
    }, T = (E) => {
      var C;
      const O = (C = E.target.files) == null ? void 0 : C[0];
      O && r(O).then((R) => {
        R && (t(R), b.value = !0);
      }).catch((R) => {
        console.error("An error occurred while uploading image"), console.error(R);
      });
    };
    return () => /* @__PURE__ */ te("div", { class: pr("image-edit", l) }, /* @__PURE__ */ te(wd, { icon: i, class: "image-icon" }), /* @__PURE__ */ te("div", { class: pr("link-importer", h.value && "focus") }, /* @__PURE__ */ te(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (E) => {
          E.preventDefault(), E.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: m.value,
        onInput: k,
        onKeydown: x,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !b.value && /* @__PURE__ */ te("div", { class: "placeholder" }, /* @__PURE__ */ te(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: y.value,
        type: "file",
        accept: "image/*",
        onChange: T
      }
    ), /* @__PURE__ */ te("label", { class: "uploader", for: y.value }, /* @__PURE__ */ te(wd, { icon: s })), /* @__PURE__ */ te("span", { class: "text", onClick: () => {
      var E;
      return (E = f.value) == null ? void 0 : E.focus();
    } }, a))), m.value && /* @__PURE__ */ te("div", { class: "confirm", onClick: () => M() }, /* @__PURE__ */ te(wd, { icon: o })));
  }
}), zX = Xn({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup({ src: n, caption: e, ratio: t, readonly: r, setAttr: i, config: s }) {
    var o;
    const a = Be(), l = Be(), c = Be(!!((o = e.value) != null && o.length)), u = Be(0), h = () => {
      var M;
      const T = a.value;
      if (!T) return;
      const E = T.closest(".milkdown-image-block");
      if (!E) return;
      const C = E.getBoundingClientRect().width;
      if (!C) return;
      const O = T.height, R = T.width, F = R < C ? O : C * (O / R), H = (F * ((M = t.value) != null ? M : 1)).toFixed(2);
      T.dataset.origin = F.toFixed(2), T.dataset.height = H, T.style.height = `${H}px`;
    }, f = (M) => {
      M.preventDefault(), M.stopPropagation(), !r.value && (c.value = !c.value);
    }, m = (M) => {
      const E = M.target.value;
      u.value && window.clearTimeout(u.value), u.value = window.setTimeout(() => {
        i("caption", E);
      }, 1e3);
    }, y = (M) => {
      const E = M.target.value;
      u.value && (window.clearTimeout(u.value), u.value = 0), i("caption", E);
    }, b = (M) => {
      M.preventDefault();
      const T = a.value;
      if (!T) return;
      const E = T.getBoundingClientRect().top, C = M.clientY - E, O = Number(C < 100 ? 100 : C).toFixed(2);
      T.dataset.height = O, T.style.height = `${O}px`;
    }, k = () => {
      window.removeEventListener("pointermove", b), window.removeEventListener("pointerup", k);
      const M = a.value;
      if (!M) return;
      const T = Number(M.dataset.origin), E = Number(M.dataset.height), C = Number.parseFloat(
        Number(E / T).toFixed(2)
      );
      Number.isNaN(C) || i("ratio", C);
    }, x = (M) => {
      r.value || (M.preventDefault(), M.stopPropagation(), window.addEventListener("pointermove", b), window.addEventListener("pointerup", k));
    };
    return () => /* @__PURE__ */ te(Rc, null, /* @__PURE__ */ te("div", { class: "image-wrapper" }, /* @__PURE__ */ te("div", { class: "operation" }, /* @__PURE__ */ te("div", { class: "operation-item", onPointerdown: f }, /* @__PURE__ */ te(wd, { icon: s.captionIcon }))), /* @__PURE__ */ te(
      "img",
      {
        ref: a,
        "data-type": D4,
        onLoad: h,
        src: n.value,
        alt: e.value
      }
    ), /* @__PURE__ */ te(
      "div",
      {
        ref: l,
        class: "image-resize-handle",
        onPointerdown: x
      }
    )), c.value && /* @__PURE__ */ te(
      "input",
      {
        draggable: "true",
        onDragstart: (M) => {
          M.preventDefault(), M.stopPropagation();
        },
        class: "caption-input",
        placeholder: s == null ? void 0 : s.captionPlaceholderText,
        onInput: m,
        onBlur: y,
        value: e.value
      }
    ));
  }
});
var FX = Object.defineProperty, U8 = Object.getOwnPropertySymbols, VX = Object.prototype.hasOwnProperty, qX = Object.prototype.propertyIsEnumerable, K8 = (n, e, t) => e in n ? FX(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, $X = (n, e) => {
  for (var t in e || (e = {}))
    VX.call(e, t) && K8(n, t, e[t]);
  if (U8)
    for (var t of U8(e))
      qX.call(e, t) && K8(n, t, e[t]);
  return n;
};
const jX = Xn({
  props: {
    src: {
      type: Object,
      required: !0
    },
    caption: {
      type: Object,
      required: !0
    },
    ratio: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e } = n;
    return () => {
      var t;
      return (t = e.value) != null && t.length ? /* @__PURE__ */ te(zX, $X({}, n)) : /* @__PURE__ */ te(
        HX,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (r) => n.setAttr("src", r),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload
        }
      );
    };
  }
}), qL = J0(
  py.node,
  (n) => (e, t, r) => {
    const i = Be(e.attrs.src), s = Be(e.attrs.caption), o = Be(e.attrs.ratio), a = Be(!1), l = Be(!t.editable), c = (k, x) => {
      if (!t.editable) return;
      const M = r();
      M != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          M,
          k,
          k === "src" ? Es.sanitize(x) : x
        )
      );
    }, u = n.get(dy.key), h = ns(jX, {
      src: i,
      caption: s,
      ratio: o,
      selected: a,
      readonly: l,
      setAttr: c,
      config: u
    }), f = document.createElement("div");
    f.className = "milkdown-image-block";
    const m = Ch(() => {
      a.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), y = u.proxyDomURL, b = (k) => {
      if (!y)
        i.value = k.attrs.src;
      else {
        const x = y(k.attrs.src);
        typeof x == "string" ? i.value = x : x.then((M) => {
          i.value = M;
        }).catch(console.error);
      }
      o.value = k.attrs.ratio, s.value = k.attrs.caption, l.value = !t.editable;
    };
    return b(e), h.mount(f), {
      dom: f,
      update: (k) => k.type !== e.type ? !1 : (b(k), !0),
      stopEvent: (k) => k.target instanceof HTMLInputElement,
      selectNode: () => {
        a.value = !0;
      },
      deselectNode: () => {
        a.value = !1;
      },
      destroy: () => {
        m(), h.unmount(), f.remove();
      }
    };
  }
);
Q0(qL, {
  displayName: "NodeView<image-block>",
  group: "ImageBlock"
});
const WX = [
  d3,
  py,
  qL,
  dy
].flat();
var N4, I4;
if (typeof WeakMap < "u") {
  let n = /* @__PURE__ */ new WeakMap();
  N4 = (e) => n.get(e), I4 = (e, t) => (n.set(e, t), t);
} else {
  const n = [];
  let t = 0;
  N4 = (r) => {
    for (let i = 0; i < n.length; i += 2)
      if (n[i] == r) return n[i + 1];
  }, I4 = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i);
}
var $t = class {
  constructor(n, e, t, r) {
    this.width = n, this.height = e, this.map = t, this.problems = r;
  }
  // Find the dimensions of the cell at the given position.
  findCell(n) {
    for (let e = 0; e < this.map.length; e++) {
      const t = this.map[e];
      if (t != n) continue;
      const r = e % this.width, i = e / this.width | 0;
      let s = r + 1, o = i + 1;
      for (let a = 1; s < this.width && this.map[e + a] == t; a++)
        s++;
      for (let a = 1; o < this.height && this.map[e + this.width * a] == t; a++)
        o++;
      return { left: r, top: i, right: s, bottom: o };
    }
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(n) {
    for (let e = 0; e < this.map.length; e++)
      if (this.map[e] == n)
        return e % this.width;
    throw new RangeError(`No cell with offset ${n} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(n, e, t) {
    const { left: r, right: i, top: s, bottom: o } = this.findCell(n);
    return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[s * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? s == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? s - 1 : o)];
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(n, e) {
    const {
      left: t,
      right: r,
      top: i,
      bottom: s
    } = this.findCell(n), {
      left: o,
      right: a,
      top: l,
      bottom: c
    } = this.findCell(e);
    return {
      left: Math.min(t, o),
      top: Math.min(i, l),
      right: Math.max(r, a),
      bottom: Math.max(s, c)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(n) {
    const e = [], t = {};
    for (let r = n.top; r < n.bottom; r++)
      for (let i = n.left; i < n.right; i++) {
        const s = r * this.width + i, o = this.map[s];
        t[o] || (t[o] = !0, !(i == n.left && i && this.map[s - 1] == o || r == n.top && r && this.map[s - this.width] == o) && e.push(o));
      }
    return e;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(n, e, t) {
    for (let r = 0, i = 0; ; r++) {
      const s = i + t.child(r).nodeSize;
      if (r == n) {
        let o = e + n * this.width;
        const a = (n + 1) * this.width;
        for (; o < a && this.map[o] < i; ) o++;
        return o == a ? s - 1 : this.map[o];
      }
      i = s;
    }
  }
  // Find the table map for the given table node.
  static get(n) {
    return N4(n) || I4(n, UX(n));
  }
};
function UX(n) {
  if (n.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + n.type.name);
  const e = KX(n), t = n.childCount, r = [];
  let i = 0, s = null;
  const o = [];
  for (let c = 0, u = e * t; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < t; c++) {
    const h = n.child(c);
    u++;
    for (let y = 0; ; y++) {
      for (; i < r.length && r[i] != 0; ) i++;
      if (y == h.childCount) break;
      const b = h.child(y), { colspan: k, rowspan: x, colwidth: M } = b.attrs;
      for (let T = 0; T < x; T++) {
        if (T + c >= t) {
          (s || (s = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: x - T
          });
          break;
        }
        const E = i + T * e;
        for (let C = 0; C < k; C++) {
          r[E + C] == 0 ? r[E + C] = u : (s || (s = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: k - C
          });
          const O = M && M[C];
          if (O) {
            const R = (E + C) % e * 2, F = o[R];
            F == null || F != O && o[R + 1] == 1 ? (o[R] = O, o[R + 1] = 1) : F == O && o[R + 1]++;
          }
        }
      }
      i += k, u += b.nodeSize;
    }
    const f = (c + 1) * e;
    let m = 0;
    for (; i < f; ) r[i++] == 0 && m++;
    m && (s || (s = [])).push({ type: "missing", row: c, n: m }), u++;
  }
  (e === 0 || t === 0) && (s || (s = [])).push({ type: "zero_sized" });
  const a = new $t(e, t, r, s);
  let l = !1;
  for (let c = 0; !l && c < o.length; c += 2)
    o[c] != null && o[c + 1] < t && (l = !0);
  return l && GX(a, o, n), a;
}
function KX(n) {
  let e = -1, t = !1;
  for (let r = 0; r < n.childCount; r++) {
    const i = n.child(r);
    let s = 0;
    if (t)
      for (let o = 0; o < r; o++) {
        const a = n.child(o);
        for (let l = 0; l < a.childCount; l++) {
          const c = a.child(l);
          o + c.attrs.rowspan > r && (s += c.attrs.colspan);
        }
      }
    for (let o = 0; o < i.childCount; o++) {
      const a = i.child(o);
      s += a.attrs.colspan, a.attrs.rowspan > 1 && (t = !0);
    }
    e == -1 ? e = s : e != s && (e = Math.max(e, s));
  }
  return e;
}
function GX(n, e, t) {
  n.problems || (n.problems = []);
  const r = {};
  for (let i = 0; i < n.map.length; i++) {
    const s = n.map[i];
    if (r[s]) continue;
    r[s] = !0;
    const o = t.nodeAt(s);
    if (!o)
      throw new RangeError(`No cell with offset ${s} found`);
    let a = null;
    const l = o.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = (i + c) % n.width, h = e[u * 2];
      h != null && (!l.colwidth || l.colwidth[c] != h) && ((a || (a = JX(l)))[c] = h);
    }
    a && n.problems.unshift({
      type: "colwidth mismatch",
      pos: s,
      colwidth: a
    });
  }
}
function JX(n) {
  if (n.colwidth) return n.colwidth.slice();
  const e = [];
  for (let t = 0; t < n.colspan; t++) e.push(0);
  return e;
}
function G8(n, e) {
  if (typeof n == "string")
    return {};
  const t = n.getAttribute("data-colwidth"), r = t && /^\d+(,\d+)*$/.test(t) ? t.split(",").map((o) => Number(o)) : null, i = Number(n.getAttribute("colspan") || 1), s = {
    colspan: i,
    rowspan: Number(n.getAttribute("rowspan") || 1),
    colwidth: r && r.length == i ? r : null
  };
  for (const o in e) {
    const a = e[o].getFromDOM, l = a && a(n);
    l != null && (s[o] = l);
  }
  return s;
}
function J8(n, e) {
  const t = {};
  n.attrs.colspan != 1 && (t.colspan = n.attrs.colspan), n.attrs.rowspan != 1 && (t.rowspan = n.attrs.rowspan), n.attrs.colwidth && (t["data-colwidth"] = n.attrs.colwidth.join(","));
  for (const r in e) {
    const i = e[r].setDOMAttr;
    i && i(n.attrs[r], t);
  }
  return t;
}
function YX(n) {
  if (n !== null) {
    if (!Array.isArray(n))
      throw new TypeError("colwidth must be null or an array");
    for (const e of n)
      if (typeof e != "number")
        throw new TypeError("colwidth must be null or an array of numbers");
  }
}
function XX(n) {
  const e = n.cellAttributes || {}, t = {
    colspan: { default: 1, validate: "number" },
    rowspan: { default: 1, validate: "number" },
    colwidth: { default: null, validate: YX }
  };
  for (const r in e)
    t[r] = {
      default: e[r].default,
      validate: e[r].validate
    };
  return {
    table: {
      content: "table_row+",
      tableRole: "table",
      isolating: !0,
      group: n.tableGroup,
      parseDOM: [{ tag: "table" }],
      toDOM() {
        return ["table", ["tbody", 0]];
      }
    },
    table_row: {
      content: "(table_cell | table_header)*",
      tableRole: "row",
      parseDOM: [{ tag: "tr" }],
      toDOM() {
        return ["tr", 0];
      }
    },
    table_cell: {
      content: n.cellContent,
      attrs: t,
      tableRole: "cell",
      isolating: !0,
      parseDOM: [
        { tag: "td", getAttrs: (r) => G8(r, e) }
      ],
      toDOM(r) {
        return ["td", J8(r, e), 0];
      }
    },
    table_header: {
      content: n.cellContent,
      attrs: t,
      tableRole: "header_cell",
      isolating: !0,
      parseDOM: [
        { tag: "th", getAttrs: (r) => G8(r, e) }
      ],
      toDOM(r) {
        return ["th", J8(r, e), 0];
      }
    }
  };
}
function Qi(n) {
  let e = n.cached.tableNodeTypes;
  if (!e) {
    e = n.cached.tableNodeTypes = {};
    for (const t in n.nodes) {
      const r = n.nodes[t], i = r.spec.tableRole;
      i && (e[i] = r);
    }
  }
  return e;
}
var Ha = new gn("selectingCells");
function ep(n) {
  for (let e = n.depth - 1; e > 0; e--)
    if (n.node(e).type.spec.tableRole == "row")
      return n.node(0).resolve(n.before(e + 1));
  return null;
}
function rs(n) {
  const e = n.selection.$head;
  for (let t = e.depth; t > 0; t--)
    if (e.node(t).type.spec.tableRole == "row") return !0;
  return !1;
}
function my(n) {
  const e = n.selection;
  if ("$anchorCell" in e && e.$anchorCell)
    return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
    return e.$anchor;
  const t = ep(e.$head) || ZX(e.$head);
  if (t)
    return t;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function ZX(n) {
  for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return n.doc.resolve(t);
  }
  for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell")
      return n.doc.resolve(t - e.nodeSize);
  }
}
function _4(n) {
  return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter;
}
function QX(n) {
  return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize);
}
function p3(n, e) {
  return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1);
}
function $L(n, e, t) {
  const r = n.node(-1), i = $t.get(r), s = n.start(-1), o = i.nextCell(n.pos - s, e, t);
  return o == null ? null : n.node(0).resolve(s + o);
}
function _c(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan - t };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some((i) => i > 0) || (r.colwidth = null)), r;
}
function eZ(n, e, t = 1) {
  const r = { ...n, colspan: n.colspan + t };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let i = 0; i < t; i++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function tZ(n, e, t) {
  const r = Qi(e.type.schema).header_cell;
  for (let i = 0; i < n.height; i++)
    if (e.nodeAt(n.map[t + i * n.width]).type != r)
      return !1;
  return !0;
}
var nn = class Io extends ht {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor(e, t = e) {
    const r = e.node(-1), i = $t.get(r), s = e.start(-1), o = i.rectBetween(
      e.pos - s,
      t.pos - s
    ), a = e.node(0), l = i.cellsInRect(o).filter((u) => u != t.pos - s);
    l.unshift(t.pos - s);
    const c = l.map((u) => {
      const h = r.nodeAt(u);
      if (!h)
        throw RangeError(`No cell with offset ${u} found`);
      const f = s + u + 1;
      return new nA(
        a.resolve(f),
        a.resolve(f + h.content.size)
      );
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t;
  }
  map(e, t) {
    const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos));
    if (_4(r) && _4(i) && p3(r, i)) {
      const s = this.$anchorCell.node(-1) != r.node(-1);
      return s && this.isRowSelection() ? Io.rowSelection(r, i) : s && this.isColSelection() ? Io.colSelection(r, i) : new Io(r, i);
    }
    return Ye.between(r, i);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const e = this.$anchorCell.node(-1), t = $t.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(
      this.$anchorCell.pos - r,
      this.$headCell.pos - r
    ), s = {}, o = [];
    for (let l = i.top; l < i.bottom; l++) {
      const c = [];
      for (let u = l * t.width + i.left, h = i.left; h < i.right; h++, u++) {
        const f = t.map[u];
        if (s[f]) continue;
        s[f] = !0;
        const m = t.findCell(f);
        let y = e.nodeAt(f);
        if (!y)
          throw RangeError(`No cell with offset ${f} found`);
        const b = i.left - m.left, k = m.right - i.right;
        if (b > 0 || k > 0) {
          let x = y.attrs;
          if (b > 0 && (x = _c(x, 0, b)), k > 0 && (x = _c(
            x,
            x.colspan - k,
            k
          )), m.left < i.left) {
            if (y = y.type.createAndFill(x), !y)
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(x)}`
              );
          } else
            y = y.type.create(x, y.content);
        }
        if (m.top < i.top || m.bottom > i.bottom) {
          const x = {
            ...y.attrs,
            rowspan: Math.min(m.bottom, i.bottom) - Math.max(m.top, i.top)
          };
          m.top < i.top ? y = y.type.createAndFill(x) : y = y.type.create(x, y.content);
        }
        c.push(y);
      }
      o.push(e.child(l).copy(pe.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : o;
    return new He(pe.from(a), 1, 1);
  }
  replace(e, t = He.empty) {
    const r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      const { $from: a, $to: l } = i[o], c = e.mapping.slice(r);
      e.replace(
        c.map(a.pos),
        c.map(l.pos),
        o ? He.empty : t
      );
    }
    const s = ht.findFrom(
      e.doc.resolve(e.mapping.slice(r).map(this.to)),
      -1
    );
    s && e.setSelection(s);
  }
  replaceWith(e, t) {
    this.replace(e, new He(pe.from(t), 0, 0));
  }
  forEachCell(e) {
    const t = this.$anchorCell.node(-1), r = $t.get(t), i = this.$anchorCell.start(-1), s = r.cellsInRect(
      r.rectBetween(
        this.$anchorCell.pos - i,
        this.$headCell.pos - i
      )
    );
    for (let o = 0; o < s.length; o++)
      e(t.nodeAt(s[o]), i + s[o]);
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1);
    if (Math.min(e, t) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, i) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection(e, t = e) {
    const r = e.node(-1), i = $t.get(r), s = e.start(-1), o = i.findCell(e.pos - s), a = i.findCell(t.pos - s), l = e.node(0);
    return o.top <= a.top ? (o.top > 0 && (e = l.resolve(s + i.map[o.left])), a.bottom < i.height && (t = l.resolve(
      s + i.map[i.width * (i.height - 1) + a.right - 1]
    ))) : (a.top > 0 && (t = l.resolve(s + i.map[a.left])), o.bottom < i.height && (e = l.resolve(
      s + i.map[i.width * (i.height - 1) + o.right - 1]
    ))), new Io(e, t);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const e = this.$anchorCell.node(-1), t = $t.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), s = t.colCount(this.$headCell.pos - r);
    if (Math.min(i, s) > 0) return !1;
    const o = i + this.$anchorCell.nodeAfter.attrs.colspan, a = s + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(o, a) == t.width;
  }
  eq(e) {
    return e instanceof Io && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection(e, t = e) {
    const r = e.node(-1), i = $t.get(r), s = e.start(-1), o = i.findCell(e.pos - s), a = i.findCell(t.pos - s), l = e.node(0);
    return o.left <= a.left ? (o.left > 0 && (e = l.resolve(
      s + i.map[o.top * i.width]
    )), a.right < i.width && (t = l.resolve(
      s + i.map[i.width * (a.top + 1) - 1]
    ))) : (a.left > 0 && (t = l.resolve(s + i.map[a.top * i.width])), o.right < i.width && (e = l.resolve(
      s + i.map[i.width * (o.top + 1) - 1]
    ))), new Io(e, t);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, t) {
    return new Io(e.resolve(t.anchor), e.resolve(t.head));
  }
  static create(e, t, r = t) {
    return new Io(e.resolve(t), e.resolve(r));
  }
  getBookmark() {
    return new nZ(this.$anchorCell.pos, this.$headCell.pos);
  }
};
nn.prototype.visible = !1;
ht.jsonID("cell", nn);
var nZ = class jL {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new jL(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const t = e.resolve(this.anchor), r = e.resolve(this.head);
    return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && p3(t, r) ? new nn(t, r) : ht.near(r, 1);
  }
};
function rZ(n) {
  if (!(n.selection instanceof nn)) return null;
  const e = [];
  return n.selection.forEachCell((t, r) => {
    e.push(
      qn.node(r, r + t.nodeSize, { class: "selectedCell" })
    );
  }), Qt.create(n.doc, e);
}
function iZ({ $from: n, $to: e }) {
  if (n.pos == e.pos || n.pos < e.pos - 6) return !1;
  let t = n.pos, r = e.pos, i = n.depth;
  for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++)
    ;
  for (let s = e.depth; s >= 0 && !(e.before(s + 1) > e.start(s)); s--, r--)
    ;
  return t == r && /row|table/.test(n.node(i).type.spec.tableRole);
}
function sZ({ $from: n, $to: e }) {
  let t, r;
  for (let i = n.depth; i > 0; i--) {
    const s = n.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      t = s;
      break;
    }
  }
  for (let i = e.depth; i > 0; i--) {
    const s = e.node(i);
    if (s.type.spec.tableRole === "cell" || s.type.spec.tableRole === "header_cell") {
      r = s;
      break;
    }
  }
  return t !== r && e.parentOffset === 0;
}
function oZ(n, e, t) {
  const r = (e || n).selection, i = (e || n).doc;
  let s, o;
  if (r instanceof Qe && (o = r.node.type.spec.tableRole)) {
    if (o == "cell" || o == "header_cell")
      s = nn.create(i, r.from);
    else if (o == "row") {
      const a = i.resolve(r.from + 1);
      s = nn.rowSelection(a, a);
    } else if (!t) {
      const a = $t.get(r.node), l = r.from + 1, c = l + a.map[a.width * a.height - 1];
      s = nn.create(i, l + 1, c);
    }
  } else r instanceof Ye && iZ(r) ? s = Ye.create(i, r.from) : r instanceof Ye && sZ(r) && (s = Ye.create(i, r.$from.start(), r.$from.end()));
  return s && (e || (e = n.tr)).setSelection(s), e;
}
var aZ = new gn("fix-tables");
function WL(n, e, t, r) {
  const i = n.childCount, s = e.childCount;
  e: for (let o = 0, a = 0; o < s; o++) {
    const l = e.child(o);
    for (let c = a, u = Math.min(i, o + 3); c < u; c++)
      if (n.child(c) == l) {
        a = c + 1, t += l.nodeSize;
        continue e;
      }
    r(l, t), a < i && n.child(a).sameMarkup(l) ? WL(n.child(a), l, t + 1, r) : l.nodesBetween(0, l.content.size, r, t + 1), t += l.nodeSize;
  }
}
function lZ(n, e) {
  let t;
  const r = (i, s) => {
    i.type.spec.tableRole == "table" && (t = cZ(n, i, s, t));
  };
  return e ? e.doc != n.doc && WL(e.doc, n.doc, 0, r) : n.doc.descendants(r), t;
}
function cZ(n, e, t, r) {
  const i = $t.get(e);
  if (!i.problems) return r;
  r || (r = n.tr);
  const s = [];
  for (let l = 0; l < i.height; l++) s.push(0);
  for (let l = 0; l < i.problems.length; l++) {
    const c = i.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const h = u.attrs;
      for (let f = 0; f < h.rowspan; f++) s[c.row + f] += c.n;
      r.setNodeMarkup(
        r.mapping.map(t + 1 + c.pos),
        null,
        _c(h, h.colspan - c.n, c.n)
      );
    } else if (c.type == "missing")
      s[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(t);
      r.delete(u, u + e.nodeSize);
    }
  }
  let o, a;
  for (let l = 0; l < s.length; l++)
    s[l] && (o == null && (o = l), a = l);
  for (let l = 0, c = t + 1; l < i.height; l++) {
    const u = e.child(l), h = c + u.nodeSize, f = s[l];
    if (f > 0) {
      let m = "cell";
      u.firstChild && (m = u.firstChild.type.spec.tableRole);
      const y = [];
      for (let k = 0; k < f; k++) {
        const x = Qi(n.schema)[m].createAndFill();
        x && y.push(x);
      }
      const b = (l == 0 || o == l - 1) && a == l ? c + 1 : h - 1;
      r.insert(r.mapping.map(b), y);
    }
    c = h;
  }
  return r.setMeta(aZ, { fixTables: !0 });
}
function UL(n) {
  const e = $t.get(n), t = [], r = e.height, i = e.width;
  for (let s = 0; s < r; s++) {
    const o = [];
    for (let a = 0; a < i; a++) {
      const l = s * i + a, c = e.map[l];
      if (s > 0) {
        const u = l - i, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      if (a > 0) {
        const u = l - 1, h = e.map[u];
        if (c === h) {
          o.push(null);
          continue;
        }
      }
      o.push(n.nodeAt(c));
    }
    t.push(o);
  }
  return t;
}
function KL(n, e) {
  const t = [], r = $t.get(n), i = r.height, s = r.width;
  for (let a = 0; a < i; a++) {
    const l = n.child(a), c = [];
    for (let h = 0; h < s; h++) {
      const f = e[a][h];
      if (!f)
        continue;
      const m = r.map[a * r.width + h], y = n.nodeAt(m);
      if (!y)
        continue;
      const b = y.type.createChecked(
        f.attrs,
        f.content,
        f.marks
      );
      c.push(b);
    }
    const u = l.type.createChecked(
      l.attrs,
      c,
      l.marks
    );
    t.push(u);
  }
  return n.type.createChecked(
    n.attrs,
    t,
    n.marks
  );
}
function Ph(n) {
  return uZ((e) => e.type.spec.tableRole === "table", n);
}
function uZ(n, e) {
  for (let t = e.depth; t >= 0; t -= 1) {
    const r = e.node(t);
    if (n(r)) {
      const i = t === 0 ? 0 : e.before(t), s = e.start(t);
      return { node: r, pos: i, start: s, depth: t };
    }
  }
  return null;
}
function au(n, e) {
  const t = Ph(e.$from);
  if (!t)
    return;
  const r = $t.get(t.node);
  return n < 0 || n > r.width - 1 ? void 0 : r.cellsInRect({
    left: n,
    right: n + 1,
    top: 0,
    bottom: r.height
  }).map((s) => {
    const o = t.node.nodeAt(s), a = s + t.start;
    return { pos: a, start: a + 1, node: o, depth: t.depth + 2 };
  });
}
function lu(n, e) {
  const t = Ph(e.$from);
  if (!t)
    return;
  const r = $t.get(t.node);
  return n < 0 || n > r.height - 1 ? void 0 : r.cellsInRect({
    left: 0,
    right: r.width,
    top: n,
    bottom: n + 1
  }).map((s) => {
    const o = t.node.nodeAt(s), a = s + t.start;
    return { pos: a, start: a + 1, node: o, depth: t.depth + 2 };
  });
}
function Y8(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = au(h, n.selection);
    f && f.forEach((m) => {
      const y = m.node.attrs.colspan + h - 1;
      y >= r && (r = h), y > i && (i = y);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = au(h, n.selection);
    f && f.forEach((m) => {
      const y = m.node.attrs.colspan + h - 1;
      m.node.attrs.colspan > 1 && y > i && (i = y);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = au(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = au(r, n.selection), a = lu(0, n.selection);
  if (!o || !a)
    return;
  const l = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = au(h, n.selection);
    if (f && f.length > 0) {
      for (let m = a.length - 1; m >= 0; m--)
        if (a[m].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: l, $head: u, indexes: s };
}
function X8(n, e, t = e) {
  let r = e, i = t;
  for (let h = e; h >= 0; h--) {
    const f = lu(h, n.selection);
    f && f.forEach((m) => {
      const y = m.node.attrs.rowspan + h - 1;
      y >= r && (r = h), y > i && (i = y);
    });
  }
  for (let h = e; h <= i; h++) {
    const f = lu(h, n.selection);
    f && f.forEach((m) => {
      const y = m.node.attrs.rowspan + h - 1;
      m.node.attrs.rowspan > 1 && y > i && (i = y);
    });
  }
  const s = [];
  for (let h = r; h <= i; h++) {
    const f = lu(h, n.selection);
    f && f.length > 0 && s.push(h);
  }
  r = s[0], i = s[s.length - 1];
  const o = lu(r, n.selection), a = au(0, n.selection);
  if (!o || !a)
    return;
  const l = n.doc.resolve(
    o[o.length - 1].pos
  );
  let c;
  for (let h = i; h >= r; h--) {
    const f = lu(h, n.selection);
    if (f && f.length > 0) {
      for (let m = a.length - 1; m >= 0; m--)
        if (a[m].pos === f[0].pos) {
          c = f[0];
          break;
        }
      if (c)
        break;
    }
  }
  if (!c)
    return;
  const u = n.doc.resolve(c.pos);
  return { $anchor: l, $head: u, indexes: s };
}
function GL(n, e, t, r) {
  const i = e[0] > t[0] ? -1 : 1, s = n.splice(e[0], e.length), o = s.length % 2 === 0 ? 1 : 0;
  let a;
  return a = i === -1 ? t[0] : t[t.length - 1] - o, n.splice(a, 0, ...s), n;
}
function Z8(n) {
  return n[0].map((e, t) => n.map((r) => r[t]));
}
function hZ(n) {
  var e, t;
  const { tr: r, originIndex: i, targetIndex: s, select: o, pos: a } = n, l = r.doc.resolve(a), c = Ph(l);
  if (!c) return !1;
  const u = (e = Y8(
    r,
    i
  )) == null ? void 0 : e.indexes, h = (t = Y8(
    r,
    s
  )) == null ? void 0 : t.indexes;
  if (!u || !h || u.includes(s)) return !1;
  const f = fZ(
    c.node,
    u,
    h
  );
  if (r.replaceWith(c.pos, c.pos + c.node.nodeSize, f), !o) return !0;
  const m = $t.get(f), y = c.start, b = s, k = m.positionAt(m.height - 1, b, f), x = r.doc.resolve(y + k), M = m.positionAt(0, b, f), T = r.doc.resolve(y + M);
  return r.setSelection(nn.colSelection(x, T)), !0;
}
function fZ(n, e, t, r) {
  let i = Z8(UL(n));
  return i = GL(i, e, t), i = Z8(i), KL(n, i);
}
function dZ(n) {
  var e, t;
  const { tr: r, originIndex: i, targetIndex: s, select: o, pos: a } = n, l = r.doc.resolve(a), c = Ph(l);
  if (!c) return !1;
  const u = (e = X8(r, i)) == null ? void 0 : e.indexes, h = (t = X8(r, s)) == null ? void 0 : t.indexes;
  if (!u || !h || u.includes(s)) return !1;
  const f = pZ(
    c.node,
    u,
    h
  );
  if (r.replaceWith(c.pos, c.pos + c.node.nodeSize, f), !o) return !0;
  const m = $t.get(f), y = c.start, b = s, k = m.positionAt(b, m.width - 1, f), x = r.doc.resolve(y + k), M = m.positionAt(b, 0, f), T = r.doc.resolve(y + M);
  return r.setSelection(nn.rowSelection(x, T)), !0;
}
function pZ(n, e, t, r) {
  let i = UL(n);
  return i = GL(i, e, t), KL(n, i);
}
function bl(n) {
  const e = n.selection, t = my(n), r = t.node(-1), i = t.start(-1), s = $t.get(r);
  return { ...e instanceof nn ? s.rectBetween(
    e.$anchorCell.pos - i,
    e.$headCell.pos - i
  ) : s.findCell(t.pos - i), tableStart: i, map: s, table: r };
}
function JL(n, { map: e, tableStart: t, table: r }, i) {
  let s = i > 0 ? -1 : 0;
  tZ(e, r, i + s) && (s = i == 0 || i == e.width ? null : 0);
  for (let o = 0; o < e.height; o++) {
    const a = o * e.width + i;
    if (i > 0 && i < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = r.nodeAt(l);
      n.setNodeMarkup(
        n.mapping.map(t + l),
        null,
        eZ(c.attrs, i - e.colCount(l))
      ), o += c.attrs.rowspan - 1;
    } else {
      const l = s == null ? Qi(r.type.schema).cell : r.nodeAt(e.map[a + s]).type, c = e.positionAt(o, i, r);
      n.insert(n.mapping.map(t + c), l.createAndFill());
    }
  }
  return n;
}
function mZ(n, e) {
  if (!rs(n)) return !1;
  if (e) {
    const t = bl(n);
    e(JL(n.tr, t, t.left));
  }
  return !0;
}
function gZ(n, e) {
  if (!rs(n)) return !1;
  if (e) {
    const t = bl(n);
    e(JL(n.tr, t, t.right));
  }
  return !0;
}
function yZ(n, { map: e, table: t, tableStart: r }, i) {
  const s = n.mapping.maps.length;
  for (let o = 0; o < e.height; ) {
    const a = o * e.width + i, l = e.map[a], c = t.nodeAt(l), u = c.attrs;
    if (i > 0 && e.map[a - 1] == l || i < e.width - 1 && e.map[a + 1] == l)
      n.setNodeMarkup(
        n.mapping.slice(s).map(r + l),
        null,
        _c(u, i - e.colCount(l))
      );
    else {
      const h = n.mapping.slice(s).map(r + l);
      n.delete(h, h + c.nodeSize);
    }
    o += u.rowspan;
  }
}
function bZ(n, e) {
  if (!rs(n)) return !1;
  if (e) {
    const t = bl(n), r = n.tr;
    if (t.left == 0 && t.right == t.map.width) return !1;
    for (let i = t.right - 1; yZ(r, t, i), i != t.left; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = $t.get(s);
    }
    e(r);
  }
  return !0;
}
function vZ(n, { map: e, table: t, tableStart: r }, i) {
  let s = 0;
  for (let c = 0; c < i; c++) s += t.child(c).nodeSize;
  const o = s + t.child(i).nodeSize, a = n.mapping.maps.length;
  n.delete(s + r, o + r);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = i * e.width; c < e.width; c++, u++) {
    const h = e.map[u];
    if (!l.has(h)) {
      if (l.add(h), i > 0 && h == e.map[u - e.width]) {
        const f = t.nodeAt(h).attrs;
        n.setNodeMarkup(n.mapping.slice(a).map(h + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (i < e.height && h == e.map[u + e.width]) {
        const f = t.nodeAt(h), m = f.attrs, y = f.type.create(
          { ...m, rowspan: f.attrs.rowspan - 1 },
          f.content
        ), b = e.positionAt(i + 1, c, t);
        n.insert(n.mapping.slice(a).map(r + b), y), c += m.colspan - 1;
      }
    }
  }
}
function wZ(n, e) {
  if (!rs(n)) return !1;
  if (e) {
    const t = bl(n), r = n.tr;
    if (t.top == 0 && t.bottom == t.map.height) return !1;
    for (let i = t.bottom - 1; vZ(r, t, i), i != t.top; i--) {
      const s = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc;
      if (!s)
        throw RangeError("No table found");
      t.table = s, t.map = $t.get(t.table);
    }
    e(r);
  }
  return !0;
}
function kZ(n, e) {
  return function(t, r) {
    if (!rs(t)) return !1;
    const i = my(t);
    if (i.nodeAfter.attrs[n] === e) return !1;
    if (r) {
      const s = t.tr;
      t.selection instanceof nn ? t.selection.forEachCell((o, a) => {
        o.attrs[n] !== e && s.setNodeMarkup(a, null, {
          ...o.attrs,
          [n]: e
        });
      }) : s.setNodeMarkup(i.pos, null, {
        ...i.nodeAfter.attrs,
        [n]: e
      }), r(s);
    }
    return !0;
  };
}
function xZ(n) {
  return function(e, t) {
    if (!rs(e)) return !1;
    if (t) {
      const r = Qi(e.schema), i = bl(e), s = e.tr, o = i.map.cellsInRect(
        n == "column" ? {
          left: i.left,
          top: 0,
          right: i.right,
          bottom: i.map.height
        } : n == "row" ? {
          left: 0,
          top: i.top,
          right: i.map.width,
          bottom: i.bottom
        } : i
      ), a = o.map((l) => i.table.nodeAt(l));
      for (let l = 0; l < o.length; l++)
        a[l].type == r.header_cell && s.setNodeMarkup(
          i.tableStart + o[l],
          r.cell,
          a[l].attrs
        );
      if (s.steps.length == 0)
        for (let l = 0; l < o.length; l++)
          s.setNodeMarkup(
            i.tableStart + o[l],
            r.header_cell,
            a[l].attrs
          );
      t(s);
    }
    return !0;
  };
}
function Q8(n, e, t) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: n == "row" ? e.map.width : 1,
    bottom: n == "column" ? e.map.height : 1
  });
  for (let i = 0; i < r.length; i++) {
    const s = e.table.nodeAt(r[i]);
    if (s && s.type !== t.header_cell)
      return !1;
  }
  return !0;
}
function m3(n, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? xZ(n) : function(t, r) {
    if (!rs(t)) return !1;
    if (r) {
      const i = Qi(t.schema), s = bl(t), o = t.tr, a = Q8("row", s, i), l = Q8(
        "column",
        s,
        i
      ), u = (n === "column" ? a : n === "row" ? l : !1) ? 1 : 0, h = n == "column" ? {
        left: 0,
        top: u,
        right: 1,
        bottom: s.map.height
      } : n == "row" ? {
        left: u,
        top: 0,
        right: s.map.width,
        bottom: 1
      } : s, f = n == "column" ? l ? i.cell : i.header_cell : n == "row" ? a ? i.cell : i.header_cell : i.cell;
      s.map.cellsInRect(h).forEach((m) => {
        const y = m + s.tableStart, b = o.doc.nodeAt(y);
        b && o.setNodeMarkup(y, f, b.attrs);
      }), r(o);
    }
    return !0;
  };
}
m3("row", {
  useDeprecatedLogic: !0
});
m3("column", {
  useDeprecatedLogic: !0
});
m3("cell", {
  useDeprecatedLogic: !0
});
function SZ(n, e) {
  if (e < 0) {
    const t = n.nodeBefore;
    if (t) return n.pos - t.nodeSize;
    for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) {
      const s = n.node(-1).child(r), o = s.lastChild;
      if (o)
        return i - 1 - o.nodeSize;
      i -= s.nodeSize;
    }
  } else {
    if (n.index() < n.parent.childCount - 1)
      return n.pos + n.nodeAfter.nodeSize;
    const t = n.node(-1);
    for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) {
      const s = t.child(r);
      if (s.childCount) return i + 1;
      i += s.nodeSize;
    }
  }
  return null;
}
function YL(n) {
  return function(e, t) {
    if (!rs(e)) return !1;
    const r = SZ(my(e), n);
    if (r == null) return !1;
    if (t) {
      const i = e.doc.resolve(r);
      t(
        e.tr.setSelection(Ye.between(i, QX(i))).scrollIntoView()
      );
    }
    return !0;
  };
}
function CZ(n, e) {
  const t = n.selection.$anchor;
  for (let r = t.depth; r > 0; r--)
    if (t.node(r).type.spec.tableRole == "table")
      return e && e(
        n.tr.delete(t.before(r), t.after(r)).scrollIntoView()
      ), !0;
  return !1;
}
function Zp(n, e) {
  const t = n.selection;
  if (!(t instanceof nn)) return !1;
  if (e) {
    const r = n.tr, i = Qi(n.schema).cell.createAndFill().content;
    t.forEachCell((s, o) => {
      s.content.eq(i) || r.replace(
        r.mapping.map(o + 1),
        r.mapping.map(o + s.nodeSize - 1),
        new He(i, 0, 0)
      );
    }), r.docChanged && e(r);
  }
  return !0;
}
function MZ(n) {
  return (e, t) => {
    const {
      from: r,
      to: i,
      select: s = !0,
      pos: o = e.selection.from
    } = n, a = e.tr;
    return dZ({ tr: a, originIndex: r, targetIndex: i, select: s, pos: o }) ? (t == null || t(a), !0) : !1;
  };
}
function TZ(n) {
  return (e, t) => {
    const {
      from: r,
      to: i,
      select: s = !0,
      pos: o = e.selection.from
    } = n, a = e.tr;
    return hZ({ tr: a, originIndex: r, targetIndex: i, select: s, pos: o }) ? (t == null || t(a), !0) : !1;
  };
}
function AZ(n) {
  if (!n.size) return null;
  let { content: e, openStart: t, openEnd: r } = n;
  for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    t--, r--, e = e.child(0).content;
  const i = e.child(0), s = i.type.spec.tableRole, o = i.type.schema, a = [];
  if (s == "row")
    for (let l = 0; l < e.childCount; l++) {
      let c = e.child(l).content;
      const u = l ? 0 : Math.max(0, t - 1), h = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
      (u || h) && (c = R4(
        Qi(o).row,
        new He(c, u, h)
      ).content), a.push(c);
    }
  else if (s == "cell" || s == "header_cell")
    a.push(
      t || r ? R4(
        Qi(o).row,
        new He(e, t, r)
      ).content : e
    );
  else
    return null;
  return EZ(o, a);
}
function EZ(n, e) {
  const t = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    for (let o = s.childCount - 1; o >= 0; o--) {
      const { rowspan: a, colspan: l } = s.child(o).attrs;
      for (let c = i; c < i + a; c++)
        t[c] = (t[c] || 0) + l;
    }
  }
  let r = 0;
  for (let i = 0; i < t.length; i++) r = Math.max(r, t[i]);
  for (let i = 0; i < t.length; i++)
    if (i >= e.length && e.push(pe.empty), t[i] < r) {
      const s = Qi(n).cell.createAndFill(), o = [];
      for (let a = t[i]; a < r; a++)
        o.push(s);
      e[i] = e[i].append(pe.from(o));
    }
  return { height: e.length, width: r, rows: e };
}
function R4(n, e) {
  const t = n.createAndFill();
  return new tA(t).replace(0, t.content.size, e).doc;
}
function LZ({ width: n, height: e, rows: t }, r, i) {
  if (n != r) {
    const s = [], o = [];
    for (let a = 0; a < t.length; a++) {
      const l = t[a], c = [];
      for (let u = s[a] || 0, h = 0; u < r; h++) {
        let f = l.child(h % l.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(
          _c(
            f.attrs,
            f.attrs.colspan,
            u + f.attrs.colspan - r
          ),
          f.content
        )), c.push(f), u += f.attrs.colspan;
        for (let m = 1; m < f.attrs.rowspan; m++)
          s[a + m] = (s[a + m] || 0) + f.attrs.colspan;
      }
      o.push(pe.from(c));
    }
    t = o, n = r;
  }
  if (e != i) {
    const s = [];
    for (let o = 0, a = 0; o < i; o++, a++) {
      const l = [], c = t[a % e];
      for (let u = 0; u < c.childCount; u++) {
        let h = c.child(u);
        o + h.attrs.rowspan > i && (h = h.type.create(
          {
            ...h.attrs,
            rowspan: Math.max(1, i - h.attrs.rowspan)
          },
          h.content
        )), l.push(h);
      }
      s.push(pe.from(l));
    }
    t = s, e = i;
  }
  return { width: n, height: e, rows: t };
}
function OZ(n, e, t, r, i, s, o) {
  const a = n.doc.type.schema, l = Qi(a);
  let c, u;
  if (i > e.width)
    for (let h = 0, f = 0; h < e.height; h++) {
      const m = t.child(h);
      f += m.nodeSize;
      const y = [];
      let b;
      m.lastChild == null || m.lastChild.type == l.cell ? b = c || (c = l.cell.createAndFill()) : b = u || (u = l.header_cell.createAndFill());
      for (let k = e.width; k < i; k++) y.push(b);
      n.insert(n.mapping.slice(o).map(f - 1 + r), y);
    }
  if (s > e.height) {
    const h = [];
    for (let y = 0, b = (e.height - 1) * e.width; y < Math.max(e.width, i); y++) {
      const k = y >= e.width ? !1 : t.nodeAt(e.map[b + y]).type == l.header_cell;
      h.push(
        k ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())
      );
    }
    const f = l.row.create(null, pe.from(h)), m = [];
    for (let y = e.height; y < s; y++) m.push(f);
    n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), m);
  }
  return !!(c || u);
}
function eS(n, e, t, r, i, s, o, a) {
  if (o == 0 || o == e.height) return !1;
  let l = !1;
  for (let c = i; c < s; c++) {
    const u = o * e.width + c, h = e.map[u];
    if (e.map[u - e.width] == h) {
      l = !0;
      const f = t.nodeAt(h), { top: m, left: y } = e.findCell(h);
      n.setNodeMarkup(n.mapping.slice(a).map(h + r), null, {
        ...f.attrs,
        rowspan: o - m
      }), n.insert(
        n.mapping.slice(a).map(e.positionAt(o, y, t)),
        f.type.createAndFill({
          ...f.attrs,
          rowspan: m + f.attrs.rowspan - o
        })
      ), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function tS(n, e, t, r, i, s, o, a) {
  if (o == 0 || o == e.width) return !1;
  let l = !1;
  for (let c = i; c < s; c++) {
    const u = c * e.width + o, h = e.map[u];
    if (e.map[u - 1] == h) {
      l = !0;
      const f = t.nodeAt(h), m = e.colCount(h), y = n.mapping.slice(a).map(h + r);
      n.setNodeMarkup(
        y,
        null,
        _c(
          f.attrs,
          o - m,
          f.attrs.colspan - (o - m)
        )
      ), n.insert(
        y + f.nodeSize,
        f.type.createAndFill(
          _c(f.attrs, 0, o - m)
        )
      ), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function nS(n, e, t, r, i) {
  let s = t ? n.doc.nodeAt(t - 1) : n.doc;
  if (!s)
    throw new Error("No table found");
  let o = $t.get(s);
  const { top: a, left: l } = r, c = l + i.width, u = a + i.height, h = n.tr;
  let f = 0;
  function m() {
    if (s = t ? h.doc.nodeAt(t - 1) : h.doc, !s)
      throw new Error("No table found");
    o = $t.get(s), f = h.mapping.maps.length;
  }
  OZ(h, o, s, t, c, u, f) && m(), eS(h, o, s, t, l, c, a, f) && m(), eS(h, o, s, t, l, c, u, f) && m(), tS(h, o, s, t, a, u, l, f) && m(), tS(h, o, s, t, a, u, c, f) && m();
  for (let y = a; y < u; y++) {
    const b = o.positionAt(y, l, s), k = o.positionAt(y, c, s);
    h.replace(
      h.mapping.slice(f).map(b + t),
      h.mapping.slice(f).map(k + t),
      new He(i.rows[y - a], 0, 0)
    );
  }
  m(), h.setSelection(
    new nn(
      h.doc.resolve(t + o.positionAt(a, l, s)),
      h.doc.resolve(t + o.positionAt(u - 1, c - 1, s))
    )
  ), e(h);
}
var DZ = a5({
  ArrowLeft: Qp("horiz", -1),
  ArrowRight: Qp("horiz", 1),
  ArrowUp: Qp("vert", -1),
  ArrowDown: Qp("vert", 1),
  "Shift-ArrowLeft": em("horiz", -1),
  "Shift-ArrowRight": em("horiz", 1),
  "Shift-ArrowUp": em("vert", -1),
  "Shift-ArrowDown": em("vert", 1),
  Backspace: Zp,
  "Mod-Backspace": Zp,
  Delete: Zp,
  "Mod-Delete": Zp
});
function Qm(n, e, t) {
  return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0);
}
function Qp(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    if (s instanceof nn)
      return Qm(
        t,
        r,
        ht.near(s.$headCell, e)
      );
    if (n != "horiz" && !s.empty) return !1;
    const o = XL(i, n, e);
    if (o == null) return !1;
    if (n == "horiz")
      return Qm(
        t,
        r,
        ht.near(t.doc.resolve(s.head + e), e)
      );
    {
      const a = t.doc.resolve(o), l = $L(a, n, e);
      let c;
      return l ? c = ht.near(l, 1) : e < 0 ? c = ht.near(t.doc.resolve(a.before(-1)), -1) : c = ht.near(t.doc.resolve(a.after(-1)), 1), Qm(t, r, c);
    }
  };
}
function em(n, e) {
  return (t, r, i) => {
    if (!i) return !1;
    const s = t.selection;
    let o;
    if (s instanceof nn)
      o = s;
    else {
      const l = XL(i, n, e);
      if (l == null) return !1;
      o = new nn(t.doc.resolve(l));
    }
    const a = $L(o.$headCell, n, e);
    return a ? Qm(
      t,
      r,
      new nn(o.$anchorCell, a)
    ) : !1;
  };
}
function NZ(n, e) {
  const t = n.state.doc, r = ep(t.resolve(e));
  return r ? (n.dispatch(n.state.tr.setSelection(new nn(r))), !0) : !1;
}
function IZ(n, e, t) {
  if (!rs(n.state)) return !1;
  let r = AZ(t);
  const i = n.state.selection;
  if (i instanceof nn) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [
        pe.from(
          R4(Qi(n.state.schema).cell, t)
        )
      ]
    });
    const s = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), a = $t.get(s).rectBetween(
      i.$anchorCell.pos - o,
      i.$headCell.pos - o
    );
    return r = LZ(r, a.right - a.left, a.bottom - a.top), nS(n.state, n.dispatch, o, a, r), !0;
  } else if (r) {
    const s = my(n.state), o = s.start(-1);
    return nS(
      n.state,
      n.dispatch,
      o,
      $t.get(s.node(-1)).findCell(s.pos - o),
      r
    ), !0;
  } else
    return !1;
}
function _Z(n, e) {
  var t;
  if (e.ctrlKey || e.metaKey) return;
  const r = rS(n, e.target);
  let i;
  if (e.shiftKey && n.state.selection instanceof nn)
    s(n.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (i = ep(n.state.selection.$anchor)) != null && ((t = u2(n, e)) == null ? void 0 : t.pos) != i.pos)
    s(i, e), e.preventDefault();
  else if (!r)
    return;
  function s(l, c) {
    let u = u2(n, c);
    const h = Ha.getState(n.state) == null;
    if (!u || !p3(l, u))
      if (h) u = l;
      else return;
    const f = new nn(l, u);
    if (h || !n.state.selection.eq(f)) {
      const m = n.state.tr.setSelection(f);
      h && m.setMeta(Ha, l.pos), n.dispatch(m);
    }
  }
  function o() {
    n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", a), Ha.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Ha, -1));
  }
  function a(l) {
    const c = l, u = Ha.getState(n.state);
    let h;
    if (u != null)
      h = n.state.doc.resolve(u);
    else if (rS(n, c.target) != r && (h = u2(n, e), !h))
      return o();
    h && s(h, c);
  }
  n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", a);
}
function XL(n, e, t) {
  if (!(n.state.selection instanceof Ye)) return null;
  const { $head: r } = n.state.selection;
  for (let i = r.depth - 1; i >= 0; i--) {
    const s = r.node(i);
    if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : s.childCount)) return null;
    if (s.type.spec.tableRole == "cell" || s.type.spec.tableRole == "header_cell") {
      const a = r.before(i), l = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left";
      return n.endOfTextblock(l) ? a : null;
    }
  }
  return null;
}
function rS(n, e) {
  for (; e && e != n.dom; e = e.parentNode)
    if (e.nodeName == "TD" || e.nodeName == "TH")
      return e;
  return null;
}
function u2(n, e) {
  const t = n.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  return t && t ? ep(n.state.doc.resolve(t.pos)) : null;
}
var RZ = class {
  constructor(n, e) {
    this.node = n, this.defaultCellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty(
      "--default-cell-min-width",
      `${e}px`
    ), this.colgroup = this.table.appendChild(document.createElement("colgroup")), P4(n, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(n) {
    return n.type != this.node.type ? !1 : (this.node = n, P4(
      n,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    ), !0);
  }
  ignoreMutation(n) {
    return n.type == "attributes" && (n.target == this.table || this.colgroup.contains(n.target));
  }
};
function P4(n, e, t, r, i, s) {
  var o;
  let a = 0, l = !0, c = e.firstChild;
  const u = n.firstChild;
  if (u) {
    for (let h = 0, f = 0; h < u.childCount; h++) {
      const { colspan: m, colwidth: y } = u.child(h).attrs;
      for (let b = 0; b < m; b++, f++) {
        const k = i == f ? s : y && y[b], x = k ? k + "px" : "";
        if (a += k || r, k || (l = !1), c)
          c.style.width != x && (c.style.width = x), c = c.nextSibling;
        else {
          const M = document.createElement("col");
          M.style.width = x, e.appendChild(M);
        }
      }
    }
    for (; c; ) {
      const h = c.nextSibling;
      (o = c.parentNode) == null || o.removeChild(c), c = h;
    }
    l ? (t.style.width = a + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = a + "px");
  }
}
var xi = new gn(
  "tableColumnResizing"
);
function PZ({
  handleWidth: n = 5,
  cellMinWidth: e = 25,
  defaultCellMinWidth: t = 100,
  View: r = RZ,
  lastColumnResizable: i = !0
} = {}) {
  const s = new mn({
    key: xi,
    state: {
      init(o, a) {
        var l, c;
        const u = (c = (l = s.spec) == null ? void 0 : l.props) == null ? void 0 : c.nodeViews, h = Qi(a.schema).table.name;
        return r && u && (u[h] = (f, m) => new r(f, t, m)), new BZ(-1, !1);
      },
      apply(o, a) {
        return a.apply(o);
      }
    },
    props: {
      attributes: (o) => {
        const a = xi.getState(o);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (o, a) => {
          HZ(o, a, n, i);
        },
        mouseleave: (o) => {
          zZ(o);
        },
        mousedown: (o, a) => {
          FZ(o, a, e, t);
        }
      },
      decorations: (o) => {
        const a = xi.getState(o);
        if (a && a.activeHandle > -1)
          return WZ(o, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return s;
}
var BZ = class eg {
  constructor(e, t) {
    this.activeHandle = e, this.dragging = t;
  }
  apply(e) {
    const t = this, r = e.getMeta(xi);
    if (r && r.setHandle != null)
      return new eg(r.setHandle, !1);
    if (r && r.setDragging !== void 0)
      return new eg(t.activeHandle, r.setDragging);
    if (t.activeHandle > -1 && e.docChanged) {
      let i = e.mapping.map(t.activeHandle, -1);
      return _4(e.doc.resolve(i)) || (i = -1), new eg(i, t.dragging);
    }
    return t;
  }
};
function HZ(n, e, t, r) {
  if (!n.editable) return;
  const i = xi.getState(n.state);
  if (i && !i.dragging) {
    const s = qZ(e.target);
    let o = -1;
    if (s) {
      const { left: a, right: l } = s.getBoundingClientRect();
      e.clientX - a <= t ? o = iS(n, e, "left", t) : l - e.clientX <= t && (o = iS(n, e, "right", t));
    }
    if (o != i.activeHandle) {
      if (!r && o !== -1) {
        const a = n.state.doc.resolve(o), l = a.node(-1), c = $t.get(l), u = a.start(-1);
        if (c.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c.width - 1)
          return;
      }
      ZL(n, o);
    }
  }
}
function zZ(n) {
  if (!n.editable) return;
  const e = xi.getState(n.state);
  e && e.activeHandle > -1 && !e.dragging && ZL(n, -1);
}
function FZ(n, e, t, r) {
  var i;
  if (!n.editable) return !1;
  const s = (i = n.dom.ownerDocument.defaultView) != null ? i : window, o = xi.getState(n.state);
  if (!o || o.activeHandle == -1 || o.dragging)
    return !1;
  const a = n.state.doc.nodeAt(o.activeHandle), l = VZ(n, o.activeHandle, a.attrs);
  n.dispatch(
    n.state.tr.setMeta(xi, {
      setDragging: { startX: e.clientX, startWidth: l }
    })
  );
  function c(h) {
    s.removeEventListener("mouseup", c), s.removeEventListener("mousemove", u);
    const f = xi.getState(n.state);
    f != null && f.dragging && ($Z(
      n,
      f.activeHandle,
      sS(f.dragging, h, t)
    ), n.dispatch(
      n.state.tr.setMeta(xi, { setDragging: null })
    ));
  }
  function u(h) {
    if (!h.which) return c(h);
    const f = xi.getState(n.state);
    if (f && f.dragging) {
      const m = sS(f.dragging, h, t);
      oS(
        n,
        f.activeHandle,
        m,
        r
      );
    }
  }
  return oS(
    n,
    o.activeHandle,
    l,
    r
  ), s.addEventListener("mouseup", c), s.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function VZ(n, e, { colspan: t, colwidth: r }) {
  const i = r && r[r.length - 1];
  if (i) return i;
  const s = n.domAtPos(e);
  let a = s.node.childNodes[s.offset].offsetWidth, l = t;
  if (r)
    for (let c = 0; c < t; c++)
      r[c] && (a -= r[c], l--);
  return a / l;
}
function qZ(n) {
  for (; n && n.nodeName != "TD" && n.nodeName != "TH"; )
    n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode;
  return n;
}
function iS(n, e, t, r) {
  const i = t == "right" ? -r : r, s = n.posAtCoords({
    left: e.clientX + i,
    top: e.clientY
  });
  if (!s) return -1;
  const { pos: o } = s, a = ep(n.state.doc.resolve(o));
  if (!a) return -1;
  if (t == "right") return a.pos;
  const l = $t.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function sS(n, e, t) {
  const r = e.clientX - n.startX;
  return Math.max(t, n.startWidth + r);
}
function ZL(n, e) {
  n.dispatch(
    n.state.tr.setMeta(xi, { setHandle: e })
  );
}
function $Z(n, e, t) {
  const r = n.state.doc.resolve(e), i = r.node(-1), s = $t.get(i), o = r.start(-1), a = s.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, l = n.state.tr;
  for (let c = 0; c < s.height; c++) {
    const u = c * s.width + a;
    if (c && s.map[u] == s.map[u - s.width]) continue;
    const h = s.map[u], f = i.nodeAt(h).attrs, m = f.colspan == 1 ? 0 : a - s.colCount(h);
    if (f.colwidth && f.colwidth[m] == t) continue;
    const y = f.colwidth ? f.colwidth.slice() : jZ(f.colspan);
    y[m] = t, l.setNodeMarkup(o + h, null, { ...f, colwidth: y });
  }
  l.docChanged && n.dispatch(l);
}
function oS(n, e, t, r) {
  const i = n.state.doc.resolve(e), s = i.node(-1), o = i.start(-1), a = $t.get(s).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1;
  let l = n.domAtPos(i.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; )
    l = l.parentNode;
  l && P4(
    s,
    l.firstChild,
    l,
    r,
    a,
    t
  );
}
function jZ(n) {
  return Array(n).fill(0);
}
function WZ(n, e) {
  var t;
  const r = [], i = n.doc.resolve(e), s = i.node(-1);
  if (!s)
    return Qt.empty;
  const o = $t.get(s), a = i.start(-1), l = o.colCount(i.pos - a) + i.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < o.height; c++) {
    const u = l + c * o.width;
    if ((l == o.width - 1 || o.map[u] != o.map[u + 1]) && (c == 0 || o.map[u] != o.map[u - o.width])) {
      const h = o.map[u], f = a + h + s.nodeAt(h).nodeSize - 1, m = document.createElement("div");
      m.className = "column-resize-handle", (t = xi.getState(n)) != null && t.dragging && r.push(
        qn.node(
          a + h,
          a + h + s.nodeAt(h).nodeSize,
          {
            class: "column-resize-dragging"
          }
        )
      ), r.push(qn.widget(f, m));
    }
  }
  return Qt.create(n.doc, r);
}
function UZ({
  allowTableNodeSelection: n = !1
} = {}) {
  return new mn({
    key: Ha,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(e, t) {
        const r = e.getMeta(Ha);
        if (r != null) return r == -1 ? null : r;
        if (t == null || !e.docChanged) return t;
        const { deleted: i, pos: s } = e.mapping.mapResult(t);
        return i ? null : s;
      }
    },
    props: {
      decorations: rZ,
      handleDOMEvents: {
        mousedown: _Z
      },
      createSelectionBetween(e) {
        return Ha.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: NZ,
      handleKeyDown: DZ,
      handlePaste: IZ
    },
    appendTransaction(e, t, r) {
      return oZ(
        r,
        lZ(r, t),
        n
      );
    }
  });
}
var n1 = typeof navigator < "u" ? navigator : null, g3 = n1 && n1.userAgent || "", KZ = /Edge\/(\d+)/.exec(g3), GZ = /MSIE \d/.exec(g3), JZ = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(g3), YZ = !!(GZ || JZ || KZ), XZ = !YZ && !!n1 && /Apple Computer/.test(n1.vendor), QL = new gn("safari-ime-span"), B4 = !1, ZZ = {
  key: QL,
  props: {
    decorations: QZ,
    handleDOMEvents: {
      compositionstart: () => {
        B4 = !0;
      },
      compositionend: () => {
        B4 = !1;
      }
    }
  }
};
function QZ(n) {
  const { $from: e, $to: t, to: r } = n.selection;
  if (B4 && e.sameParent(t)) {
    const i = qn.widget(r, eQ, {
      ignoreSelection: !0,
      key: "safari-ime-span"
    });
    return Qt.create(n.doc, [i]);
  }
}
function eQ(n) {
  const e = n.dom.ownerDocument.createElement("span");
  return e.className = "ProseMirror-safari-ime-span", e;
}
var tQ = new mn(XZ ? ZZ : { key: QL });
function aS(n, e) {
  const t = String(n);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, i = t.indexOf(e);
  for (; i !== -1; )
    r++, i = t.indexOf(e, i + e.length);
  return r;
}
function nQ(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function rQ(n, e, t) {
  const i = U1((t || {}).ignore || []), s = iQ(e);
  let o = -1;
  for (; ++o < s.length; )
    Zw(n, "text", a);
  function a(c, u) {
    let h = -1, f;
    for (; ++h < u.length; ) {
      const m = u[h], y = f ? f.children : void 0;
      if (i(
        m,
        y ? y.indexOf(m) : void 0,
        f
      ))
        return;
      f = m;
    }
    if (f)
      return l(c, u);
  }
  function l(c, u) {
    const h = u[u.length - 1], f = s[o][0], m = s[o][1];
    let y = 0;
    const k = h.children.indexOf(c);
    let x = !1, M = [];
    f.lastIndex = 0;
    let T = f.exec(c.value);
    for (; T; ) {
      const E = T.index, C = {
        index: T.index,
        input: T.input,
        stack: [...u, c]
      };
      let O = m(...T, C);
      if (typeof O == "string" && (O = O.length > 0 ? { type: "text", value: O } : void 0), O === !1 ? f.lastIndex = E + 1 : (y !== E && M.push({
        type: "text",
        value: c.value.slice(y, E)
      }), Array.isArray(O) ? M.push(...O) : O && M.push(O), y = E + T[0].length, x = !0), !f.global)
        break;
      T = f.exec(c.value);
    }
    return x ? (y < c.value.length && M.push({ type: "text", value: c.value.slice(y) }), h.children.splice(k, 1, ...M)) : M = [c], k + M.length;
  }
}
function iQ(n) {
  const e = [];
  if (!Array.isArray(n))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const t = !n[0] || Array.isArray(n[0]) ? n : [n];
  let r = -1;
  for (; ++r < t.length; ) {
    const i = t[r];
    e.push([sQ(i[0]), oQ(i[1])]);
  }
  return e;
}
function sQ(n) {
  return typeof n == "string" ? new RegExp(nQ(n), "g") : n;
}
function oQ(n) {
  return typeof n == "function" ? n : function() {
    return n;
  };
}
const h2 = "phrasing", f2 = ["autolink", "link", "image", "label"];
function aQ() {
  return {
    transforms: [pQ],
    enter: {
      literalAutolink: cQ,
      literalAutolinkEmail: d2,
      literalAutolinkHttp: d2,
      literalAutolinkWww: d2
    },
    exit: {
      literalAutolink: dQ,
      literalAutolinkEmail: fQ,
      literalAutolinkHttp: uQ,
      literalAutolinkWww: hQ
    }
  };
}
function lQ() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: h2,
        notInConstruct: f2
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: h2,
        notInConstruct: f2
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: h2,
        notInConstruct: f2
      }
    ]
  };
}
function cQ(n) {
  this.enter({ type: "link", title: null, url: "", children: [] }, n);
}
function d2(n) {
  this.config.enter.autolinkProtocol.call(this, n);
}
function uQ(n) {
  this.config.exit.autolinkProtocol.call(this, n);
}
function hQ(n) {
  this.config.exit.data.call(this, n);
  const e = this.stack[this.stack.length - 1];
  e.type, e.url = "http://" + this.sliceSerialize(n);
}
function fQ(n) {
  this.config.exit.autolinkEmail.call(this, n);
}
function dQ(n) {
  this.exit(n);
}
function pQ(n) {
  rQ(
    n,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, mQ],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), gQ]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function mQ(n, e, t, r, i) {
  let s = "";
  if (!eO(i) || (/^w/i.test(e) && (t = e + t, e = "", s = "http://"), !yQ(t)))
    return !1;
  const o = bQ(t + r);
  if (!o[0]) return !1;
  const a = {
    type: "link",
    title: null,
    url: s + e + o[0],
    children: [{ type: "text", value: e + o[0] }]
  };
  return o[1] ? [a, { type: "text", value: o[1] }] : a;
}
function gQ(n, e, t, r) {
  return (
    // Not an expected previous character.
    !eO(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(t) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + e + "@" + t,
      children: [{ type: "text", value: e + "@" + t }]
    }
  );
}
function yQ(n) {
  const e = n.split(".");
  return !(e.length < 2 || e[e.length - 1] && (/_/.test(e[e.length - 1]) || !/[a-zA-Z\d]/.test(e[e.length - 1])) || e[e.length - 2] && (/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])));
}
function bQ(n) {
  const e = /[!"&'),.:;<>?\]}]+$/.exec(n);
  if (!e)
    return [n, void 0];
  n = n.slice(0, e.index);
  let t = e[0], r = t.indexOf(")");
  const i = aS(n, "(");
  let s = aS(n, ")");
  for (; r !== -1 && i > s; )
    n += t.slice(0, r + 1), t = t.slice(r + 1), r = t.indexOf(")"), s++;
  return [n, t];
}
function eO(n, e) {
  const t = n.input.charCodeAt(n.index - 1);
  return (n.index === 0 || Oc(t) || j1(t)) && // If it’s an email, the previous character should not be a slash.
  (!e || t !== 47);
}
tO.peek = AQ;
function vQ() {
  this.buffer();
}
function wQ(n) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, n);
}
function kQ() {
  this.buffer();
}
function xQ(n) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    n
  );
}
function SQ(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = bs(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function CQ(n) {
  this.exit(n);
}
function MQ(n) {
  const e = this.resume(), t = this.stack[this.stack.length - 1];
  t.type, t.identifier = bs(
    this.sliceSerialize(n)
  ).toLowerCase(), t.label = e;
}
function TQ(n) {
  this.exit(n);
}
function AQ() {
  return "[";
}
function tO(n, e, t, r) {
  const i = t.createTracker(r);
  let s = i.move("[^");
  const o = t.enter("footnoteReference"), a = t.enter("reference");
  return s += i.move(
    t.safe(t.associationId(n), { after: "]", before: s })
  ), a(), o(), s += i.move("]"), s;
}
function EQ() {
  return {
    enter: {
      gfmFootnoteCallString: vQ,
      gfmFootnoteCall: wQ,
      gfmFootnoteDefinitionLabelString: kQ,
      gfmFootnoteDefinition: xQ
    },
    exit: {
      gfmFootnoteCallString: SQ,
      gfmFootnoteCall: CQ,
      gfmFootnoteDefinitionLabelString: MQ,
      gfmFootnoteDefinition: TQ
    }
  };
}
function LQ(n) {
  let e = !1;
  return n && n.firstLineBlank && (e = !0), {
    handlers: { footnoteDefinition: t, footnoteReference: tO },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function t(r, i, s, o) {
    const a = s.createTracker(o);
    let l = a.move("[^");
    const c = s.enter("footnoteDefinition"), u = s.enter("label");
    return l += a.move(
      s.safe(s.associationId(r), { before: l, after: "]" })
    ), u(), l += a.move("]:"), r.children && r.children.length > 0 && (a.shift(4), l += a.move(
      (e ? `
` : " ") + s.indentLines(
        s.containerFlow(r, a.current()),
        e ? nO : OQ
      )
    )), c(), l;
  }
}
function OQ(n, e, t) {
  return e === 0 ? n : nO(n, e, t);
}
function nO(n, e, t) {
  return (t ? "" : "    ") + n;
}
const DQ = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
rO.peek = PQ;
function NQ() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: _Q },
    exit: { strikethrough: RQ }
  };
}
function IQ() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: DQ
      }
    ],
    handlers: { delete: rO }
  };
}
function _Q(n) {
  this.enter({ type: "delete", children: [] }, n);
}
function RQ(n) {
  this.exit(n);
}
function rO(n, e, t, r) {
  const i = t.createTracker(r), s = t.enter("strikethrough");
  let o = i.move("~~");
  return o += t.containerPhrasing(n, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), s(), o;
}
function PQ() {
  return "~";
}
function BQ(n) {
  return n.length;
}
function HQ(n, e) {
  const t = e || {}, r = (t.align || []).concat(), i = t.stringLength || BQ, s = [], o = [], a = [], l = [];
  let c = 0, u = -1;
  for (; ++u < n.length; ) {
    const b = [], k = [];
    let x = -1;
    for (n[u].length > c && (c = n[u].length); ++x < n[u].length; ) {
      const M = zQ(n[u][x]);
      if (t.alignDelimiters !== !1) {
        const T = i(M);
        k[x] = T, (l[x] === void 0 || T > l[x]) && (l[x] = T);
      }
      b.push(M);
    }
    o[u] = b, a[u] = k;
  }
  let h = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++h < c; )
      s[h] = lS(r[h]);
  else {
    const b = lS(r);
    for (; ++h < c; )
      s[h] = b;
  }
  h = -1;
  const f = [], m = [];
  for (; ++h < c; ) {
    const b = s[h];
    let k = "", x = "";
    b === 99 ? (k = ":", x = ":") : b === 108 ? k = ":" : b === 114 && (x = ":");
    let M = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[h] - k.length - x.length
    );
    const T = k + "-".repeat(M) + x;
    t.alignDelimiters !== !1 && (M = k.length + M + x.length, M > l[h] && (l[h] = M), m[h] = M), f[h] = T;
  }
  o.splice(1, 0, f), a.splice(1, 0, m), u = -1;
  const y = [];
  for (; ++u < o.length; ) {
    const b = o[u], k = a[u];
    h = -1;
    const x = [];
    for (; ++h < c; ) {
      const M = b[h] || "";
      let T = "", E = "";
      if (t.alignDelimiters !== !1) {
        const C = l[h] - (k[h] || 0), O = s[h];
        O === 114 ? T = " ".repeat(C) : O === 99 ? C % 2 ? (T = " ".repeat(C / 2 + 0.5), E = " ".repeat(C / 2 - 0.5)) : (T = " ".repeat(C / 2), E = T) : E = " ".repeat(C);
      }
      t.delimiterStart !== !1 && !h && x.push("|"), t.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && M === "") && (t.delimiterStart !== !1 || h) && x.push(" "), t.alignDelimiters !== !1 && x.push(T), x.push(M), t.alignDelimiters !== !1 && x.push(E), t.padding !== !1 && x.push(" "), (t.delimiterEnd !== !1 || h !== c - 1) && x.push("|");
    }
    y.push(
      t.delimiterEnd === !1 ? x.join("").replace(/ +$/, "") : x.join("")
    );
  }
  return y.join(`
`);
}
function zQ(n) {
  return n == null ? "" : String(n);
}
function lS(n) {
  const e = typeof n == "string" ? n.codePointAt(0) : 0;
  return e === 67 || e === 99 ? 99 : e === 76 || e === 108 ? 108 : e === 82 || e === 114 ? 114 : 0;
}
function FQ() {
  return {
    enter: {
      table: VQ,
      tableData: cS,
      tableHeader: cS,
      tableRow: $Q
    },
    exit: {
      codeText: jQ,
      table: qQ,
      tableData: p2,
      tableHeader: p2,
      tableRow: p2
    }
  };
}
function VQ(n) {
  const e = n._align;
  this.enter(
    {
      type: "table",
      align: e.map(function(t) {
        return t === "none" ? null : t;
      }),
      children: []
    },
    n
  ), this.data.inTable = !0;
}
function qQ(n) {
  this.exit(n), this.data.inTable = void 0;
}
function $Q(n) {
  this.enter({ type: "tableRow", children: [] }, n);
}
function p2(n) {
  this.exit(n);
}
function cS(n) {
  this.enter({ type: "tableCell", children: [] }, n);
}
function jQ(n) {
  let e = this.resume();
  this.data.inTable && (e = e.replace(/\\([\\|])/g, WQ));
  const t = this.stack[this.stack.length - 1];
  t.type, t.value = e, this.exit(n);
}
function WQ(n, e) {
  return e === "|" ? e : n;
}
function UQ(n) {
  const e = n || {}, t = e.tableCellPadding, r = e.tablePipeAlign, i = e.stringLength, s = t ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: f,
      table: o,
      tableCell: l,
      tableRow: a
    }
  };
  function o(m, y, b, k) {
    return c(u(m, b, k), m.align);
  }
  function a(m, y, b, k) {
    const x = h(m, b, k), M = c([x]);
    return M.slice(0, M.indexOf(`
`));
  }
  function l(m, y, b, k) {
    const x = b.enter("tableCell"), M = b.enter("phrasing"), T = b.containerPhrasing(m, {
      ...k,
      before: s,
      after: s
    });
    return M(), x(), T;
  }
  function c(m, y) {
    return HQ(m, {
      align: y,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: t,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(m, y, b) {
    const k = m.children;
    let x = -1;
    const M = [], T = y.enter("table");
    for (; ++x < k.length; )
      M[x] = h(k[x], y, b);
    return T(), M;
  }
  function h(m, y, b) {
    const k = m.children;
    let x = -1;
    const M = [], T = y.enter("tableRow");
    for (; ++x < k.length; )
      M[x] = l(k[x], m, y, b);
    return T(), M;
  }
  function f(m, y, b) {
    let k = e5.inlineCode(m, y, b);
    return b.stack.includes("tableCell") && (k = k.replace(/\|/g, "\\$&")), k;
  }
}
function KQ() {
  return {
    exit: {
      taskListCheckValueChecked: uS,
      taskListCheckValueUnchecked: uS,
      paragraph: JQ
    }
  };
}
function GQ() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: YQ }
  };
}
function uS(n) {
  const e = this.stack[this.stack.length - 2];
  e.type, e.checked = n.type === "taskListCheckValueChecked";
}
function JQ(n) {
  const e = this.stack[this.stack.length - 2];
  if (e && e.type === "listItem" && typeof e.checked == "boolean") {
    const t = this.stack[this.stack.length - 1];
    t.type;
    const r = t.children[0];
    if (r && r.type === "text") {
      const i = e.children;
      let s = -1, o;
      for (; ++s < i.length; ) {
        const a = i[s];
        if (a.type === "paragraph") {
          o = a;
          break;
        }
      }
      o === t && (r.value = r.value.slice(1), r.value.length === 0 ? t.children.shift() : t.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, t.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(n);
}
function YQ(n, e, t, r) {
  const i = n.children[0], s = typeof n.checked == "boolean" && i && i.type === "paragraph", o = "[" + (n.checked ? "x" : " ") + "] ", a = t.createTracker(r);
  s && a.move(o);
  let l = e5.listItem(n, e, t, {
    ...r,
    ...a.current()
  });
  return s && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + o;
  }
}
function XQ() {
  return [
    aQ(),
    EQ(),
    NQ(),
    FQ(),
    KQ()
  ];
}
function ZQ(n) {
  return {
    extensions: [
      lQ(),
      LQ(n),
      IQ(),
      UQ(n),
      GQ()
    ]
  };
}
const QQ = {
  tokenize: see,
  partial: !0
}, iO = {
  tokenize: oee,
  partial: !0
}, sO = {
  tokenize: aee,
  partial: !0
}, oO = {
  tokenize: lee,
  partial: !0
}, eee = {
  tokenize: cee,
  partial: !0
}, aO = {
  name: "wwwAutolink",
  tokenize: ree,
  previous: cO
}, lO = {
  name: "protocolAutolink",
  tokenize: iee,
  previous: uO
}, ga = {
  name: "emailAutolink",
  tokenize: nee,
  previous: hO
}, ho = {};
function tee() {
  return {
    text: ho
  };
}
let Dl = 48;
for (; Dl < 123; )
  ho[Dl] = ga, Dl++, Dl === 58 ? Dl = 65 : Dl === 91 && (Dl = 97);
ho[43] = ga;
ho[45] = ga;
ho[46] = ga;
ho[95] = ga;
ho[72] = [ga, lO];
ho[104] = [ga, lO];
ho[87] = [ga, aO];
ho[119] = [ga, aO];
function nee(n, e, t) {
  const r = this;
  let i, s;
  return o;
  function o(h) {
    return !H4(h) || !hO.call(r, r.previous) || y3(r.events) ? t(h) : (n.enter("literalAutolink"), n.enter("literalAutolinkEmail"), a(h));
  }
  function a(h) {
    return H4(h) ? (n.consume(h), a) : h === 64 ? (n.consume(h), l) : t(h);
  }
  function l(h) {
    return h === 46 ? n.check(eee, u, c)(h) : h === 45 || h === 95 || ei(h) ? (s = !0, n.consume(h), l) : u(h);
  }
  function c(h) {
    return n.consume(h), i = !0, l;
  }
  function u(h) {
    return s && i && Or(r.previous) ? (n.exit("literalAutolinkEmail"), n.exit("literalAutolink"), e(h)) : t(h);
  }
}
function ree(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !cO.call(r, r.previous) || y3(r.events) ? t(o) : (n.enter("literalAutolink"), n.enter("literalAutolinkWww"), n.check(QQ, n.attempt(iO, n.attempt(sO, s), t), t)(o));
  }
  function s(o) {
    return n.exit("literalAutolinkWww"), n.exit("literalAutolink"), e(o);
  }
}
function iee(n, e, t) {
  const r = this;
  let i = "", s = !1;
  return o;
  function o(h) {
    return (h === 72 || h === 104) && uO.call(r, r.previous) && !y3(r.events) ? (n.enter("literalAutolink"), n.enter("literalAutolinkHttp"), i += String.fromCodePoint(h), n.consume(h), a) : t(h);
  }
  function a(h) {
    if (Or(h) && i.length < 5)
      return i += String.fromCodePoint(h), n.consume(h), a;
    if (h === 58) {
      const f = i.toLowerCase();
      if (f === "http" || f === "https")
        return n.consume(h), l;
    }
    return t(h);
  }
  function l(h) {
    return h === 47 ? (n.consume(h), s ? c : (s = !0, l)) : t(h);
  }
  function c(h) {
    return h === null || qg(h) || tn(h) || Oc(h) || j1(h) ? t(h) : n.attempt(iO, n.attempt(sO, u), t)(h);
  }
  function u(h) {
    return n.exit("literalAutolinkHttp"), n.exit("literalAutolink"), e(h);
  }
}
function see(n, e, t) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, n.consume(o), i) : o === 46 && r === 3 ? (n.consume(o), s) : t(o);
  }
  function s(o) {
    return o === null ? t(o) : e(o);
  }
}
function oee(n, e, t) {
  let r, i, s;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? n.check(oO, l, a)(c) : c === null || tn(c) || Oc(c) || c !== 45 && j1(c) ? l(c) : (s = !0, n.consume(c), o);
  }
  function a(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), n.consume(c), o;
  }
  function l(c) {
    return i || r || !s ? t(c) : e(c);
  }
}
function aee(n, e) {
  let t = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (t++, n.consume(o), i) : o === 41 && r < t ? s(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? n.check(oO, e, s)(o) : o === null || tn(o) || Oc(o) ? e(o) : (n.consume(o), i);
  }
  function s(o) {
    return o === 41 && r++, n.consume(o), i;
  }
}
function lee(n, e, t) {
  return r;
  function r(a) {
    return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (n.consume(a), r) : a === 38 ? (n.consume(a), s) : a === 93 ? (n.consume(a), i) : (
      // `<` is an end.
      a === 60 || // So is whitespace.
      a === null || tn(a) || Oc(a) ? e(a) : t(a)
    );
  }
  function i(a) {
    return a === null || a === 40 || a === 91 || tn(a) || Oc(a) ? e(a) : r(a);
  }
  function s(a) {
    return Or(a) ? o(a) : t(a);
  }
  function o(a) {
    return a === 59 ? (n.consume(a), r) : Or(a) ? (n.consume(a), o) : t(a);
  }
}
function cee(n, e, t) {
  return r;
  function r(s) {
    return n.consume(s), i;
  }
  function i(s) {
    return ei(s) ? t(s) : e(s);
  }
}
function cO(n) {
  return n === null || n === 40 || n === 42 || n === 95 || n === 91 || n === 93 || n === 126 || tn(n);
}
function uO(n) {
  return !Or(n);
}
function hO(n) {
  return !(n === 47 || H4(n));
}
function H4(n) {
  return n === 43 || n === 45 || n === 46 || n === 95 || ei(n);
}
function y3(n) {
  let e = n.length, t = !1;
  for (; e--; ) {
    const r = n[e][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      t = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      t = !1;
      break;
    }
  }
  return n.length > 0 && !t && (n[n.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), t;
}
const uee = {
  tokenize: bee,
  partial: !0
};
function hee() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: mee,
        continuation: {
          tokenize: gee
        },
        exit: yee
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: pee
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: fee,
        resolveTo: dee
      }
    }
  };
}
function fee(n, e, t) {
  const r = this;
  let i = r.events.length;
  const s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const l = r.events[i][1];
    if (l.type === "labelImage") {
      o = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return a;
  function a(l) {
    if (!o || !o._balanced)
      return t(l);
    const c = bs(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !s.includes(c.slice(1)) ? t(l) : (n.enter("gfmFootnoteCallLabelMarker"), n.consume(l), n.exit("gfmFootnoteCallLabelMarker"), e(l));
  }
}
function dee(n, e) {
  let t = n.length;
  for (; t--; )
    if (n[t][1].type === "labelImage" && n[t][0] === "enter") {
      n[t][1];
      break;
    }
  n[t + 1][1].type = "data", n[t + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, n[t + 3][1].start),
    end: Object.assign({}, n[n.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, n[t + 3][1].end),
    end: Object.assign({}, n[t + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const s = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, n[n.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, s.start),
    end: Object.assign({}, s.end)
  }, a = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    n[t + 1],
    n[t + 2],
    ["enter", r, e],
    // The `[`
    n[t + 3],
    n[t + 4],
    // The `^`.
    ["enter", i, e],
    ["exit", i, e],
    // Everything in between.
    ["enter", s, e],
    ["enter", o, e],
    ["exit", o, e],
    ["exit", s, e],
    // The ending (`]`, properly parsed and labelled).
    n[n.length - 2],
    n[n.length - 1],
    ["exit", r, e]
  ];
  return n.splice(t, n.length - t + 1, ...a), n;
}
function pee(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s = 0, o;
  return a;
  function a(h) {
    return n.enter("gfmFootnoteCall"), n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(h) {
    return h !== 94 ? t(h) : (n.enter("gfmFootnoteCallMarker"), n.consume(h), n.exit("gfmFootnoteCallMarker"), n.enter("gfmFootnoteCallString"), n.enter("chunkString").contentType = "string", c);
  }
  function c(h) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || tn(h)
    )
      return t(h);
    if (h === 93) {
      n.exit("chunkString");
      const f = n.exit("gfmFootnoteCallString");
      return i.includes(bs(r.sliceSerialize(f))) ? (n.enter("gfmFootnoteCallLabelMarker"), n.consume(h), n.exit("gfmFootnoteCallLabelMarker"), n.exit("gfmFootnoteCall"), e) : t(h);
    }
    return tn(h) || (o = !0), s++, n.consume(h), h === 92 ? u : c;
  }
  function u(h) {
    return h === 91 || h === 92 || h === 93 ? (n.consume(h), s++, c) : c(h);
  }
}
function mee(n, e, t) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s, o = 0, a;
  return l;
  function l(y) {
    return n.enter("gfmFootnoteDefinition")._container = !0, n.enter("gfmFootnoteDefinitionLabel"), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(y), n.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(y) {
    return y === 94 ? (n.enter("gfmFootnoteDefinitionMarker"), n.consume(y), n.exit("gfmFootnoteDefinitionMarker"), n.enter("gfmFootnoteDefinitionLabelString"), n.enter("chunkString").contentType = "string", u) : t(y);
  }
  function u(y) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      y === 93 && !a || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      y === null || y === 91 || tn(y)
    )
      return t(y);
    if (y === 93) {
      n.exit("chunkString");
      const b = n.exit("gfmFootnoteDefinitionLabelString");
      return s = bs(r.sliceSerialize(b)), n.enter("gfmFootnoteDefinitionLabelMarker"), n.consume(y), n.exit("gfmFootnoteDefinitionLabelMarker"), n.exit("gfmFootnoteDefinitionLabel"), f;
    }
    return tn(y) || (a = !0), o++, n.consume(y), y === 92 ? h : u;
  }
  function h(y) {
    return y === 91 || y === 92 || y === 93 ? (n.consume(y), o++, u) : u(y);
  }
  function f(y) {
    return y === 58 ? (n.enter("definitionMarker"), n.consume(y), n.exit("definitionMarker"), i.includes(s) || i.push(s), Ct(n, m, "gfmFootnoteDefinitionWhitespace")) : t(y);
  }
  function m(y) {
    return e(y);
  }
}
function gee(n, e, t) {
  return n.check(j0, e, n.attempt(uee, e, t));
}
function yee(n) {
  n.exit("gfmFootnoteDefinition");
}
function bee(n, e, t) {
  const r = this;
  return Ct(n, i, "gfmFootnoteDefinitionIndent", 5);
  function i(s) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? e(s) : t(s);
  }
}
function vee(n) {
  let t = (n || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: s,
    resolveAll: i
  };
  return t == null && (t = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, a) {
    let l = -1;
    for (; ++l < o.length; )
      if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
        let c = l;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[l][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[l][1].end)
            }, h = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[l][1].start)
            }, f = [["enter", u, a], ["enter", o[c][1], a], ["exit", o[c][1], a], ["enter", h, a]], m = a.parser.constructs.insideSpan.null;
            m && Ti(f, f.length, 0, W1(m, o.slice(c + 1, l), a)), Ti(f, f.length, 0, [["exit", h, a], ["enter", o[l][1], a], ["exit", o[l][1], a], ["exit", u, a]]), Ti(o, c - 1, l - c + 3, f), l = c + f.length - 2;
            break;
          }
      }
    for (l = -1; ++l < o.length; )
      o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
    return o;
  }
  function s(o, a, l) {
    const c = this.previous, u = this.events;
    let h = 0;
    return f;
    function f(y) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(y) : (o.enter("strikethroughSequenceTemporary"), m(y));
    }
    function m(y) {
      const b = fh(c);
      if (y === 126)
        return h > 1 ? l(y) : (o.consume(y), h++, m);
      if (h < 2 && !t) return l(y);
      const k = o.exit("strikethroughSequenceTemporary"), x = fh(y);
      return k._open = !x || x === 2 && !!b, k._close = !b || b === 2 && !!x, a(y);
    }
  }
}
class wee {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(e, t, r) {
    kee(this, e, t, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(e) {
    if (this.map.sort(function(s, o) {
      return s[0] - o[0];
    }), this.map.length === 0)
      return;
    let t = this.map.length;
    const r = [];
    for (; t > 0; )
      t -= 1, r.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0];
    r.push(e.slice()), e.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const s of i)
        e.push(s);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function kee(n, e, t, r) {
  let i = 0;
  if (!(t === 0 && r.length === 0)) {
    for (; i < n.map.length; ) {
      if (n.map[i][0] === e) {
        n.map[i][1] += t, n.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    n.map.push([e, t, r]);
  }
}
function xee(n, e) {
  let t = !1;
  const r = [];
  for (; e < n.length; ) {
    const i = n[e];
    if (t) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(n[e + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (n[e - 1][1].type === "tableDelimiterMarker") {
          const s = r.length - 1;
          r[s] = r[s] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (t = !0);
    e += 1;
  }
  return r;
}
function See() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: Cee,
        resolveAll: Mee
      }
    }
  };
}
function Cee(n, e, t) {
  const r = this;
  let i = 0, s = 0, o;
  return a;
  function a(z) {
    let K = r.events.length - 1;
    for (; K > -1; ) {
      const ie = r.events[K][1].type;
      if (ie === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ie === "linePrefix") K--;
      else break;
    }
    const U = K > -1 ? r.events[K][1].type : null, ae = U === "tableHead" || U === "tableRow" ? O : l;
    return ae === O && r.parser.lazy[r.now().line] ? t(z) : ae(z);
  }
  function l(z) {
    return n.enter("tableHead"), n.enter("tableRow"), c(z);
  }
  function c(z) {
    return z === 124 || (o = !0, s += 1), u(z);
  }
  function u(z) {
    return z === null ? t(z) : Xe(z) ? s > 1 ? (s = 0, r.interrupt = !0, n.exit("tableRow"), n.enter("lineEnding"), n.consume(z), n.exit("lineEnding"), m) : t(z) : Lt(z) ? Ct(n, u, "whitespace")(z) : (s += 1, o && (o = !1, i += 1), z === 124 ? (n.enter("tableCellDivider"), n.consume(z), n.exit("tableCellDivider"), o = !0, u) : (n.enter("data"), h(z)));
  }
  function h(z) {
    return z === null || z === 124 || tn(z) ? (n.exit("data"), u(z)) : (n.consume(z), z === 92 ? f : h);
  }
  function f(z) {
    return z === 92 || z === 124 ? (n.consume(z), h) : h(z);
  }
  function m(z) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? t(z) : (n.enter("tableDelimiterRow"), o = !1, Lt(z) ? Ct(n, y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(z) : y(z));
  }
  function y(z) {
    return z === 45 || z === 58 ? k(z) : z === 124 ? (o = !0, n.enter("tableCellDivider"), n.consume(z), n.exit("tableCellDivider"), b) : C(z);
  }
  function b(z) {
    return Lt(z) ? Ct(n, k, "whitespace")(z) : k(z);
  }
  function k(z) {
    return z === 58 ? (s += 1, o = !0, n.enter("tableDelimiterMarker"), n.consume(z), n.exit("tableDelimiterMarker"), x) : z === 45 ? (s += 1, x(z)) : z === null || Xe(z) ? E(z) : C(z);
  }
  function x(z) {
    return z === 45 ? (n.enter("tableDelimiterFiller"), M(z)) : C(z);
  }
  function M(z) {
    return z === 45 ? (n.consume(z), M) : z === 58 ? (o = !0, n.exit("tableDelimiterFiller"), n.enter("tableDelimiterMarker"), n.consume(z), n.exit("tableDelimiterMarker"), T) : (n.exit("tableDelimiterFiller"), T(z));
  }
  function T(z) {
    return Lt(z) ? Ct(n, E, "whitespace")(z) : E(z);
  }
  function E(z) {
    return z === 124 ? y(z) : z === null || Xe(z) ? !o || i !== s ? C(z) : (n.exit("tableDelimiterRow"), n.exit("tableHead"), e(z)) : C(z);
  }
  function C(z) {
    return t(z);
  }
  function O(z) {
    return n.enter("tableRow"), R(z);
  }
  function R(z) {
    return z === 124 ? (n.enter("tableCellDivider"), n.consume(z), n.exit("tableCellDivider"), R) : z === null || Xe(z) ? (n.exit("tableRow"), e(z)) : Lt(z) ? Ct(n, R, "whitespace")(z) : (n.enter("data"), F(z));
  }
  function F(z) {
    return z === null || z === 124 || tn(z) ? (n.exit("data"), R(z)) : (n.consume(z), z === 92 ? H : F);
  }
  function H(z) {
    return z === 92 || z === 124 ? (n.consume(z), F) : F(z);
  }
}
function Mee(n, e) {
  let t = -1, r = !0, i = 0, s = [0, 0, 0, 0], o = [0, 0, 0, 0], a = !1, l = 0, c, u, h;
  const f = new wee();
  for (; ++t < n.length; ) {
    const m = n[t], y = m[1];
    m[0] === "enter" ? y.type === "tableHead" ? (a = !1, l !== 0 && (hS(f, e, l, c, u), u = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, y.start),
      // Note: correct end is set later.
      end: Object.assign({}, y.end)
    }, f.add(t, 0, [["enter", c, e]])) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (r = !0, h = void 0, s = [0, 0, 0, 0], o = [0, t + 1, 0, 0], a && (a = !1, u = {
      type: "tableBody",
      start: Object.assign({}, y.start),
      // Note: correct end is set later.
      end: Object.assign({}, y.end)
    }, f.add(t, 0, [["enter", u, e]])), i = y.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (s[1] !== 0 && (o[0] = o[1], h = tm(f, e, s, i, void 0, h), s = [0, 0, 0, 0]), o[2] = t)) : y.type === "tableCellDivider" && (r ? r = !1 : (s[1] !== 0 && (o[0] = o[1], h = tm(f, e, s, i, void 0, h)), s = o, o = [s[1], t, 0, 0])) : y.type === "tableHead" ? (a = !0, l = t) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (l = t, s[1] !== 0 ? (o[0] = o[1], h = tm(f, e, s, i, t, h)) : o[1] !== 0 && (h = tm(f, e, o, i, t, h)), i = 0) : i && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") && (o[3] = t);
  }
  for (l !== 0 && hS(f, e, l, c, u), f.consume(e.events), t = -1; ++t < e.events.length; ) {
    const m = e.events[t];
    m[0] === "enter" && m[1].type === "table" && (m[1]._align = xee(e.events, t));
  }
  return n;
}
function tm(n, e, t, r, i, s) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent";
  t[0] !== 0 && (s.end = Object.assign({}, cu(e.events, t[0])), n.add(t[0], 0, [["exit", s, e]]));
  const l = cu(e.events, t[1]);
  if (s = {
    type: o,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, n.add(t[1], 0, [["enter", s, e]]), t[2] !== 0) {
    const c = cu(e.events, t[2]), u = cu(e.events, t[3]), h = {
      type: a,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (n.add(t[2], 0, [["enter", h, e]]), r !== 2) {
      const f = e.events[t[2]], m = e.events[t[3]];
      if (f[1].end = Object.assign({}, m[1].end), f[1].type = "chunkText", f[1].contentType = "text", t[3] > t[2] + 1) {
        const y = t[2] + 1, b = t[3] - t[2] - 1;
        n.add(y, b, []);
      }
    }
    n.add(t[3] + 1, 0, [["exit", h, e]]);
  }
  return i !== void 0 && (s.end = Object.assign({}, cu(e.events, i)), n.add(i, 0, [["exit", s, e]]), s = void 0), s;
}
function hS(n, e, t, r, i) {
  const s = [], o = cu(e.events, t);
  i && (i.end = Object.assign({}, o), s.push(["exit", i, e])), r.end = Object.assign({}, o), s.push(["exit", r, e]), n.add(t + 1, 0, s);
}
function cu(n, e) {
  const t = n[e], r = t[0] === "enter" ? "start" : "end";
  return t[1][r];
}
const Tee = {
  name: "tasklistCheck",
  tokenize: Eee
};
function Aee() {
  return {
    text: {
      91: Tee
    }
  };
}
function Eee(n, e, t) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? t(l) : (n.enter("taskListCheck"), n.enter("taskListCheckMarker"), n.consume(l), n.exit("taskListCheckMarker"), s)
    );
  }
  function s(l) {
    return tn(l) ? (n.enter("taskListCheckValueUnchecked"), n.consume(l), n.exit("taskListCheckValueUnchecked"), o) : l === 88 || l === 120 ? (n.enter("taskListCheckValueChecked"), n.consume(l), n.exit("taskListCheckValueChecked"), o) : t(l);
  }
  function o(l) {
    return l === 93 ? (n.enter("taskListCheckMarker"), n.consume(l), n.exit("taskListCheckMarker"), n.exit("taskListCheck"), a) : t(l);
  }
  function a(l) {
    return Xe(l) ? e(l) : Lt(l) ? n.check({
      tokenize: Lee
    }, e, t)(l) : t(l);
  }
}
function Lee(n, e, t) {
  return Ct(n, r, "whitespace");
  function r(i) {
    return i === null ? t(i) : e(i);
  }
}
function Oee(n) {
  return gA([
    tee(),
    hee(),
    vee(n),
    See(),
    Aee()
  ]);
}
const Dee = {};
function Nee(n) {
  const e = (
    /** @type {Processor<Root>} */
    this
  ), t = n || Dee, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(Oee(t)), s.push(XQ()), o.push(ZQ(t));
}
function ut(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/preset-gfm",
      ...e
    }
  }), n;
}
const b3 = Y0("strike_through");
ut(b3, {
  displayName: "Attr<strikethrough>",
  group: "Strikethrough"
});
const Bh = Dh("strike_through", (n) => ({
  parseDOM: [
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: (e) => e === "line-through"
    }
  ],
  toDOM: (e) => ["del", n.get(b3.key)(e)],
  parseMarkdown: {
    match: (e) => e.type === "delete",
    runner: (e, t, r) => {
      e.openMark(r), e.next(t.children), e.closeMark(r);
    }
  },
  toMarkdown: {
    match: (e) => e.type.name === "strike_through",
    runner: (e, t) => {
      e.withMark(t, "delete");
    }
  }
}));
ut(Bh.mark, {
  displayName: "MarkSchema<strikethrough>",
  group: "Strikethrough"
});
ut(Bh.ctx, {
  displayName: "MarkSchemaCtx<strikethrough>",
  group: "Strikethrough"
});
const gy = ct(
  "ToggleStrikeThrough",
  (n) => () => G1(Bh.type(n))
);
ut(gy, {
  displayName: "Command<ToggleStrikethrough>",
  group: "Strikethrough"
});
const fO = Sr((n) => $0(
  new RegExp("(?<![\\w:/])(~{1,2})(.+?)\\1(?!\\w|\\/)"),
  Bh.type(n)
));
ut(fO, {
  displayName: "InputRule<strikethrough>",
  group: "Strikethrough"
});
const v3 = ai("strikeThroughKeymap", {
  ToggleStrikethrough: {
    shortcuts: "Mod-Alt-x",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(gy.key);
    }
  }
});
ut(v3.ctx, {
  displayName: "KeymapCtx<strikethrough>",
  group: "Strikethrough"
});
ut(v3.shortcuts, {
  displayName: "Keymap<strikethrough>",
  group: "Strikethrough"
});
const tp = XX({
  tableGroup: "block",
  cellContent: "paragraph",
  cellAttributes: {
    alignment: {
      default: "left",
      getFromDOM: (n) => n.style.textAlign || "left",
      setDOMAttr: (n, e) => {
        e.style = `text-align: ${n || "left"}`;
      }
    }
  }
}), qc = Rn("table", () => ({
  ...tp.table,
  content: "table_header_row table_row+",
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "table",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r,
        isHeader: o === 0
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table",
    runner: (n, e) => {
      var i;
      const t = (i = e.content.firstChild) == null ? void 0 : i.content;
      if (!t) return;
      const r = [];
      t.forEach((s) => {
        r.push(s.attrs.alignment);
      }), n.openNode("table", void 0, { align: r }), n.next(e.content), n.closeNode();
    }
  }
}));
ut(qc.node, {
  displayName: "NodeSchema<table>",
  group: "Table"
});
ut(qc.ctx, {
  displayName: "NodeSchemaCtx<table>",
  group: "Table"
});
const yy = Rn("table_header_row", () => ({
  ...tp.table_row,
  disableDropCursor: !0,
  content: "(table_header)*",
  parseDOM: [{ tag: "tr[data-is-header]" }],
  toDOM() {
    return ["tr", { "data-is-header": !0 }, 0];
  },
  parseMarkdown: {
    match: (n) => !!(n.type === "tableRow" && n.isHeader),
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o],
        isHeader: e.isHeader
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header_row",
    runner: (n, e) => {
      n.openNode("tableRow", void 0, { isHeader: !0 }), n.next(e.content), n.closeNode();
    }
  }
}));
ut(yy.node, {
  displayName: "NodeSchema<tableHeaderRow>",
  group: "Table"
});
ut(yy.ctx, {
  displayName: "NodeSchemaCtx<tableHeaderRow>",
  group: "Table"
});
const np = Rn("table_row", () => ({
  ...tp.table_row,
  disableDropCursor: !0,
  content: "(table_cell)*",
  parseMarkdown: {
    match: (n) => n.type === "tableRow",
    runner: (n, e, t) => {
      const r = e.align, i = e.children.map((s, o) => ({
        ...s,
        align: r[o]
      }));
      n.openNode(t), n.next(i), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_row",
    runner: (n, e) => {
      e.content.size !== 0 && (n.openNode("tableRow"), n.next(e.content), n.closeNode());
    }
  }
}));
ut(np.node, {
  displayName: "NodeSchema<tableRow>",
  group: "Table"
});
ut(np.ctx, {
  displayName: "NodeSchemaCtx<tableRow>",
  group: "Table"
});
const rp = Rn("table_cell", () => ({
  ...tp.table_cell,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }).openNode(n.schema.nodes.paragraph).next(e.children).closeNode().closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_cell",
    runner: (n, e) => {
      n.openNode("tableCell").next(e.content).closeNode();
    }
  }
}));
ut(rp.node, {
  displayName: "NodeSchema<tableCell>",
  group: "Table"
});
ut(rp.ctx, {
  displayName: "NodeSchemaCtx<tableCell>",
  group: "Table"
});
const by = Rn("table_header", () => ({
  ...tp.table_header,
  disableDropCursor: !0,
  parseMarkdown: {
    match: (n) => n.type === "tableCell" && !!n.isHeader,
    runner: (n, e, t) => {
      const r = e.align;
      n.openNode(t, { alignment: r }), n.openNode(n.schema.nodes.paragraph), n.next(e.children), n.closeNode(), n.closeNode();
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === "table_header",
    runner: (n, e) => {
      n.openNode("tableCell"), n.next(e.content), n.closeNode();
    }
  }
}));
ut(by.node, {
  displayName: "NodeSchema<tableHeader>",
  group: "Table"
});
ut(by.ctx, {
  displayName: "NodeSchemaCtx<tableHeader>",
  group: "Table"
});
function w3(n, e = 3, t = 3) {
  const r = Array(t).fill(0).map(() => rp.type(n).createAndFill()), i = Array(t).fill(0).map(() => by.type(n).createAndFill()), s = Array(e).fill(0).map(
    (o, a) => a === 0 ? yy.type(n).create(null, i) : np.type(n).create(null, r)
  );
  return qc.type(n).create(null, s);
}
function dO(n) {
  return (e, t) => (r) => {
    t = t ?? r.selection.from;
    const i = r.doc.resolve(t), s = fA(
      (l) => l.type.name === "table"
    )(i), o = s ? {
      node: s.node,
      from: s.start
    } : void 0, a = n === "row";
    if (o) {
      const l = $t.get(o.node);
      if (e >= 0 && e < (a ? l.height : l.width)) {
        const c = l.positionAt(
          a ? e : l.height - 1,
          a ? l.width - 1 : e,
          o.node
        ), u = r.doc.resolve(o.from + c), h = a ? nn.rowSelection : nn.colSelection, f = l.positionAt(
          a ? e : 0,
          a ? 0 : e,
          o.node
        ), m = r.doc.resolve(o.from + f);
        return hA(
          r.setSelection(
            h(u, m)
          )
        );
      }
    }
    return r;
  };
}
const Iee = dO("row"), _ee = dO("col");
function pO(n, e, { map: t, tableStart: r, table: i }, s) {
  const o = Array(s).fill(0).reduce((l, c, u) => l + i.child(u).nodeSize, r), a = Array(t.width).fill(0).map((l, c) => {
    const u = i.nodeAt(t.map[c]);
    return rp.type(n).createAndFill({ alignment: u == null ? void 0 : u.attrs.alignment });
  });
  return e.insert(o, np.type(n).create(null, a)), e;
}
function Ree(n) {
  const e = Ph(n.$from);
  if (!e) return;
  const t = $t.get(e.node);
  return t.cellsInRect({
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  }).map((i) => {
    const s = e.node.nodeAt(i), o = i + e.start;
    return { pos: o, start: o + 1, node: s };
  });
}
function Pee(n) {
  const e = Ree(n.selection);
  if (e && e[0]) {
    const t = n.doc.resolve(e[0].pos), r = e[e.length - 1];
    if (r) {
      const i = n.doc.resolve(r.pos);
      return hA(n.setSelection(new nn(i, t)));
    }
  }
  return n;
}
const k3 = ct(
  "GoToPrevTableCell",
  () => () => YL(-1)
);
ut(k3, {
  displayName: "Command<goToPrevTableCellCommand>",
  group: "Table"
});
const x3 = ct(
  "GoToNextTableCell",
  () => () => YL(1)
);
ut(x3, {
  displayName: "Command<goToNextTableCellCommand>",
  group: "Table"
});
const S3 = ct(
  "ExitTable",
  (n) => () => (e, t) => {
    if (!rs(e)) return !1;
    const { $head: r } = e.selection, i = $$(r, qc.type(n));
    if (!i) return !1;
    const { to: s } = i, o = e.tr.replaceWith(
      s,
      s,
      uo.type(n).createAndFill()
    );
    return o.setSelection(ht.near(o.doc.resolve(s), 1)).scrollIntoView(), t == null || t(o), !0;
  }
);
ut(S3, {
  displayName: "Command<breakTableCommand>",
  group: "Table"
});
const mO = ct(
  "InsertTable",
  (n) => ({ row: e, col: t } = {}) => (r, i) => {
    const { selection: s, tr: o } = r, { from: a } = s, l = w3(n, e, t), c = o.replaceSelectionWith(l), u = ht.findFrom(c.doc.resolve(a), 1, !0);
    return u && c.setSelection(u), i == null || i(c), !0;
  }
);
ut(mO, {
  displayName: "Command<insertTableCommand>",
  group: "Table"
});
const C3 = ct(
  "MoveRow",
  () => ({ from: n, to: e, pos: t } = {}) => MZ({
    from: n ?? 0,
    to: e ?? 0,
    pos: t
  })
);
ut(C3, {
  displayName: "Command<moveRowCommand>",
  group: "Table"
});
const M3 = ct(
  "MoveCol",
  () => ({ from: n, to: e, pos: t } = {}) => TZ({
    from: n ?? 0,
    to: e ?? 0,
    pos: t
  })
);
ut(M3, {
  displayName: "Command<moveColCommand>",
  group: "Table"
});
const Yl = ct(
  "SelectRow",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!(t == null ? void 0 : t(Iee(n.index, n.pos)(r)));
  }
);
ut(Yl, {
  displayName: "Command<selectRowCommand>",
  group: "Table"
});
const Xl = ct(
  "SelectCol",
  () => (n = { index: 0 }) => (e, t) => {
    const { tr: r } = e;
    return !!(t == null ? void 0 : t(_ee(n.index, n.pos)(r)));
  }
);
ut(Xl, {
  displayName: "Command<selectColCommand>",
  group: "Table"
});
const gO = ct(
  "SelectTable",
  () => () => (n, e) => {
    const { tr: t } = n;
    return !!(e == null ? void 0 : e(Pee(t)));
  }
);
ut(gO, {
  displayName: "Command<selectTableCommand>",
  group: "Table"
});
const T3 = ct(
  "DeleteSelectedCells",
  () => () => (n, e) => {
    const { selection: t } = n;
    if (!(t instanceof nn)) return !1;
    const r = t.isRowSelection(), i = t.isColSelection();
    return r && i ? CZ(n, e) : i ? bZ(n, e) : wZ(n, e);
  }
);
ut(T3, {
  displayName: "Command<deleteSelectedCellsCommand>",
  group: "Table"
});
const A3 = ct(
  "AddColBefore",
  () => () => mZ
);
ut(A3, {
  displayName: "Command<addColBeforeCommand>",
  group: "Table"
});
const E3 = ct(
  "AddColAfter",
  () => () => gZ
);
ut(E3, {
  displayName: "Command<addColAfterCommand>",
  group: "Table"
});
const L3 = ct(
  "AddRowBefore",
  (n) => () => (e, t) => {
    if (!rs(e)) return !1;
    if (t) {
      const r = bl(e);
      t(pO(n, e.tr, r, r.top));
    }
    return !0;
  }
);
ut(L3, {
  displayName: "Command<addRowBeforeCommand>",
  group: "Table"
});
const O3 = ct(
  "AddRowAfter",
  (n) => () => (e, t) => {
    if (!rs(e)) return !1;
    if (t) {
      const r = bl(e);
      t(pO(n, e.tr, r, r.bottom));
    }
    return !0;
  }
);
ut(O3, {
  displayName: "Command<addRowAfterCommand>",
  group: "Table"
});
const D3 = ct(
  "SetAlign",
  () => (n = "left") => kZ("alignment", n)
);
ut(D3, {
  displayName: "Command<setAlignCommand>",
  group: "Table"
});
const yO = Sr(
  (n) => new ii(
    /^\|(?<col>\d+)[xX](?<row>\d+)\|\s$/,
    (e, t, r, i) => {
      var c, u;
      const s = e.doc.resolve(r);
      if (!s.node(-1).canReplaceWith(
        s.index(-1),
        s.indexAfter(-1),
        qc.type(n)
      ))
        return null;
      const o = Math.max(Number(((c = t.groups) == null ? void 0 : c.row) ?? 0), 2), a = w3(n, o, Number((u = t.groups) == null ? void 0 : u.col)), l = e.tr.replaceRangeWith(r, i, a);
      return l.setSelection(Ye.create(l.doc, r + 3)).scrollIntoView();
    }
  )
);
ut(yO, {
  displayName: "InputRule<insertTableInputRule>",
  group: "Table"
});
const N3 = ai("tableKeymap", {
  NextCell: {
    priority: 100,
    shortcuts: ["Mod-]", "Tab"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(x3.key);
    }
  },
  PrevCell: {
    shortcuts: ["Mod-[", "Shift-Tab"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(k3.key);
    }
  },
  ExitTable: {
    shortcuts: ["Mod-Enter", "Enter"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(S3.key);
    }
  }
});
ut(N3.ctx, {
  displayName: "KeymapCtx<table>",
  group: "Table"
});
ut(N3.shortcuts, {
  displayName: "Keymap<table>",
  group: "Table"
});
const m2 = "footnote_definition", fS = "footnoteDefinition", I3 = Rn(
  "footnote_definition",
  () => ({
    group: "block",
    content: "block+",
    defining: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `dl[data-type="${m2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Ms(n);
          return {
            label: n.dataset.label
          };
        },
        contentElement: "dd"
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "dl",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": m2
        },
        ["dt", e],
        ["dd", 0]
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === fS,
      runner: (n, e, t) => {
        n.openNode(t, {
          label: e.label
        }).next(e.children).closeNode();
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === m2,
      runner: (n, e) => {
        n.openNode(fS, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        }).next(e.content).closeNode();
      }
    }
  })
);
ut(I3.ctx, {
  displayName: "NodeSchemaCtx<footnodeDef>",
  group: "footnote"
});
ut(I3.node, {
  displayName: "NodeSchema<footnodeDef>",
  group: "footnote"
});
const g2 = "footnote_reference", _3 = Rn(
  "footnote_reference",
  () => ({
    group: "inline",
    inline: !0,
    atom: !0,
    attrs: {
      label: {
        default: "",
        validate: "string"
      }
    },
    parseDOM: [
      {
        tag: `sup[data-type="${g2}"]`,
        getAttrs: (n) => {
          if (!(n instanceof HTMLElement)) throw Ms(n);
          return {
            label: n.dataset.label
          };
        }
      }
    ],
    toDOM: (n) => {
      const e = n.attrs.label;
      return [
        "sup",
        {
          // TODO: add a prosemirror plugin to sync label on change
          "data-label": e,
          "data-type": g2
        },
        e
      ];
    },
    parseMarkdown: {
      match: ({ type: n }) => n === "footnoteReference",
      runner: (n, e, t) => {
        n.addNode(t, {
          label: e.label
        });
      }
    },
    toMarkdown: {
      match: (n) => n.type.name === g2,
      runner: (n, e) => {
        n.addNode("footnoteReference", void 0, void 0, {
          label: e.attrs.label,
          identifier: e.attrs.label
        });
      }
    }
  })
);
ut(_3.ctx, {
  displayName: "NodeSchemaCtx<footnodeRef>",
  group: "footnote"
});
ut(_3.node, {
  displayName: "NodeSchema<footnodeRef>",
  group: "footnote"
});
const R3 = As.extendSchema(
  (n) => (e) => {
    const t = n(e);
    return {
      ...t,
      attrs: {
        ...t.attrs,
        checked: {
          default: null,
          validate: "boolean|null"
        }
      },
      parseDOM: [
        {
          tag: 'li[data-item-type="task"]',
          getAttrs: (r) => {
            if (!(r instanceof HTMLElement)) throw Ms(r);
            return {
              label: r.dataset.label,
              listType: r.dataset.listType,
              spread: r.dataset.spread,
              checked: r.dataset.checked ? r.dataset.checked === "true" : null
            };
          }
        },
        ...(t == null ? void 0 : t.parseDOM) || []
      ],
      toDOM: (r) => t.toDOM && r.attrs.checked == null ? t.toDOM(r) : [
        "li",
        {
          "data-item-type": "task",
          "data-label": r.attrs.label,
          "data-list-type": r.attrs.listType,
          "data-spread": r.attrs.spread,
          "data-checked": r.attrs.checked
        },
        0
      ],
      parseMarkdown: {
        match: ({ type: r }) => r === "listItem",
        runner: (r, i, s) => {
          if (i.checked == null) {
            t.parseMarkdown.runner(r, i, s);
            return;
          }
          const o = i.label != null ? `${i.label}.` : "•", a = i.checked != null ? !!i.checked : null, l = i.label != null ? "ordered" : "bullet", c = i.spread != null ? `${i.spread}` : "true";
          r.openNode(s, { label: o, listType: l, spread: c, checked: a }), r.next(i.children), r.closeNode();
        }
      },
      toMarkdown: {
        match: (r) => r.type.name === "list_item",
        runner: (r, i) => {
          if (i.attrs.checked == null) {
            t.toMarkdown.runner(r, i);
            return;
          }
          const s = i.attrs.label, o = i.attrs.listType, a = i.attrs.spread === "true", l = i.attrs.checked;
          r.openNode("listItem", void 0, {
            label: s,
            listType: o,
            spread: a,
            checked: l
          }), r.next(i.content), r.closeNode();
        }
      }
    };
  }
);
ut(R3.node, {
  displayName: "NodeSchema<taskListItem>",
  group: "ListItem"
});
ut(R3.ctx, {
  displayName: "NodeSchemaCtx<taskListItem>",
  group: "ListItem"
});
const bO = Sr(() => new ii(
  /^\[(?<checked>\s|x)\]\s$/,
  (n, e, t, r) => {
    var u;
    const i = n.doc.resolve(t);
    let s = 0, o = i.node(s);
    for (; o && o.type.name !== "list_item"; )
      s--, o = i.node(s);
    if (!o || o.attrs.checked != null) return null;
    const a = ((u = e.groups) == null ? void 0 : u.checked) === "x", l = i.before(s), c = n.tr;
    return c.deleteRange(t, r).setNodeMarkup(l, void 0, {
      ...o.attrs,
      checked: a
    }), c;
  }
));
ut(bO, {
  displayName: "InputRule<wrapInTaskListInputRule>",
  group: "ListItem"
});
const Bee = [
  v3,
  N3
].flat(), Hee = [
  yO,
  bO
], zee = [fO], vO = jn(() => tQ);
ut(vO, {
  displayName: "Prose<autoInsertSpanPlugin>",
  group: "Prose"
});
const Fee = jn(() => PZ({}));
ut(Fee, {
  displayName: "Prose<columnResizingPlugin>",
  group: "Prose"
});
const wO = jn(
  () => UZ({ allowTableNodeSelection: !0 })
);
ut(wO, {
  displayName: "Prose<tableEditingPlugin>",
  group: "Prose"
});
const P3 = co("remarkGFM", () => Nee);
ut(P3.plugin, {
  displayName: "Remark<remarkGFMPlugin>",
  group: "Remark"
});
ut(P3.options, {
  displayName: "RemarkConfig<remarkGFMPlugin>",
  group: "Remark"
});
const Vee = new gn("MILKDOWN_KEEP_TABLE_ALIGN_PLUGIN");
function qee(n, e) {
  let t = 0;
  return e.forEach((r, i, s) => {
    r === n && (t = s);
  }), t;
}
const kO = jn(() => new mn({
  key: Vee,
  appendTransaction: (n, e, t) => {
    let r;
    const i = (s, o) => {
      if (r || (r = t.tr), s.type.name !== "table_cell") return;
      const a = t.doc.resolve(o), l = a.node(a.depth), u = a.node(a.depth - 1).firstChild;
      if (!u) return;
      const h = qee(s, l), f = u.maybeChild(h);
      if (!f) return;
      const m = f.attrs.alignment, y = s.attrs.alignment;
      m !== y && r.setNodeMarkup(o, void 0, { ...s.attrs, alignment: m });
    };
    return e.doc !== t.doc && t.doc.descendants(i), r;
  }
}));
ut(kO, {
  displayName: "Prose<keepTableAlignPlugin>",
  group: "Prose"
});
const $ee = [
  kO,
  vO,
  P3,
  wO
].flat(), jee = [
  R3,
  qc,
  yy,
  np,
  by,
  rp,
  I3,
  _3,
  b3,
  Bh
].flat(), Wee = [
  x3,
  k3,
  S3,
  mO,
  C3,
  M3,
  Yl,
  Xl,
  gO,
  T3,
  L3,
  O3,
  A3,
  E3,
  D3,
  gy
], Uee = [
  jee,
  Hee,
  zee,
  Bee,
  Wee,
  $ee
].flat(), Kee = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), r = H3(n.state, t.from);
  return r.line ? Gee(n) : r.block ? Yee(n) : !1;
};
function B3(n, e) {
  return ({ state: t, dispatch: r }) => {
    if (t.readOnly)
      return !1;
    let i = n(e, t);
    return i ? (r(t.update(i)), !0) : !1;
  };
}
const Gee = /* @__PURE__ */ B3(
  Qee,
  0
  /* CommentOption.Toggle */
), Jee = /* @__PURE__ */ B3(
  xO,
  0
  /* CommentOption.Toggle */
), Yee = /* @__PURE__ */ B3(
  (n, e) => xO(n, e, Zee(e)),
  0
  /* CommentOption.Toggle */
);
function H3(n, e) {
  let t = n.languageDataAt("commentTokens", e, 1);
  return t.length ? t[0] : {};
}
const hf = 50;
function Xee(n, { open: e, close: t }, r, i) {
  let s = n.sliceDoc(r - hf, r), o = n.sliceDoc(i, i + hf), a = /\s*$/.exec(s)[0].length, l = /^\s*/.exec(o)[0].length, c = s.length - a;
  if (s.slice(c - e.length, c) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: r - a, margin: a && 1 },
      close: { pos: i + l, margin: l && 1 }
    };
  let u, h;
  i - r <= 2 * hf ? u = h = n.sliceDoc(r, i) : (u = n.sliceDoc(r, r + hf), h = n.sliceDoc(i - hf, i));
  let f = /^\s*/.exec(u)[0].length, m = /\s*$/.exec(h)[0].length, y = h.length - m - t.length;
  return u.slice(f, f + e.length) == e && h.slice(y, y + t.length) == t ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(u.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - m - t.length,
      margin: /\s/.test(h.charAt(y - 1)) ? 1 : 0
    }
  } : null;
}
function Zee(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let r = n.doc.lineAt(t.from), i = t.to <= r.to ? r : n.doc.lineAt(t.to);
    i.from > r.from && i.from == t.to && (i = t.to == r.to + 1 ? r : n.doc.lineAt(t.to - 1));
    let s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function xO(n, e, t = e.selection.ranges) {
  let r = t.map((s) => H3(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = t.map((s, o) => Xee(e, r[o], s.from, s.to));
  if (n != 2 && !i.every((s) => s))
    return { changes: e.changes(t.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (n != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, a; o < i.length; o++)
      if (a = i[o]) {
        let l = r[o], { open: c, close: u } = a;
        s.push({ from: c.pos - l.open.length, to: c.pos + c.margin }, { from: u.pos - u.margin, to: u.pos + l.close.length });
      }
    return { changes: s };
  }
  return null;
}
function Qee(n, e, t = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of t) {
    let a = r.length, l = 1e9, c = H3(e, s).line;
    if (c) {
      for (let u = s; u <= o; ) {
        let h = e.doc.lineAt(u);
        if (h.from > i && (s == o || o > h.from)) {
          i = h.from;
          let f = /^\s*/.exec(h.text)[0].length, m = f == h.length, y = h.text.slice(f, f + c.length) == c ? f : -1;
          f < h.text.length && f < l && (l = f), r.push({ line: h, comment: y, token: c, indent: f, empty: m, single: !1 });
        }
        u = h.to + 1;
      }
      if (l < 1e9)
        for (let u = a; u < r.length; u++)
          r[u].indent < r[u].line.text.length && (r[u].indent = l);
      r.length == a + 1 && (r[a].single = !0);
    }
  }
  if (n != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: a, token: l, indent: c, empty: u, single: h } of r)
      (h || !u) && s.push({ from: a.from + c, insert: l + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: a, token: l } of r)
      if (a >= 0) {
        let c = o.from + a, u = c + l.length;
        o.text[u - o.from] == " " && u++, s.push({ from: c, to: u });
      }
    return { changes: s };
  }
  return null;
}
const z4 = /* @__PURE__ */ fa.define(), ete = /* @__PURE__ */ fa.define(), tte = /* @__PURE__ */ ze.define(), SO = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (r, i) => e(r, i) || t(r, i)
    });
  }
}), CO = /* @__PURE__ */ rr.define({
  create() {
    return kd.empty;
  },
  update(n, e) {
    let t = e.state.facet(SO), r = e.annotation(z4);
    if (r) {
      let l = ti.fromTransaction(e, r.selection), c = r.side, u = c == 0 ? n.undone : n.done;
      return l ? u = r1(u, u.length, t.minDepth, l) : u = AO(u, e.startState.selection), new kd(c == 0 ? r.rest : u, c == 0 ? u : r.rest);
    }
    let i = e.annotation(ete);
    if ((i == "full" || i == "before") && (n = n.isolate()), e.annotation(Nr.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = ti.fromTransaction(e), o = e.annotation(Nr.time), a = e.annotation(Nr.userEvent);
    return s ? n = n.addChanges(s, o, a, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, a, t.newGroupDelay)), (i == "full" || i == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new kd(n.done.map(ti.fromJSON), n.undone.map(ti.fromJSON));
  }
});
function nte(n = {}) {
  return [
    CO,
    SO.of(n),
    $e.domEventHandlers({
      beforeinput(e, t) {
        let r = e.inputType == "historyUndo" ? MO : e.inputType == "historyRedo" ? F4 : null;
        return r ? (e.preventDefault(), r(t)) : !1;
      }
    })
  ];
}
function vy(n, e) {
  return function({ state: t, dispatch: r }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(CO, !1);
    if (!i)
      return !1;
    let s = i.pop(n, t, e);
    return s ? (r(s), !0) : !1;
  };
}
const MO = /* @__PURE__ */ vy(0, !1), F4 = /* @__PURE__ */ vy(1, !1), rte = /* @__PURE__ */ vy(0, !0), ite = /* @__PURE__ */ vy(1, !0);
class ti {
  constructor(e, t, r, i, s) {
    this.changes = e, this.effects = t, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new ti(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new ti(e.changes && Jn.fromJSON(e.changes), [], e.mapped && Qs.fromJSON(e.mapped), e.startSelection && ce.fromJSON(e.startSelection), e.selectionsAfter.map(ce.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let r = ji;
    for (let i of e.startState.facet(tte)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new ti(e.changes.invert(e.startState.doc), r, void 0, t || e.startState.selection, ji);
  }
  static selection(e) {
    return new ti(void 0, ji, void 0, void 0, e);
  }
}
function r1(n, e, t, r) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(i, e);
  return s.push(r), s;
}
function ste(n, e) {
  let t = [], r = !1;
  return n.iterChangedRanges((i, s) => t.push(i, s)), e.iterChangedRanges((i, s, o, a) => {
    for (let l = 0; l < t.length; ) {
      let c = t[l++], u = t[l++];
      a >= c && o <= u && (r = !0);
    }
  }), r;
}
function ote(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, r) => t.empty != e.ranges[r].empty).length === 0;
}
function TO(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const ji = [], ate = 200;
function AO(n, e) {
  if (n.length) {
    let t = n[n.length - 1], r = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - ate));
    return r.length && r[r.length - 1].eq(e) ? n : (r.push(e), r1(n, n.length - 1, 1e9, t.setSelAfter(r)));
  } else
    return [ti.selection([e])];
}
function lte(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function y2(n, e) {
  if (!n.length)
    return n;
  let t = n.length, r = ji;
  for (; t; ) {
    let i = cte(n[t - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = i, s;
    } else
      e = i.mapped, t--, r = i.selectionsAfter;
  }
  return r.length ? [ti.selection(r)] : ji;
}
function cte(n, e, t) {
  let r = TO(n.selectionsAfter.length ? n.selectionsAfter.map((a) => a.map(e)) : ji, t);
  if (!n.changes)
    return ti.selection(r);
  let i = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new ti(i, pt.mapEffects(n.effects, e), o, n.startSelection.map(s), r);
}
const ute = /^(input\.type|delete)($|\.)/;
let kd = class _f {
  constructor(e, t, r = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new _f(this.done, this.undone) : this;
  }
  addChanges(e, t, r, i, s) {
    let o = this.done, a = o[o.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!r || ute.test(r)) && (!a.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(s, ste(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    r == "input.type.compose") ? o = r1(o, o.length - 1, i.minDepth, new ti(e.changes.compose(a.changes), TO(pt.mapEffects(e.effects, a.changes), a.effects), a.mapped, a.startSelection, ji)) : o = r1(o, o.length, i.minDepth, e), new _f(o, ji, t, r);
  }
  addSelection(e, t, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ji;
    return s.length > 0 && t - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && ote(s[s.length - 1], e) ? this : new _f(AO(this.done, e), this.undone, t, r);
  }
  addMapping(e) {
    return new _f(y2(this.done, e), y2(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || t.selection;
    if (r && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: z4.of({ side: e, rest: lte(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let a = i.length == 1 ? ji : i.slice(0, i.length - 1);
      return s.mapped && (a = y2(a, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: z4.of({ side: e, rest: a, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
};
kd.empty = /* @__PURE__ */ new kd(ji, ji);
const hte = [
  { key: "Mod-z", run: MO, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: F4, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: F4, preventDefault: !0 },
  { key: "Mod-u", run: rte, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: ite, preventDefault: !0 }
];
function Hh(n, e) {
  return ce.create(n.ranges.map(e), n.mainIndex);
}
function Ls(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Os({ state: n, dispatch: e }, t) {
  let r = Hh(n.selection, t);
  return r.eq(n.selection, !0) ? !1 : (e(Ls(n, r)), !0);
}
function wy(n, e) {
  return ce.cursor(e ? n.to : n.from);
}
function EO(n, e) {
  return Os(n, (t) => t.empty ? n.moveByChar(t, e) : wy(t, e));
}
function Cr(n) {
  return n.textDirectionAt(n.state.selection.main.head) == pn.LTR;
}
const LO = (n) => EO(n, !Cr(n)), OO = (n) => EO(n, Cr(n));
function DO(n, e) {
  return Os(n, (t) => t.empty ? n.moveByGroup(t, e) : wy(t, e));
}
const fte = (n) => DO(n, !Cr(n)), dte = (n) => DO(n, Cr(n));
function pte(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function ky(n, e, t) {
  let r = dr(n).resolveInner(e.head), i = t ? Mt.closedBy : Mt.openedBy;
  for (let l = e.head; ; ) {
    let c = t ? r.childAfter(l) : r.childBefore(l);
    if (!c)
      break;
    pte(n, c, i) ? r = c : l = t ? c.to : c.from;
  }
  let s = r.type.prop(i), o, a;
  return s && (o = t ? Js(n, r.from, 1) : Js(n, r.to, -1)) && o.matched ? a = t ? o.end.to : o.end.from : a = t ? r.to : r.from, ce.cursor(a, t ? -1 : 1);
}
const mte = (n) => Os(n, (e) => ky(n.state, e, !Cr(n))), gte = (n) => Os(n, (e) => ky(n.state, e, Cr(n)));
function NO(n, e) {
  return Os(n, (t) => {
    if (!t.empty)
      return wy(t, e);
    let r = n.moveVertically(t, e);
    return r.head != t.head ? r : n.moveToLineBoundary(t, e);
  });
}
const IO = (n) => NO(n, !1), _O = (n) => NO(n, !0);
function RO(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, r = 0, i;
  if (e) {
    for (let s of n.state.facet($e.scrollMargins)) {
      let o = s(n);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (r = Math.max(o == null ? void 0 : o.bottom, r));
    }
    i = n.scrollDOM.clientHeight - t - r;
  } else
    i = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, i - 5)
  };
}
function PO(n, e) {
  let t = RO(n), { state: r } = n, i = Hh(r.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : wy(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(r.selection.main.head), a = n.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, c = a.bottom - t.marginBottom;
    o && o.top > l && o.bottom < c && (s = $e.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - l }));
  }
  return n.dispatch(Ls(r, i), { effects: s }), !0;
}
const dS = (n) => PO(n, !1), V4 = (n) => PO(n, !0);
function vl(n, e, t) {
  let r = n.lineBlockAt(e.head), i = n.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? r.to : r.from) && (i = n.moveToLineBoundary(e, t, !1)), !t && i.head == r.from && r.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = ce.cursor(r.from + s));
  }
  return i;
}
const yte = (n) => Os(n, (e) => vl(n, e, !0)), bte = (n) => Os(n, (e) => vl(n, e, !1)), vte = (n) => Os(n, (e) => vl(n, e, !Cr(n))), wte = (n) => Os(n, (e) => vl(n, e, Cr(n))), kte = (n) => Os(n, (e) => ce.cursor(n.lineBlockAt(e.head).from, 1)), xte = (n) => Os(n, (e) => ce.cursor(n.lineBlockAt(e.head).to, -1));
function Ste(n, e, t) {
  let r = !1, i = Hh(n.selection, (s) => {
    let o = Js(n, s.head, -1) || Js(n, s.head, 1) || s.head > 0 && Js(n, s.head - 1, 1) || s.head < n.doc.length && Js(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let a = o.start.from == s.head ? o.end.to : o.end.from;
    return ce.cursor(a);
  });
  return r ? (e(Ls(n, i)), !0) : !1;
}
const Cte = ({ state: n, dispatch: e }) => Ste(n, e);
function is(n, e) {
  let t = Hh(n.state.selection, (r) => {
    let i = e(r);
    return ce.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Ls(n.state, t)), !0);
}
function BO(n, e) {
  return is(n, (t) => n.moveByChar(t, e));
}
const HO = (n) => BO(n, !Cr(n)), zO = (n) => BO(n, Cr(n));
function FO(n, e) {
  return is(n, (t) => n.moveByGroup(t, e));
}
const Mte = (n) => FO(n, !Cr(n)), Tte = (n) => FO(n, Cr(n)), Ate = (n) => is(n, (e) => ky(n.state, e, !Cr(n))), Ete = (n) => is(n, (e) => ky(n.state, e, Cr(n)));
function VO(n, e) {
  return is(n, (t) => n.moveVertically(t, e));
}
const qO = (n) => VO(n, !1), $O = (n) => VO(n, !0);
function jO(n, e) {
  return is(n, (t) => n.moveVertically(t, e, RO(n).height));
}
const pS = (n) => jO(n, !1), mS = (n) => jO(n, !0), Lte = (n) => is(n, (e) => vl(n, e, !0)), Ote = (n) => is(n, (e) => vl(n, e, !1)), Dte = (n) => is(n, (e) => vl(n, e, !Cr(n))), Nte = (n) => is(n, (e) => vl(n, e, Cr(n))), Ite = (n) => is(n, (e) => ce.cursor(n.lineBlockAt(e.head).from)), _te = (n) => is(n, (e) => ce.cursor(n.lineBlockAt(e.head).to)), gS = ({ state: n, dispatch: e }) => (e(Ls(n, { anchor: 0 })), !0), yS = ({ state: n, dispatch: e }) => (e(Ls(n, { anchor: n.doc.length })), !0), bS = ({ state: n, dispatch: e }) => (e(Ls(n, { anchor: n.selection.main.anchor, head: 0 })), !0), vS = ({ state: n, dispatch: e }) => (e(Ls(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), Rte = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), Pte = ({ state: n, dispatch: e }) => {
  let t = xy(n).map(({ from: r, to: i }) => ce.range(r, Math.min(i + 1, n.doc.length)));
  return e(n.update({ selection: ce.create(t), userEvent: "select" })), !0;
}, Bte = ({ state: n, dispatch: e }) => {
  let t = Hh(n.selection, (r) => {
    let i = dr(n), s = i.resolveStack(r.from, 1);
    if (r.empty) {
      let o = i.resolveStack(r.from, -1);
      o.node.from >= s.node.from && o.node.to <= s.node.to && (s = o);
    }
    for (let o = s; o; o = o.next) {
      let { node: a } = o;
      if ((a.from < r.from && a.to >= r.to || a.to > r.to && a.from <= r.from) && o.next)
        return ce.range(a.to, a.from);
    }
    return r;
  });
  return t.eq(n.selection) ? !1 : (e(Ls(n, t)), !0);
};
function WO(n, e) {
  let { state: t } = n, r = t.selection, i = t.selection.ranges.slice();
  for (let s of t.selection.ranges) {
    let o = t.doc.lineAt(s.head);
    if (e ? o.to < n.state.doc.length : o.from > 0)
      for (let a = s; ; ) {
        let l = n.moveVertically(a, e);
        if (l.head < o.from || l.head > o.to) {
          i.some((c) => c.head == l.head) || i.push(l);
          break;
        } else {
          if (l.head == a.head)
            break;
          a = l;
        }
      }
  }
  return i.length == r.ranges.length ? !1 : (n.dispatch(Ls(t, ce.create(i, i.length - 1))), !0);
}
const Hte = (n) => WO(n, !1), zte = (n) => WO(n, !0), Fte = ({ state: n, dispatch: e }) => {
  let t = n.selection, r = null;
  return t.ranges.length > 1 ? r = ce.create([t.main]) : t.main.empty || (r = ce.create([ce.cursor(t.main.head)])), r ? (e(Ls(n, r)), !0) : !1;
};
function ip(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: r } = n, i = r.changeByRange((s) => {
    let { from: o, to: a } = s;
    if (o == a) {
      let l = e(s);
      l < o ? (t = "delete.backward", l = nm(n, l, !1)) : l > o && (t = "delete.forward", l = nm(n, l, !0)), o = Math.min(o, l), a = Math.max(a, l);
    } else
      o = nm(n, o, !1), a = nm(n, a, !0);
    return o == a ? { range: s } : { changes: { from: o, to: a }, range: ce.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (n.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? $e.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function nm(n, e, t) {
  if (n instanceof $e)
    for (let r of n.state.facet($e.atomicRanges).map((i) => i(n)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = t ? s : i);
      });
  return e;
}
const UO = (n, e, t) => ip(n, (r) => {
  let i = r.from, { state: s } = n, o = s.doc.lineAt(i), a, l;
  if (t && !e && i > o.from && i < o.from + 200 && !/[^ \t]/.test(a = o.text.slice(0, i - o.from))) {
    if (a[a.length - 1] == "	")
      return i - 1;
    let c = Eh(a, s.tabSize), u = c % Tc(s) || Tc(s);
    for (let h = 0; h < u && a[a.length - 1 - h] == " "; h++)
      i--;
    l = i;
  } else
    l = fr(o.text, i - o.from, e, e) + o.from, l == i && o.number != (e ? s.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(o.text.slice(l - o.from, i - o.from)) && (l = fr(o.text, l - o.from, !1, !1) + o.from);
  return l;
}), q4 = (n) => UO(n, !1, !0), KO = (n) => UO(n, !0, !1), GO = (n, e) => ip(n, (t) => {
  let r = t.head, { state: i } = n, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let a = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == t.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let l = fr(s.text, r - s.from, e) + s.from, c = s.text.slice(Math.min(r, l) - s.from, Math.max(r, l) - s.from), u = o(c);
    if (a != null && u != a)
      break;
    (c != " " || r != t.head) && (a = u), r = l;
  }
  return r;
}), JO = (n) => GO(n, !1), Vte = (n) => GO(n, !0), qte = (n) => ip(n, (e) => {
  let t = n.lineBlockAt(e.head).to;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), $te = (n) => ip(n, (e) => {
  let t = n.moveToLineBoundary(e, !1).head;
  return e.head > t ? t : Math.max(0, e.head - 1);
}), jte = (n) => ip(n, (e) => {
  let t = n.moveToLineBoundary(e, !0).head;
  return e.head < t ? t : Math.min(n.state.doc.length, e.head + 1);
}), Wte = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: Bt.of(["", ""]) },
    range: ce.cursor(r.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Ute = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == n.doc.length)
      return { range: r };
    let i = r.from, s = n.doc.lineAt(i), o = i == s.from ? i - 1 : fr(s.text, i - s.from, !1) + s.from, a = i == s.to ? i + 1 : fr(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: a, insert: n.doc.slice(i, a).append(n.doc.slice(o, i)) },
      range: ce.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function xy(n) {
  let e = [], t = -1;
  for (let r of n.selection.ranges) {
    let i = n.doc.lineAt(r.from), s = n.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = n.doc.lineAt(r.to - 1)), t >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    t = s.number + 1;
  }
  return e;
}
function YO(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of xy(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), a = o.length + 1;
    if (t) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let l of s.ranges)
        i.push(ce.range(Math.min(n.doc.length, l.anchor + a), Math.min(n.doc.length, l.head + a)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let l of s.ranges)
        i.push(ce.range(l.anchor - a, l.head - a));
    }
  }
  return r.length ? (e(n.update({
    changes: r,
    scrollIntoView: !0,
    selection: ce.create(i, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Kte = ({ state: n, dispatch: e }) => YO(n, e, !1), Gte = ({ state: n, dispatch: e }) => YO(n, e, !0);
function XO(n, e, t) {
  if (n.readOnly)
    return !1;
  let r = [];
  for (let i of xy(n))
    t ? r.push({ from: i.from, insert: n.doc.slice(i.from, i.to) + n.lineBreak }) : r.push({ from: i.to, insert: n.lineBreak + n.doc.slice(i.from, i.to) });
  return e(n.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Jte = ({ state: n, dispatch: e }) => XO(n, e, !1), Yte = ({ state: n, dispatch: e }) => XO(n, e, !0), Xte = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(xy(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = Hh(e.selection, (i) => {
    let s;
    if (n.lineWrapping) {
      let o = n.lineBlockAt(i.head), a = n.coordsAtPos(i.head, i.assoc || 1);
      a && (s = o.bottom + n.documentTop - a.bottom + n.defaultLineHeight / 2);
    }
    return n.moveVertically(i, !0, s);
  }).map(t);
  return n.dispatch({ changes: t, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Zte(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = dr(n).resolveInner(e), r = t.childBefore(e), i = t.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(Mt.closedBy)) && s.indexOf(i.name) > -1 && n.doc.lineAt(r.to).from == n.doc.lineAt(i.from).from && !/\S/.test(n.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const wS = /* @__PURE__ */ ZO(!1), Qte = /* @__PURE__ */ ZO(!0);
function ZO(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, a = e.doc.lineAt(s), l = !n && s == o && Zte(e, s);
      n && (s = o = (o <= a.to ? a : e.doc.lineAt(o)).to);
      let c = new N1(e, { simulateBreak: s, simulateDoubleBreak: !!l }), u = Bw(c, s);
      for (u == null && (u = Eh(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < a.to && /\s/.test(a.text[o - a.from]); )
        o++;
      l ? { from: s, to: o } = l : s > a.from && s < a.from + 100 && !/\S/.test(a.text.slice(0, s)) && (s = a.from);
      let h = ["", Hd(e, u)];
      return l && h.push(Hd(e, c.lineIndent(a.from, -1))), {
        changes: { from: s, to: o, insert: Bt.of(h) },
        range: ce.cursor(s + 1 + h[1].length)
      };
    });
    return t(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function z3(n, e) {
  let t = -1;
  return n.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let a = n.doc.lineAt(o);
      a.number > t && (r.empty || r.to > a.from) && (e(a, i, r), t = a.number), o = a.to + 1;
    }
    let s = n.changes(i);
    return {
      changes: i,
      range: ce.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const ene = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), r = new N1(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o ?? -1;
  } }), i = z3(n, (s, o, a) => {
    let l = Bw(r, s.from);
    if (l == null)
      return;
    /\S/.test(s.text) || (l = 0);
    let c = /^\s*/.exec(s.text)[0], u = Hd(n, l);
    (c != u || a.from < s.from + c.length) && (t[s.from] = l, o.push({ from: s.from, to: s.from + c.length, insert: u }));
  });
  return i.changes.empty || e(n.update(i, { userEvent: "indent" })), !0;
}, QO = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(z3(n, (t, r) => {
  r.push({ from: t.from, insert: n.facet(D1) });
}), { userEvent: "input.indent" })), !0), eD = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update(z3(n, (t, r) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let s = Eh(i, n.tabSize), o = 0, a = Hd(n, Math.max(0, s - Tc(n)));
  for (; o < i.length && o < a.length && i.charCodeAt(o) == a.charCodeAt(o); )
    o++;
  r.push({ from: t.from + o, to: t.from + i.length, insert: a.slice(o) });
}), { userEvent: "delete.dedent" })), !0), tne = (n) => (n.setTabFocusMode(), !0), nne = [
  { key: "Ctrl-b", run: LO, shift: HO, preventDefault: !0 },
  { key: "Ctrl-f", run: OO, shift: zO },
  { key: "Ctrl-p", run: IO, shift: qO },
  { key: "Ctrl-n", run: _O, shift: $O },
  { key: "Ctrl-a", run: kte, shift: Ite },
  { key: "Ctrl-e", run: xte, shift: _te },
  { key: "Ctrl-d", run: KO },
  { key: "Ctrl-h", run: q4 },
  { key: "Ctrl-k", run: qte },
  { key: "Ctrl-Alt-h", run: JO },
  { key: "Ctrl-o", run: Wte },
  { key: "Ctrl-t", run: Ute },
  { key: "Ctrl-v", run: V4 }
], rne = /* @__PURE__ */ [
  { key: "ArrowLeft", run: LO, shift: HO, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: fte, shift: Mte, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: vte, shift: Dte, preventDefault: !0 },
  { key: "ArrowRight", run: OO, shift: zO, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: dte, shift: Tte, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: wte, shift: Nte, preventDefault: !0 },
  { key: "ArrowUp", run: IO, shift: qO, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: gS, shift: bS },
  { mac: "Ctrl-ArrowUp", run: dS, shift: pS },
  { key: "ArrowDown", run: _O, shift: $O, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: yS, shift: vS },
  { mac: "Ctrl-ArrowDown", run: V4, shift: mS },
  { key: "PageUp", run: dS, shift: pS },
  { key: "PageDown", run: V4, shift: mS },
  { key: "Home", run: bte, shift: Ote, preventDefault: !0 },
  { key: "Mod-Home", run: gS, shift: bS },
  { key: "End", run: yte, shift: Lte, preventDefault: !0 },
  { key: "Mod-End", run: yS, shift: vS },
  { key: "Enter", run: wS, shift: wS },
  { key: "Mod-a", run: Rte },
  { key: "Backspace", run: q4, shift: q4, preventDefault: !0 },
  { key: "Delete", run: KO, preventDefault: !0 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: JO, preventDefault: !0 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Vte, preventDefault: !0 },
  { mac: "Mod-Backspace", run: $te, preventDefault: !0 },
  { mac: "Mod-Delete", run: jte, preventDefault: !0 }
].concat(/* @__PURE__ */ nne.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), tD = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: mte, shift: Ate },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: gte, shift: Ete },
  { key: "Alt-ArrowUp", run: Kte },
  { key: "Shift-Alt-ArrowUp", run: Jte },
  { key: "Alt-ArrowDown", run: Gte },
  { key: "Shift-Alt-ArrowDown", run: Yte },
  { key: "Mod-Alt-ArrowUp", run: Hte },
  { key: "Mod-Alt-ArrowDown", run: zte },
  { key: "Escape", run: Fte },
  { key: "Mod-Enter", run: Qte },
  { key: "Alt-l", mac: "Ctrl-l", run: Pte },
  { key: "Mod-i", run: Bte, preventDefault: !0 },
  { key: "Mod-[", run: eD },
  { key: "Mod-]", run: QO },
  { key: "Mod-Alt-\\", run: ene },
  { key: "Shift-Mod-k", run: Xte },
  { key: "Shift-Mod-\\", run: Cte },
  { key: "Mod-/", run: Kee },
  { key: "Alt-A", run: Jee },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: tne }
].concat(rne), ine = { key: "Tab", run: QO, shift: eD };
var i1 = 200, nr = function() {
};
nr.prototype.append = function(e) {
  return e.length ? (e = nr.from(e), !this.length && e || e.length < i1 && this.leafAppend(e) || this.length < i1 && e.leafPrepend(this) || this.appendInner(e)) : this;
};
nr.prototype.prepend = function(e) {
  return e.length ? nr.from(e).append(this) : this;
};
nr.prototype.appendInner = function(e) {
  return new sne(this, e);
};
nr.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? nr.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
nr.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
nr.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
nr.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(s, o) {
    return i.push(e(s, o));
  }, t, r), i;
};
nr.from = function(e) {
  return e instanceof nr ? e : e && e.length ? new nD(e) : nr.empty;
};
var nD = /* @__PURE__ */ function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, s) {
    return i == 0 && s == this.length ? this : new e(this.values.slice(i, s));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, s, o, a) {
    for (var l = s; l < o; l++)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, s, o, a) {
    for (var l = s - 1; l >= o; l--)
      if (i(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= i1)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= i1)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(nr);
nr.empty = new nD([]);
var sne = /* @__PURE__ */ function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i < a && this.left.forEachInner(r, i, Math.min(s, a), o) === !1 || s > a && this.right.forEachInner(r, Math.max(i - a, 0), Math.min(this.length, s) - a, o + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, s, o) {
    var a = this.left.length;
    if (i > a && this.right.forEachInvertedInner(r, i - a, Math.max(s, a) - a, o + a) === !1 || s < a && this.left.forEachInvertedInner(r, Math.min(i, a), s, o) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var s = this.left.length;
    return i <= s ? this.left.slice(r, i) : r >= s ? this.right.slice(r - s, i - s) : this.left.slice(r, s).append(this.right.slice(0, i - s));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(nr);
const one = 500;
class ys {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, s;
    t && (i = this.remapping(r, this.items.length), s = i.maps.length);
    let o = e.tr, a, l, c = [], u = [];
    return this.items.forEach((h, f) => {
      if (!h.step) {
        i || (i = this.remapping(r, f + 1), s = i.maps.length), s--, u.push(h);
        return;
      }
      if (i) {
        u.push(new $s(h.map));
        let m = h.step.map(i.slice(s)), y;
        m && o.maybeStep(m).doc && (y = o.mapping.maps[o.mapping.maps.length - 1], c.push(new $s(y, void 0, void 0, c.length + u.length))), s--, y && i.appendMap(y, s);
      } else
        o.maybeStep(h.step);
      if (h.selection)
        return a = i ? h.selection.map(i.slice(s)) : h.selection, l = new ys(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: o, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let s = [], o = this.eventCount, a = this.items, l = !i && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let h = e.steps[u].invert(e.docs[u]), f = new $s(e.mapping.maps[u], h, t), m;
      (m = l && l.merge(f)) && (f = m, u ? s.pop() : a = a.slice(0, a.length - 1)), s.push(f), t && (o++, t = void 0), i || (l = f);
    }
    let c = o - r.depth;
    return c > lne && (a = ane(a, c), o -= c), new ys(a.append(s), o);
  }
  remapping(e, t) {
    let r = new qd();
    return this.items.forEach((i, s) => {
      let o = i.mirrorOffset != null && s - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, o);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new ys(this.items.append(e.map((t) => new $s(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), s = e.mapping, o = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, i);
    let l = t;
    this.items.forEach((f) => {
      let m = s.getMirror(--l);
      if (m == null)
        return;
      o = Math.min(o, m);
      let y = s.maps[m];
      if (f.step) {
        let b = e.steps[m].invert(e.docs[m]), k = f.selection && f.selection.map(s.slice(l + 1, m));
        k && a++, r.push(new $s(y, b, k));
      } else
        r.push(new $s(y));
    }, i);
    let c = [];
    for (let f = t; f < o; f++)
      c.push(new $s(s.maps[f]));
    let u = this.items.slice(0, i).append(c).append(r), h = new ys(u, a);
    return h.emptyItemCount() > one && (h = h.compress(this.items.length - r.length)), h;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], s = 0;
    return this.items.forEach((o, a) => {
      if (a >= e)
        i.push(o), o.selection && s++;
      else if (o.step) {
        let l = o.step.map(t.slice(r)), c = l && l.getMap();
        if (r--, c && t.appendMap(c, r), l) {
          let u = o.selection && o.selection.map(t.slice(r));
          u && s++;
          let h = new $s(c.invert(), l, u), f, m = i.length - 1;
          (f = i.length && i[m].merge(h)) ? i[m] = f : i.push(h);
        }
      } else o.map && r--;
    }, this.items.length, 0), new ys(nr.from(i.reverse()), s);
  }
}
ys.empty = new ys(nr.empty, 0);
function ane(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class $s {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new $s(t.getMap().invert(), t, this.selection);
    }
  }
}
class Ra {
  constructor(e, t, r, i, s) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = s;
  }
}
const lne = 20;
function cne(n, e, t, r) {
  let i = t.getMeta(vc), s;
  if (i)
    return i.historyState;
  t.getMeta(fne) && (n = new Ra(n.done, n.undone, null, 0, -1));
  let o = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (o && o.getMeta(vc))
    return o.getMeta(vc).redo ? new Ra(n.done.addTransform(t, void 0, r, tg(e)), n.undone, kS(t.mapping.maps), n.prevTime, n.prevComposition) : new Ra(n.done, n.undone.addTransform(t, void 0, r, tg(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) {
    let a = t.getMeta("composition"), l = n.prevTime == 0 || !o && n.prevComposition != a && (n.prevTime < (t.time || 0) - r.newGroupDelay || !une(t, n.prevRanges)), c = o ? b2(n.prevRanges, t.mapping) : kS(t.mapping.maps);
    return new Ra(n.done.addTransform(t, l ? e.selection.getBookmark() : void 0, r, tg(e)), ys.empty, c, t.time, a ?? n.prevComposition);
  } else return (s = t.getMeta("rebased")) ? new Ra(n.done.rebased(t, s), n.undone.rebased(t, s), b2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new Ra(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), b2(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function une(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let s = 0; s < e.length; s += 2)
      r <= e[s + 1] && i >= e[s] && (t = !0);
  }), t;
}
function kS(n) {
  let e = [];
  for (let t = n.length - 1; t >= 0 && e.length == 0; t--)
    n[t].forEach((r, i, s, o) => e.push(s, o));
  return e;
}
function b2(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), s = e.map(n[r + 1], -1);
    i <= s && t.push(i, s);
  }
  return t;
}
function hne(n, e, t) {
  let r = tg(e), i = vc.get(e).spec.config, s = (t ? n.undone : n.done).popEvent(e, r);
  if (!s)
    return null;
  let o = s.selection.resolve(s.transform.doc), a = (t ? n.done : n.undone).addTransform(s.transform, e.selection.getBookmark(), i, r), l = new Ra(t ? a : s.remaining, t ? s.remaining : a, null, 0, -1);
  return s.transform.setSelection(o).setMeta(vc, { redo: t, historyState: l });
}
let v2 = !1, xS = null;
function tg(n) {
  let e = n.plugins;
  if (xS != e) {
    v2 = !1, xS = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        v2 = !0;
        break;
      }
  }
  return v2;
}
const vc = new gn("history"), fne = new gn("closeHistory");
function dne(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new mn({
    key: vc,
    state: {
      init() {
        return new Ra(ys.empty, ys.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return cne(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? Sy : r == "historyRedo" ? bh : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
function rD(n, e) {
  return (t, r) => {
    let i = vc.getState(t);
    if (!i || (n ? i.undone : i.done).eventCount == 0)
      return !1;
    if (r) {
      let s = hne(i, t, n);
      s && r(e ? s.scrollIntoView() : s);
    }
    return !0;
  };
}
const Sy = rD(!1, !0), bh = rD(!0, !0);
var pne = Object.defineProperty, SS = Object.getOwnPropertySymbols, mne = Object.prototype.hasOwnProperty, gne = Object.prototype.propertyIsEnumerable, CS = (n, e, t) => e in n ? pne(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, yne = (n, e) => {
  for (var t in e || (e = {}))
    mne.call(e, t) && CS(n, t, e[t]);
  if (SS)
    for (var t of SS(e))
      gne.call(e, t) && CS(n, t, e[t]);
  return n;
};
function iD(n, e) {
  return Object.assign(n, {
    meta: yne({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const bne = {
  extensions: [],
  languages: [],
  expandIcon: "⬇",
  searchIcon: "🔍",
  clearSearchIcon: "⌫",
  searchPlaceholder: "Search language",
  noResultText: "No result",
  copyText: "Copy",
  copyIcon: "📋",
  onCopy: () => {
  },
  renderLanguage: (n) => n,
  renderPreview: () => null,
  previewToggleButton: (n) => n ? "Edit" : "Hide",
  previewLabel: "Preview"
}, sp = Wt(bne, "codeBlockConfigCtx");
iD(sp, {
  displayName: "Config<code-block>",
  group: "CodeBlock"
});
class vne {
  constructor(e) {
    this.languages = e, this.map = {}, e.forEach((t) => {
      t.alias.forEach((r) => {
        this.map[r] = t;
      });
    });
  }
  getAll() {
    return this.languages.map((e) => ({
      name: e.name,
      alias: e.alias
    }));
  }
  load(e) {
    const r = this.map[e.toLowerCase()];
    return r ? r.support ? Promise.resolve(r.support) : r.load() : Promise.resolve(void 0);
  }
}
function Au({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
Au.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
var wne = (n, e, t) => new Promise((r, i) => {
  var s = (l) => {
    try {
      a(t.next(l));
    } catch (c) {
      i(c);
    }
  }, o = (l) => {
    try {
      a(t.throw(l));
    } catch (c) {
      i(c);
    }
  }, a = (l) => l.done ? r(l.value) : Promise.resolve(l.value).then(s, o);
  a((t = t.apply(n, e)).next());
});
function kne(n) {
  return wne(this, null, function* () {
    try {
      return navigator.clipboard.writeText(n);
    } catch {
      const t = document.createElement("textarea"), r = document.activeElement;
      t.value = n, t.setAttribute("readonly", ""), t.style.contain = "strict", t.style.position = "absolute", t.style.left = "-9999px", t.style.fontSize = "12pt";
      const i = document.getSelection(), s = i ? i.rangeCount > 0 && i.getRangeAt(0) : null;
      document.body.appendChild(t), t.select(), t.selectionStart = 0, t.selectionEnd = n.length, document.execCommand("copy"), document.body.removeChild(t), s && (i.removeAllRanges(), i.addRange(s)), r && r.focus();
    }
  });
}
const xne = Xn({
  props: {
    copyText: {
      type: String,
      required: !0
    },
    copyIcon: {
      type: String,
      required: !0
    },
    onCopy: {
      type: Function,
      required: !0
    },
    text: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = () => {
      kne(n.text).then(() => n.onCopy(n.text)).catch(console.error);
    };
    return () => /* @__PURE__ */ te(Rc, null, /* @__PURE__ */ te("button", { type: "button", class: "copy-button", onClick: e }, /* @__PURE__ */ te(Au, { icon: n.copyIcon }), n.copyText));
  }
}), Sne = Xn({
  props: {
    language: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    }
  },
  setup({ language: n, config: e, setLanguage: t, getAllLanguages: r, getReadOnly: i }) {
    const s = Be(), o = Be(!1), a = Be(), l = Be(), c = Be("");
    hw([o, s, l], () => {
      c.value = "";
      const b = s.value, k = l.value;
      !b || !k || Cs(b, k, {
        placement: "bottom-start"
      }).then(({ x, y: M }) => {
        Object.assign(k.style, {
          left: `${x}px`,
          top: `${M}px`
        });
      }).catch(console.error);
    });
    const u = (b) => {
      if (b.preventDefault(), b.stopPropagation(), i()) return;
      const k = !o.value;
      o.value = k, k && setTimeout(() => {
        var x;
        return (x = a.value) == null ? void 0 : x.focus();
      }, 0);
    }, h = (b) => {
      const k = b.target;
      c.value = k.value;
    }, f = (b) => {
      b.key === "Escape" && (c.value = "");
    }, m = Qa(() => {
      var b;
      if (!o.value) return [];
      const k = (b = r()) != null ? b : [], x = k.find(
        (T) => T.name.toLowerCase() === n.value.toLowerCase()
      ), M = k.filter((T) => {
        const E = c.value.toLowerCase();
        return (T.name.toLowerCase().includes(E) || T.alias.some(
          (C) => C.toLowerCase().includes(E)
        )) && T !== x;
      });
      return M.length === 0 ? [] : x ? [x, ...M] : M;
    }), y = (b) => {
      const k = b.target;
      if (s.value && s.value.contains(k)) return;
      const x = l.value, M = s.value;
      !M || !x || M.dataset.expanded === "true" && (x.contains(k) || (o.value = !1));
    };
    return R0(() => {
      window.addEventListener("click", y);
    }), k1(() => {
      window.removeEventListener("click", y);
    }), () => /* @__PURE__ */ te(Rc, null, /* @__PURE__ */ te(
      "button",
      {
        type: "button",
        ref: s,
        class: "language-button",
        onClick: u,
        "data-expanded": String(o.value)
      },
      n.value || "Text",
      /* @__PURE__ */ te("div", { class: "expand-icon" }, /* @__PURE__ */ te(Au, { icon: e.expandIcon }))
    ), /* @__PURE__ */ te("div", { ref: l, class: "language-picker" }, o.value ? /* @__PURE__ */ te("div", { class: "list-wrapper" }, /* @__PURE__ */ te("div", { class: "search-box" }, /* @__PURE__ */ te("div", { class: "search-icon" }, /* @__PURE__ */ te(Au, { icon: e.searchIcon })), /* @__PURE__ */ te(
      "input",
      {
        ref: a,
        class: "search-input",
        placeholder: e.searchPlaceholder,
        value: c.value,
        onInput: h,
        onKeydown: f
      }
    ), /* @__PURE__ */ te(
      "div",
      {
        class: pr(
          "clear-icon",
          c.value.length === 0 && "hidden"
        ),
        onMousedown: (b) => {
          b.preventDefault(), c.value = "";
        }
      },
      /* @__PURE__ */ te(Au, { icon: e.clearSearchIcon })
    )), /* @__PURE__ */ te(
      "ul",
      {
        class: "language-list",
        role: "listbox",
        onKeydown: (b) => {
          if (b.key === "Enter") {
            const k = document.activeElement;
            k instanceof HTMLElement && k.dataset.language && t(k.dataset.language);
          }
        }
      },
      m.value.length ? m.value.map((b) => /* @__PURE__ */ te(
        "li",
        {
          role: "listitem",
          tabindex: "0",
          class: "language-list-item",
          "aria-selected": b.name.toLowerCase() === n.value.toLowerCase(),
          "data-language": b.name,
          onClick: () => {
            t(b.name), o.value = !1;
          }
        },
        e.renderLanguage(
          b.name,
          b.name.toLowerCase() === n.value.toLowerCase()
        )
      )) : /* @__PURE__ */ te("li", { class: "language-list-item no-result" }, e.noResultText)
    )) : null));
  }
}), Cne = Xn({
  props: {
    text: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    previewOnlyMode: {
      type: Object,
      required: !0
    },
    preview: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { previewOnlyMode: e, config: t, preview: r } = n, i = Be();
    return Ch(() => {
      const s = i.value;
      if (!s) return;
      for (; s.firstChild; )
        s.removeChild(s.firstChild);
      const o = r.value;
      (typeof o == "string" || o instanceof Element) && (s.innerHTML = Es.sanitize(o));
    }), () => r.value ? /* @__PURE__ */ te("div", { class: "preview-panel" }, !e.value && /* @__PURE__ */ te(Rc, null, /* @__PURE__ */ te("div", { class: "preview-divider" }), /* @__PURE__ */ te("div", { class: pr("preview-label", e && "hidden") }, t.previewLabel)), /* @__PURE__ */ te("div", { ref: i, class: "preview" })) : null;
  }
}), Mne = Xn({
  props: {
    text: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    getReadOnly: {
      type: Function,
      required: !0
    },
    codemirror: {
      type: Object,
      required: !0
    },
    language: {
      type: Object,
      required: !0
    },
    getAllLanguages: {
      type: Function,
      required: !0
    },
    setLanguage: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = Be(!1), t = Be();
    R0(() => {
      for (var s; (s = t.value) != null && s.firstChild; )
        t.value.removeChild(t.value.firstChild);
      t.value && t.value.appendChild(n.codemirror.dom);
    });
    const r = Qa(() => {
      const s = n.text.value, o = n.language.value;
      return n.config.renderPreview(o, s);
    }), i = () => {
    };
    return () => {
      var s;
      return /* @__PURE__ */ te(Rc, null, /* @__PURE__ */ te("div", { class: "tools" }, /* @__PURE__ */ te(
        Sne,
        {
          language: n.language,
          config: n.config,
          setLanguage: n.setLanguage,
          getAllLanguages: n.getAllLanguages,
          getReadOnly: n.getReadOnly
        }
      ), /* @__PURE__ */ te("div", { class: "tools-button-group" }, /* @__PURE__ */ te(
        xne,
        {
          copyIcon: n.config.copyIcon,
          copyText: n.config.copyText,
          onCopy: (s = n.config.onCopy) != null ? s : i,
          text: n.text.value
        }
      ), r.value ? /* @__PURE__ */ te(
        "button",
        {
          class: "preview-toggle-button",
          onClick: () => e.value = !e.value
        },
        /* @__PURE__ */ te(
          Au,
          {
            icon: n.config.previewToggleButton(
              e.value
            )
          }
        )
      ) : null)), /* @__PURE__ */ te(
        "div",
        {
          ref: t,
          class: pr(
            "codemirror-host",
            r.value && e.value && "hidden"
          )
        }
      ), /* @__PURE__ */ te(
        Cne,
        {
          text: n.text,
          language: n.language,
          config: n.config,
          previewOnlyMode: e,
          preview: r
        }
      ));
    };
  }
});
class Tne {
  constructor(e, t, r, i, s) {
    this.node = e, this.view = t, this.getPos = r, this.loader = i, this.config = s, this.selected = Be(!1), this.language = Be(""), this.text = Be(""), this.updating = !1, this.languageName = "", this.forwardUpdate = (o) => {
      var a;
      if (this.updating || !this.cm.hasFocus) return;
      let l = ((a = this.getPos()) != null ? a : 0) + 1;
      const { main: c } = o.state.selection, u = l + c.from, h = l + c.to, f = this.view.state.selection;
      if (o.docChanged || f.from !== u || f.to !== h) {
        const m = this.view.state.tr;
        o.changes.iterChanges((y, b, k, x, M) => {
          M.length ? m.replaceWith(
            l + y,
            l + b,
            this.view.state.schema.text(M.toString())
          ) : m.delete(l + y, l + b), l += x - k - (b - y);
        }), m.setSelection(Ye.create(m.doc, u, h)), this.view.dispatch(m);
      }
    }, this.createApp = () => ns(Mne, {
      text: this.text,
      selected: this.selected,
      codemirror: this.cm,
      language: this.language,
      getAllLanguages: this.getAllLanguages,
      getReadOnly: () => !this.view.editable,
      setLanguage: this.setLanguage,
      config: this.config
    }), this.codeMirrorKeymap = () => {
      const o = this.view;
      return [
        { key: "ArrowUp", run: () => this.maybeEscape("line", -1) },
        { key: "ArrowLeft", run: () => this.maybeEscape("char", -1) },
        { key: "ArrowDown", run: () => this.maybeEscape("line", 1) },
        { key: "ArrowRight", run: () => this.maybeEscape("char", 1) },
        {
          key: "Mod-Enter",
          run: () => QA(o.state, o.dispatch) ? (o.focus(), !0) : !1
        },
        { key: "Mod-z", run: () => Sy(o.state, o.dispatch) },
        { key: "Shift-Mod-z", run: () => bh(o.state, o.dispatch) },
        { key: "Mod-y", run: () => bh(o.state, o.dispatch) },
        {
          key: "Backspace",
          run: () => {
            var a;
            const l = this.cm.state.selection.ranges;
            if (l.length > 1) return !1;
            const c = l[0];
            if (c && (!c.empty || c.anchor > 0) || this.cm.state.doc.lines >= 2) return !1;
            const u = this.view.state, h = (a = this.getPos()) != null ? a : 0, f = u.tr.replaceWith(
              h,
              h + this.node.nodeSize,
              u.schema.nodes.paragraph.createChecked({}, this.node.content)
            );
            return f.setSelection(Ye.near(f.doc.resolve(h))), this.view.dispatch(f), this.view.focus(), !0;
          }
        }
      ];
    }, this.maybeEscape = (o, a) => {
      var l;
      const { state: c } = this.cm;
      let u = c.selection.main;
      if (!u.empty || (o === "line" && (u = c.doc.lineAt(u.head)), a < 0 ? u.from > 0 : u.to < c.doc.length)) return !1;
      const h = ((l = this.getPos()) != null ? l : 0) + (a < 0 ? 0 : this.node.nodeSize), f = Ye.near(
        this.view.state.doc.resolve(h),
        a
      ), m = this.view.state.tr.setSelection(f).scrollIntoView();
      return this.view.dispatch(m), this.view.focus(), !0;
    }, this.setLanguage = (o) => {
      var a;
      this.view.dispatch(
        this.view.state.tr.setNodeAttribute(
          (a = this.getPos()) != null ? a : 0,
          "language",
          o
        )
      );
    }, this.getAllLanguages = () => this.loader.getAll(), this.languageConf = new oh(), this.readOnlyConf = new oh(), this.cm = new $e({
      doc: this.node.textContent,
      root: this.view.root,
      extensions: [
        this.readOnlyConf.of(bn.readOnly.of(!this.view.editable)),
        UM(),
        Lh.of(this.codeMirrorKeymap()),
        this.languageConf.of([]),
        bn.changeFilter.of(() => this.view.editable),
        ...s.extensions,
        $e.updateListener.of(this.forwardUpdate)
      ]
    }), this.app = this.createApp(), this.dom = this.createDom(this.app), this.disposeSelectedWatcher = Ch(() => {
      this.selected.value ? this.dom.classList.add("selected") : this.dom.classList.remove("selected");
    }), this.updateLanguage();
  }
  createDom(e) {
    const t = document.createElement("div");
    return t.className = "milkdown-code-block", this.text.value = this.node.textContent, e.mount(t), t;
  }
  updateLanguage() {
    const e = this.node.attrs.language;
    if (e === this.languageName) return;
    this.language.value = e, this.loader.load(e ?? "").then((r) => {
      r && (this.cm.dispatch({
        effects: this.languageConf.reconfigure(r)
      }), this.languageName = e);
    }).catch(console.error);
  }
  setSelection(e, t) {
    this.cm.dom.isConnected && (this.cm.focus(), this.updating = !0, this.cm.dispatch({ selection: { anchor: e, head: t } }), this.updating = !1);
  }
  update(e) {
    if (e.type !== this.node.type) return !1;
    if (this.updating) return !0;
    this.node = e, this.text.value = e.textContent, this.updateLanguage(), this.view.editable === this.cm.state.readOnly && this.cm.dispatch({
      effects: this.readOnlyConf.reconfigure(
        bn.readOnly.of(!this.view.editable)
      )
    });
    const t = Ane(this.cm.state.doc.toString(), e.textContent);
    return t && (this.updating = !0, this.cm.dispatch({
      changes: { from: t.from, to: t.to, insert: t.text },
      scrollIntoView: !0
    }), this.updating = !1), !0;
  }
  selectNode() {
    this.selected.value = !0, this.cm.focus();
  }
  deselectNode() {
    this.selected.value = !1;
  }
  stopEvent() {
    return !0;
  }
  destroy() {
    this.app.unmount(), this.cm.destroy(), this.disposeSelectedWatcher();
  }
}
function Ane(n, e) {
  if (n === e) return null;
  let t = 0, r = n.length, i = e.length;
  for (; t < r && n.charCodeAt(t) === e.charCodeAt(t); )
    ++t;
  for (; r > t && i > t && n.charCodeAt(r - 1) === e.charCodeAt(i - 1); )
    r--, i--;
  return { from: t, to: r, text: e.slice(t, i) };
}
const sD = J0(
  ao.node,
  (n) => {
    const e = n.get(sp.key), t = new vne(e.languages);
    return (r, i, s) => new Tne(r, i, s, t, e);
  }
);
iD(sD, {
  displayName: "NodeView<code-block>",
  group: "CodeBlock"
});
const Ene = [
  sD,
  sp
], MS = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class vh {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (a) => s(MS(a)) : MS, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Yr(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = xw(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Ws(e);
      let i = this.normalize(t);
      if (i.length)
        for (let s = 0, o = r; ; s++) {
          let a = i.charCodeAt(s), l = this.match(a, o, this.bufferPos + this.bufferStart);
          if (s == i.length - 1) {
            if (l)
              return this.value = l, this;
            break;
          }
          o == r && s < t.length && t.charCodeAt(s) == a && o++;
        }
    }
  }
  match(e, t, r) {
    let i = null;
    for (let s = 0; s < this.matches.length; s += 2) {
      let o = this.matches[s], a = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? i = { from: this.matches[s + 1], to: r } : (this.matches[s]++, a = !0)), a || (this.matches.splice(s, 2), s -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: r } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferStart) && (i = null), i;
  }
}
typeof Symbol < "u" && (vh.prototype[Symbol.iterator] = function() {
  return this;
});
const oD = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, F3 = "gm" + (/x/.unicode == null ? "" : "u");
class aD {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = oD, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new lD(e, t, r, i, s);
    this.re = new RegExp(t, F3 + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = s1(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let r = this.curLineStart + t.index, i = r + t[0].length;
        if (this.matchPos = s1(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const w2 = /* @__PURE__ */ new WeakMap();
class Eu {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, r) {
    let i = w2.get(e);
    if (!i || i.from >= r || i.to <= t) {
      let a = new Eu(t, e.sliceString(t, r));
      return w2.set(e, a), a;
    }
    if (i.from == t && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > t && (s = e.sliceString(t, o) + s, o = t), i.to < r && (s += e.sliceString(i.to, r)), w2.set(e, new Eu(o, s)), new Eu(t, s.slice(t - o, r - o));
  }
}
class lD {
  constructor(e, t, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = oD, this.matchPos = s1(e, i), this.re = new RegExp(t, F3 + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = Eu.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let r = this.flat.from + t.index, i = r + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, t)))
          return this.value = { from: r, to: i, match: t }, this.matchPos = s1(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Eu.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (aD.prototype[Symbol.iterator] = lD.prototype[Symbol.iterator] = function() {
  return this;
});
function Lne(n) {
  try {
    return new RegExp(n, F3), !0;
  } catch {
    return !1;
  }
}
function s1(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), r;
  for (; e < t.to && (r = t.text.charCodeAt(e - t.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function $4(n) {
  let e = String(n.state.doc.lineAt(n.state.selection.main.head).number), t = Xt("input", { class: "cm-textfield", name: "line", value: e }), r = Xt("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), n.dispatch({ effects: xd.of(!1) }), n.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, Xt("label", n.state.phrase("Go to line"), ": ", t), " ", Xt("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")), Xt("button", {
    name: "close",
    onclick: () => {
      n.dispatch({ effects: xd.of(!1) }), n.focus();
    },
    "aria-label": n.state.phrase("close"),
    type: "button"
  }, ["×"]));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(t.value);
    if (!s)
      return;
    let { state: o } = n, a = o.doc.lineAt(o.selection.main.head), [, l, c, u, h] = s, f = u ? +u.slice(1) : 0, m = c ? +c : a.number;
    if (c && h) {
      let k = m / 100;
      l && (k = k * (l == "-" ? -1 : 1) + a.number / o.doc.lines), m = Math.round(o.doc.lines * k);
    } else c && l && (m = m * (l == "-" ? -1 : 1) + a.number);
    let y = o.doc.line(Math.max(1, Math.min(o.doc.lines, m))), b = ce.cursor(y.from + Math.max(0, Math.min(f, y.length)));
    n.dispatch({
      effects: [xd.of(!1), $e.scrollIntoView(b.from, { y: "center" })],
      selection: b
    }), n.focus();
  }
  return { dom: r };
}
const xd = /* @__PURE__ */ pt.define(), TS = /* @__PURE__ */ rr.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(xd) && (n = t.value);
    return n;
  },
  provide: (n) => Bd.from(n, (e) => e ? $4 : null)
}), One = (n) => {
  let e = Pd(n, $4);
  if (!e) {
    let t = [xd.of(!0)];
    n.state.field(TS, !1) == null && t.push(pt.appendConfig.of([TS, Dne])), n.dispatch({ effects: t }), e = Pd(n, $4);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, Dne = /* @__PURE__ */ $e.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    position: "relative",
    "& label": { fontSize: "80%" },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      bottom: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: "0"
    }
  }
}), Nne = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, Ine = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, Nne, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function _ne(n) {
  return [zne, Hne];
}
const Rne = /* @__PURE__ */ rt.mark({ class: "cm-selectionMatch" }), Pne = /* @__PURE__ */ rt.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function AS(n, e, t, r) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != yn.Word) && (r == e.doc.length || n(e.sliceDoc(r, r + 1)) != yn.Word);
}
function Bne(n, e, t, r) {
  return n(e.sliceDoc(t, t + 1)) == yn.Word && n(e.sliceDoc(r - 1, r)) == yn.Word;
}
const Hne = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(Ine), { state: t } = n, r = t.selection;
    if (r.ranges.length > 1)
      return rt.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return rt.none;
      let l = t.wordAt(i.head);
      if (!l)
        return rt.none;
      o = t.charCategorizer(i.head), s = t.sliceDoc(l.from, l.to);
    } else {
      let l = i.to - i.from;
      if (l < e.minSelectionLength || l > 200)
        return rt.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(i.from, i.to), o = t.charCategorizer(i.head), !(AS(o, t, i.from, i.to) && Bne(o, t, i.from, i.to)))
          return rt.none;
      } else if (s = t.sliceDoc(i.from, i.to), !s)
        return rt.none;
    }
    let a = [];
    for (let l of n.visibleRanges) {
      let c = new vh(t.doc, s, l.from, l.to);
      for (; !c.next().done; ) {
        let { from: u, to: h } = c.value;
        if ((!o || AS(o, t, u, h)) && (i.empty && u <= i.from && h >= i.to ? a.push(Pne.range(u, h)) : (u >= i.to || h <= i.from) && a.push(Rne.range(u, h)), a.length > e.maxMatches))
          return rt.none;
      }
    }
    return rt.set(a);
  }
}, {
  decorations: (n) => n.decorations
}), zne = /* @__PURE__ */ $e.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Fne = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, r = ce.create(t.ranges.map((i) => n.wordAt(i.head) || ce.cursor(i.head)), t.mainIndex);
  return r.eq(t) ? !1 : (e(n.update({ selection: r })), !0);
};
function Vne(n, e) {
  let { main: t, ranges: r } = n.selection, i = n.wordAt(t.head), s = i && i.from == t.from && i.to == t.to;
  for (let o = !1, a = new vh(n.doc, e, r[r.length - 1].to); ; )
    if (a.next(), a.done) {
      if (o)
        return null;
      a = new vh(n.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((l) => l.from == a.value.from))
        continue;
      if (s) {
        let l = n.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const qne = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return Fne({ state: n, dispatch: e });
  let r = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = Vne(n, r);
  return i ? (e(n.update({
    selection: n.selection.addRange(ce.range(i.from, i.to), !1),
    effects: $e.scrollIntoView(i.to)
  })), !0) : !1;
}, zh = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new ere(e),
      scrollToMatch: (e) => $e.scrollIntoView(e)
    });
  }
});
class cD {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Lne(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Une(this) : new jne(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, r) {
    let i = e.doc ? e : bn.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? hu(this, i, t, r) : uu(this, i, t, r);
  }
}
class uD {
  constructor(e) {
    this.spec = e;
  }
}
function uu(n, e, t, r) {
  return new vh(e.doc, n.unquoted, t, r, n.caseSensitive ? void 0 : (i) => i.toLowerCase(), n.wholeWord ? $ne(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function $ne(n, e) {
  return (t, r, i, s) => ((s > t || s + i.length < r) && (s = Math.max(0, t - 2), i = n.sliceString(s, Math.min(n.length, r + 2))), (e(o1(i, t - s)) != yn.Word || e(a1(i, t - s)) != yn.Word) && (e(a1(i, r - s)) != yn.Word || e(o1(i, r - s)) != yn.Word));
}
class jne extends uD {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, r) {
    let i = uu(this.spec, e, r, e.doc.length).nextOverlapping();
    if (i.done) {
      let s = Math.min(e.doc.length, t + this.spec.unquoted.length);
      i = uu(this.spec, e, 0, s).nextOverlapping();
    }
    return i.done || i.value.from == t && i.value.to == r ? null : i.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, r) {
    for (let i = r; ; ) {
      let s = Math.max(t, i - 1e4 - this.spec.unquoted.length), o = uu(this.spec, e, s, i), a = null;
      for (; !o.nextOverlapping().done; )
        a = o.value;
      if (a)
        return a;
      if (s == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, r) {
    let i = this.prevMatchInRange(e, 0, t);
    return i || (i = this.prevMatchInRange(e, Math.max(0, r - this.spec.unquoted.length), e.doc.length)), i && (i.from != t || i.to != r) ? i : null;
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let r = uu(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = uu(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function hu(n, e, t, r) {
  return new aD(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? Wne(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, r);
}
function o1(n, e) {
  return n.slice(fr(n, e, !1), e);
}
function a1(n, e) {
  return n.slice(e, fr(n, e));
}
function Wne(n) {
  return (e, t, r) => !r[0].length || (n(o1(r.input, r.index)) != yn.Word || n(a1(r.input, r.index)) != yn.Word) && (n(a1(r.input, r.index + r[0].length)) != yn.Word || n(o1(r.input, r.index + r[0].length)) != yn.Word);
}
class Une extends uD {
  nextMatch(e, t, r) {
    let i = hu(this.spec, e, r, e.doc.length).next();
    return i.done && (i = hu(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(
        t,
        r - i * 1e4
        /* FindPrev.ChunkSize */
      ), o = hu(this.spec, e, s, r), a = null;
      for (; !o.next().done; )
        a = o.value;
      if (a && (s == t || a.from > s + 10))
        return a;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, r) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&]|\d+)/g, (t, r) => {
      if (r == "&")
        return e.match[0];
      if (r == "$")
        return "$";
      for (let i = r.length; i > 0; i--) {
        let s = +r.slice(0, i);
        if (s > 0 && s < e.match.length)
          return e.match[s] + r.slice(i);
      }
      return t;
    });
  }
  matchAll(e, t) {
    let r = hu(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, t, r, i) {
    let s = hu(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const Qd = /* @__PURE__ */ pt.define(), V3 = /* @__PURE__ */ pt.define(), Za = /* @__PURE__ */ rr.define({
  create(n) {
    return new k2(j4(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Qd) ? n = new k2(t.value.create(), n.panel) : t.is(V3) && (n = new k2(n.query, t.value ? q3 : null));
    return n;
  },
  provide: (n) => Bd.from(n, (e) => e.panel)
});
class k2 {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const Kne = /* @__PURE__ */ rt.mark({ class: "cm-searchMatch" }), Gne = /* @__PURE__ */ rt.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Jne = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(Za));
  }
  update(n) {
    let e = n.state.field(Za);
    (e != n.startState.field(Za) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return rt.none;
    let { view: t } = this, r = new ra();
    for (let i = 0, s = t.visibleRanges, o = s.length; i < o; i++) {
      let { from: a, to: l } = s[i];
      for (; i < o - 1 && l > s[i + 1].from - 2 * 250; )
        l = s[++i].to;
      n.highlight(t.state, a, l, (c, u) => {
        let h = t.state.selection.ranges.some((f) => f.from == c && f.to == u);
        r.add(c, u, h ? Gne : Kne);
      });
    }
    return r.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function op(n) {
  return (e) => {
    let t = e.state.field(Za, !1);
    return t && t.query.spec.valid ? n(e, t) : dD(e);
  };
}
const l1 = /* @__PURE__ */ op((n, { query: e }) => {
  let { to: t } = n.state.selection.main, r = e.nextMatch(n.state, t, t);
  if (!r)
    return !1;
  let i = ce.single(r.from, r.to), s = n.state.facet(zh);
  return n.dispatch({
    selection: i,
    effects: [$3(n, r), s.scrollToMatch(i.main, n)],
    userEvent: "select.search"
  }), fD(n), !0;
}), c1 = /* @__PURE__ */ op((n, { query: e }) => {
  let { state: t } = n, { from: r } = t.selection.main, i = e.prevMatch(t, r, r);
  if (!i)
    return !1;
  let s = ce.single(i.from, i.to), o = n.state.facet(zh);
  return n.dispatch({
    selection: s,
    effects: [$3(n, i), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), fD(n), !0;
}), Yne = /* @__PURE__ */ op((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: ce.create(t.map((r) => ce.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Xne = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: r, to: i } = t.main, s = [], o = 0;
  for (let a = new vh(n.doc, n.sliceDoc(r, i)); !a.next().done; ) {
    if (s.length > 1e3)
      return !1;
    a.value.from == r && (o = s.length), s.push(ce.range(a.value.from, a.value.to));
  }
  return e(n.update({
    selection: ce.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, ES = /* @__PURE__ */ op((n, { query: e }) => {
  let { state: t } = n, { from: r, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, r, r);
  if (!s)
    return !1;
  let o = s, a = [], l, c, u = [];
  o.from == r && o.to == i && (c = t.toText(e.getReplacement(o)), a.push({ from: o.from, to: o.to, insert: c }), o = e.nextMatch(t, o.from, o.to), u.push($e.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(r).number) + ".")));
  let h = n.state.changes(a);
  return o && (l = ce.single(o.from, o.to).map(h), u.push($3(n, o)), u.push(t.facet(zh).scrollToMatch(l.main, n))), n.dispatch({
    changes: h,
    selection: l,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), Zne = /* @__PURE__ */ op((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let r = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: $e.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function q3(n) {
  return n.state.facet(zh).createPanel(n);
}
function j4(n, e) {
  var t, r, i, s, o;
  let a = n.selection.main, l = a.empty || a.to > a.from + 100 ? "" : n.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let c = n.facet(zh);
  return new cD({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : c.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function hD(n) {
  let e = Pd(n, q3);
  return e && e.dom.querySelector("[main-field]");
}
function fD(n) {
  let e = hD(n);
  e && e == n.root.activeElement && e.select();
}
const dD = (n) => {
  let e = n.state.field(Za, !1);
  if (e && e.panel) {
    let t = hD(n);
    if (t && t != n.root.activeElement) {
      let r = j4(n.state, e.query.spec);
      r.valid && n.dispatch({ effects: Qd.of(r) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      V3.of(!0),
      e ? Qd.of(j4(n.state, e.query.spec)) : pt.appendConfig.of(nre)
    ] });
  return !0;
}, pD = (n) => {
  let e = n.state.field(Za, !1);
  if (!e || !e.panel)
    return !1;
  let t = Pd(n, q3);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: V3.of(!1) }), !0;
}, Qne = [
  { key: "Mod-f", run: dD, scope: "editor search-panel" },
  { key: "F3", run: l1, shift: c1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: l1, shift: c1, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: pD, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Xne },
  { key: "Mod-Alt-g", run: One },
  { key: "Mod-d", run: qne, preventDefault: !0 }
];
class ere {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Za).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Xt("input", {
      value: t.search,
      placeholder: di(e, "Find"),
      "aria-label": di(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Xt("input", {
      value: t.replace,
      placeholder: di(e, "Replace"),
      "aria-label": di(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Xt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Xt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Xt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return Xt("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = Xt("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => l1(e), [di(e, "next")]),
      r("prev", () => c1(e), [di(e, "previous")]),
      r("select", () => Yne(e), [di(e, "all")]),
      Xt("label", null, [this.caseField, di(e, "match case")]),
      Xt("label", null, [this.reField, di(e, "regexp")]),
      Xt("label", null, [this.wordField, di(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Xt("br"),
        this.replaceField,
        r("replace", () => ES(e), [di(e, "replace")]),
        r("replaceAll", () => Zne(e), [di(e, "replace all")])
      ],
      Xt("button", {
        name: "close",
        onclick: () => pD(e),
        "aria-label": di(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new cD({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: Qd.of(e) }));
  }
  keydown(e) {
    eF(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? c1 : l1)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), ES(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let r of t.effects)
        r.is(Qd) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(zh).top;
  }
}
function di(n, e) {
  return n.state.phrase(e);
}
const rm = 30, im = /[\s\.,:;?!]/;
function $3(n, { from: e, to: t }) {
  let r = n.state.doc.lineAt(e), i = n.state.doc.lineAt(t).to, s = Math.max(r.from, e - rm), o = Math.min(i, t + rm), a = n.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let l = 0; l < rm; l++)
      if (!im.test(a[l + 1]) && im.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (o != i) {
    for (let l = a.length - 1; l > a.length - rm; l--)
      if (!im.test(a[l - 1]) && im.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return $e.announce.of(`${n.state.phrase("current match")}. ${a} ${n.state.phrase("on line")} ${r.number}.`);
}
const tre = /* @__PURE__ */ $e.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), nre = [
  Za,
  /* @__PURE__ */ fl.low(Jne),
  tre
];
class mD {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, r, i) {
    this.state = e, this.pos = t, this.explicit = r, this.view = i, this.abortListeners = [], this.abortOnDocChange = !1;
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = dr(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), r = Math.max(t.from, this.pos - 250), i = t.text.slice(r - t.from, this.pos - t.from), s = i.search(gD(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  
  By default, running queries will not be aborted for regular
  typing or backspacing, on the assumption that they are likely to
  return a result with a
  [`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that
  allows the result to be used after all. Passing `onDocChange:
  true` will cause this query to be aborted for any document
  change.
  */
  addEventListener(e, t, r) {
    e == "abort" && this.abortListeners && (this.abortListeners.push(t), r && r.onDocChange && (this.abortOnDocChange = !0));
  }
}
function LS(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function rre(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of n) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      t[i[s]] = !0;
  }
  let r = LS(e) + LS(t) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function ire(n) {
  let e = n.map((i) => typeof i == "string" ? { label: i } : i), [t, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : rre(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: t } : null;
  };
}
function uue(n, e) {
  return (t) => {
    for (let r = dr(t.state).resolveInner(t.pos, -1); r; r = r.parent) {
      if (n.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(t);
  };
}
class OS {
  constructor(e, t, r, i) {
    this.completion = e, this.source = t, this.match = r, this.score = i;
  }
}
function wc(n) {
  return n.selection.main.from;
}
function gD(n, e) {
  var t;
  let { source: r } = n, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? n : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const j3 = /* @__PURE__ */ fa.define();
function sre(n, e, t, r) {
  let { main: i } = n.selection, s = t - i.from, o = r - i.from;
  return {
    ...n.changeByRange((a) => {
      if (a != i && t != r && n.sliceDoc(a.from + s, a.from + o) != n.sliceDoc(t, r))
        return { range: a };
      let l = n.toText(e);
      return {
        changes: { from: a.from + s, to: r == i.from ? a.to : a.from + o, insert: l },
        range: ce.cursor(a.from + s + l.length)
      };
    }),
    scrollIntoView: !0,
    userEvent: "input.complete"
  };
}
const DS = /* @__PURE__ */ new WeakMap();
function ore(n) {
  if (!Array.isArray(n))
    return n;
  let e = DS.get(n);
  return e || DS.set(n, e = ire(n)), e;
}
const u1 = /* @__PURE__ */ pt.define(), e0 = /* @__PURE__ */ pt.define();
class are {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let r = Yr(e, t), i = Ws(r);
      this.chars.push(r);
      let s = e.slice(t, t + i), o = s.toUpperCase();
      this.folded.push(Yr(o == s ? s.toLowerCase() : o, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: r, any: i, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let M = Yr(e, 0), T = Ws(M), E = T == e.length ? 0 : -100;
      if (M != t[0]) if (M == r[0])
        E += -200;
      else
        return null;
      return this.ret(E, [0, T]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, c = 0;
    if (a < 0) {
      for (let M = 0, T = Math.min(e.length, 200); M < T && c < l; ) {
        let E = Yr(e, M);
        (E == t[c] || E == r[c]) && (i[c++] = M), M += Ws(E);
      }
      if (c < l)
        return null;
    }
    let u = 0, h = 0, f = !1, m = 0, y = -1, b = -1, k = /[a-z]/.test(e), x = !0;
    for (let M = 0, T = Math.min(e.length, 200), E = 0; M < T && h < l; ) {
      let C = Yr(e, M);
      a < 0 && (u < l && C == t[u] && (s[u++] = M), m < l && (C == t[m] || C == r[m] ? (m == 0 && (y = M), b = M + 1, m++) : m = 0));
      let O, R = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (O = xw(C)) != O.toLowerCase() ? 1 : O != O.toUpperCase() ? 2 : 0;
      (!M || R == 1 && k || E == 0 && R != 0) && (t[h] == C || r[h] == C && (f = !0) ? o[h++] = M : o.length && (x = !1)), E = R, M += Ws(C);
    }
    return h == l && o[0] == 0 && x ? this.result(-100 + (f ? -200 : 0), o, e) : m == l && y == 0 ? this.ret(-200 - e.length + (b == e.length ? 0 : -100), [0, b]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : m == l ? this.ret(-900 - e.length, [y, b]) : h == l ? this.result(-100 + (f ? -200 : 0) + -700 + (x ? 0 : -1100), o, e) : t.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, r) {
    let i = [], s = 0;
    for (let o of t) {
      let a = o + (this.astral ? Ws(Yr(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = a : (i[s++] = o, i[s++] = a);
    }
    return this.ret(e - r.length, i);
  }
}
class lre {
  constructor(e) {
    this.pattern = e, this.matched = [], this.score = 0, this.folded = e.toLowerCase();
  }
  match(e) {
    if (e.length < this.pattern.length)
      return null;
    let t = e.slice(0, this.pattern.length), r = t == this.pattern ? 0 : t.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, t.length], this.score = r + (e.length == this.pattern.length ? 0 : -100), this);
  }
}
const tr = /* @__PURE__ */ ze.define({
  combine(n) {
    return lo(n, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: cre,
      filterStrict: !1,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (r) => NS(e(r), t(r)),
      optionClass: (e, t) => (r) => NS(e(r), t(r)),
      addToOptions: (e, t) => e.concat(t),
      filterStrict: (e, t) => e || t
    });
  }
});
function NS(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function cre(n, e, t, r, i, s) {
  let o = n.textDirection == pn.RTL, a = o, l = !1, c = "top", u, h, f = e.left - i.left, m = i.right - e.right, y = r.right - r.left, b = r.bottom - r.top;
  if (a && f < Math.min(y, m) ? a = !1 : !a && m < Math.min(y, f) && (a = !0), y <= (a ? f : m))
    u = Math.max(i.top, Math.min(t.top, i.bottom - b)) - e.top, h = Math.min(400, a ? f : m);
  else {
    l = !0, h = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let M = i.bottom - e.bottom;
    M >= b || M > e.top ? u = t.bottom - e.top : (c = "bottom", u = e.bottom - t.top);
  }
  let k = (e.bottom - e.top) / s.offsetHeight, x = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / k}px; max-width: ${h / x}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function ure(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), t.type && r.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(t, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = t.displayLabel || t.label, l = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], h = s[c++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(a.slice(u, h))), f.className = "cm-completionMatchedText", l = h;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = t.detail, r;
    },
    position: 80
  }), e.sort((t, r) => t.position - r.position).map((t) => t.render);
}
function x2(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let r = Math.floor((n - e) / t);
  return { from: n - (r + 1) * t, to: n - r * t };
}
class hre {
  constructor(e, t, r) {
    this.view = e, this.stateField = t, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(t), { options: s, selected: o } = i.open, a = e.state.facet(tr);
    this.optionContent = ure(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = x2(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(t).open;
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < c.length) {
          this.applyCompletion(e, c[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(tr).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: e0.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, t) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, t, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var t;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: a } = r.open;
      (!i.open || i.open.options != s) && (this.range = x2(s.length, o, e.state.facet(tr).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), a != ((t = i.open) === null || t === void 0 ? void 0 : t.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of t.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = x2(t.options.length, t.selected, this.view.state.facet(tr).maxRenderedOptions), this.showOptions(t.options, e.id)), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: r } = t.options[t.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => Qr(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), t = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return t && dre(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.documentElement;
      s = { left: 0, top: 0, right: o.clientWidth, bottom: o.clientHeight };
    }
    return i.top > Math.min(s.bottom, t.bottom) - 10 || i.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(tr).positionInfo(this.view, t, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, r) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions")), i.addEventListener("mousedown", (o) => {
      o.target == i && o.preventDefault();
    });
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let m = i.appendChild(document.createElement("completion-section"));
            m.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = t + "-" + o, u.setAttribute("role", "option");
      let h = this.optionClass(a);
      h && (u.className = h);
      for (let f of this.optionContent) {
        let m = f(a, this.view.state, this.view, l);
        m && u.appendChild(m);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function fre(n, e) {
  return (t) => new hre(t, n, e);
}
function dre(n, e) {
  let t = n.getBoundingClientRect(), r = e.getBoundingClientRect(), i = t.height / n.offsetHeight;
  r.top < t.top ? n.scrollTop -= (t.top - r.top) / i : r.bottom > t.bottom && (n.scrollTop += (r.bottom - t.bottom) / i);
}
function IS(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function pre(n, e) {
  let t = [], r = null, i = null, s = (u) => {
    t.push(u);
    let { section: h } = u.completion;
    if (h) {
      r || (r = []);
      let f = typeof h == "string" ? h : h.name;
      r.some((m) => m.name == f) || r.push(typeof h == "string" ? { name: f } : h);
    }
  }, o = e.facet(tr);
  for (let u of n)
    if (u.hasResult()) {
      let h = u.result.getMatch;
      if (u.result.filter === !1)
        for (let f of u.result.options)
          s(new OS(f, u.source, h ? h(f) : [], 1e9 - t.length));
      else {
        let f = e.sliceDoc(u.from, u.to), m, y = o.filterStrict ? new lre(f) : new are(f);
        for (let b of u.result.options)
          if (m = y.match(b.label)) {
            let k = b.displayLabel ? h ? h(b, m.matched) : [] : m.matched, x = m.score + (b.boost || 0);
            if (s(new OS(b, u.source, k, x)), typeof b.section == "object" && b.section.rank === "dynamic") {
              let { name: M } = b.section;
              i || (i = /* @__PURE__ */ Object.create(null)), i[M] = Math.max(x, i[M] || -1e9);
            }
          }
      }
    }
  if (r) {
    let u = /* @__PURE__ */ Object.create(null), h = 0, f = (m, y) => (m.rank === "dynamic" && y.rank === "dynamic" ? i[y.name] - i[m.name] : 0) || (typeof m.rank == "number" ? m.rank : 1e9) - (typeof y.rank == "number" ? y.rank : 1e9) || (m.name < y.name ? -1 : 1);
    for (let m of r.sort(f))
      h -= 1e5, u[m.name] = h;
    for (let m of t) {
      let { section: y } = m.completion;
      y && (m.score += u[typeof y == "string" ? y : y.name]);
    }
  }
  let a = [], l = null, c = o.compareCompletions;
  for (let u of t.sort((h, f) => f.score - h.score || c(h.completion, f.completion))) {
    let h = u.completion;
    !l || l.label != h.label || l.detail != h.detail || l.type != null && h.type != null && l.type != h.type || l.apply != h.apply || l.boost != h.boost ? a.push(u) : IS(u.completion) > IS(l) && (a[a.length - 1] = u), l = u.completion;
  }
  return a;
}
class bu {
  constructor(e, t, r, i, s, o) {
    this.options = e, this.attrs = t, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new bu(this.options, _S(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, r, i, s, o) {
    if (i && !o && e.some((c) => c.isPending))
      return i.setDisabled();
    let a = pre(e, t);
    if (!a.length)
      return i && e.some((c) => c.isPending) ? i.setDisabled() : null;
    let l = t.facet(tr).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let c = i.options[i.selected].completion;
      for (let u = 0; u < a.length; u++)
        if (a[u].completion == c) {
          l = u;
          break;
        }
    }
    return new bu(a, _S(r, l), {
      pos: e.reduce((c, u) => u.hasResult() ? Math.min(c, u.from) : c, 1e8),
      create: wre,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new bu(this.options, this.attrs, { ...this.tooltip, pos: e.mapPos(this.tooltip.pos) }, this.timestamp, this.selected, this.disabled);
  }
  setDisabled() {
    return new bu(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, !0);
  }
}
class h1 {
  constructor(e, t, r) {
    this.active = e, this.id = t, this.open = r;
  }
  static start() {
    return new h1(bre, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, r = t.facet(tr), s = (r.override || t.languageDataAt("autocomplete", wc(t)).map(ore)).map((l) => (this.active.find((u) => u.source == l) || new Wi(
      l,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, r));
    s.length == this.active.length && s.every((l, c) => l == this.active[c]) && (s = this.active);
    let o = this.open, a = e.effects.some((l) => l.is(W3));
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !mre(s, this.active) || a ? o = bu.build(s, t, this.id, o, r, a) : o && o.disabled && !s.some((l) => l.isPending) && (o = null), !o && s.every((l) => !l.isPending) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new Wi(
      l.source,
      0
      /* State.Inactive */
    ) : l));
    for (let l of e.effects)
      l.is(bD) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new h1(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? gre : yre;
  }
}
function mre(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, r = 0; ; ) {
    for (; t < n.length && !n[t].hasResult(); )
      t++;
    for (; r < e.length && !e[r].hasResult(); )
      r++;
    let i = t == n.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (n[t++].result != e[r++].result)
      return !1;
  }
}
const gre = {
  "aria-autocomplete": "list"
}, yre = {};
function _S(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const bre = [];
function yD(n, e) {
  if (n.isUserEvent("input.complete")) {
    let r = n.annotation(j3);
    if (r && e.activateOnCompletion(r))
      return 12;
  }
  let t = n.isUserEvent("input.type");
  return t && e.activateOnTyping ? 5 : t ? 1 : n.isUserEvent("delete.backward") ? 2 : n.selection ? 8 : n.docChanged ? 16 : 0;
}
class Wi {
  constructor(e, t, r = !1) {
    this.source = e, this.state = t, this.explicit = r;
  }
  hasResult() {
    return !1;
  }
  get isPending() {
    return this.state == 1;
  }
  update(e, t) {
    let r = yD(e, t), i = this;
    (r & 8 || r & 16 && this.touches(e)) && (i = new Wi(
      i.source,
      0
      /* State.Inactive */
    )), r & 4 && i.state == 0 && (i = new Wi(
      this.source,
      1
      /* State.Pending */
    )), i = i.updateFor(e, r);
    for (let s of e.effects)
      if (s.is(u1))
        i = new Wi(i.source, 1, s.value);
      else if (s.is(e0))
        i = new Wi(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(W3))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  updateFor(e, t) {
    return this.map(e.changes);
  }
  map(e) {
    return this;
  }
  touches(e) {
    return e.changes.touchesRange(wc(e.state));
  }
}
class Lu extends Wi {
  constructor(e, t, r, i, s, o) {
    super(e, 3, t), this.limit = r, this.result = i, this.from = s, this.to = o;
  }
  hasResult() {
    return !0;
  }
  updateFor(e, t) {
    var r;
    if (!(t & 3))
      return this.map(e.changes);
    let i = this.result;
    i.map && !e.changes.empty && (i = i.map(i, e.changes));
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = wc(e.state);
    if (a > o || !i || t & 2 && (wc(e.startState) == this.from || a < this.limit))
      return new Wi(
        this.source,
        t & 4 ? 1 : 0
        /* State.Inactive */
      );
    let l = e.changes.mapPos(this.limit);
    return vre(i.validFor, e.state, s, o) ? new Lu(this.source, this.explicit, l, i, s, o) : i.update && (i = i.update(i, s, o, new mD(e.state, a, !1))) ? new Lu(this.source, this.explicit, l, i, i.from, (r = i.to) !== null && r !== void 0 ? r : wc(e.state)) : new Wi(this.source, 1, this.explicit);
  }
  map(e) {
    return e.empty ? this : (this.result.map ? this.result.map(this.result, e) : this.result) ? new Lu(this.source, this.explicit, e.mapPos(this.limit), this.result, e.mapPos(this.from), e.mapPos(this.to, 1)) : new Wi(
      this.source,
      0
      /* State.Inactive */
    );
  }
  touches(e) {
    return e.changes.touchesRange(this.from, this.to);
  }
}
function vre(n, e, t, r) {
  if (!n)
    return !1;
  let i = e.sliceDoc(t, r);
  return typeof n == "function" ? n(i, t, r, e) : gD(n, !0).test(i);
}
const W3 = /* @__PURE__ */ pt.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), bD = /* @__PURE__ */ pt.define(), Zr = /* @__PURE__ */ rr.define({
  create() {
    return h1.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    Pw.from(n, (e) => e.tooltip),
    $e.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function U3(n, e) {
  const t = e.completion.apply || e.completion.label;
  let r = n.state.field(Zr).active.find((i) => i.source == e.source);
  return r instanceof Lu ? (typeof t == "string" ? n.dispatch({
    ...sre(n.state, t, r.from, r.to),
    annotations: j3.of(e.completion)
  }) : t(n, e.completion, r.from, r.to), !0) : !1;
}
const wre = /* @__PURE__ */ fre(Zr, U3);
function sm(n, e = "option") {
  return (t) => {
    let r = t.state.field(Zr, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < t.state.facet(tr).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = YM(t, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (n ? 1 : -1) : n ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), t.dispatch({ effects: bD.of(a) }), !0;
  };
}
const kre = (n) => {
  let e = n.state.field(Zr, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(tr).interactionDelay ? !1 : U3(n, e.open.options[e.open.selected]);
}, S2 = (n) => n.state.field(Zr, !1) ? (n.dispatch({ effects: u1.of(!0) }), !0) : !1, xre = (n) => {
  let e = n.state.field(Zr, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (n.dispatch({ effects: e0.of(null) }), !0);
};
class Sre {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Cre = 50, Mre = 1e3, Tre = /* @__PURE__ */ $n.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of n.state.field(Zr).active)
      e.isPending && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Zr), t = n.state.facet(tr);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Zr) == e)
      return;
    let r = n.transactions.some((s) => {
      let o = yD(s, t);
      return o & 8 || (s.selection || s.docChanged) && !(o & 3);
    });
    for (let s = 0; s < this.running.length; s++) {
      let o = this.running[s];
      if (r || o.context.abortOnDocChange && n.docChanged || o.updates.length + n.transactions.length > Cre && Date.now() - o.time > Mre) {
        for (let a of o.context.abortListeners)
          try {
            a();
          } catch (l) {
            Qr(this.view.state, l);
          }
        o.context.abortListeners = null, this.running.splice(s--, 1);
      } else
        o.updates.push(...n.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), n.transactions.some((s) => s.effects.some((o) => o.is(u1))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : t.activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((s) => s.isPending && !this.running.some((o) => o.active.source == s.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let s of n.transactions)
        s.isUserEvent("input.type") ? this.composing = 2 : this.composing == 2 && s.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: n } = this.view, e = n.field(Zr);
    for (let t of e.active)
      t.isPending && !this.running.some((r) => r.active.source == t.source) && this.startQuery(t);
    this.running.length && e.open && e.open.disabled && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(tr).updateSyncTime));
  }
  startQuery(n) {
    let { state: e } = this.view, t = wc(e), r = new mD(e, t, n.explicit, this.view), i = new Sre(n, r);
    this.running.push(i), Promise.resolve(n.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: e0.of(null) }), Qr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(tr).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(tr), r = this.view.state.field(Zr);
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (s.done === void 0)
        continue;
      if (this.running.splice(i--, 1), s.done) {
        let a = wc(s.updates.length ? s.updates[0].startState : this.view.state), l = Math.min(a, s.done.from + (s.active.explicit ? 0 : 1)), c = new Lu(s.active.source, s.active.explicit, l, s.done, s.done.from, (n = s.done.to) !== null && n !== void 0 ? n : a);
        for (let u of s.updates)
          c = c.update(u, t);
        if (c.hasResult()) {
          e.push(c);
          continue;
        }
      }
      let o = r.active.find((a) => a.source == s.active.source);
      if (o && o.isPending)
        if (s.done == null) {
          let a = new Wi(
            s.active.source,
            0
            /* State.Inactive */
          );
          for (let l of s.updates)
            a = a.update(l, t);
          a.isPending || e.push(a);
        } else
          this.startQuery(o);
    }
    (e.length || r.open && r.open.disabled) && this.view.dispatch({ effects: W3.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Zr, !1);
      if (e && e.tooltip && this.view.state.facet(tr).closeOnBlur) {
        let t = e.open && YM(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: e0.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: u1.of(!1) }), 20), this.composing = 0;
    }
  }
}), Are = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), Ere = /* @__PURE__ */ fl.highest(/* @__PURE__ */ $e.domEventHandlers({
  keydown(n, e) {
    let t = e.state.field(Zr, !1);
    if (!t || !t.open || t.open.disabled || t.open.selected < 0 || n.key.length > 1 || n.ctrlKey && !(Are && n.altKey) || n.metaKey)
      return !1;
    let r = t.open.options[t.open.selected], i = t.active.find((o) => o.source == r.source), s = r.completion.commitCharacters || i.result.commitCharacters;
    return s && s.indexOf(n.key) > -1 && U3(e, r), !1;
  }
})), vD = /* @__PURE__ */ $e.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box",
    whiteSpace: "pre-line"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class Lre {
  constructor(e, t, r, i) {
    this.field = e, this.line = t, this.from = r, this.to = i;
  }
}
class K3 {
  constructor(e, t, r) {
    this.field = e, this.from = t, this.to = r;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, hr.TrackDel), r = e.mapPos(this.to, 1, hr.TrackDel);
    return t == null || r == null ? null : new K3(this.field, t, r);
  }
}
class G3 {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let r = [], i = [t], s = e.doc.lineAt(t), o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (r.length) {
        let c = o, u = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < u; h++)
          c += e.facet(D1);
        i.push(t + c.length - u), l = c + l.slice(u);
      }
      r.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new K3(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: r, ranges: a };
  }
  static parse(e) {
    let t = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^{}]*))?|((?:\\[{}]|[^{}])*))\}/.exec(o); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", c = -1, u = l.replace(/\\[{}]/g, (h) => h[1]);
        for (let h = 0; h < t.length; h++)
          (a != null ? t[h].seq == a : u && t[h].name == u) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < t.length && (a == null || t[h].seq != null && t[h].seq < a); )
            h++;
          t.splice(h, 0, { seq: a, name: u }), c = h;
          for (let f of i)
            f.field >= c && f.field++;
        }
        for (let h of i)
          if (h.line == r.length && h.from > s.index) {
            let f = s[2] ? 3 + (s[1] || "").length : 2;
            h.from -= f, h.to -= f;
          }
        i.push(new Lre(c, r.length, s.index, s.index + u.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);
      }
      o = o.replace(/\\([{}])/g, (a, l, c) => {
        for (let u of i)
          u.line == r.length && u.from > c && (u.from--, u.to--);
        return l;
      }), r.push(o);
    }
    return new G3(r, i);
  }
}
let Ore = /* @__PURE__ */ rt.widget({ widget: /* @__PURE__ */ new class extends da {
  toDOM() {
    let n = document.createElement("span");
    return n.className = "cm-snippetFieldPosition", n;
  }
  ignoreEvent() {
    return !1;
  }
}() }), Dre = /* @__PURE__ */ rt.mark({ class: "cm-snippetField" });
class Fh {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = rt.set(e.map((r) => (r.from == r.to ? Ore : Dre).range(r.from, r.to)), !0);
  }
  map(e) {
    let t = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new Fh(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((r) => r.field == this.active && r.from <= t.from && r.to >= t.to));
  }
}
const ap = /* @__PURE__ */ pt.define({
  map(n, e) {
    return n && n.map(e);
  }
}), Nre = /* @__PURE__ */ pt.define(), t0 = /* @__PURE__ */ rr.define({
  create() {
    return null;
  },
  update(n, e) {
    for (let t of e.effects) {
      if (t.is(ap))
        return t.value;
      if (t.is(Nre) && n)
        return new Fh(n.ranges, t.value);
    }
    return n && e.docChanged && (n = n.map(e.changes)), n && e.selection && !n.selectionInsideField(e.selection) && (n = null), n;
  },
  provide: (n) => $e.decorations.from(n, (e) => e ? e.deco : rt.none)
});
function J3(n, e) {
  return ce.create(n.filter((t) => t.field == e).map((t) => ce.range(t.from, t.to)));
}
function Ire(n) {
  let e = G3.parse(n);
  return (t, r, i, s) => {
    let { text: o, ranges: a } = e.instantiate(t.state, i), { main: l } = t.state.selection, c = {
      changes: { from: i, to: s == l.from ? l.to : s, insert: Bt.of(o) },
      scrollIntoView: !0,
      annotations: r ? [j3.of(r), Nr.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (c.selection = J3(a, 0)), a.some((u) => u.field > 0)) {
      let u = new Fh(a, 0), h = c.effects = [ap.of(u)];
      t.state.field(t0, !1) === void 0 && h.push(pt.appendConfig.of([t0, Hre, zre, vD]));
    }
    t.dispatch(t.state.update(c));
  };
}
function wD(n) {
  return ({ state: e, dispatch: t }) => {
    let r = e.field(t0, !1);
    if (!r || n < 0 && r.active == 0)
      return !1;
    let i = r.active + n, s = n > 0 && !r.ranges.some((o) => o.field == i + n);
    return t(e.update({
      selection: J3(r.ranges, i),
      effects: ap.of(s ? null : new Fh(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const _re = ({ state: n, dispatch: e }) => n.field(t0, !1) ? (e(n.update({ effects: ap.of(null) })), !0) : !1, Rre = /* @__PURE__ */ wD(1), Pre = /* @__PURE__ */ wD(-1), Bre = [
  { key: "Tab", run: Rre, shift: Pre },
  { key: "Escape", run: _re }
], RS = /* @__PURE__ */ ze.define({
  combine(n) {
    return n.length ? n[0] : Bre;
  }
}), Hre = /* @__PURE__ */ fl.highest(/* @__PURE__ */ Lh.compute([RS], (n) => n.facet(RS)));
function hue(n, e) {
  return { ...e, apply: Ire(n) };
}
const zre = /* @__PURE__ */ $e.domEventHandlers({
  mousedown(n, e) {
    let t = e.state.field(t0, !1), r;
    if (!t || (r = e.posAtCoords({ x: n.clientX, y: n.clientY })) == null)
      return !1;
    let i = t.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: J3(t.ranges, i.field),
      effects: ap.of(t.ranges.some((s) => s.field > i.field) ? new Fh(t.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), n0 = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Zl = /* @__PURE__ */ pt.define({
  map(n, e) {
    let t = e.mapPos(n, -1, hr.TrackAfter);
    return t ?? void 0;
  }
}), Y3 = /* @__PURE__ */ new class extends xc {
}();
Y3.startSide = 1;
Y3.endSide = -1;
const kD = /* @__PURE__ */ rr.define({
  create() {
    return Ht.empty;
  },
  update(n, e) {
    if (n = n.map(e.changes), e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head);
      n = n.update({ filter: (r) => r >= t.from && r <= t.to });
    }
    for (let t of e.effects)
      t.is(Zl) && (n = n.update({ add: [Y3.range(t.value, t.value + 1)] }));
    return n;
  }
});
function Fre() {
  return [qre, kD];
}
const C2 = "()[]{}<>«»»«［］｛｝";
function xD(n) {
  for (let e = 0; e < C2.length; e += 2)
    if (C2.charCodeAt(e) == n)
      return C2.charAt(e + 1);
  return xw(n < 128 ? n : n + 1);
}
function SD(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || n0;
}
const Vre = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), qre = /* @__PURE__ */ $e.inputHandler.of((n, e, t, r) => {
  if ((Vre ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let i = n.state.selection.main;
  if (r.length > 2 || r.length == 2 && Ws(Yr(r, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let s = Wre(n.state, r);
  return s ? (n.dispatch(s), !0) : !1;
}), $re = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let r = SD(n, n.selection.main.head).brackets || n0.brackets, i = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let a = Ure(n.doc, o.head);
      for (let l of r)
        if (l == a && Cy(n.doc, o.head) == xD(Yr(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: ce.cursor(o.head - l.length)
          };
    }
    return { range: i = o };
  });
  return i || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, jre = [
  { key: "Backspace", run: $re }
];
function Wre(n, e) {
  let t = SD(n, n.selection.main.head), r = t.brackets || n0.brackets;
  for (let i of r) {
    let s = xD(Yr(i, 0));
    if (e == i)
      return s == i ? Jre(n, i, r.indexOf(i + i + i) > -1, t) : Kre(n, i, s, t.before || n0.before);
    if (e == s && CD(n, n.selection.main.from))
      return Gre(n, i, s);
  }
  return null;
}
function CD(n, e) {
  let t = !1;
  return n.field(kD).between(0, n.doc.length, (r) => {
    r == e && (t = !0);
  }), t;
}
function Cy(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, Ws(Yr(t, 0)));
}
function Ure(n, e) {
  let t = n.sliceString(e - 2, e);
  return Ws(Yr(t, 0)) == t.length ? t : t.slice(1);
}
function Kre(n, e, t, r) {
  let i = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: Zl.of(o.to + e.length),
        range: ce.range(o.anchor + e.length, o.head + e.length)
      };
    let a = Cy(n.doc, o.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: Zl.of(o.head + e.length),
      range: ce.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Gre(n, e, t) {
  let r = null, i = n.changeByRange((s) => s.empty && Cy(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: ce.cursor(s.head + t.length)
  } : r = { range: s });
  return r ? null : n.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Jre(n, e, t, r) {
  let i = r.stringPrefixes || n0.stringPrefixes, s = null, o = n.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Zl.of(a.to + e.length),
        range: ce.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = Cy(n.doc, l), u;
    if (c == e) {
      if (PS(n, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Zl.of(l + e.length),
          range: ce.cursor(l + e.length)
        };
      if (CD(n, l)) {
        let f = t && n.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: ce.cursor(l + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(l - 2 * e.length, l) == e + e && (u = BS(n, l - 2 * e.length, i)) > -1 && PS(n, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Zl.of(l + e.length),
          range: ce.cursor(l + e.length)
        };
      if (n.charCategorizer(l)(c) != yn.Word && BS(n, l, i) > -1 && !Yre(n, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: Zl.of(l + e.length),
          range: ce.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function PS(n, e) {
  let t = dr(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function Yre(n, e, t, r) {
  let i = dr(n).resolveInner(e, -1), s = r.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = n.sliceDoc(i.from, Math.min(i.to, i.from + t.length + s)), l = a.indexOf(t);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > t.length + l; ) {
        if (n.sliceDoc(u.to - t.length, u.to) == t)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function BS(n, e, t) {
  let r = n.charCategorizer(e);
  if (r(n.sliceDoc(e - 1, e)) != yn.Word)
    return e;
  for (let i of t) {
    let s = e - i.length;
    if (n.sliceDoc(s, e) == i && r(n.sliceDoc(s - 1, s)) != yn.Word)
      return s;
  }
  return -1;
}
function Xre(n = {}) {
  return [
    Ere,
    Zr,
    tr.of(n),
    Tre,
    Zre,
    vD
  ];
}
const MD = [
  { key: "Ctrl-Space", run: S2 },
  { mac: "Alt-`", run: S2 },
  { mac: "Alt-i", run: S2 },
  { key: "Escape", run: xre },
  { key: "ArrowDown", run: /* @__PURE__ */ sm(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ sm(!1) },
  { key: "PageDown", run: /* @__PURE__ */ sm(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ sm(!1, "page") },
  { key: "Enter", run: kre }
], Zre = /* @__PURE__ */ fl.highest(/* @__PURE__ */ Lh.computeN([tr], (n) => n.facet(tr).defaultKeymap ? [MD] : []));
class HS {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.diagnostic = r;
  }
}
class Wl {
  constructor(e, t, r) {
    this.diagnostics = e, this.panel = t, this.selected = r;
  }
  static init(e, t, r) {
    let i = r.facet(r0).markerFilter;
    i && (e = i(e, r));
    let s = e.slice().sort((u, h) => u.from - h.from || u.to - h.to), o = new ra(), a = [], l = 0;
    for (let u = 0; ; ) {
      let h = u == s.length ? null : s[u];
      if (!h && !a.length)
        break;
      let f, m;
      for (a.length ? (f = l, m = a.reduce((b, k) => Math.min(b, k.to), h && h.from > f ? h.from : 1e8)) : (f = h.from, m = h.to, a.push(h), u++); u < s.length; ) {
        let b = s[u];
        if (b.from == f && (b.to > b.from || b.to == f))
          a.push(b), u++, m = Math.min(b.to, m);
        else {
          m = Math.min(b.from, m);
          break;
        }
      }
      let y = hie(a);
      if (a.some((b) => b.from == b.to || b.from == b.to - 1 && r.doc.lineAt(b.from).to == b.from))
        o.add(f, f, rt.widget({
          widget: new aie(y),
          diagnostics: a.slice()
        }));
      else {
        let b = a.reduce((k, x) => x.markClass ? k + " " + x.markClass : k, "");
        o.add(f, m, rt.mark({
          class: "cm-lintRange cm-lintRange-" + y + b,
          diagnostics: a.slice(),
          inclusiveEnd: a.some((k) => k.to > m)
        }));
      }
      l = m;
      for (let b = 0; b < a.length; b++)
        a[b].to <= l && a.splice(b--, 1);
    }
    let c = o.finish();
    return new Wl(c, t, wh(c));
  }
}
function wh(n, e = null, t = 0) {
  let r = null;
  return n.between(t, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostics.indexOf(e) < 0))
      if (!r)
        r = new HS(i, s, e || o.diagnostics[0]);
      else {
        if (o.diagnostics.indexOf(r.diagnostic) < 0)
          return !1;
        r = new HS(r.from, s, r.diagnostic);
      }
  }), r;
}
function Qre(n, e) {
  let t = e.pos, r = e.end || t, i = n.state.facet(r0).hideOn(n, t, r);
  if (i != null)
    return i;
  let s = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((o) => o.is(TD)) || n.changes.touchesRange(s.from, Math.max(s.to, r)));
}
function eie(n, e) {
  return n.field(Mi, !1) ? e : e.concat(pt.appendConfig.of(fie));
}
const TD = /* @__PURE__ */ pt.define(), X3 = /* @__PURE__ */ pt.define(), AD = /* @__PURE__ */ pt.define(), Mi = /* @__PURE__ */ rr.define({
  create() {
    return new Wl(rt.none, null, null);
  },
  update(n, e) {
    if (e.docChanged && n.diagnostics.size) {
      let t = n.diagnostics.map(e.changes), r = null, i = n.panel;
      if (n.selected) {
        let s = e.changes.mapPos(n.selected.from, 1);
        r = wh(t, n.selected.diagnostic, s) || wh(t, null, s);
      }
      !t.size && i && e.state.facet(r0).autoPanel && (i = null), n = new Wl(t, i, r);
    }
    for (let t of e.effects)
      if (t.is(TD)) {
        let r = e.state.facet(r0).autoPanel ? t.value.length ? i0.open : null : n.panel;
        n = Wl.init(t.value, r, e.state);
      } else t.is(X3) ? n = new Wl(n.diagnostics, t.value ? i0.open : null, n.selected) : t.is(AD) && (n = new Wl(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    Bd.from(n, (e) => e.panel),
    $e.decorations.from(n, (e) => e.diagnostics)
  ]
}), tie = /* @__PURE__ */ rt.mark({ class: "cm-lintRange cm-lintRange-active" });
function nie(n, e, t) {
  let { diagnostics: r } = n.state.field(Mi), i, s = -1, o = -1;
  r.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, c, { spec: u }) => {
    if (e >= l && e <= c && (l == c || (e > l || t > 0) && (e < c || t < 0)))
      return i = u.diagnostics, s = l, o = c, !1;
  });
  let a = n.state.facet(r0).tooltipFilter;
  return i && a && (i = a(i, n.state)), i ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: rie(n, i) };
    }
  } : null;
}
function rie(n, e) {
  return Xt("ul", { class: "cm-tooltip-lint" }, e.map((t) => LD(n, t, !1)));
}
const iie = (n) => {
  let e = n.state.field(Mi, !1);
  (!e || !e.panel) && n.dispatch({ effects: eie(n.state, [X3.of(!0)]) });
  let t = Pd(n, i0.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, zS = (n) => {
  let e = n.state.field(Mi, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: X3.of(!1) }), !0);
}, sie = (n) => {
  let e = n.state.field(Mi, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, r = e.diagnostics.iter(t.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == t.from && r.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, oie = [
  { key: "Mod-Shift-m", run: iie, preventDefault: !0 },
  { key: "F8", run: sie }
], r0 = /* @__PURE__ */ ze.define({
  combine(n) {
    return {
      sources: n.map((e) => e.source).filter((e) => e != null),
      ...lo(n.map((e) => e.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null,
        needsRefresh: null,
        hideOn: () => null
      }, {
        delay: Math.max,
        markerFilter: FS,
        tooltipFilter: FS,
        needsRefresh: (e, t) => e ? t ? (r) => e(r) || t(r) : e : t,
        hideOn: (e, t) => e ? t ? (r, i, s) => e(r, i, s) || t(r, i, s) : e : t,
        autoPanel: (e, t) => e || t
      })
    };
  }
});
function FS(n, e) {
  return n ? e ? (t, r) => e(n(t, r), r) : n : e;
}
function ED(n) {
  let e = [];
  if (n)
    e: for (let { name: t } of n) {
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
          e.push(i);
          continue e;
        }
      }
      e.push("");
    }
  return e;
}
function LD(n, e, t) {
  var r;
  let i = t ? ED(e.actions) : [];
  return Xt("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Xt("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage(n) : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let a = !1, l = (m) => {
      if (m.preventDefault(), a)
        return;
      a = !0;
      let y = wh(n.state.field(Mi).diagnostics, e);
      y && s.apply(n, y.from, y.to);
    }, { name: c } = s, u = i[o] ? c.indexOf(i[o]) : -1, h = u < 0 ? c : [
      c.slice(0, u),
      Xt("u", c.slice(u, u + 1)),
      c.slice(u + 1)
    ], f = s.markClass ? " " + s.markClass : "";
    return Xt("button", {
      type: "button",
      class: "cm-diagnosticAction" + f,
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${c}${u < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, h);
  }), e.source && Xt("div", { class: "cm-diagnosticSource" }, e.source));
}
class aie extends da {
  constructor(e) {
    super(), this.sev = e;
  }
  eq(e) {
    return e.sev == this.sev;
  }
  toDOM() {
    return Xt("span", { class: "cm-lintPoint cm-lintPoint-" + this.sev });
  }
}
class VS {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = LD(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class i0 {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        zS(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = ED(s.actions);
        for (let a = 0; a < o.length; a++)
          if (o[a].toUpperCase().charCodeAt(0) == i.keyCode) {
            let l = wh(this.view.state.field(Mi).diagnostics, s);
            l && s.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = Xt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: r
    }), this.dom = Xt("div", { class: "cm-panel-lint" }, this.list, Xt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => zS(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Mi).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Mi), r = 0, i = !1, s = null, o = /* @__PURE__ */ new Set();
    for (e.between(0, this.view.state.doc.length, (a, l, { spec: c }) => {
      for (let u of c.diagnostics) {
        if (o.has(u))
          continue;
        o.add(u);
        let h = -1, f;
        for (let m = r; m < this.items.length; m++)
          if (this.items[m].diagnostic == u) {
            h = m;
            break;
          }
        h < 0 ? (f = new VS(this.view, u), this.items.splice(r, 0, f), i = !0) : (f = this.items[h], h > r && (this.items.splice(r, h - r), i = !0)), t && f.diagnostic == t.diagnostic ? f.dom.hasAttribute("aria-selected") || (f.dom.setAttribute("aria-selected", "true"), s = f) : f.dom.hasAttribute("aria-selected") && f.dom.removeAttribute("aria-selected"), r++;
      }
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new VS(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: a, panel: l }) => {
        let c = l.height / this.list.offsetHeight;
        a.top < l.top ? this.list.scrollTop -= (l.top - a.top) / c : a.bottom > l.bottom && (this.list.scrollTop += (a.bottom - l.bottom) / c);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          t();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Mi), r = wh(t.diagnostics, this.items[e].diagnostic);
    r && this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: AD.of(r)
    });
  }
  static open(e) {
    return new i0(e);
  }
}
function lie(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function om(n) {
  return lie(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const cie = /* @__PURE__ */ $e.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ om("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ om("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ om("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ om("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function uie(n) {
  return n == "error" ? 4 : n == "warning" ? 3 : n == "info" ? 2 : 1;
}
function hie(n) {
  let e = "hint", t = 1;
  for (let r of n) {
    let i = uie(r.severity);
    i > t && (t = i, e = r.severity);
  }
  return e;
}
const fie = [
  Mi,
  /* @__PURE__ */ $e.decorations.compute([Mi], (n) => {
    let { selected: e, panel: t } = n.field(Mi);
    return !e || !t || e.from == e.to ? rt.none : rt.set([
      tie.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ zF(nie, { hideOn: Qre }),
  cie
], die = [
  YF(),
  QF(),
  gF(),
  nte(),
  RV(),
  UM(),
  uF(),
  bn.allowMultipleSelections.of(!0),
  kV(),
  mT(zV, { fallback: !0 }),
  UV(),
  Fre(),
  Xre(),
  EF(),
  DF(),
  xF(),
  _ne(),
  Lh.of([
    ...jre,
    ...tD,
    ...Qne,
    ...hte,
    ...DV,
    ...MD,
    ...oie
  ])
];
function pie(n) {
  return n.nodeType === 1;
}
function mie(n) {
  return pie(n) && n.namespaceURI === "http://www.w3.org/1999/xhtml";
}
function gie(n) {
  let e = [[-1, n.state.doc]], t = [];
  for (; e.length > 0; ) {
    const [r, i] = e.pop();
    if (r >= 0) {
      let s = n.nodeDOM(r);
      if (s && mie(s)) {
        let { top: o, bottom: a, left: l, right: c } = s.getBoundingClientRect();
        t.push([r, [
          l,
          o,
          c,
          o
        ]], [r + i.nodeSize, [
          l,
          a,
          c,
          a
        ]]);
      }
    }
    if (i.isBlock && !i.isTextblock) {
      let s = r + 1;
      for (let o of i.children)
        e.push([s, o]), s += o.nodeSize;
    }
  }
  return t;
}
function yie(n, e) {
  let t = [], r, i;
  const s = () => {
    const u = n.dom.getBoundingClientRect(), h = n.state.doc;
    return t && r && i && u.width === i.width && u.height === i.height && u.x === i.x && u.y === i.y && r.eq(h) || (i = u, r = h, t = gie(n)), t;
  }, o = (u, h) => {
    if (!n.editable || n.isDestroyed) return;
    const f = (b, k) => {
      const [x, M] = b, [T, E] = k, C = $S(u, M), O = $S(u, E);
      return C - O || x - T;
    };
    let m = s();
    m.sort(f), m = m.slice(0, 8);
    const y = m.find((b) => (e == null ? void 0 : e({
      view: n,
      pos: b[0],
      event: h
    })) !== !1);
    if (!(y && vie(n, y[0])))
      return y;
  };
  let a, l;
  return (u, h) => (a && bie(a, u) || (a = u, l = o(u, h)), l);
}
function bie(n, e) {
  return n[0] === e[0] && n[1] === e[1];
}
function qS(n, e) {
  return Math.abs(n[0] - e[0]) + Math.abs(n[1] - e[1]);
}
function $S(n, e) {
  return Math.min(qS(n, [e[0], e[1]]), qS(n, [e[2], e[3]]));
}
function vie(n, e) {
  const t = n.dragging;
  if (!t) return;
  const { move: r } = t;
  if (!r) return;
  const i = n.state.selection;
  if (!(i instanceof Qe)) return;
  const { from: s, to: o } = i;
  return s <= e && e <= o;
}
function wie(n) {
  let e;
  return new mn({
    key: new gn("prosekit-drop-indicator"),
    view: (t) => (e = yie(t, n.onDrag), xie(t, e, n)),
    props: { handleDrop(t, r, i, s) {
      if (!e) return !1;
      const o = e([r.clientX, r.clientY], r);
      if (!o) return !1;
      r.preventDefault();
      let a = o[0], l = t.state.tr;
      if (s) {
        let { node: m } = t.dragging || {};
        m ? m.replace(l) : l.deleteSelection();
      }
      let c = l.mapping.map(a), u = i.openStart == 0 && i.openEnd == 0 && i.content.childCount == 1, h = l.doc;
      if (u ? l.replaceRangeWith(c, c, i.content.firstChild) : l.replaceRange(c, c, i), l.doc.eq(h)) return !0;
      let f = l.doc.resolve(c);
      if (u && Qe.isSelectable(i.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(i.content.firstChild)) l.setSelection(new Qe(f));
      else {
        let m = l.mapping.map(a);
        l.mapping.maps[l.mapping.maps.length - 1].forEach((y, b, k, x) => m = x), l.setSelection(kie(t, f, l.doc.resolve(m)));
      }
      return t.focus(), t.dispatch(l.setMeta("uiEvent", "drop")), !0;
    } }
  });
}
function kie(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || Ye.between(e, t, r);
}
function xie(n, e, t) {
  let r = n.dom, i, s, o, a = !1;
  const l = () => {
    i && clearTimeout(i), a = !1, i = setTimeout(() => {
      var h;
      a || (h = t.onHide) == null || h.call(t);
    }, 30);
  }, c = (h) => {
    var b;
    a = !0;
    const { clientX: f, clientY: m } = h;
    if (s === f && o === m) return;
    s = f, o = m;
    let y = e([f, m], h);
    if (y) {
      const [k, [x, M, T, E]] = y, C = {
        p1: {
          x,
          y: M
        },
        p2: {
          x: T,
          y: E
        }
      };
      (b = t.onShow) == null || b.call(t, {
        view: n,
        pos: k,
        line: C
      });
    } else {
      l();
      return;
    }
  };
  return r.addEventListener("dragover", c), r.addEventListener("dragend", l), r.addEventListener("drop", l), r.addEventListener("dragleave", l), { destroy: () => {
    r.removeEventListener("dragover", c), r.removeEventListener("dragend", l), r.removeEventListener("drop", l), r.removeEventListener("dragleave", l);
  } };
}
class On extends ht {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return On.valid(r) ? new On(r) : ht.near(r);
  }
  content() {
    return He.empty;
  }
  eq(e) {
    return e instanceof On && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new On(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Z3(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !Sie(e) || !Cie(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e: for (; ; ) {
      if (!r && On.valid(e))
        return e;
      let i = e.pos, s = null;
      for (let o = e.depth; ; o--) {
        let a = e.node(o);
        if (t > 0 ? e.indexAfter(o) < a.childCount : e.index(o) > 0) {
          s = a.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1);
          break;
        } else if (o == 0)
          return null;
        i += t;
        let l = e.doc.resolve(i);
        if (On.valid(l))
          return l;
      }
      for (; ; ) {
        let o = t > 0 ? s.firstChild : s.lastChild;
        if (!o) {
          if (s.isAtom && !s.isText && !Qe.isSelectable(s)) {
            e = e.doc.resolve(i + s.nodeSize * t), r = !1;
            continue e;
          }
          break;
        }
        s = o, i += t;
        let a = e.doc.resolve(i);
        if (On.valid(a))
          return a;
      }
      return null;
    }
  }
}
On.prototype.visible = !1;
On.findFrom = On.findGapCursorFrom;
ht.jsonID("gapcursor", On);
class Z3 {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Z3(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return On.valid(t) ? new On(t) : ht.near(t);
  }
}
function Sie(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Cie(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function Mie() {
  return new mn({
    props: {
      decorations: Lie,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && On.valid(t) ? new On(t) : null;
      },
      handleClick: Aie,
      handleKeyDown: Tie,
      handleDOMEvents: { beforeinput: Eie }
    }
  });
}
const Tie = a5({
  ArrowLeft: am("horiz", -1),
  ArrowRight: am("horiz", 1),
  ArrowUp: am("vert", -1),
  ArrowDown: am("vert", 1)
});
function am(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, s) {
    let o = r.selection, a = e > 0 ? o.$to : o.$from, l = o.empty;
    if (o instanceof Ye) {
      if (!s.endOfTextblock(t) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = On.findGapCursorFrom(a, e, l);
    return c ? (i && i(r.tr.setSelection(new On(c))), !0) : !1;
  };
}
function Aie(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!On.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && Qe.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new On(r))), !0);
}
function Eie(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof On))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = pe.empty;
  for (let o = r.length - 1; o >= 0; o--)
    i = pe.from(r[o].createAndFill(null, i));
  let s = n.state.tr.replace(t.pos, t.pos, new He(i, 0, 0));
  return s.setSelection(Ye.near(s.doc.resolve(t.pos + 1))), n.dispatch(s), !1;
}
function Lie(n) {
  if (!(n.selection instanceof On))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Qt.create(n.doc, [qn.widget(n.selection.head, e, { key: "gapcursor" })]);
}
function lp(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-cursor",
      ...e
    }
  }), n;
}
const s0 = Wt(
  null,
  "dropIndicatorState"
);
lp(s0, {
  displayName: "Ctx<dropIndicatorState>"
});
const My = Wt(
  {
    width: 2,
    color: !1,
    class: "milkdown-drop-indicator"
  },
  "dropIndicatorConfig"
);
lp(My, {
  displayName: "Ctx<dropIndicatorConfig>"
});
const Oie = new gn("MILKDOWN_DROP_INDICATOR_DOM"), OD = jn(
  (n) => new mn({
    key: Oie,
    view: (e) => {
      var o;
      const t = n.get(My.key), r = document.createElement("div");
      Object.assign(r.style, {
        position: "fixed",
        pointerEvents: "none",
        display: "none",
        backgroundColor: t.color,
        top: "0",
        left: "0"
      }), r.classList.add(t.class), r.classList.add("milkdown-drop-indicator"), (o = e.dom.parentNode) == null || o.appendChild(r);
      const i = n.use(s0.key), s = (a) => {
        Die(r, a, t);
      };
      return i.on(s), {
        destroy: () => {
          i.off(s), r.remove();
        }
      };
    }
  })
);
lp(OD, {
  displayName: "Prose<dropIndicatorDOM>"
});
function Die(n, e, t) {
  if (!e) {
    Object.assign(n.style, { display: "none" });
    return;
  }
  const { line: r } = e, { width: i } = t, {
    p1: { x: s, y: o },
    p2: { x: a, y: l }
  } = r, c = o === l;
  let u, h, f = o, m = s;
  c ? (u = a - s, h = i, f -= i / 2) : (u = i, h = l - o, m -= i / 2), f = Math.round(f), m = Math.round(m), Object.assign(n.style, {
    display: "block",
    width: `${u}px`,
    height: `${h}px`,
    transform: `translate(${m}px, ${f}px)`
  });
}
const DD = jn((n) => wie({
  onShow: (i) => {
    n.set(s0.key, i);
  },
  onHide: () => {
    n.set(s0.key, null);
  },
  onDrag: () => !0
}));
lp(DD, {
  displayName: "Prose<dropIndicator>"
});
const ND = jn(() => Mie());
lp(ND, {
  displayName: "Prose<gapCursor>"
});
const Nie = [
  ND,
  My,
  s0,
  OD,
  DD
].flat();
function Iie(n) {
  var e;
  const t = (e = void 0) != null ? e : !1;
  let r = typeof document > "u" ? null : document.createElement("div");
  return new mn({
    key: _ie,
    view: (i) => {
      t !== !0 && Hie(i.state.schema, t || []);
      const s = i.dom.ownerDocument;
      r = r || document.createElement("div");
      const o = r, a = () => {
        Pie(i, o);
      };
      let l;
      return window.ResizeObserver && (l = new window.ResizeObserver(() => a()), l.observe(i.dom)), s.addEventListener("selectionchange", a), {
        update: () => {
          a();
        },
        destroy: () => {
          s.removeEventListener("selectionchange", a), l && l.unobserve(i.dom);
        }
      };
    },
    props: {
      handleKeyDown: (i, s) => {
        var o;
        const { selection: a } = i.state;
        if (s.altKey || s.ctrlKey || s.metaKey || s.shiftKey || s.isComposing || !["ArrowLeft", "ArrowRight"].includes(s.key) || !W4(a) || !a.empty)
          return !1;
        const l = a.$head, [c, u] = ID(l), h = i.state.storedMarks || l.marks();
        if (c && u && !wt.sameSet(c, u)) {
          if (s.key === "ArrowLeft" && !wt.sameSet(c, h))
            return i.dispatch(i.state.tr.setStoredMarks(c)), !0;
          if (s.key === "ArrowRight" && !wt.sameSet(u, h))
            return i.dispatch(i.state.tr.setStoredMarks(u)), !0;
        }
        return s.key === "ArrowLeft" && l.textOffset === 1 ? (i.dispatch(
          i.state.tr.setSelection(Ye.create(i.state.doc, l.pos - 1)).setStoredMarks(l.marks())
        ), !0) : s.key === "ArrowRight" && l.textOffset + 1 === ((o = l.parent.maybeChild(l.index())) == null ? void 0 : o.nodeSize) ? (i.dispatch(
          i.state.tr.setSelection(Ye.create(i.state.doc, l.pos + 1)).setStoredMarks(l.marks())
        ), !0) : !1;
      },
      decorations: (i) => {
        if (!(!r || !W4(i.selection) || !i.selection.empty))
          return Qt.create(i.doc, [
            qn.widget(0, r, {
              key: "prosemirror-virtual-cursor"
            })
          ]);
      },
      attributes: {
        class: "virtual-cursor-enabled"
      }
    }
  });
}
var _ie = new gn("prosemirror-virtual-cursor");
function Rie(n, e) {
  var t;
  const r = window.getSelection();
  if (!r || !r.rangeCount)
    return null;
  const i = (t = r == null ? void 0 : r.getRangeAt(0)) == null ? void 0 : t.cloneRange();
  if (!i)
    return null;
  i.collapse(e);
  const s = i.getClientRects(), o = s != null && s.length ? s[s.length - 1] : null;
  return o != null && o.height ? o : n.coordsAtPos(n.state.selection.head);
}
function ID(n) {
  const e = n.index(), t = n.parent.maybeChild(e);
  let r = n.textOffset ? t : null;
  return !r && e > 0 && (r = n.parent.maybeChild(e - 1)), [r == null ? void 0 : r.marks, t == null ? void 0 : t.marks];
}
function W4(n) {
  return n && typeof n == "object" && "$cursor" in n;
}
function Pie(n, e) {
  if (!n || !n.dom || n.isDestroyed || !e)
    return;
  const { state: t, dom: r } = n, { selection: i } = t;
  if (!W4(i))
    return;
  const s = Rie(n, i.$head === i.$from);
  if (!s)
    return e;
  const o = r.getBoundingClientRect();
  let a = "prosemirror-virtual-cursor";
  const l = t.selection.$head, [c, u] = ID(l), h = t.storedMarks || l.marks();
  i.$cursor && c && u && h && !wt.sameSet(c, u) && (wt.sameSet(c, h) ? a += " prosemirror-virtual-cursor-left" : wt.sameSet(u, h) && (a += " prosemirror-virtual-cursor-right")), e.className = a, Bie(e, "prosemirror-virtual-cursor-animation"), e.style.height = `${s.bottom - s.top}px`, e.style.left = `${s.left - o.left}px`, e.style.top = `${s.top - o.top}px`;
}
function Bie(n, e) {
  n.classList.remove(e), n.offsetWidth, n.classList.add(e);
}
function Hie(n, e) {
  for (const [t, r] of Object.entries(n.marks))
    r.spec.inclusive === !1 && !e.includes(t) && console.warn(
      `[prosemirror-virtual-cursor] Virtual cursor does not work well with marks that have inclusive set to false. Please consider removing the inclusive option from the "${t}" mark or adding it to the "skipWarning" option.`
    );
}
var zie = Object.defineProperty, jS = Object.getOwnPropertySymbols, Fie = Object.prototype.hasOwnProperty, Vie = Object.prototype.propertyIsEnumerable, WS = (n, e, t) => e in n ? zie(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, qie = (n, e) => {
  for (var t in e || (e = {}))
    Fie.call(e, t) && WS(n, t, e[t]);
  if (jS)
    for (var t of jS(e))
      Vie.call(e, t) && WS(n, t, e[t]);
  return n;
};
function _D(n, e) {
  return Object.assign(n, {
    meta: qie({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const $ie = {
  imageIcon: "🌌",
  uploadButton: "Upload",
  confirmButton: "⏎",
  uploadPlaceholderText: "/Paste",
  onUpload: (n) => Promise.resolve(URL.createObjectURL(n))
}, Ty = Wt(
  $ie,
  "inlineImageConfigCtx"
);
_D(Ty, {
  displayName: "Config<image-inline>",
  group: "ImageInline"
});
function ng({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
ng.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const jie = b5("abcdefg", 8), Wie = Xn({
  props: {
    src: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setLink: {
      type: Function,
      required: !0
    },
    imageIcon: {
      type: String,
      required: !1
    },
    uploadButton: {
      type: String,
      required: !1
    },
    confirmButton: {
      type: String,
      required: !1
    },
    uploadPlaceholderText: {
      type: String,
      required: !1
    },
    onUpload: {
      type: Function,
      required: !0
    }
  },
  setup({
    readonly: n,
    src: e,
    setLink: t,
    onUpload: r,
    imageIcon: i,
    uploadButton: s,
    confirmButton: o,
    uploadPlaceholderText: a,
    className: l
  }) {
    var c, u;
    const h = Be(!1), f = Be(), m = Be((c = e.value) != null ? c : ""), y = Be(jie()), b = Be(((u = e.value) == null ? void 0 : u.length) !== 0), k = (E) => {
      const O = E.target.value;
      b.value = O.length !== 0, m.value = O;
    }, x = (E) => {
      var C, O;
      E.key === "Enter" && t((O = (C = f.value) == null ? void 0 : C.value) != null ? O : "");
    }, M = () => {
      var E, C;
      t((C = (E = f.value) == null ? void 0 : E.value) != null ? C : "");
    }, T = (E) => {
      var C;
      const O = (C = E.target.files) == null ? void 0 : C[0];
      O && r(O).then((R) => {
        R && (t(R), b.value = !0);
      }).catch((R) => {
        console.error("An error occurred while uploading image"), console.error(R);
      });
    };
    return () => /* @__PURE__ */ te("div", { class: pr("image-edit", l) }, /* @__PURE__ */ te(ng, { icon: i, class: "image-icon" }), /* @__PURE__ */ te("div", { class: pr("link-importer", h.value && "focus") }, /* @__PURE__ */ te(
      "input",
      {
        ref: f,
        draggable: "true",
        onDragstart: (E) => {
          E.preventDefault(), E.stopPropagation();
        },
        disabled: n.value,
        class: "link-input-area",
        value: m.value,
        onInput: k,
        onKeydown: x,
        onFocus: () => h.value = !0,
        onBlur: () => h.value = !1
      }
    ), !b.value && /* @__PURE__ */ te("div", { class: "placeholder" }, /* @__PURE__ */ te(
      "input",
      {
        disabled: n.value,
        class: "hidden",
        id: y.value,
        type: "file",
        accept: "image/*",
        onChange: T
      }
    ), /* @__PURE__ */ te("label", { class: "uploader", for: y.value }, /* @__PURE__ */ te(ng, { icon: s })), /* @__PURE__ */ te("span", { class: "text", onClick: () => {
      var E;
      return (E = f.value) == null ? void 0 : E.focus();
    } }, a))), m.value && /* @__PURE__ */ te("div", { class: "confirm", onClick: () => M() }, /* @__PURE__ */ te(ng, { icon: o })));
  }
}), Uie = Xn({
  props: {
    src: {
      type: Object,
      required: !0
    },
    alt: {
      type: Object,
      required: !0
    },
    title: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const { src: e, alt: t, title: r } = n;
    return () => {
      var i;
      return (i = e.value) != null && i.length ? /* @__PURE__ */ te(
        "img",
        {
          class: "image-inline",
          src: e.value,
          alt: t.value,
          title: r.value
        }
      ) : /* @__PURE__ */ te(
        Wie,
        {
          src: n.src,
          selected: n.selected,
          readonly: n.readonly,
          setLink: (s) => n.setAttr("src", s),
          imageIcon: n.config.imageIcon,
          uploadButton: n.config.uploadButton,
          confirmButton: n.config.confirmButton,
          uploadPlaceholderText: n.config.uploadPlaceholderText,
          onUpload: n.config.onUpload,
          className: "empty-image-inline"
        }
      );
    };
  }
}), RD = J0(
  zc.node,
  (n) => (e, t, r) => {
    const i = Be(e.attrs.src), s = Be(e.attrs.alt), o = Be(e.attrs.title), a = Be(!1), l = Be(!t.editable), c = (k, x) => {
      if (!t.editable) return;
      const M = r();
      M != null && t.dispatch(
        t.state.tr.setNodeAttribute(
          M,
          k,
          k === "src" ? Es.sanitize(x) : x
        )
      );
    }, u = n.get(Ty.key), h = ns(Uie, {
      src: i,
      alt: s,
      title: o,
      selected: a,
      readonly: l,
      setAttr: c,
      config: u
    }), f = document.createElement("span");
    f.className = "milkdown-image-inline";
    const m = Ch(() => {
      a.value ? f.classList.add("selected") : f.classList.remove("selected");
    }), y = u.proxyDomURL, b = (k) => {
      if (!y)
        i.value = k.attrs.src;
      else {
        const x = y(k.attrs.src);
        typeof x == "string" ? i.value = x : x.then((M) => {
          i.value = M;
        }).catch(console.error);
      }
      s.value = k.attrs.alt, o.value = k.attrs.title;
    };
    return b(e), h.mount(f), {
      dom: f,
      update: (k) => k.type !== e.type ? !1 : (b(k), !0),
      stopEvent: (k) => k.target instanceof HTMLInputElement,
      selectNode: () => {
        a.value = !0;
      },
      deselectNode: () => {
        a.value = !1;
      },
      destroy: () => {
        m(), h.unmount(), f.remove();
      }
    };
  }
);
_D(RD, {
  displayName: "NodeView<image-inline>",
  group: "ImageInline"
});
const Kie = [
  Ty,
  RD
];
class Jr {
  // The + prefix indicates that these fields aren't writeable
  // Lexer holding the input string.
  // Start offset, zero-based inclusive.
  // End offset, zero-based exclusive.
  constructor(e, t, r) {
    this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = r;
  }
  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(e, t) {
    return t ? !e || !e.loc || !t.loc || e.loc.lexer !== t.loc.lexer ? null : new Jr(e.loc.lexer, e.loc.start, t.loc.end) : e && e.loc;
  }
}
class Ei {
  // don't expand the token
  // used in \noexpand
  constructor(e, t) {
    this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
  }
  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(e, t) {
    return new Ei(t, Jr.range(this, e));
  }
}
class ke {
  // Error start position based on passed-in Token or ParseNode.
  // Length of affected text based on passed-in Token or ParseNode.
  // The underlying error message without any context added.
  constructor(e, t) {
    this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
    var r = "KaTeX parse error: " + e, i, s, o = t && t.loc;
    if (o && o.start <= o.end) {
      var a = o.lexer.input;
      i = o.start, s = o.end, i === a.length ? r += " at end of input: " : r += " at position " + (i + 1) + ": ";
      var l = a.slice(i, s).replace(/[^]/g, "$&̲"), c;
      i > 15 ? c = "…" + a.slice(i - 15, i) : c = a.slice(0, i);
      var u;
      s + 15 < a.length ? u = a.slice(s, s + 15) + "…" : u = a.slice(s), r += c + l + u;
    }
    var h = new Error(r);
    return h.name = "ParseError", h.__proto__ = ke.prototype, h.position = i, i != null && s != null && (h.length = s - i), h.rawMessage = e, h;
  }
}
ke.prototype.__proto__ = Error.prototype;
var Gie = function(e, t) {
  return e.indexOf(t) !== -1;
}, Jie = function(e, t) {
  return e === void 0 ? t : e;
}, Yie = /([A-Z])/g, Xie = function(e) {
  return e.replace(Yie, "-$1").toLowerCase();
}, Zie = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
}, Qie = /[&><"']/g;
function ese(n) {
  return String(n).replace(Qie, (e) => Zie[e]);
}
var PD = function n(e) {
  return e.type === "ordgroup" || e.type === "color" ? e.body.length === 1 ? n(e.body[0]) : e : e.type === "font" ? n(e.body) : e;
}, tse = function(e) {
  var t = PD(e);
  return t.type === "mathord" || t.type === "textord" || t.type === "atom";
}, nse = function(e) {
  if (!e)
    throw new Error("Expected non-null, but got " + String(e));
  return e;
}, rse = function(e) {
  var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
  return t ? t[2] !== ":" || !/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? null : t[1].toLowerCase() : "_relative";
}, et = {
  contains: Gie,
  deflt: Jie,
  escape: ese,
  hyphenate: Xie,
  getBaseElem: PD,
  isCharacterBox: tse,
  protocolFromUrl: rse
}, rg = {
  displayMode: {
    type: "boolean",
    description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
    cli: "-d, --display-mode"
  },
  output: {
    type: {
      enum: ["htmlAndMathml", "html", "mathml"]
    },
    description: "Determines the markup language of the output.",
    cli: "-F, --format <type>"
  },
  leqno: {
    type: "boolean",
    description: "Render display math in leqno style (left-justified tags)."
  },
  fleqn: {
    type: "boolean",
    description: "Render display math flush left."
  },
  throwOnError: {
    type: "boolean",
    default: !0,
    cli: "-t, --no-throw-on-error",
    cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
  },
  errorColor: {
    type: "string",
    default: "#cc0000",
    cli: "-c, --error-color <color>",
    cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
    cliProcessor: (n) => "#" + n
  },
  macros: {
    type: "object",
    cli: "-m, --macro <def>",
    cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
    cliDefault: [],
    cliProcessor: (n, e) => (e.push(n), e)
  },
  minRuleThickness: {
    type: "number",
    description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
    processor: (n) => Math.max(0, n),
    cli: "--min-rule-thickness <size>",
    cliProcessor: parseFloat
  },
  colorIsTextColor: {
    type: "boolean",
    description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
    cli: "-b, --color-is-text-color"
  },
  strict: {
    type: [{
      enum: ["warn", "ignore", "error"]
    }, "boolean", "function"],
    description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
    cli: "-S, --strict",
    cliDefault: !1
  },
  trust: {
    type: ["boolean", "function"],
    description: "Trust the input, enabling all HTML features such as \\url.",
    cli: "-T, --trust"
  },
  maxSize: {
    type: "number",
    default: 1 / 0,
    description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
    processor: (n) => Math.max(0, n),
    cli: "-s, --max-size <n>",
    cliProcessor: parseInt
  },
  maxExpand: {
    type: "number",
    default: 1e3,
    description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
    processor: (n) => Math.max(0, n),
    cli: "-e, --max-expand <n>",
    cliProcessor: (n) => n === "Infinity" ? 1 / 0 : parseInt(n)
  },
  globalGroup: {
    type: "boolean",
    cli: !1
  }
};
function ise(n) {
  if (n.default)
    return n.default;
  var e = n.type, t = Array.isArray(e) ? e[0] : e;
  if (typeof t != "string")
    return t.enum[0];
  switch (t) {
    case "boolean":
      return !1;
    case "string":
      return "";
    case "number":
      return 0;
    case "object":
      return {};
  }
}
class Q3 {
  constructor(e) {
    this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {};
    for (var t in rg)
      if (rg.hasOwnProperty(t)) {
        var r = rg[t];
        this[t] = e[t] !== void 0 ? r.processor ? r.processor(e[t]) : e[t] : ise(r);
      }
  }
  /**
   * Report nonstrict (non-LaTeX-compatible) input.
   * Can safely not be called if `this.strict` is false in JavaScript.
   */
  reportNonstrict(e, t, r) {
    var i = this.strict;
    if (typeof i == "function" && (i = i(e, t, r)), !(!i || i === "ignore")) {
      if (i === !0 || i === "error")
        throw new ke("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [" + e + "]"), r);
      i === "warn" ? typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")) : typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]"));
    }
  }
  /**
   * Check whether to apply strict (LaTeX-adhering) behavior for unusual
   * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
   * instead, "error" translates to a return value of `true`, while "ignore"
   * translates to a return value of `false`.  May still print a warning:
   * "warn" prints a warning and returns `false`.
   * This is for the second category of `errorCode`s listed in the README.
   */
  useStrictBehavior(e, t, r) {
    var i = this.strict;
    if (typeof i == "function")
      try {
        i = i(e, t, r);
      } catch {
        i = "error";
      }
    return !i || i === "ignore" ? !1 : i === !0 || i === "error" ? !0 : i === "warn" ? (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [" + e + "]")), !1) : (typeof console < "u" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [" + e + "]")), !1);
  }
  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(e) {
    if (e.url && !e.protocol) {
      var t = et.protocolFromUrl(e.url);
      if (t == null)
        return !1;
      e.protocol = t;
    }
    var r = typeof this.trust == "function" ? this.trust(e) : this.trust;
    return !!r;
  }
}
class Ca {
  constructor(e, t, r) {
    this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = r;
  }
  /**
   * Get the style of a superscript given a base in the current style.
   */
  sup() {
    return js[sse[this.id]];
  }
  /**
   * Get the style of a subscript given a base in the current style.
   */
  sub() {
    return js[ose[this.id]];
  }
  /**
   * Get the style of a fraction numerator given the fraction in the current
   * style.
   */
  fracNum() {
    return js[ase[this.id]];
  }
  /**
   * Get the style of a fraction denominator given the fraction in the current
   * style.
   */
  fracDen() {
    return js[lse[this.id]];
  }
  /**
   * Get the cramped version of a style (in particular, cramping a cramped style
   * doesn't change the style).
   */
  cramp() {
    return js[cse[this.id]];
  }
  /**
   * Get a text or display version of this style.
   */
  text() {
    return js[use[this.id]];
  }
  /**
   * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
   */
  isTight() {
    return this.size >= 2;
  }
}
var e6 = 0, f1 = 1, Ou = 2, ta = 3, o0 = 4, Ui = 5, kh = 6, Dr = 7, js = [new Ca(e6, 0, !1), new Ca(f1, 0, !0), new Ca(Ou, 1, !1), new Ca(ta, 1, !0), new Ca(o0, 2, !1), new Ca(Ui, 2, !0), new Ca(kh, 3, !1), new Ca(Dr, 3, !0)], sse = [o0, Ui, o0, Ui, kh, Dr, kh, Dr], ose = [Ui, Ui, Ui, Ui, Dr, Dr, Dr, Dr], ase = [Ou, ta, o0, Ui, kh, Dr, kh, Dr], lse = [ta, ta, Ui, Ui, Dr, Dr, Dr, Dr], cse = [f1, f1, ta, ta, Ui, Ui, Dr, Dr], use = [e6, f1, Ou, ta, Ou, ta, Ou, ta], ot = {
  DISPLAY: js[e6],
  TEXT: js[Ou],
  SCRIPT: js[o0],
  SCRIPTSCRIPT: js[kh]
}, U4 = [{
  // Latin characters beyond the Latin-1 characters we have metrics for.
  // Needed for Czech, Hungarian and Turkish text, for example.
  name: "latin",
  blocks: [
    [256, 591],
    // Latin Extended-A and Latin Extended-B
    [768, 879]
    // Combining Diacritical marks
  ]
}, {
  // The Cyrillic script used by Russian and related languages.
  // A Cyrillic subset used to be supported as explicitly defined
  // symbols in symbols.js
  name: "cyrillic",
  blocks: [[1024, 1279]]
}, {
  // Armenian
  name: "armenian",
  blocks: [[1328, 1423]]
}, {
  // The Brahmic scripts of South and Southeast Asia
  // Devanagari (0900–097F)
  // Bengali (0980–09FF)
  // Gurmukhi (0A00–0A7F)
  // Gujarati (0A80–0AFF)
  // Oriya (0B00–0B7F)
  // Tamil (0B80–0BFF)
  // Telugu (0C00–0C7F)
  // Kannada (0C80–0CFF)
  // Malayalam (0D00–0D7F)
  // Sinhala (0D80–0DFF)
  // Thai (0E00–0E7F)
  // Lao (0E80–0EFF)
  // Tibetan (0F00–0FFF)
  // Myanmar (1000–109F)
  name: "brahmic",
  blocks: [[2304, 4255]]
}, {
  name: "georgian",
  blocks: [[4256, 4351]]
}, {
  // Chinese and Japanese.
  // The "k" in cjk is for Korean, but we've separated Korean out
  name: "cjk",
  blocks: [
    [12288, 12543],
    // CJK symbols and punctuation, Hiragana, Katakana
    [19968, 40879],
    // CJK ideograms
    [65280, 65376]
    // Fullwidth punctuation
    // TODO: add halfwidth Katakana and Romanji glyphs
  ]
}, {
  // Korean
  name: "hangul",
  blocks: [[44032, 55215]]
}];
function hse(n) {
  for (var e = 0; e < U4.length; e++)
    for (var t = U4[e], r = 0; r < t.blocks.length; r++) {
      var i = t.blocks[r];
      if (n >= i[0] && n <= i[1])
        return t.name;
    }
  return null;
}
var ig = [];
U4.forEach((n) => n.blocks.forEach((e) => ig.push(...e)));
function BD(n) {
  for (var e = 0; e < ig.length; e += 2)
    if (n >= ig[e] && n <= ig[e + 1])
      return !0;
  return !1;
}
var eu = 80, fse = function(e, t) {
  return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, dse = function(e, t) {
  return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, pse = function(e, t) {
  return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, mse = function(e, t) {
  return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, gse = function(e, t) {
  return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, yse = function(e) {
  var t = e / 2;
  return "M400000 " + e + " H0 L" + t + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, bse = function(e, t, r) {
  var i = r - 54 - t - e;
  return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + i + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, vse = function(e, t, r) {
  t = 1e3 * t;
  var i = "";
  switch (e) {
    case "sqrtMain":
      i = fse(t, eu);
      break;
    case "sqrtSize1":
      i = dse(t, eu);
      break;
    case "sqrtSize2":
      i = pse(t, eu);
      break;
    case "sqrtSize3":
      i = mse(t, eu);
      break;
    case "sqrtSize4":
      i = gse(t, eu);
      break;
    case "sqrtTall":
      i = bse(t, eu, r);
  }
  return i;
}, wse = function(e, t) {
  switch (e) {
    case "⎜":
      return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
    case "∣":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
    case "∥":
      return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V" + t + " H367z");
    case "⎟":
      return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
    case "⎢":
      return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
    case "⎥":
      return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
    case "⎪":
      return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
    case "⏐":
      return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
    case "‖":
      return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V" + t + " H478z");
    default:
      return "";
  }
}, US = {
  // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
  doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
  // doublerightarrow is from glyph U+21D2 in font KaTeX Main
  doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
  // leftarrow is from glyph U+2190 in font KaTeX Main
  leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
  // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
  leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
  leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
  // overgroup is from the MnSymbol package (public domain)
  leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
  leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
  // Harpoons are from glyph U+21BD in font KaTeX Main
  leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
  leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
  leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
  leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
  // hook is from glyph U+21A9 in font KaTeX Main
  lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
  leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
  leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
  // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
  leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
  longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
  midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
  midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
  oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
  oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
  oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
  oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
  rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
  rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
  rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
  rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
  rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
  rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
  rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
  rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
  rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
  righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
  rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
  rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
  // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
  twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
  twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
  // tilde1 is a modified version of a glyph from the MnSymbol package
  tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
  // ditto tilde2, tilde3, & tilde4
  tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
  tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
  tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
  // vec is from glyph U+20D7 in font KaTeX Main
  vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
  // widehat1 is a modified version of a glyph from the MnSymbol package
  widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
  // ditto widehat2, widehat3, & widehat4
  widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
  // widecheck paths are all inverted versions of widehat
  widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
  widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
  // The next ten paths support reaction arrows from the mhchem package.
  // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
  // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
  baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
  // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
  rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
  // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
  // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
  baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
  rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
  shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
  shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, kse = function(e, t) {
  switch (e) {
    case "lbrack":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
    case "rbrack":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
    case "vert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
    case "doublevert":
      return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
    case "lfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "rfloor":
      return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
    case "lceil":
      return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
    case "rceil":
      return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
    case "lparen":
      return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
    case "rparen":
      return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
    default:
      throw new Error("Unknown stretchy delimiter.");
  }
};
class cp {
  // HtmlDomNode
  // Never used; needed for satisfying interface.
  constructor(e) {
    this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
  }
  hasClass(e) {
    return et.contains(this.classes, e);
  }
  /** Convert the fragment into a node. */
  toNode() {
    for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++)
      e.appendChild(this.children[t].toNode());
    return e;
  }
  /** Convert the fragment into HTML markup. */
  toMarkup() {
    for (var e = "", t = 0; t < this.children.length; t++)
      e += this.children[t].toMarkup();
    return e;
  }
  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    var e = (t) => t.toText();
    return this.children.map(e).join("");
  }
}
var Xs = {
  "AMS-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68889, 0, 0, 0.72222],
    66: [0, 0.68889, 0, 0, 0.66667],
    67: [0, 0.68889, 0, 0, 0.72222],
    68: [0, 0.68889, 0, 0, 0.72222],
    69: [0, 0.68889, 0, 0, 0.66667],
    70: [0, 0.68889, 0, 0, 0.61111],
    71: [0, 0.68889, 0, 0, 0.77778],
    72: [0, 0.68889, 0, 0, 0.77778],
    73: [0, 0.68889, 0, 0, 0.38889],
    74: [0.16667, 0.68889, 0, 0, 0.5],
    75: [0, 0.68889, 0, 0, 0.77778],
    76: [0, 0.68889, 0, 0, 0.66667],
    77: [0, 0.68889, 0, 0, 0.94445],
    78: [0, 0.68889, 0, 0, 0.72222],
    79: [0.16667, 0.68889, 0, 0, 0.77778],
    80: [0, 0.68889, 0, 0, 0.61111],
    81: [0.16667, 0.68889, 0, 0, 0.77778],
    82: [0, 0.68889, 0, 0, 0.72222],
    83: [0, 0.68889, 0, 0, 0.55556],
    84: [0, 0.68889, 0, 0, 0.66667],
    85: [0, 0.68889, 0, 0, 0.72222],
    86: [0, 0.68889, 0, 0, 0.72222],
    87: [0, 0.68889, 0, 0, 1],
    88: [0, 0.68889, 0, 0, 0.72222],
    89: [0, 0.68889, 0, 0, 0.72222],
    90: [0, 0.68889, 0, 0, 0.66667],
    107: [0, 0.68889, 0, 0, 0.55556],
    160: [0, 0, 0, 0, 0.25],
    165: [0, 0.675, 0.025, 0, 0.75],
    174: [0.15559, 0.69224, 0, 0, 0.94666],
    240: [0, 0.68889, 0, 0, 0.55556],
    295: [0, 0.68889, 0, 0, 0.54028],
    710: [0, 0.825, 0, 0, 2.33334],
    732: [0, 0.9, 0, 0, 2.33334],
    770: [0, 0.825, 0, 0, 2.33334],
    771: [0, 0.9, 0, 0, 2.33334],
    989: [0.08167, 0.58167, 0, 0, 0.77778],
    1008: [0, 0.43056, 0.04028, 0, 0.66667],
    8245: [0, 0.54986, 0, 0, 0.275],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8487: [0, 0.68889, 0, 0, 0.72222],
    8498: [0, 0.68889, 0, 0, 0.55556],
    8502: [0, 0.68889, 0, 0, 0.66667],
    8503: [0, 0.68889, 0, 0, 0.44445],
    8504: [0, 0.68889, 0, 0, 0.66667],
    8513: [0, 0.68889, 0, 0, 0.63889],
    8592: [-0.03598, 0.46402, 0, 0, 0.5],
    8594: [-0.03598, 0.46402, 0, 0, 0.5],
    8602: [-0.13313, 0.36687, 0, 0, 1],
    8603: [-0.13313, 0.36687, 0, 0, 1],
    8606: [0.01354, 0.52239, 0, 0, 1],
    8608: [0.01354, 0.52239, 0, 0, 1],
    8610: [0.01354, 0.52239, 0, 0, 1.11111],
    8611: [0.01354, 0.52239, 0, 0, 1.11111],
    8619: [0, 0.54986, 0, 0, 1],
    8620: [0, 0.54986, 0, 0, 1],
    8621: [-0.13313, 0.37788, 0, 0, 1.38889],
    8622: [-0.13313, 0.36687, 0, 0, 1],
    8624: [0, 0.69224, 0, 0, 0.5],
    8625: [0, 0.69224, 0, 0, 0.5],
    8630: [0, 0.43056, 0, 0, 1],
    8631: [0, 0.43056, 0, 0, 1],
    8634: [0.08198, 0.58198, 0, 0, 0.77778],
    8635: [0.08198, 0.58198, 0, 0, 0.77778],
    8638: [0.19444, 0.69224, 0, 0, 0.41667],
    8639: [0.19444, 0.69224, 0, 0, 0.41667],
    8642: [0.19444, 0.69224, 0, 0, 0.41667],
    8643: [0.19444, 0.69224, 0, 0, 0.41667],
    8644: [0.1808, 0.675, 0, 0, 1],
    8646: [0.1808, 0.675, 0, 0, 1],
    8647: [0.1808, 0.675, 0, 0, 1],
    8648: [0.19444, 0.69224, 0, 0, 0.83334],
    8649: [0.1808, 0.675, 0, 0, 1],
    8650: [0.19444, 0.69224, 0, 0, 0.83334],
    8651: [0.01354, 0.52239, 0, 0, 1],
    8652: [0.01354, 0.52239, 0, 0, 1],
    8653: [-0.13313, 0.36687, 0, 0, 1],
    8654: [-0.13313, 0.36687, 0, 0, 1],
    8655: [-0.13313, 0.36687, 0, 0, 1],
    8666: [0.13667, 0.63667, 0, 0, 1],
    8667: [0.13667, 0.63667, 0, 0, 1],
    8669: [-0.13313, 0.37788, 0, 0, 1],
    8672: [-0.064, 0.437, 0, 0, 1.334],
    8674: [-0.064, 0.437, 0, 0, 1.334],
    8705: [0, 0.825, 0, 0, 0.5],
    8708: [0, 0.68889, 0, 0, 0.55556],
    8709: [0.08167, 0.58167, 0, 0, 0.77778],
    8717: [0, 0.43056, 0, 0, 0.42917],
    8722: [-0.03598, 0.46402, 0, 0, 0.5],
    8724: [0.08198, 0.69224, 0, 0, 0.77778],
    8726: [0.08167, 0.58167, 0, 0, 0.77778],
    8733: [0, 0.69224, 0, 0, 0.77778],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8737: [0, 0.69224, 0, 0, 0.72222],
    8738: [0.03517, 0.52239, 0, 0, 0.72222],
    8739: [0.08167, 0.58167, 0, 0, 0.22222],
    8740: [0.25142, 0.74111, 0, 0, 0.27778],
    8741: [0.08167, 0.58167, 0, 0, 0.38889],
    8742: [0.25142, 0.74111, 0, 0, 0.5],
    8756: [0, 0.69224, 0, 0, 0.66667],
    8757: [0, 0.69224, 0, 0, 0.66667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8765: [-0.13313, 0.37788, 0, 0, 0.77778],
    8769: [-0.13313, 0.36687, 0, 0, 0.77778],
    8770: [-0.03625, 0.46375, 0, 0, 0.77778],
    8774: [0.30274, 0.79383, 0, 0, 0.77778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8778: [0.08167, 0.58167, 0, 0, 0.77778],
    8782: [0.06062, 0.54986, 0, 0, 0.77778],
    8783: [0.06062, 0.54986, 0, 0, 0.77778],
    8785: [0.08198, 0.58198, 0, 0, 0.77778],
    8786: [0.08198, 0.58198, 0, 0, 0.77778],
    8787: [0.08198, 0.58198, 0, 0, 0.77778],
    8790: [0, 0.69224, 0, 0, 0.77778],
    8791: [0.22958, 0.72958, 0, 0, 0.77778],
    8796: [0.08198, 0.91667, 0, 0, 0.77778],
    8806: [0.25583, 0.75583, 0, 0, 0.77778],
    8807: [0.25583, 0.75583, 0, 0, 0.77778],
    8808: [0.25142, 0.75726, 0, 0, 0.77778],
    8809: [0.25142, 0.75726, 0, 0, 0.77778],
    8812: [0.25583, 0.75583, 0, 0, 0.5],
    8814: [0.20576, 0.70576, 0, 0, 0.77778],
    8815: [0.20576, 0.70576, 0, 0, 0.77778],
    8816: [0.30274, 0.79383, 0, 0, 0.77778],
    8817: [0.30274, 0.79383, 0, 0, 0.77778],
    8818: [0.22958, 0.72958, 0, 0, 0.77778],
    8819: [0.22958, 0.72958, 0, 0, 0.77778],
    8822: [0.1808, 0.675, 0, 0, 0.77778],
    8823: [0.1808, 0.675, 0, 0, 0.77778],
    8828: [0.13667, 0.63667, 0, 0, 0.77778],
    8829: [0.13667, 0.63667, 0, 0, 0.77778],
    8830: [0.22958, 0.72958, 0, 0, 0.77778],
    8831: [0.22958, 0.72958, 0, 0, 0.77778],
    8832: [0.20576, 0.70576, 0, 0, 0.77778],
    8833: [0.20576, 0.70576, 0, 0, 0.77778],
    8840: [0.30274, 0.79383, 0, 0, 0.77778],
    8841: [0.30274, 0.79383, 0, 0, 0.77778],
    8842: [0.13597, 0.63597, 0, 0, 0.77778],
    8843: [0.13597, 0.63597, 0, 0, 0.77778],
    8847: [0.03517, 0.54986, 0, 0, 0.77778],
    8848: [0.03517, 0.54986, 0, 0, 0.77778],
    8858: [0.08198, 0.58198, 0, 0, 0.77778],
    8859: [0.08198, 0.58198, 0, 0, 0.77778],
    8861: [0.08198, 0.58198, 0, 0, 0.77778],
    8862: [0, 0.675, 0, 0, 0.77778],
    8863: [0, 0.675, 0, 0, 0.77778],
    8864: [0, 0.675, 0, 0, 0.77778],
    8865: [0, 0.675, 0, 0, 0.77778],
    8872: [0, 0.69224, 0, 0, 0.61111],
    8873: [0, 0.69224, 0, 0, 0.72222],
    8874: [0, 0.69224, 0, 0, 0.88889],
    8876: [0, 0.68889, 0, 0, 0.61111],
    8877: [0, 0.68889, 0, 0, 0.61111],
    8878: [0, 0.68889, 0, 0, 0.72222],
    8879: [0, 0.68889, 0, 0, 0.72222],
    8882: [0.03517, 0.54986, 0, 0, 0.77778],
    8883: [0.03517, 0.54986, 0, 0, 0.77778],
    8884: [0.13667, 0.63667, 0, 0, 0.77778],
    8885: [0.13667, 0.63667, 0, 0, 0.77778],
    8888: [0, 0.54986, 0, 0, 1.11111],
    8890: [0.19444, 0.43056, 0, 0, 0.55556],
    8891: [0.19444, 0.69224, 0, 0, 0.61111],
    8892: [0.19444, 0.69224, 0, 0, 0.61111],
    8901: [0, 0.54986, 0, 0, 0.27778],
    8903: [0.08167, 0.58167, 0, 0, 0.77778],
    8905: [0.08167, 0.58167, 0, 0, 0.77778],
    8906: [0.08167, 0.58167, 0, 0, 0.77778],
    8907: [0, 0.69224, 0, 0, 0.77778],
    8908: [0, 0.69224, 0, 0, 0.77778],
    8909: [-0.03598, 0.46402, 0, 0, 0.77778],
    8910: [0, 0.54986, 0, 0, 0.76042],
    8911: [0, 0.54986, 0, 0, 0.76042],
    8912: [0.03517, 0.54986, 0, 0, 0.77778],
    8913: [0.03517, 0.54986, 0, 0, 0.77778],
    8914: [0, 0.54986, 0, 0, 0.66667],
    8915: [0, 0.54986, 0, 0, 0.66667],
    8916: [0, 0.69224, 0, 0, 0.66667],
    8918: [0.0391, 0.5391, 0, 0, 0.77778],
    8919: [0.0391, 0.5391, 0, 0, 0.77778],
    8920: [0.03517, 0.54986, 0, 0, 1.33334],
    8921: [0.03517, 0.54986, 0, 0, 1.33334],
    8922: [0.38569, 0.88569, 0, 0, 0.77778],
    8923: [0.38569, 0.88569, 0, 0, 0.77778],
    8926: [0.13667, 0.63667, 0, 0, 0.77778],
    8927: [0.13667, 0.63667, 0, 0, 0.77778],
    8928: [0.30274, 0.79383, 0, 0, 0.77778],
    8929: [0.30274, 0.79383, 0, 0, 0.77778],
    8934: [0.23222, 0.74111, 0, 0, 0.77778],
    8935: [0.23222, 0.74111, 0, 0, 0.77778],
    8936: [0.23222, 0.74111, 0, 0, 0.77778],
    8937: [0.23222, 0.74111, 0, 0, 0.77778],
    8938: [0.20576, 0.70576, 0, 0, 0.77778],
    8939: [0.20576, 0.70576, 0, 0, 0.77778],
    8940: [0.30274, 0.79383, 0, 0, 0.77778],
    8941: [0.30274, 0.79383, 0, 0, 0.77778],
    8994: [0.19444, 0.69224, 0, 0, 0.77778],
    8995: [0.19444, 0.69224, 0, 0, 0.77778],
    9416: [0.15559, 0.69224, 0, 0, 0.90222],
    9484: [0, 0.69224, 0, 0, 0.5],
    9488: [0, 0.69224, 0, 0, 0.5],
    9492: [0, 0.37788, 0, 0, 0.5],
    9496: [0, 0.37788, 0, 0, 0.5],
    9585: [0.19444, 0.68889, 0, 0, 0.88889],
    9586: [0.19444, 0.74111, 0, 0, 0.88889],
    9632: [0, 0.675, 0, 0, 0.77778],
    9633: [0, 0.675, 0, 0, 0.77778],
    9650: [0, 0.54986, 0, 0, 0.72222],
    9651: [0, 0.54986, 0, 0, 0.72222],
    9654: [0.03517, 0.54986, 0, 0, 0.77778],
    9660: [0, 0.54986, 0, 0, 0.72222],
    9661: [0, 0.54986, 0, 0, 0.72222],
    9664: [0.03517, 0.54986, 0, 0, 0.77778],
    9674: [0.11111, 0.69224, 0, 0, 0.66667],
    9733: [0.19444, 0.69224, 0, 0, 0.94445],
    10003: [0, 0.69224, 0, 0, 0.83334],
    10016: [0, 0.69224, 0, 0, 0.83334],
    10731: [0.11111, 0.69224, 0, 0, 0.66667],
    10846: [0.19444, 0.75583, 0, 0, 0.61111],
    10877: [0.13667, 0.63667, 0, 0, 0.77778],
    10878: [0.13667, 0.63667, 0, 0, 0.77778],
    10885: [0.25583, 0.75583, 0, 0, 0.77778],
    10886: [0.25583, 0.75583, 0, 0, 0.77778],
    10887: [0.13597, 0.63597, 0, 0, 0.77778],
    10888: [0.13597, 0.63597, 0, 0, 0.77778],
    10889: [0.26167, 0.75726, 0, 0, 0.77778],
    10890: [0.26167, 0.75726, 0, 0, 0.77778],
    10891: [0.48256, 0.98256, 0, 0, 0.77778],
    10892: [0.48256, 0.98256, 0, 0, 0.77778],
    10901: [0.13667, 0.63667, 0, 0, 0.77778],
    10902: [0.13667, 0.63667, 0, 0, 0.77778],
    10933: [0.25142, 0.75726, 0, 0, 0.77778],
    10934: [0.25142, 0.75726, 0, 0, 0.77778],
    10935: [0.26167, 0.75726, 0, 0, 0.77778],
    10936: [0.26167, 0.75726, 0, 0, 0.77778],
    10937: [0.26167, 0.75726, 0, 0, 0.77778],
    10938: [0.26167, 0.75726, 0, 0, 0.77778],
    10949: [0.25583, 0.75583, 0, 0, 0.77778],
    10950: [0.25583, 0.75583, 0, 0, 0.77778],
    10955: [0.28481, 0.79383, 0, 0, 0.77778],
    10956: [0.28481, 0.79383, 0, 0, 0.77778],
    57350: [0.08167, 0.58167, 0, 0, 0.22222],
    57351: [0.08167, 0.58167, 0, 0, 0.38889],
    57352: [0.08167, 0.58167, 0, 0, 0.77778],
    57353: [0, 0.43056, 0.04028, 0, 0.66667],
    57356: [0.25142, 0.75726, 0, 0, 0.77778],
    57357: [0.25142, 0.75726, 0, 0, 0.77778],
    57358: [0.41951, 0.91951, 0, 0, 0.77778],
    57359: [0.30274, 0.79383, 0, 0, 0.77778],
    57360: [0.30274, 0.79383, 0, 0, 0.77778],
    57361: [0.41951, 0.91951, 0, 0, 0.77778],
    57366: [0.25142, 0.75726, 0, 0, 0.77778],
    57367: [0.25142, 0.75726, 0, 0, 0.77778],
    57368: [0.25142, 0.75726, 0, 0, 0.77778],
    57369: [0.25142, 0.75726, 0, 0, 0.77778],
    57370: [0.13597, 0.63597, 0, 0, 0.77778],
    57371: [0.13597, 0.63597, 0, 0, 0.77778]
  },
  "Caligraphic-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.68333, 0, 0.19445, 0.79847],
    66: [0, 0.68333, 0.03041, 0.13889, 0.65681],
    67: [0, 0.68333, 0.05834, 0.13889, 0.52653],
    68: [0, 0.68333, 0.02778, 0.08334, 0.77139],
    69: [0, 0.68333, 0.08944, 0.11111, 0.52778],
    70: [0, 0.68333, 0.09931, 0.11111, 0.71875],
    71: [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
    72: [0, 0.68333, 965e-5, 0.11111, 0.84452],
    73: [0, 0.68333, 0.07382, 0, 0.54452],
    74: [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
    75: [0, 0.68333, 0.01445, 0.05556, 0.76195],
    76: [0, 0.68333, 0, 0.13889, 0.68972],
    77: [0, 0.68333, 0, 0.13889, 1.2009],
    78: [0, 0.68333, 0.14736, 0.08334, 0.82049],
    79: [0, 0.68333, 0.02778, 0.11111, 0.79611],
    80: [0, 0.68333, 0.08222, 0.08334, 0.69556],
    81: [0.09722, 0.68333, 0, 0.11111, 0.81667],
    82: [0, 0.68333, 0, 0.08334, 0.8475],
    83: [0, 0.68333, 0.075, 0.13889, 0.60556],
    84: [0, 0.68333, 0.25417, 0, 0.54464],
    85: [0, 0.68333, 0.09931, 0.08334, 0.62583],
    86: [0, 0.68333, 0.08222, 0, 0.61278],
    87: [0, 0.68333, 0.08222, 0.08334, 0.98778],
    88: [0, 0.68333, 0.14643, 0.13889, 0.7133],
    89: [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
    90: [0, 0.68333, 0.07944, 0.13889, 0.72473],
    160: [0, 0, 0, 0, 0.25]
  },
  "Fraktur-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69141, 0, 0, 0.29574],
    34: [0, 0.69141, 0, 0, 0.21471],
    38: [0, 0.69141, 0, 0, 0.73786],
    39: [0, 0.69141, 0, 0, 0.21201],
    40: [0.24982, 0.74947, 0, 0, 0.38865],
    41: [0.24982, 0.74947, 0, 0, 0.38865],
    42: [0, 0.62119, 0, 0, 0.27764],
    43: [0.08319, 0.58283, 0, 0, 0.75623],
    44: [0, 0.10803, 0, 0, 0.27764],
    45: [0.08319, 0.58283, 0, 0, 0.75623],
    46: [0, 0.10803, 0, 0, 0.27764],
    47: [0.24982, 0.74947, 0, 0, 0.50181],
    48: [0, 0.47534, 0, 0, 0.50181],
    49: [0, 0.47534, 0, 0, 0.50181],
    50: [0, 0.47534, 0, 0, 0.50181],
    51: [0.18906, 0.47534, 0, 0, 0.50181],
    52: [0.18906, 0.47534, 0, 0, 0.50181],
    53: [0.18906, 0.47534, 0, 0, 0.50181],
    54: [0, 0.69141, 0, 0, 0.50181],
    55: [0.18906, 0.47534, 0, 0, 0.50181],
    56: [0, 0.69141, 0, 0, 0.50181],
    57: [0.18906, 0.47534, 0, 0, 0.50181],
    58: [0, 0.47534, 0, 0, 0.21606],
    59: [0.12604, 0.47534, 0, 0, 0.21606],
    61: [-0.13099, 0.36866, 0, 0, 0.75623],
    63: [0, 0.69141, 0, 0, 0.36245],
    65: [0, 0.69141, 0, 0, 0.7176],
    66: [0, 0.69141, 0, 0, 0.88397],
    67: [0, 0.69141, 0, 0, 0.61254],
    68: [0, 0.69141, 0, 0, 0.83158],
    69: [0, 0.69141, 0, 0, 0.66278],
    70: [0.12604, 0.69141, 0, 0, 0.61119],
    71: [0, 0.69141, 0, 0, 0.78539],
    72: [0.06302, 0.69141, 0, 0, 0.7203],
    73: [0, 0.69141, 0, 0, 0.55448],
    74: [0.12604, 0.69141, 0, 0, 0.55231],
    75: [0, 0.69141, 0, 0, 0.66845],
    76: [0, 0.69141, 0, 0, 0.66602],
    77: [0, 0.69141, 0, 0, 1.04953],
    78: [0, 0.69141, 0, 0, 0.83212],
    79: [0, 0.69141, 0, 0, 0.82699],
    80: [0.18906, 0.69141, 0, 0, 0.82753],
    81: [0.03781, 0.69141, 0, 0, 0.82699],
    82: [0, 0.69141, 0, 0, 0.82807],
    83: [0, 0.69141, 0, 0, 0.82861],
    84: [0, 0.69141, 0, 0, 0.66899],
    85: [0, 0.69141, 0, 0, 0.64576],
    86: [0, 0.69141, 0, 0, 0.83131],
    87: [0, 0.69141, 0, 0, 1.04602],
    88: [0, 0.69141, 0, 0, 0.71922],
    89: [0.18906, 0.69141, 0, 0, 0.83293],
    90: [0.12604, 0.69141, 0, 0, 0.60201],
    91: [0.24982, 0.74947, 0, 0, 0.27764],
    93: [0.24982, 0.74947, 0, 0, 0.27764],
    94: [0, 0.69141, 0, 0, 0.49965],
    97: [0, 0.47534, 0, 0, 0.50046],
    98: [0, 0.69141, 0, 0, 0.51315],
    99: [0, 0.47534, 0, 0, 0.38946],
    100: [0, 0.62119, 0, 0, 0.49857],
    101: [0, 0.47534, 0, 0, 0.40053],
    102: [0.18906, 0.69141, 0, 0, 0.32626],
    103: [0.18906, 0.47534, 0, 0, 0.5037],
    104: [0.18906, 0.69141, 0, 0, 0.52126],
    105: [0, 0.69141, 0, 0, 0.27899],
    106: [0, 0.69141, 0, 0, 0.28088],
    107: [0, 0.69141, 0, 0, 0.38946],
    108: [0, 0.69141, 0, 0, 0.27953],
    109: [0, 0.47534, 0, 0, 0.76676],
    110: [0, 0.47534, 0, 0, 0.52666],
    111: [0, 0.47534, 0, 0, 0.48885],
    112: [0.18906, 0.52396, 0, 0, 0.50046],
    113: [0.18906, 0.47534, 0, 0, 0.48912],
    114: [0, 0.47534, 0, 0, 0.38919],
    115: [0, 0.47534, 0, 0, 0.44266],
    116: [0, 0.62119, 0, 0, 0.33301],
    117: [0, 0.47534, 0, 0, 0.5172],
    118: [0, 0.52396, 0, 0, 0.5118],
    119: [0, 0.52396, 0, 0, 0.77351],
    120: [0.18906, 0.47534, 0, 0, 0.38865],
    121: [0.18906, 0.47534, 0, 0, 0.49884],
    122: [0.18906, 0.47534, 0, 0, 0.39054],
    160: [0, 0, 0, 0, 0.25],
    8216: [0, 0.69141, 0, 0, 0.21471],
    8217: [0, 0.69141, 0, 0, 0.21471],
    58112: [0, 0.62119, 0, 0, 0.49749],
    58113: [0, 0.62119, 0, 0, 0.4983],
    58114: [0.18906, 0.69141, 0, 0, 0.33328],
    58115: [0.18906, 0.69141, 0, 0, 0.32923],
    58116: [0.18906, 0.47534, 0, 0, 0.50343],
    58117: [0, 0.69141, 0, 0, 0.33301],
    58118: [0, 0.62119, 0, 0, 0.33409],
    58119: [0, 0.47534, 0, 0, 0.50073]
  },
  "Main-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.35],
    34: [0, 0.69444, 0, 0, 0.60278],
    35: [0.19444, 0.69444, 0, 0, 0.95833],
    36: [0.05556, 0.75, 0, 0, 0.575],
    37: [0.05556, 0.75, 0, 0, 0.95833],
    38: [0, 0.69444, 0, 0, 0.89444],
    39: [0, 0.69444, 0, 0, 0.31944],
    40: [0.25, 0.75, 0, 0, 0.44722],
    41: [0.25, 0.75, 0, 0, 0.44722],
    42: [0, 0.75, 0, 0, 0.575],
    43: [0.13333, 0.63333, 0, 0, 0.89444],
    44: [0.19444, 0.15556, 0, 0, 0.31944],
    45: [0, 0.44444, 0, 0, 0.38333],
    46: [0, 0.15556, 0, 0, 0.31944],
    47: [0.25, 0.75, 0, 0, 0.575],
    48: [0, 0.64444, 0, 0, 0.575],
    49: [0, 0.64444, 0, 0, 0.575],
    50: [0, 0.64444, 0, 0, 0.575],
    51: [0, 0.64444, 0, 0, 0.575],
    52: [0, 0.64444, 0, 0, 0.575],
    53: [0, 0.64444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0, 0.64444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0, 0.64444, 0, 0, 0.575],
    58: [0, 0.44444, 0, 0, 0.31944],
    59: [0.19444, 0.44444, 0, 0, 0.31944],
    60: [0.08556, 0.58556, 0, 0, 0.89444],
    61: [-0.10889, 0.39111, 0, 0, 0.89444],
    62: [0.08556, 0.58556, 0, 0, 0.89444],
    63: [0, 0.69444, 0, 0, 0.54305],
    64: [0, 0.69444, 0, 0, 0.89444],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0, 0, 0.81805],
    67: [0, 0.68611, 0, 0, 0.83055],
    68: [0, 0.68611, 0, 0, 0.88194],
    69: [0, 0.68611, 0, 0, 0.75555],
    70: [0, 0.68611, 0, 0, 0.72361],
    71: [0, 0.68611, 0, 0, 0.90416],
    72: [0, 0.68611, 0, 0, 0.9],
    73: [0, 0.68611, 0, 0, 0.43611],
    74: [0, 0.68611, 0, 0, 0.59444],
    75: [0, 0.68611, 0, 0, 0.90138],
    76: [0, 0.68611, 0, 0, 0.69166],
    77: [0, 0.68611, 0, 0, 1.09166],
    78: [0, 0.68611, 0, 0, 0.9],
    79: [0, 0.68611, 0, 0, 0.86388],
    80: [0, 0.68611, 0, 0, 0.78611],
    81: [0.19444, 0.68611, 0, 0, 0.86388],
    82: [0, 0.68611, 0, 0, 0.8625],
    83: [0, 0.68611, 0, 0, 0.63889],
    84: [0, 0.68611, 0, 0, 0.8],
    85: [0, 0.68611, 0, 0, 0.88472],
    86: [0, 0.68611, 0.01597, 0, 0.86944],
    87: [0, 0.68611, 0.01597, 0, 1.18888],
    88: [0, 0.68611, 0, 0, 0.86944],
    89: [0, 0.68611, 0.02875, 0, 0.86944],
    90: [0, 0.68611, 0, 0, 0.70277],
    91: [0.25, 0.75, 0, 0, 0.31944],
    92: [0.25, 0.75, 0, 0, 0.575],
    93: [0.25, 0.75, 0, 0, 0.31944],
    94: [0, 0.69444, 0, 0, 0.575],
    95: [0.31, 0.13444, 0.03194, 0, 0.575],
    97: [0, 0.44444, 0, 0, 0.55902],
    98: [0, 0.69444, 0, 0, 0.63889],
    99: [0, 0.44444, 0, 0, 0.51111],
    100: [0, 0.69444, 0, 0, 0.63889],
    101: [0, 0.44444, 0, 0, 0.52708],
    102: [0, 0.69444, 0.10903, 0, 0.35139],
    103: [0.19444, 0.44444, 0.01597, 0, 0.575],
    104: [0, 0.69444, 0, 0, 0.63889],
    105: [0, 0.69444, 0, 0, 0.31944],
    106: [0.19444, 0.69444, 0, 0, 0.35139],
    107: [0, 0.69444, 0, 0, 0.60694],
    108: [0, 0.69444, 0, 0, 0.31944],
    109: [0, 0.44444, 0, 0, 0.95833],
    110: [0, 0.44444, 0, 0, 0.63889],
    111: [0, 0.44444, 0, 0, 0.575],
    112: [0.19444, 0.44444, 0, 0, 0.63889],
    113: [0.19444, 0.44444, 0, 0, 0.60694],
    114: [0, 0.44444, 0, 0, 0.47361],
    115: [0, 0.44444, 0, 0, 0.45361],
    116: [0, 0.63492, 0, 0, 0.44722],
    117: [0, 0.44444, 0, 0, 0.63889],
    118: [0, 0.44444, 0.01597, 0, 0.60694],
    119: [0, 0.44444, 0.01597, 0, 0.83055],
    120: [0, 0.44444, 0, 0, 0.60694],
    121: [0.19444, 0.44444, 0.01597, 0, 0.60694],
    122: [0, 0.44444, 0, 0, 0.51111],
    123: [0.25, 0.75, 0, 0, 0.575],
    124: [0.25, 0.75, 0, 0, 0.31944],
    125: [0.25, 0.75, 0, 0, 0.575],
    126: [0.35, 0.34444, 0, 0, 0.575],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.86853],
    168: [0, 0.69444, 0, 0, 0.575],
    172: [0, 0.44444, 0, 0, 0.76666],
    176: [0, 0.69444, 0, 0, 0.86944],
    177: [0.13333, 0.63333, 0, 0, 0.89444],
    184: [0.17014, 0, 0, 0, 0.51111],
    198: [0, 0.68611, 0, 0, 1.04166],
    215: [0.13333, 0.63333, 0, 0, 0.89444],
    216: [0.04861, 0.73472, 0, 0, 0.89444],
    223: [0, 0.69444, 0, 0, 0.59722],
    230: [0, 0.44444, 0, 0, 0.83055],
    247: [0.13333, 0.63333, 0, 0, 0.89444],
    248: [0.09722, 0.54167, 0, 0, 0.575],
    305: [0, 0.44444, 0, 0, 0.31944],
    338: [0, 0.68611, 0, 0, 1.16944],
    339: [0, 0.44444, 0, 0, 0.89444],
    567: [0.19444, 0.44444, 0, 0, 0.35139],
    710: [0, 0.69444, 0, 0, 0.575],
    711: [0, 0.63194, 0, 0, 0.575],
    713: [0, 0.59611, 0, 0, 0.575],
    714: [0, 0.69444, 0, 0, 0.575],
    715: [0, 0.69444, 0, 0, 0.575],
    728: [0, 0.69444, 0, 0, 0.575],
    729: [0, 0.69444, 0, 0, 0.31944],
    730: [0, 0.69444, 0, 0, 0.86944],
    732: [0, 0.69444, 0, 0, 0.575],
    733: [0, 0.69444, 0, 0, 0.575],
    915: [0, 0.68611, 0, 0, 0.69166],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0, 0, 0.89444],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0, 0, 0.76666],
    928: [0, 0.68611, 0, 0, 0.9],
    931: [0, 0.68611, 0, 0, 0.83055],
    933: [0, 0.68611, 0, 0, 0.89444],
    934: [0, 0.68611, 0, 0, 0.83055],
    936: [0, 0.68611, 0, 0, 0.89444],
    937: [0, 0.68611, 0, 0, 0.83055],
    8211: [0, 0.44444, 0.03194, 0, 0.575],
    8212: [0, 0.44444, 0.03194, 0, 1.14999],
    8216: [0, 0.69444, 0, 0, 0.31944],
    8217: [0, 0.69444, 0, 0, 0.31944],
    8220: [0, 0.69444, 0, 0, 0.60278],
    8221: [0, 0.69444, 0, 0, 0.60278],
    8224: [0.19444, 0.69444, 0, 0, 0.51111],
    8225: [0.19444, 0.69444, 0, 0, 0.51111],
    8242: [0, 0.55556, 0, 0, 0.34444],
    8407: [0, 0.72444, 0.15486, 0, 0.575],
    8463: [0, 0.69444, 0, 0, 0.66759],
    8465: [0, 0.69444, 0, 0, 0.83055],
    8467: [0, 0.69444, 0, 0, 0.47361],
    8472: [0.19444, 0.44444, 0, 0, 0.74027],
    8476: [0, 0.69444, 0, 0, 0.83055],
    8501: [0, 0.69444, 0, 0, 0.70277],
    8592: [-0.10889, 0.39111, 0, 0, 1.14999],
    8593: [0.19444, 0.69444, 0, 0, 0.575],
    8594: [-0.10889, 0.39111, 0, 0, 1.14999],
    8595: [0.19444, 0.69444, 0, 0, 0.575],
    8596: [-0.10889, 0.39111, 0, 0, 1.14999],
    8597: [0.25, 0.75, 0, 0, 0.575],
    8598: [0.19444, 0.69444, 0, 0, 1.14999],
    8599: [0.19444, 0.69444, 0, 0, 1.14999],
    8600: [0.19444, 0.69444, 0, 0, 1.14999],
    8601: [0.19444, 0.69444, 0, 0, 1.14999],
    8636: [-0.10889, 0.39111, 0, 0, 1.14999],
    8637: [-0.10889, 0.39111, 0, 0, 1.14999],
    8640: [-0.10889, 0.39111, 0, 0, 1.14999],
    8641: [-0.10889, 0.39111, 0, 0, 1.14999],
    8656: [-0.10889, 0.39111, 0, 0, 1.14999],
    8657: [0.19444, 0.69444, 0, 0, 0.70277],
    8658: [-0.10889, 0.39111, 0, 0, 1.14999],
    8659: [0.19444, 0.69444, 0, 0, 0.70277],
    8660: [-0.10889, 0.39111, 0, 0, 1.14999],
    8661: [0.25, 0.75, 0, 0, 0.70277],
    8704: [0, 0.69444, 0, 0, 0.63889],
    8706: [0, 0.69444, 0.06389, 0, 0.62847],
    8707: [0, 0.69444, 0, 0, 0.63889],
    8709: [0.05556, 0.75, 0, 0, 0.575],
    8711: [0, 0.68611, 0, 0, 0.95833],
    8712: [0.08556, 0.58556, 0, 0, 0.76666],
    8715: [0.08556, 0.58556, 0, 0, 0.76666],
    8722: [0.13333, 0.63333, 0, 0, 0.89444],
    8723: [0.13333, 0.63333, 0, 0, 0.89444],
    8725: [0.25, 0.75, 0, 0, 0.575],
    8726: [0.25, 0.75, 0, 0, 0.575],
    8727: [-0.02778, 0.47222, 0, 0, 0.575],
    8728: [-0.02639, 0.47361, 0, 0, 0.575],
    8729: [-0.02639, 0.47361, 0, 0, 0.575],
    8730: [0.18, 0.82, 0, 0, 0.95833],
    8733: [0, 0.44444, 0, 0, 0.89444],
    8734: [0, 0.44444, 0, 0, 1.14999],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.31944],
    8741: [0.25, 0.75, 0, 0, 0.575],
    8743: [0, 0.55556, 0, 0, 0.76666],
    8744: [0, 0.55556, 0, 0, 0.76666],
    8745: [0, 0.55556, 0, 0, 0.76666],
    8746: [0, 0.55556, 0, 0, 0.76666],
    8747: [0.19444, 0.69444, 0.12778, 0, 0.56875],
    8764: [-0.10889, 0.39111, 0, 0, 0.89444],
    8768: [0.19444, 0.69444, 0, 0, 0.31944],
    8771: [222e-5, 0.50222, 0, 0, 0.89444],
    8773: [0.027, 0.638, 0, 0, 0.894],
    8776: [0.02444, 0.52444, 0, 0, 0.89444],
    8781: [222e-5, 0.50222, 0, 0, 0.89444],
    8801: [222e-5, 0.50222, 0, 0, 0.89444],
    8804: [0.19667, 0.69667, 0, 0, 0.89444],
    8805: [0.19667, 0.69667, 0, 0, 0.89444],
    8810: [0.08556, 0.58556, 0, 0, 1.14999],
    8811: [0.08556, 0.58556, 0, 0, 1.14999],
    8826: [0.08556, 0.58556, 0, 0, 0.89444],
    8827: [0.08556, 0.58556, 0, 0, 0.89444],
    8834: [0.08556, 0.58556, 0, 0, 0.89444],
    8835: [0.08556, 0.58556, 0, 0, 0.89444],
    8838: [0.19667, 0.69667, 0, 0, 0.89444],
    8839: [0.19667, 0.69667, 0, 0, 0.89444],
    8846: [0, 0.55556, 0, 0, 0.76666],
    8849: [0.19667, 0.69667, 0, 0, 0.89444],
    8850: [0.19667, 0.69667, 0, 0, 0.89444],
    8851: [0, 0.55556, 0, 0, 0.76666],
    8852: [0, 0.55556, 0, 0, 0.76666],
    8853: [0.13333, 0.63333, 0, 0, 0.89444],
    8854: [0.13333, 0.63333, 0, 0, 0.89444],
    8855: [0.13333, 0.63333, 0, 0, 0.89444],
    8856: [0.13333, 0.63333, 0, 0, 0.89444],
    8857: [0.13333, 0.63333, 0, 0, 0.89444],
    8866: [0, 0.69444, 0, 0, 0.70277],
    8867: [0, 0.69444, 0, 0, 0.70277],
    8868: [0, 0.69444, 0, 0, 0.89444],
    8869: [0, 0.69444, 0, 0, 0.89444],
    8900: [-0.02639, 0.47361, 0, 0, 0.575],
    8901: [-0.02639, 0.47361, 0, 0, 0.31944],
    8902: [-0.02778, 0.47222, 0, 0, 0.575],
    8968: [0.25, 0.75, 0, 0, 0.51111],
    8969: [0.25, 0.75, 0, 0, 0.51111],
    8970: [0.25, 0.75, 0, 0, 0.51111],
    8971: [0.25, 0.75, 0, 0, 0.51111],
    8994: [-0.13889, 0.36111, 0, 0, 1.14999],
    8995: [-0.13889, 0.36111, 0, 0, 1.14999],
    9651: [0.19444, 0.69444, 0, 0, 1.02222],
    9657: [-0.02778, 0.47222, 0, 0, 0.575],
    9661: [0.19444, 0.69444, 0, 0, 1.02222],
    9667: [-0.02778, 0.47222, 0, 0, 0.575],
    9711: [0.19444, 0.69444, 0, 0, 1.14999],
    9824: [0.12963, 0.69444, 0, 0, 0.89444],
    9825: [0.12963, 0.69444, 0, 0, 0.89444],
    9826: [0.12963, 0.69444, 0, 0, 0.89444],
    9827: [0.12963, 0.69444, 0, 0, 0.89444],
    9837: [0, 0.75, 0, 0, 0.44722],
    9838: [0.19444, 0.69444, 0, 0, 0.44722],
    9839: [0.19444, 0.69444, 0, 0, 0.44722],
    10216: [0.25, 0.75, 0, 0, 0.44722],
    10217: [0.25, 0.75, 0, 0, 0.44722],
    10815: [0, 0.68611, 0, 0, 0.9],
    10927: [0.19667, 0.69667, 0, 0, 0.89444],
    10928: [0.19667, 0.69667, 0, 0, 0.89444],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Main-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.11417, 0, 0.38611],
    34: [0, 0.69444, 0.07939, 0, 0.62055],
    35: [0.19444, 0.69444, 0.06833, 0, 0.94444],
    37: [0.05556, 0.75, 0.12861, 0, 0.94444],
    38: [0, 0.69444, 0.08528, 0, 0.88555],
    39: [0, 0.69444, 0.12945, 0, 0.35555],
    40: [0.25, 0.75, 0.15806, 0, 0.47333],
    41: [0.25, 0.75, 0.03306, 0, 0.47333],
    42: [0, 0.75, 0.14333, 0, 0.59111],
    43: [0.10333, 0.60333, 0.03306, 0, 0.88555],
    44: [0.19444, 0.14722, 0, 0, 0.35555],
    45: [0, 0.44444, 0.02611, 0, 0.41444],
    46: [0, 0.14722, 0, 0, 0.35555],
    47: [0.25, 0.75, 0.15806, 0, 0.59111],
    48: [0, 0.64444, 0.13167, 0, 0.59111],
    49: [0, 0.64444, 0.13167, 0, 0.59111],
    50: [0, 0.64444, 0.13167, 0, 0.59111],
    51: [0, 0.64444, 0.13167, 0, 0.59111],
    52: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    53: [0, 0.64444, 0.13167, 0, 0.59111],
    54: [0, 0.64444, 0.13167, 0, 0.59111],
    55: [0.19444, 0.64444, 0.13167, 0, 0.59111],
    56: [0, 0.64444, 0.13167, 0, 0.59111],
    57: [0, 0.64444, 0.13167, 0, 0.59111],
    58: [0, 0.44444, 0.06695, 0, 0.35555],
    59: [0.19444, 0.44444, 0.06695, 0, 0.35555],
    61: [-0.10889, 0.39111, 0.06833, 0, 0.88555],
    63: [0, 0.69444, 0.11472, 0, 0.59111],
    64: [0, 0.69444, 0.09208, 0, 0.88555],
    65: [0, 0.68611, 0, 0, 0.86555],
    66: [0, 0.68611, 0.0992, 0, 0.81666],
    67: [0, 0.68611, 0.14208, 0, 0.82666],
    68: [0, 0.68611, 0.09062, 0, 0.87555],
    69: [0, 0.68611, 0.11431, 0, 0.75666],
    70: [0, 0.68611, 0.12903, 0, 0.72722],
    71: [0, 0.68611, 0.07347, 0, 0.89527],
    72: [0, 0.68611, 0.17208, 0, 0.8961],
    73: [0, 0.68611, 0.15681, 0, 0.47166],
    74: [0, 0.68611, 0.145, 0, 0.61055],
    75: [0, 0.68611, 0.14208, 0, 0.89499],
    76: [0, 0.68611, 0, 0, 0.69777],
    77: [0, 0.68611, 0.17208, 0, 1.07277],
    78: [0, 0.68611, 0.17208, 0, 0.8961],
    79: [0, 0.68611, 0.09062, 0, 0.85499],
    80: [0, 0.68611, 0.0992, 0, 0.78721],
    81: [0.19444, 0.68611, 0.09062, 0, 0.85499],
    82: [0, 0.68611, 0.02559, 0, 0.85944],
    83: [0, 0.68611, 0.11264, 0, 0.64999],
    84: [0, 0.68611, 0.12903, 0, 0.7961],
    85: [0, 0.68611, 0.17208, 0, 0.88083],
    86: [0, 0.68611, 0.18625, 0, 0.86555],
    87: [0, 0.68611, 0.18625, 0, 1.15999],
    88: [0, 0.68611, 0.15681, 0, 0.86555],
    89: [0, 0.68611, 0.19803, 0, 0.86555],
    90: [0, 0.68611, 0.14208, 0, 0.70888],
    91: [0.25, 0.75, 0.1875, 0, 0.35611],
    93: [0.25, 0.75, 0.09972, 0, 0.35611],
    94: [0, 0.69444, 0.06709, 0, 0.59111],
    95: [0.31, 0.13444, 0.09811, 0, 0.59111],
    97: [0, 0.44444, 0.09426, 0, 0.59111],
    98: [0, 0.69444, 0.07861, 0, 0.53222],
    99: [0, 0.44444, 0.05222, 0, 0.53222],
    100: [0, 0.69444, 0.10861, 0, 0.59111],
    101: [0, 0.44444, 0.085, 0, 0.53222],
    102: [0.19444, 0.69444, 0.21778, 0, 0.4],
    103: [0.19444, 0.44444, 0.105, 0, 0.53222],
    104: [0, 0.69444, 0.09426, 0, 0.59111],
    105: [0, 0.69326, 0.11387, 0, 0.35555],
    106: [0.19444, 0.69326, 0.1672, 0, 0.35555],
    107: [0, 0.69444, 0.11111, 0, 0.53222],
    108: [0, 0.69444, 0.10861, 0, 0.29666],
    109: [0, 0.44444, 0.09426, 0, 0.94444],
    110: [0, 0.44444, 0.09426, 0, 0.64999],
    111: [0, 0.44444, 0.07861, 0, 0.59111],
    112: [0.19444, 0.44444, 0.07861, 0, 0.59111],
    113: [0.19444, 0.44444, 0.105, 0, 0.53222],
    114: [0, 0.44444, 0.11111, 0, 0.50167],
    115: [0, 0.44444, 0.08167, 0, 0.48694],
    116: [0, 0.63492, 0.09639, 0, 0.385],
    117: [0, 0.44444, 0.09426, 0, 0.62055],
    118: [0, 0.44444, 0.11111, 0, 0.53222],
    119: [0, 0.44444, 0.11111, 0, 0.76777],
    120: [0, 0.44444, 0.12583, 0, 0.56055],
    121: [0.19444, 0.44444, 0.105, 0, 0.56166],
    122: [0, 0.44444, 0.13889, 0, 0.49055],
    126: [0.35, 0.34444, 0.11472, 0, 0.59111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0.11473, 0, 0.59111],
    176: [0, 0.69444, 0, 0, 0.94888],
    184: [0.17014, 0, 0, 0, 0.53222],
    198: [0, 0.68611, 0.11431, 0, 1.02277],
    216: [0.04861, 0.73472, 0.09062, 0, 0.88555],
    223: [0.19444, 0.69444, 0.09736, 0, 0.665],
    230: [0, 0.44444, 0.085, 0, 0.82666],
    248: [0.09722, 0.54167, 0.09458, 0, 0.59111],
    305: [0, 0.44444, 0.09426, 0, 0.35555],
    338: [0, 0.68611, 0.11431, 0, 1.14054],
    339: [0, 0.44444, 0.085, 0, 0.82666],
    567: [0.19444, 0.44444, 0.04611, 0, 0.385],
    710: [0, 0.69444, 0.06709, 0, 0.59111],
    711: [0, 0.63194, 0.08271, 0, 0.59111],
    713: [0, 0.59444, 0.10444, 0, 0.59111],
    714: [0, 0.69444, 0.08528, 0, 0.59111],
    715: [0, 0.69444, 0, 0, 0.59111],
    728: [0, 0.69444, 0.10333, 0, 0.59111],
    729: [0, 0.69444, 0.12945, 0, 0.35555],
    730: [0, 0.69444, 0, 0, 0.94888],
    732: [0, 0.69444, 0.11472, 0, 0.59111],
    733: [0, 0.69444, 0.11472, 0, 0.59111],
    915: [0, 0.68611, 0.12903, 0, 0.69777],
    916: [0, 0.68611, 0, 0, 0.94444],
    920: [0, 0.68611, 0.09062, 0, 0.88555],
    923: [0, 0.68611, 0, 0, 0.80666],
    926: [0, 0.68611, 0.15092, 0, 0.76777],
    928: [0, 0.68611, 0.17208, 0, 0.8961],
    931: [0, 0.68611, 0.11431, 0, 0.82666],
    933: [0, 0.68611, 0.10778, 0, 0.88555],
    934: [0, 0.68611, 0.05632, 0, 0.82666],
    936: [0, 0.68611, 0.10778, 0, 0.88555],
    937: [0, 0.68611, 0.0992, 0, 0.82666],
    8211: [0, 0.44444, 0.09811, 0, 0.59111],
    8212: [0, 0.44444, 0.09811, 0, 1.18221],
    8216: [0, 0.69444, 0.12945, 0, 0.35555],
    8217: [0, 0.69444, 0.12945, 0, 0.35555],
    8220: [0, 0.69444, 0.16772, 0, 0.62055],
    8221: [0, 0.69444, 0.07939, 0, 0.62055]
  },
  "Main-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.12417, 0, 0.30667],
    34: [0, 0.69444, 0.06961, 0, 0.51444],
    35: [0.19444, 0.69444, 0.06616, 0, 0.81777],
    37: [0.05556, 0.75, 0.13639, 0, 0.81777],
    38: [0, 0.69444, 0.09694, 0, 0.76666],
    39: [0, 0.69444, 0.12417, 0, 0.30667],
    40: [0.25, 0.75, 0.16194, 0, 0.40889],
    41: [0.25, 0.75, 0.03694, 0, 0.40889],
    42: [0, 0.75, 0.14917, 0, 0.51111],
    43: [0.05667, 0.56167, 0.03694, 0, 0.76666],
    44: [0.19444, 0.10556, 0, 0, 0.30667],
    45: [0, 0.43056, 0.02826, 0, 0.35778],
    46: [0, 0.10556, 0, 0, 0.30667],
    47: [0.25, 0.75, 0.16194, 0, 0.51111],
    48: [0, 0.64444, 0.13556, 0, 0.51111],
    49: [0, 0.64444, 0.13556, 0, 0.51111],
    50: [0, 0.64444, 0.13556, 0, 0.51111],
    51: [0, 0.64444, 0.13556, 0, 0.51111],
    52: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    53: [0, 0.64444, 0.13556, 0, 0.51111],
    54: [0, 0.64444, 0.13556, 0, 0.51111],
    55: [0.19444, 0.64444, 0.13556, 0, 0.51111],
    56: [0, 0.64444, 0.13556, 0, 0.51111],
    57: [0, 0.64444, 0.13556, 0, 0.51111],
    58: [0, 0.43056, 0.0582, 0, 0.30667],
    59: [0.19444, 0.43056, 0.0582, 0, 0.30667],
    61: [-0.13313, 0.36687, 0.06616, 0, 0.76666],
    63: [0, 0.69444, 0.1225, 0, 0.51111],
    64: [0, 0.69444, 0.09597, 0, 0.76666],
    65: [0, 0.68333, 0, 0, 0.74333],
    66: [0, 0.68333, 0.10257, 0, 0.70389],
    67: [0, 0.68333, 0.14528, 0, 0.71555],
    68: [0, 0.68333, 0.09403, 0, 0.755],
    69: [0, 0.68333, 0.12028, 0, 0.67833],
    70: [0, 0.68333, 0.13305, 0, 0.65277],
    71: [0, 0.68333, 0.08722, 0, 0.77361],
    72: [0, 0.68333, 0.16389, 0, 0.74333],
    73: [0, 0.68333, 0.15806, 0, 0.38555],
    74: [0, 0.68333, 0.14028, 0, 0.525],
    75: [0, 0.68333, 0.14528, 0, 0.76888],
    76: [0, 0.68333, 0, 0, 0.62722],
    77: [0, 0.68333, 0.16389, 0, 0.89666],
    78: [0, 0.68333, 0.16389, 0, 0.74333],
    79: [0, 0.68333, 0.09403, 0, 0.76666],
    80: [0, 0.68333, 0.10257, 0, 0.67833],
    81: [0.19444, 0.68333, 0.09403, 0, 0.76666],
    82: [0, 0.68333, 0.03868, 0, 0.72944],
    83: [0, 0.68333, 0.11972, 0, 0.56222],
    84: [0, 0.68333, 0.13305, 0, 0.71555],
    85: [0, 0.68333, 0.16389, 0, 0.74333],
    86: [0, 0.68333, 0.18361, 0, 0.74333],
    87: [0, 0.68333, 0.18361, 0, 0.99888],
    88: [0, 0.68333, 0.15806, 0, 0.74333],
    89: [0, 0.68333, 0.19383, 0, 0.74333],
    90: [0, 0.68333, 0.14528, 0, 0.61333],
    91: [0.25, 0.75, 0.1875, 0, 0.30667],
    93: [0.25, 0.75, 0.10528, 0, 0.30667],
    94: [0, 0.69444, 0.06646, 0, 0.51111],
    95: [0.31, 0.12056, 0.09208, 0, 0.51111],
    97: [0, 0.43056, 0.07671, 0, 0.51111],
    98: [0, 0.69444, 0.06312, 0, 0.46],
    99: [0, 0.43056, 0.05653, 0, 0.46],
    100: [0, 0.69444, 0.10333, 0, 0.51111],
    101: [0, 0.43056, 0.07514, 0, 0.46],
    102: [0.19444, 0.69444, 0.21194, 0, 0.30667],
    103: [0.19444, 0.43056, 0.08847, 0, 0.46],
    104: [0, 0.69444, 0.07671, 0, 0.51111],
    105: [0, 0.65536, 0.1019, 0, 0.30667],
    106: [0.19444, 0.65536, 0.14467, 0, 0.30667],
    107: [0, 0.69444, 0.10764, 0, 0.46],
    108: [0, 0.69444, 0.10333, 0, 0.25555],
    109: [0, 0.43056, 0.07671, 0, 0.81777],
    110: [0, 0.43056, 0.07671, 0, 0.56222],
    111: [0, 0.43056, 0.06312, 0, 0.51111],
    112: [0.19444, 0.43056, 0.06312, 0, 0.51111],
    113: [0.19444, 0.43056, 0.08847, 0, 0.46],
    114: [0, 0.43056, 0.10764, 0, 0.42166],
    115: [0, 0.43056, 0.08208, 0, 0.40889],
    116: [0, 0.61508, 0.09486, 0, 0.33222],
    117: [0, 0.43056, 0.07671, 0, 0.53666],
    118: [0, 0.43056, 0.10764, 0, 0.46],
    119: [0, 0.43056, 0.10764, 0, 0.66444],
    120: [0, 0.43056, 0.12042, 0, 0.46389],
    121: [0.19444, 0.43056, 0.08847, 0, 0.48555],
    122: [0, 0.43056, 0.12292, 0, 0.40889],
    126: [0.35, 0.31786, 0.11585, 0, 0.51111],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.66786, 0.10474, 0, 0.51111],
    176: [0, 0.69444, 0, 0, 0.83129],
    184: [0.17014, 0, 0, 0, 0.46],
    198: [0, 0.68333, 0.12028, 0, 0.88277],
    216: [0.04861, 0.73194, 0.09403, 0, 0.76666],
    223: [0.19444, 0.69444, 0.10514, 0, 0.53666],
    230: [0, 0.43056, 0.07514, 0, 0.71555],
    248: [0.09722, 0.52778, 0.09194, 0, 0.51111],
    338: [0, 0.68333, 0.12028, 0, 0.98499],
    339: [0, 0.43056, 0.07514, 0, 0.71555],
    710: [0, 0.69444, 0.06646, 0, 0.51111],
    711: [0, 0.62847, 0.08295, 0, 0.51111],
    713: [0, 0.56167, 0.10333, 0, 0.51111],
    714: [0, 0.69444, 0.09694, 0, 0.51111],
    715: [0, 0.69444, 0, 0, 0.51111],
    728: [0, 0.69444, 0.10806, 0, 0.51111],
    729: [0, 0.66786, 0.11752, 0, 0.30667],
    730: [0, 0.69444, 0, 0, 0.83129],
    732: [0, 0.66786, 0.11585, 0, 0.51111],
    733: [0, 0.69444, 0.1225, 0, 0.51111],
    915: [0, 0.68333, 0.13305, 0, 0.62722],
    916: [0, 0.68333, 0, 0, 0.81777],
    920: [0, 0.68333, 0.09403, 0, 0.76666],
    923: [0, 0.68333, 0, 0, 0.69222],
    926: [0, 0.68333, 0.15294, 0, 0.66444],
    928: [0, 0.68333, 0.16389, 0, 0.74333],
    931: [0, 0.68333, 0.12028, 0, 0.71555],
    933: [0, 0.68333, 0.11111, 0, 0.76666],
    934: [0, 0.68333, 0.05986, 0, 0.71555],
    936: [0, 0.68333, 0.11111, 0, 0.76666],
    937: [0, 0.68333, 0.10257, 0, 0.71555],
    8211: [0, 0.43056, 0.09208, 0, 0.51111],
    8212: [0, 0.43056, 0.09208, 0, 1.02222],
    8216: [0, 0.69444, 0.12417, 0, 0.30667],
    8217: [0, 0.69444, 0.12417, 0, 0.30667],
    8220: [0, 0.69444, 0.1685, 0, 0.51444],
    8221: [0, 0.69444, 0.06961, 0, 0.51444],
    8463: [0, 0.68889, 0, 0, 0.54028]
  },
  "Main-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.27778],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.77778],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.19444, 0.10556, 0, 0, 0.27778],
    45: [0, 0.43056, 0, 0, 0.33333],
    46: [0, 0.10556, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.64444, 0, 0, 0.5],
    49: [0, 0.64444, 0, 0, 0.5],
    50: [0, 0.64444, 0, 0, 0.5],
    51: [0, 0.64444, 0, 0, 0.5],
    52: [0, 0.64444, 0, 0, 0.5],
    53: [0, 0.64444, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0, 0.64444, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0, 0.64444, 0, 0, 0.5],
    58: [0, 0.43056, 0, 0, 0.27778],
    59: [0.19444, 0.43056, 0, 0, 0.27778],
    60: [0.0391, 0.5391, 0, 0, 0.77778],
    61: [-0.13313, 0.36687, 0, 0, 0.77778],
    62: [0.0391, 0.5391, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.77778],
    65: [0, 0.68333, 0, 0, 0.75],
    66: [0, 0.68333, 0, 0, 0.70834],
    67: [0, 0.68333, 0, 0, 0.72222],
    68: [0, 0.68333, 0, 0, 0.76389],
    69: [0, 0.68333, 0, 0, 0.68056],
    70: [0, 0.68333, 0, 0, 0.65278],
    71: [0, 0.68333, 0, 0, 0.78472],
    72: [0, 0.68333, 0, 0, 0.75],
    73: [0, 0.68333, 0, 0, 0.36111],
    74: [0, 0.68333, 0, 0, 0.51389],
    75: [0, 0.68333, 0, 0, 0.77778],
    76: [0, 0.68333, 0, 0, 0.625],
    77: [0, 0.68333, 0, 0, 0.91667],
    78: [0, 0.68333, 0, 0, 0.75],
    79: [0, 0.68333, 0, 0, 0.77778],
    80: [0, 0.68333, 0, 0, 0.68056],
    81: [0.19444, 0.68333, 0, 0, 0.77778],
    82: [0, 0.68333, 0, 0, 0.73611],
    83: [0, 0.68333, 0, 0, 0.55556],
    84: [0, 0.68333, 0, 0, 0.72222],
    85: [0, 0.68333, 0, 0, 0.75],
    86: [0, 0.68333, 0.01389, 0, 0.75],
    87: [0, 0.68333, 0.01389, 0, 1.02778],
    88: [0, 0.68333, 0, 0, 0.75],
    89: [0, 0.68333, 0.025, 0, 0.75],
    90: [0, 0.68333, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.27778],
    92: [0.25, 0.75, 0, 0, 0.5],
    93: [0.25, 0.75, 0, 0, 0.27778],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.31, 0.12056, 0.02778, 0, 0.5],
    97: [0, 0.43056, 0, 0, 0.5],
    98: [0, 0.69444, 0, 0, 0.55556],
    99: [0, 0.43056, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.55556],
    101: [0, 0.43056, 0, 0, 0.44445],
    102: [0, 0.69444, 0.07778, 0, 0.30556],
    103: [0.19444, 0.43056, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.55556],
    105: [0, 0.66786, 0, 0, 0.27778],
    106: [0.19444, 0.66786, 0, 0, 0.30556],
    107: [0, 0.69444, 0, 0, 0.52778],
    108: [0, 0.69444, 0, 0, 0.27778],
    109: [0, 0.43056, 0, 0, 0.83334],
    110: [0, 0.43056, 0, 0, 0.55556],
    111: [0, 0.43056, 0, 0, 0.5],
    112: [0.19444, 0.43056, 0, 0, 0.55556],
    113: [0.19444, 0.43056, 0, 0, 0.52778],
    114: [0, 0.43056, 0, 0, 0.39167],
    115: [0, 0.43056, 0, 0, 0.39445],
    116: [0, 0.61508, 0, 0, 0.38889],
    117: [0, 0.43056, 0, 0, 0.55556],
    118: [0, 0.43056, 0.01389, 0, 0.52778],
    119: [0, 0.43056, 0.01389, 0, 0.72222],
    120: [0, 0.43056, 0, 0, 0.52778],
    121: [0.19444, 0.43056, 0.01389, 0, 0.52778],
    122: [0, 0.43056, 0, 0, 0.44445],
    123: [0.25, 0.75, 0, 0, 0.5],
    124: [0.25, 0.75, 0, 0, 0.27778],
    125: [0.25, 0.75, 0, 0, 0.5],
    126: [0.35, 0.31786, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    163: [0, 0.69444, 0, 0, 0.76909],
    167: [0.19444, 0.69444, 0, 0, 0.44445],
    168: [0, 0.66786, 0, 0, 0.5],
    172: [0, 0.43056, 0, 0, 0.66667],
    176: [0, 0.69444, 0, 0, 0.75],
    177: [0.08333, 0.58333, 0, 0, 0.77778],
    182: [0.19444, 0.69444, 0, 0, 0.61111],
    184: [0.17014, 0, 0, 0, 0.44445],
    198: [0, 0.68333, 0, 0, 0.90278],
    215: [0.08333, 0.58333, 0, 0, 0.77778],
    216: [0.04861, 0.73194, 0, 0, 0.77778],
    223: [0, 0.69444, 0, 0, 0.5],
    230: [0, 0.43056, 0, 0, 0.72222],
    247: [0.08333, 0.58333, 0, 0, 0.77778],
    248: [0.09722, 0.52778, 0, 0, 0.5],
    305: [0, 0.43056, 0, 0, 0.27778],
    338: [0, 0.68333, 0, 0, 1.01389],
    339: [0, 0.43056, 0, 0, 0.77778],
    567: [0.19444, 0.43056, 0, 0, 0.30556],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.62847, 0, 0, 0.5],
    713: [0, 0.56778, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.66786, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.75],
    732: [0, 0.66786, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.68333, 0, 0, 0.625],
    916: [0, 0.68333, 0, 0, 0.83334],
    920: [0, 0.68333, 0, 0, 0.77778],
    923: [0, 0.68333, 0, 0, 0.69445],
    926: [0, 0.68333, 0, 0, 0.66667],
    928: [0, 0.68333, 0, 0, 0.75],
    931: [0, 0.68333, 0, 0, 0.72222],
    933: [0, 0.68333, 0, 0, 0.77778],
    934: [0, 0.68333, 0, 0, 0.72222],
    936: [0, 0.68333, 0, 0, 0.77778],
    937: [0, 0.68333, 0, 0, 0.72222],
    8211: [0, 0.43056, 0.02778, 0, 0.5],
    8212: [0, 0.43056, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5],
    8224: [0.19444, 0.69444, 0, 0, 0.44445],
    8225: [0.19444, 0.69444, 0, 0, 0.44445],
    8230: [0, 0.123, 0, 0, 1.172],
    8242: [0, 0.55556, 0, 0, 0.275],
    8407: [0, 0.71444, 0.15382, 0, 0.5],
    8463: [0, 0.68889, 0, 0, 0.54028],
    8465: [0, 0.69444, 0, 0, 0.72222],
    8467: [0, 0.69444, 0, 0.11111, 0.41667],
    8472: [0.19444, 0.43056, 0, 0.11111, 0.63646],
    8476: [0, 0.69444, 0, 0, 0.72222],
    8501: [0, 0.69444, 0, 0, 0.61111],
    8592: [-0.13313, 0.36687, 0, 0, 1],
    8593: [0.19444, 0.69444, 0, 0, 0.5],
    8594: [-0.13313, 0.36687, 0, 0, 1],
    8595: [0.19444, 0.69444, 0, 0, 0.5],
    8596: [-0.13313, 0.36687, 0, 0, 1],
    8597: [0.25, 0.75, 0, 0, 0.5],
    8598: [0.19444, 0.69444, 0, 0, 1],
    8599: [0.19444, 0.69444, 0, 0, 1],
    8600: [0.19444, 0.69444, 0, 0, 1],
    8601: [0.19444, 0.69444, 0, 0, 1],
    8614: [0.011, 0.511, 0, 0, 1],
    8617: [0.011, 0.511, 0, 0, 1.126],
    8618: [0.011, 0.511, 0, 0, 1.126],
    8636: [-0.13313, 0.36687, 0, 0, 1],
    8637: [-0.13313, 0.36687, 0, 0, 1],
    8640: [-0.13313, 0.36687, 0, 0, 1],
    8641: [-0.13313, 0.36687, 0, 0, 1],
    8652: [0.011, 0.671, 0, 0, 1],
    8656: [-0.13313, 0.36687, 0, 0, 1],
    8657: [0.19444, 0.69444, 0, 0, 0.61111],
    8658: [-0.13313, 0.36687, 0, 0, 1],
    8659: [0.19444, 0.69444, 0, 0, 0.61111],
    8660: [-0.13313, 0.36687, 0, 0, 1],
    8661: [0.25, 0.75, 0, 0, 0.61111],
    8704: [0, 0.69444, 0, 0, 0.55556],
    8706: [0, 0.69444, 0.05556, 0.08334, 0.5309],
    8707: [0, 0.69444, 0, 0, 0.55556],
    8709: [0.05556, 0.75, 0, 0, 0.5],
    8711: [0, 0.68333, 0, 0, 0.83334],
    8712: [0.0391, 0.5391, 0, 0, 0.66667],
    8715: [0.0391, 0.5391, 0, 0, 0.66667],
    8722: [0.08333, 0.58333, 0, 0, 0.77778],
    8723: [0.08333, 0.58333, 0, 0, 0.77778],
    8725: [0.25, 0.75, 0, 0, 0.5],
    8726: [0.25, 0.75, 0, 0, 0.5],
    8727: [-0.03472, 0.46528, 0, 0, 0.5],
    8728: [-0.05555, 0.44445, 0, 0, 0.5],
    8729: [-0.05555, 0.44445, 0, 0, 0.5],
    8730: [0.2, 0.8, 0, 0, 0.83334],
    8733: [0, 0.43056, 0, 0, 0.77778],
    8734: [0, 0.43056, 0, 0, 1],
    8736: [0, 0.69224, 0, 0, 0.72222],
    8739: [0.25, 0.75, 0, 0, 0.27778],
    8741: [0.25, 0.75, 0, 0, 0.5],
    8743: [0, 0.55556, 0, 0, 0.66667],
    8744: [0, 0.55556, 0, 0, 0.66667],
    8745: [0, 0.55556, 0, 0, 0.66667],
    8746: [0, 0.55556, 0, 0, 0.66667],
    8747: [0.19444, 0.69444, 0.11111, 0, 0.41667],
    8764: [-0.13313, 0.36687, 0, 0, 0.77778],
    8768: [0.19444, 0.69444, 0, 0, 0.27778],
    8771: [-0.03625, 0.46375, 0, 0, 0.77778],
    8773: [-0.022, 0.589, 0, 0, 0.778],
    8776: [-0.01688, 0.48312, 0, 0, 0.77778],
    8781: [-0.03625, 0.46375, 0, 0, 0.77778],
    8784: [-0.133, 0.673, 0, 0, 0.778],
    8801: [-0.03625, 0.46375, 0, 0, 0.77778],
    8804: [0.13597, 0.63597, 0, 0, 0.77778],
    8805: [0.13597, 0.63597, 0, 0, 0.77778],
    8810: [0.0391, 0.5391, 0, 0, 1],
    8811: [0.0391, 0.5391, 0, 0, 1],
    8826: [0.0391, 0.5391, 0, 0, 0.77778],
    8827: [0.0391, 0.5391, 0, 0, 0.77778],
    8834: [0.0391, 0.5391, 0, 0, 0.77778],
    8835: [0.0391, 0.5391, 0, 0, 0.77778],
    8838: [0.13597, 0.63597, 0, 0, 0.77778],
    8839: [0.13597, 0.63597, 0, 0, 0.77778],
    8846: [0, 0.55556, 0, 0, 0.66667],
    8849: [0.13597, 0.63597, 0, 0, 0.77778],
    8850: [0.13597, 0.63597, 0, 0, 0.77778],
    8851: [0, 0.55556, 0, 0, 0.66667],
    8852: [0, 0.55556, 0, 0, 0.66667],
    8853: [0.08333, 0.58333, 0, 0, 0.77778],
    8854: [0.08333, 0.58333, 0, 0, 0.77778],
    8855: [0.08333, 0.58333, 0, 0, 0.77778],
    8856: [0.08333, 0.58333, 0, 0, 0.77778],
    8857: [0.08333, 0.58333, 0, 0, 0.77778],
    8866: [0, 0.69444, 0, 0, 0.61111],
    8867: [0, 0.69444, 0, 0, 0.61111],
    8868: [0, 0.69444, 0, 0, 0.77778],
    8869: [0, 0.69444, 0, 0, 0.77778],
    8872: [0.249, 0.75, 0, 0, 0.867],
    8900: [-0.05555, 0.44445, 0, 0, 0.5],
    8901: [-0.05555, 0.44445, 0, 0, 0.27778],
    8902: [-0.03472, 0.46528, 0, 0, 0.5],
    8904: [5e-3, 0.505, 0, 0, 0.9],
    8942: [0.03, 0.903, 0, 0, 0.278],
    8943: [-0.19, 0.313, 0, 0, 1.172],
    8945: [-0.1, 0.823, 0, 0, 1.282],
    8968: [0.25, 0.75, 0, 0, 0.44445],
    8969: [0.25, 0.75, 0, 0, 0.44445],
    8970: [0.25, 0.75, 0, 0, 0.44445],
    8971: [0.25, 0.75, 0, 0, 0.44445],
    8994: [-0.14236, 0.35764, 0, 0, 1],
    8995: [-0.14236, 0.35764, 0, 0, 1],
    9136: [0.244, 0.744, 0, 0, 0.412],
    9137: [0.244, 0.745, 0, 0, 0.412],
    9651: [0.19444, 0.69444, 0, 0, 0.88889],
    9657: [-0.03472, 0.46528, 0, 0, 0.5],
    9661: [0.19444, 0.69444, 0, 0, 0.88889],
    9667: [-0.03472, 0.46528, 0, 0, 0.5],
    9711: [0.19444, 0.69444, 0, 0, 1],
    9824: [0.12963, 0.69444, 0, 0, 0.77778],
    9825: [0.12963, 0.69444, 0, 0, 0.77778],
    9826: [0.12963, 0.69444, 0, 0, 0.77778],
    9827: [0.12963, 0.69444, 0, 0, 0.77778],
    9837: [0, 0.75, 0, 0, 0.38889],
    9838: [0.19444, 0.69444, 0, 0, 0.38889],
    9839: [0.19444, 0.69444, 0, 0, 0.38889],
    10216: [0.25, 0.75, 0, 0, 0.38889],
    10217: [0.25, 0.75, 0, 0, 0.38889],
    10222: [0.244, 0.744, 0, 0, 0.412],
    10223: [0.244, 0.745, 0, 0, 0.412],
    10229: [0.011, 0.511, 0, 0, 1.609],
    10230: [0.011, 0.511, 0, 0, 1.638],
    10231: [0.011, 0.511, 0, 0, 1.859],
    10232: [0.024, 0.525, 0, 0, 1.609],
    10233: [0.024, 0.525, 0, 0, 1.638],
    10234: [0.024, 0.525, 0, 0, 1.858],
    10236: [0.011, 0.511, 0, 0, 1.638],
    10815: [0, 0.68333, 0, 0, 0.75],
    10927: [0.13597, 0.63597, 0, 0, 0.77778],
    10928: [0.13597, 0.63597, 0, 0, 0.77778],
    57376: [0.19444, 0.69444, 0, 0, 0]
  },
  "Math-BoldItalic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.44444, 0, 0, 0.575],
    49: [0, 0.44444, 0, 0, 0.575],
    50: [0, 0.44444, 0, 0, 0.575],
    51: [0.19444, 0.44444, 0, 0, 0.575],
    52: [0.19444, 0.44444, 0, 0, 0.575],
    53: [0.19444, 0.44444, 0, 0, 0.575],
    54: [0, 0.64444, 0, 0, 0.575],
    55: [0.19444, 0.44444, 0, 0, 0.575],
    56: [0, 0.64444, 0, 0, 0.575],
    57: [0.19444, 0.44444, 0, 0, 0.575],
    65: [0, 0.68611, 0, 0, 0.86944],
    66: [0, 0.68611, 0.04835, 0, 0.8664],
    67: [0, 0.68611, 0.06979, 0, 0.81694],
    68: [0, 0.68611, 0.03194, 0, 0.93812],
    69: [0, 0.68611, 0.05451, 0, 0.81007],
    70: [0, 0.68611, 0.15972, 0, 0.68889],
    71: [0, 0.68611, 0, 0, 0.88673],
    72: [0, 0.68611, 0.08229, 0, 0.98229],
    73: [0, 0.68611, 0.07778, 0, 0.51111],
    74: [0, 0.68611, 0.10069, 0, 0.63125],
    75: [0, 0.68611, 0.06979, 0, 0.97118],
    76: [0, 0.68611, 0, 0, 0.75555],
    77: [0, 0.68611, 0.11424, 0, 1.14201],
    78: [0, 0.68611, 0.11424, 0, 0.95034],
    79: [0, 0.68611, 0.03194, 0, 0.83666],
    80: [0, 0.68611, 0.15972, 0, 0.72309],
    81: [0.19444, 0.68611, 0, 0, 0.86861],
    82: [0, 0.68611, 421e-5, 0, 0.87235],
    83: [0, 0.68611, 0.05382, 0, 0.69271],
    84: [0, 0.68611, 0.15972, 0, 0.63663],
    85: [0, 0.68611, 0.11424, 0, 0.80027],
    86: [0, 0.68611, 0.25555, 0, 0.67778],
    87: [0, 0.68611, 0.15972, 0, 1.09305],
    88: [0, 0.68611, 0.07778, 0, 0.94722],
    89: [0, 0.68611, 0.25555, 0, 0.67458],
    90: [0, 0.68611, 0.06979, 0, 0.77257],
    97: [0, 0.44444, 0, 0, 0.63287],
    98: [0, 0.69444, 0, 0, 0.52083],
    99: [0, 0.44444, 0, 0, 0.51342],
    100: [0, 0.69444, 0, 0, 0.60972],
    101: [0, 0.44444, 0, 0, 0.55361],
    102: [0.19444, 0.69444, 0.11042, 0, 0.56806],
    103: [0.19444, 0.44444, 0.03704, 0, 0.5449],
    104: [0, 0.69444, 0, 0, 0.66759],
    105: [0, 0.69326, 0, 0, 0.4048],
    106: [0.19444, 0.69326, 0.0622, 0, 0.47083],
    107: [0, 0.69444, 0.01852, 0, 0.6037],
    108: [0, 0.69444, 88e-4, 0, 0.34815],
    109: [0, 0.44444, 0, 0, 1.0324],
    110: [0, 0.44444, 0, 0, 0.71296],
    111: [0, 0.44444, 0, 0, 0.58472],
    112: [0.19444, 0.44444, 0, 0, 0.60092],
    113: [0.19444, 0.44444, 0.03704, 0, 0.54213],
    114: [0, 0.44444, 0.03194, 0, 0.5287],
    115: [0, 0.44444, 0, 0, 0.53125],
    116: [0, 0.63492, 0, 0, 0.41528],
    117: [0, 0.44444, 0, 0, 0.68102],
    118: [0, 0.44444, 0.03704, 0, 0.56666],
    119: [0, 0.44444, 0.02778, 0, 0.83148],
    120: [0, 0.44444, 0, 0, 0.65903],
    121: [0.19444, 0.44444, 0.03704, 0, 0.59028],
    122: [0, 0.44444, 0.04213, 0, 0.55509],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68611, 0.15972, 0, 0.65694],
    916: [0, 0.68611, 0, 0, 0.95833],
    920: [0, 0.68611, 0.03194, 0, 0.86722],
    923: [0, 0.68611, 0, 0, 0.80555],
    926: [0, 0.68611, 0.07458, 0, 0.84125],
    928: [0, 0.68611, 0.08229, 0, 0.98229],
    931: [0, 0.68611, 0.05451, 0, 0.88507],
    933: [0, 0.68611, 0.15972, 0, 0.67083],
    934: [0, 0.68611, 0, 0, 0.76666],
    936: [0, 0.68611, 0.11653, 0, 0.71402],
    937: [0, 0.68611, 0.04835, 0, 0.8789],
    945: [0, 0.44444, 0, 0, 0.76064],
    946: [0.19444, 0.69444, 0.03403, 0, 0.65972],
    947: [0.19444, 0.44444, 0.06389, 0, 0.59003],
    948: [0, 0.69444, 0.03819, 0, 0.52222],
    949: [0, 0.44444, 0, 0, 0.52882],
    950: [0.19444, 0.69444, 0.06215, 0, 0.50833],
    951: [0.19444, 0.44444, 0.03704, 0, 0.6],
    952: [0, 0.69444, 0.03194, 0, 0.5618],
    953: [0, 0.44444, 0, 0, 0.41204],
    954: [0, 0.44444, 0, 0, 0.66759],
    955: [0, 0.69444, 0, 0, 0.67083],
    956: [0.19444, 0.44444, 0, 0, 0.70787],
    957: [0, 0.44444, 0.06898, 0, 0.57685],
    958: [0.19444, 0.69444, 0.03021, 0, 0.50833],
    959: [0, 0.44444, 0, 0, 0.58472],
    960: [0, 0.44444, 0.03704, 0, 0.68241],
    961: [0.19444, 0.44444, 0, 0, 0.6118],
    962: [0.09722, 0.44444, 0.07917, 0, 0.42361],
    963: [0, 0.44444, 0.03704, 0, 0.68588],
    964: [0, 0.44444, 0.13472, 0, 0.52083],
    965: [0, 0.44444, 0.03704, 0, 0.63055],
    966: [0.19444, 0.44444, 0, 0, 0.74722],
    967: [0.19444, 0.44444, 0, 0, 0.71805],
    968: [0.19444, 0.69444, 0.03704, 0, 0.75833],
    969: [0, 0.44444, 0.03704, 0, 0.71782],
    977: [0, 0.69444, 0, 0, 0.69155],
    981: [0.19444, 0.69444, 0, 0, 0.7125],
    982: [0, 0.44444, 0.03194, 0, 0.975],
    1009: [0.19444, 0.44444, 0, 0, 0.6118],
    1013: [0, 0.44444, 0, 0, 0.48333],
    57649: [0, 0.44444, 0, 0, 0.39352],
    57911: [0.19444, 0.44444, 0, 0, 0.43889]
  },
  "Math-Italic": {
    32: [0, 0, 0, 0, 0.25],
    48: [0, 0.43056, 0, 0, 0.5],
    49: [0, 0.43056, 0, 0, 0.5],
    50: [0, 0.43056, 0, 0, 0.5],
    51: [0.19444, 0.43056, 0, 0, 0.5],
    52: [0.19444, 0.43056, 0, 0, 0.5],
    53: [0.19444, 0.43056, 0, 0, 0.5],
    54: [0, 0.64444, 0, 0, 0.5],
    55: [0.19444, 0.43056, 0, 0, 0.5],
    56: [0, 0.64444, 0, 0, 0.5],
    57: [0.19444, 0.43056, 0, 0, 0.5],
    65: [0, 0.68333, 0, 0.13889, 0.75],
    66: [0, 0.68333, 0.05017, 0.08334, 0.75851],
    67: [0, 0.68333, 0.07153, 0.08334, 0.71472],
    68: [0, 0.68333, 0.02778, 0.05556, 0.82792],
    69: [0, 0.68333, 0.05764, 0.08334, 0.7382],
    70: [0, 0.68333, 0.13889, 0.08334, 0.64306],
    71: [0, 0.68333, 0, 0.08334, 0.78625],
    72: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    73: [0, 0.68333, 0.07847, 0.11111, 0.43958],
    74: [0, 0.68333, 0.09618, 0.16667, 0.55451],
    75: [0, 0.68333, 0.07153, 0.05556, 0.84931],
    76: [0, 0.68333, 0, 0.02778, 0.68056],
    77: [0, 0.68333, 0.10903, 0.08334, 0.97014],
    78: [0, 0.68333, 0.10903, 0.08334, 0.80347],
    79: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    80: [0, 0.68333, 0.13889, 0.08334, 0.64201],
    81: [0.19444, 0.68333, 0, 0.08334, 0.79056],
    82: [0, 0.68333, 773e-5, 0.08334, 0.75929],
    83: [0, 0.68333, 0.05764, 0.08334, 0.6132],
    84: [0, 0.68333, 0.13889, 0.08334, 0.58438],
    85: [0, 0.68333, 0.10903, 0.02778, 0.68278],
    86: [0, 0.68333, 0.22222, 0, 0.58333],
    87: [0, 0.68333, 0.13889, 0, 0.94445],
    88: [0, 0.68333, 0.07847, 0.08334, 0.82847],
    89: [0, 0.68333, 0.22222, 0, 0.58056],
    90: [0, 0.68333, 0.07153, 0.08334, 0.68264],
    97: [0, 0.43056, 0, 0, 0.52859],
    98: [0, 0.69444, 0, 0, 0.42917],
    99: [0, 0.43056, 0, 0.05556, 0.43276],
    100: [0, 0.69444, 0, 0.16667, 0.52049],
    101: [0, 0.43056, 0, 0.05556, 0.46563],
    102: [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
    103: [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
    104: [0, 0.69444, 0, 0, 0.57616],
    105: [0, 0.65952, 0, 0, 0.34451],
    106: [0.19444, 0.65952, 0.05724, 0, 0.41181],
    107: [0, 0.69444, 0.03148, 0, 0.5206],
    108: [0, 0.69444, 0.01968, 0.08334, 0.29838],
    109: [0, 0.43056, 0, 0, 0.87801],
    110: [0, 0.43056, 0, 0, 0.60023],
    111: [0, 0.43056, 0, 0.05556, 0.48472],
    112: [0.19444, 0.43056, 0, 0.08334, 0.50313],
    113: [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
    114: [0, 0.43056, 0.02778, 0.05556, 0.45116],
    115: [0, 0.43056, 0, 0.05556, 0.46875],
    116: [0, 0.61508, 0, 0.08334, 0.36111],
    117: [0, 0.43056, 0, 0.02778, 0.57246],
    118: [0, 0.43056, 0.03588, 0.02778, 0.48472],
    119: [0, 0.43056, 0.02691, 0.08334, 0.71592],
    120: [0, 0.43056, 0, 0.02778, 0.57153],
    121: [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
    122: [0, 0.43056, 0.04398, 0.05556, 0.46505],
    160: [0, 0, 0, 0, 0.25],
    915: [0, 0.68333, 0.13889, 0.08334, 0.61528],
    916: [0, 0.68333, 0, 0.16667, 0.83334],
    920: [0, 0.68333, 0.02778, 0.08334, 0.76278],
    923: [0, 0.68333, 0, 0.16667, 0.69445],
    926: [0, 0.68333, 0.07569, 0.08334, 0.74236],
    928: [0, 0.68333, 0.08125, 0.05556, 0.83125],
    931: [0, 0.68333, 0.05764, 0.08334, 0.77986],
    933: [0, 0.68333, 0.13889, 0.05556, 0.58333],
    934: [0, 0.68333, 0, 0.08334, 0.66667],
    936: [0, 0.68333, 0.11, 0.05556, 0.61222],
    937: [0, 0.68333, 0.05017, 0.08334, 0.7724],
    945: [0, 0.43056, 37e-4, 0.02778, 0.6397],
    946: [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
    947: [0.19444, 0.43056, 0.05556, 0, 0.51773],
    948: [0, 0.69444, 0.03785, 0.05556, 0.44444],
    949: [0, 0.43056, 0, 0.08334, 0.46632],
    950: [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
    951: [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
    952: [0, 0.69444, 0.02778, 0.08334, 0.46944],
    953: [0, 0.43056, 0, 0.05556, 0.35394],
    954: [0, 0.43056, 0, 0, 0.57616],
    955: [0, 0.69444, 0, 0, 0.58334],
    956: [0.19444, 0.43056, 0, 0.02778, 0.60255],
    957: [0, 0.43056, 0.06366, 0.02778, 0.49398],
    958: [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
    959: [0, 0.43056, 0, 0.05556, 0.48472],
    960: [0, 0.43056, 0.03588, 0, 0.57003],
    961: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    962: [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
    963: [0, 0.43056, 0.03588, 0, 0.57141],
    964: [0, 0.43056, 0.1132, 0.02778, 0.43715],
    965: [0, 0.43056, 0.03588, 0.02778, 0.54028],
    966: [0.19444, 0.43056, 0, 0.08334, 0.65417],
    967: [0.19444, 0.43056, 0, 0.05556, 0.62569],
    968: [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
    969: [0, 0.43056, 0.03588, 0, 0.62245],
    977: [0, 0.69444, 0, 0.08334, 0.59144],
    981: [0.19444, 0.69444, 0, 0.08334, 0.59583],
    982: [0, 0.43056, 0.02778, 0, 0.82813],
    1009: [0.19444, 0.43056, 0, 0.08334, 0.51702],
    1013: [0, 0.43056, 0, 0.05556, 0.4059],
    57649: [0, 0.43056, 0, 0.02778, 0.32246],
    57911: [0.19444, 0.43056, 0, 0.08334, 0.38403]
  },
  "SansSerif-Bold": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.36667],
    34: [0, 0.69444, 0, 0, 0.55834],
    35: [0.19444, 0.69444, 0, 0, 0.91667],
    36: [0.05556, 0.75, 0, 0, 0.55],
    37: [0.05556, 0.75, 0, 0, 1.02912],
    38: [0, 0.69444, 0, 0, 0.83056],
    39: [0, 0.69444, 0, 0, 0.30556],
    40: [0.25, 0.75, 0, 0, 0.42778],
    41: [0.25, 0.75, 0, 0, 0.42778],
    42: [0, 0.75, 0, 0, 0.55],
    43: [0.11667, 0.61667, 0, 0, 0.85556],
    44: [0.10556, 0.13056, 0, 0, 0.30556],
    45: [0, 0.45833, 0, 0, 0.36667],
    46: [0, 0.13056, 0, 0, 0.30556],
    47: [0.25, 0.75, 0, 0, 0.55],
    48: [0, 0.69444, 0, 0, 0.55],
    49: [0, 0.69444, 0, 0, 0.55],
    50: [0, 0.69444, 0, 0, 0.55],
    51: [0, 0.69444, 0, 0, 0.55],
    52: [0, 0.69444, 0, 0, 0.55],
    53: [0, 0.69444, 0, 0, 0.55],
    54: [0, 0.69444, 0, 0, 0.55],
    55: [0, 0.69444, 0, 0, 0.55],
    56: [0, 0.69444, 0, 0, 0.55],
    57: [0, 0.69444, 0, 0, 0.55],
    58: [0, 0.45833, 0, 0, 0.30556],
    59: [0.10556, 0.45833, 0, 0, 0.30556],
    61: [-0.09375, 0.40625, 0, 0, 0.85556],
    63: [0, 0.69444, 0, 0, 0.51945],
    64: [0, 0.69444, 0, 0, 0.73334],
    65: [0, 0.69444, 0, 0, 0.73334],
    66: [0, 0.69444, 0, 0, 0.73334],
    67: [0, 0.69444, 0, 0, 0.70278],
    68: [0, 0.69444, 0, 0, 0.79445],
    69: [0, 0.69444, 0, 0, 0.64167],
    70: [0, 0.69444, 0, 0, 0.61111],
    71: [0, 0.69444, 0, 0, 0.73334],
    72: [0, 0.69444, 0, 0, 0.79445],
    73: [0, 0.69444, 0, 0, 0.33056],
    74: [0, 0.69444, 0, 0, 0.51945],
    75: [0, 0.69444, 0, 0, 0.76389],
    76: [0, 0.69444, 0, 0, 0.58056],
    77: [0, 0.69444, 0, 0, 0.97778],
    78: [0, 0.69444, 0, 0, 0.79445],
    79: [0, 0.69444, 0, 0, 0.79445],
    80: [0, 0.69444, 0, 0, 0.70278],
    81: [0.10556, 0.69444, 0, 0, 0.79445],
    82: [0, 0.69444, 0, 0, 0.70278],
    83: [0, 0.69444, 0, 0, 0.61111],
    84: [0, 0.69444, 0, 0, 0.73334],
    85: [0, 0.69444, 0, 0, 0.76389],
    86: [0, 0.69444, 0.01528, 0, 0.73334],
    87: [0, 0.69444, 0.01528, 0, 1.03889],
    88: [0, 0.69444, 0, 0, 0.73334],
    89: [0, 0.69444, 0.0275, 0, 0.73334],
    90: [0, 0.69444, 0, 0, 0.67223],
    91: [0.25, 0.75, 0, 0, 0.34306],
    93: [0.25, 0.75, 0, 0, 0.34306],
    94: [0, 0.69444, 0, 0, 0.55],
    95: [0.35, 0.10833, 0.03056, 0, 0.55],
    97: [0, 0.45833, 0, 0, 0.525],
    98: [0, 0.69444, 0, 0, 0.56111],
    99: [0, 0.45833, 0, 0, 0.48889],
    100: [0, 0.69444, 0, 0, 0.56111],
    101: [0, 0.45833, 0, 0, 0.51111],
    102: [0, 0.69444, 0.07639, 0, 0.33611],
    103: [0.19444, 0.45833, 0.01528, 0, 0.55],
    104: [0, 0.69444, 0, 0, 0.56111],
    105: [0, 0.69444, 0, 0, 0.25556],
    106: [0.19444, 0.69444, 0, 0, 0.28611],
    107: [0, 0.69444, 0, 0, 0.53056],
    108: [0, 0.69444, 0, 0, 0.25556],
    109: [0, 0.45833, 0, 0, 0.86667],
    110: [0, 0.45833, 0, 0, 0.56111],
    111: [0, 0.45833, 0, 0, 0.55],
    112: [0.19444, 0.45833, 0, 0, 0.56111],
    113: [0.19444, 0.45833, 0, 0, 0.56111],
    114: [0, 0.45833, 0.01528, 0, 0.37222],
    115: [0, 0.45833, 0, 0, 0.42167],
    116: [0, 0.58929, 0, 0, 0.40417],
    117: [0, 0.45833, 0, 0, 0.56111],
    118: [0, 0.45833, 0.01528, 0, 0.5],
    119: [0, 0.45833, 0.01528, 0, 0.74445],
    120: [0, 0.45833, 0, 0, 0.5],
    121: [0.19444, 0.45833, 0.01528, 0, 0.5],
    122: [0, 0.45833, 0, 0, 0.47639],
    126: [0.35, 0.34444, 0, 0, 0.55],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.69444, 0, 0, 0.55],
    176: [0, 0.69444, 0, 0, 0.73334],
    180: [0, 0.69444, 0, 0, 0.55],
    184: [0.17014, 0, 0, 0, 0.48889],
    305: [0, 0.45833, 0, 0, 0.25556],
    567: [0.19444, 0.45833, 0, 0, 0.28611],
    710: [0, 0.69444, 0, 0, 0.55],
    711: [0, 0.63542, 0, 0, 0.55],
    713: [0, 0.63778, 0, 0, 0.55],
    728: [0, 0.69444, 0, 0, 0.55],
    729: [0, 0.69444, 0, 0, 0.30556],
    730: [0, 0.69444, 0, 0, 0.73334],
    732: [0, 0.69444, 0, 0, 0.55],
    733: [0, 0.69444, 0, 0, 0.55],
    915: [0, 0.69444, 0, 0, 0.58056],
    916: [0, 0.69444, 0, 0, 0.91667],
    920: [0, 0.69444, 0, 0, 0.85556],
    923: [0, 0.69444, 0, 0, 0.67223],
    926: [0, 0.69444, 0, 0, 0.73334],
    928: [0, 0.69444, 0, 0, 0.79445],
    931: [0, 0.69444, 0, 0, 0.79445],
    933: [0, 0.69444, 0, 0, 0.85556],
    934: [0, 0.69444, 0, 0, 0.79445],
    936: [0, 0.69444, 0, 0, 0.85556],
    937: [0, 0.69444, 0, 0, 0.79445],
    8211: [0, 0.45833, 0.03056, 0, 0.55],
    8212: [0, 0.45833, 0.03056, 0, 1.10001],
    8216: [0, 0.69444, 0, 0, 0.30556],
    8217: [0, 0.69444, 0, 0, 0.30556],
    8220: [0, 0.69444, 0, 0, 0.55834],
    8221: [0, 0.69444, 0, 0, 0.55834]
  },
  "SansSerif-Italic": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0.05733, 0, 0.31945],
    34: [0, 0.69444, 316e-5, 0, 0.5],
    35: [0.19444, 0.69444, 0.05087, 0, 0.83334],
    36: [0.05556, 0.75, 0.11156, 0, 0.5],
    37: [0.05556, 0.75, 0.03126, 0, 0.83334],
    38: [0, 0.69444, 0.03058, 0, 0.75834],
    39: [0, 0.69444, 0.07816, 0, 0.27778],
    40: [0.25, 0.75, 0.13164, 0, 0.38889],
    41: [0.25, 0.75, 0.02536, 0, 0.38889],
    42: [0, 0.75, 0.11775, 0, 0.5],
    43: [0.08333, 0.58333, 0.02536, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0.01946, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0.13164, 0, 0.5],
    48: [0, 0.65556, 0.11156, 0, 0.5],
    49: [0, 0.65556, 0.11156, 0, 0.5],
    50: [0, 0.65556, 0.11156, 0, 0.5],
    51: [0, 0.65556, 0.11156, 0, 0.5],
    52: [0, 0.65556, 0.11156, 0, 0.5],
    53: [0, 0.65556, 0.11156, 0, 0.5],
    54: [0, 0.65556, 0.11156, 0, 0.5],
    55: [0, 0.65556, 0.11156, 0, 0.5],
    56: [0, 0.65556, 0.11156, 0, 0.5],
    57: [0, 0.65556, 0.11156, 0, 0.5],
    58: [0, 0.44444, 0.02502, 0, 0.27778],
    59: [0.125, 0.44444, 0.02502, 0, 0.27778],
    61: [-0.13, 0.37, 0.05087, 0, 0.77778],
    63: [0, 0.69444, 0.11809, 0, 0.47222],
    64: [0, 0.69444, 0.07555, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0.08293, 0, 0.66667],
    67: [0, 0.69444, 0.11983, 0, 0.63889],
    68: [0, 0.69444, 0.07555, 0, 0.72223],
    69: [0, 0.69444, 0.11983, 0, 0.59722],
    70: [0, 0.69444, 0.13372, 0, 0.56945],
    71: [0, 0.69444, 0.11983, 0, 0.66667],
    72: [0, 0.69444, 0.08094, 0, 0.70834],
    73: [0, 0.69444, 0.13372, 0, 0.27778],
    74: [0, 0.69444, 0.08094, 0, 0.47222],
    75: [0, 0.69444, 0.11983, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0.08094, 0, 0.875],
    78: [0, 0.69444, 0.08094, 0, 0.70834],
    79: [0, 0.69444, 0.07555, 0, 0.73611],
    80: [0, 0.69444, 0.08293, 0, 0.63889],
    81: [0.125, 0.69444, 0.07555, 0, 0.73611],
    82: [0, 0.69444, 0.08293, 0, 0.64584],
    83: [0, 0.69444, 0.09205, 0, 0.55556],
    84: [0, 0.69444, 0.13372, 0, 0.68056],
    85: [0, 0.69444, 0.08094, 0, 0.6875],
    86: [0, 0.69444, 0.1615, 0, 0.66667],
    87: [0, 0.69444, 0.1615, 0, 0.94445],
    88: [0, 0.69444, 0.13372, 0, 0.66667],
    89: [0, 0.69444, 0.17261, 0, 0.66667],
    90: [0, 0.69444, 0.11983, 0, 0.61111],
    91: [0.25, 0.75, 0.15942, 0, 0.28889],
    93: [0.25, 0.75, 0.08719, 0, 0.28889],
    94: [0, 0.69444, 0.0799, 0, 0.5],
    95: [0.35, 0.09444, 0.08616, 0, 0.5],
    97: [0, 0.44444, 981e-5, 0, 0.48056],
    98: [0, 0.69444, 0.03057, 0, 0.51667],
    99: [0, 0.44444, 0.08336, 0, 0.44445],
    100: [0, 0.69444, 0.09483, 0, 0.51667],
    101: [0, 0.44444, 0.06778, 0, 0.44445],
    102: [0, 0.69444, 0.21705, 0, 0.30556],
    103: [0.19444, 0.44444, 0.10836, 0, 0.5],
    104: [0, 0.69444, 0.01778, 0, 0.51667],
    105: [0, 0.67937, 0.09718, 0, 0.23889],
    106: [0.19444, 0.67937, 0.09162, 0, 0.26667],
    107: [0, 0.69444, 0.08336, 0, 0.48889],
    108: [0, 0.69444, 0.09483, 0, 0.23889],
    109: [0, 0.44444, 0.01778, 0, 0.79445],
    110: [0, 0.44444, 0.01778, 0, 0.51667],
    111: [0, 0.44444, 0.06613, 0, 0.5],
    112: [0.19444, 0.44444, 0.0389, 0, 0.51667],
    113: [0.19444, 0.44444, 0.04169, 0, 0.51667],
    114: [0, 0.44444, 0.10836, 0, 0.34167],
    115: [0, 0.44444, 0.0778, 0, 0.38333],
    116: [0, 0.57143, 0.07225, 0, 0.36111],
    117: [0, 0.44444, 0.04169, 0, 0.51667],
    118: [0, 0.44444, 0.10836, 0, 0.46111],
    119: [0, 0.44444, 0.10836, 0, 0.68334],
    120: [0, 0.44444, 0.09169, 0, 0.46111],
    121: [0.19444, 0.44444, 0.10836, 0, 0.46111],
    122: [0, 0.44444, 0.08752, 0, 0.43472],
    126: [0.35, 0.32659, 0.08826, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0.06385, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.73752],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0.04169, 0, 0.23889],
    567: [0.19444, 0.44444, 0.04169, 0, 0.26667],
    710: [0, 0.69444, 0.0799, 0, 0.5],
    711: [0, 0.63194, 0.08432, 0, 0.5],
    713: [0, 0.60889, 0.08776, 0, 0.5],
    714: [0, 0.69444, 0.09205, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0.09483, 0, 0.5],
    729: [0, 0.67937, 0.07774, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.73752],
    732: [0, 0.67659, 0.08826, 0, 0.5],
    733: [0, 0.69444, 0.09205, 0, 0.5],
    915: [0, 0.69444, 0.13372, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0.07555, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0.12816, 0, 0.66667],
    928: [0, 0.69444, 0.08094, 0, 0.70834],
    931: [0, 0.69444, 0.11983, 0, 0.72222],
    933: [0, 0.69444, 0.09031, 0, 0.77778],
    934: [0, 0.69444, 0.04603, 0, 0.72222],
    936: [0, 0.69444, 0.09031, 0, 0.77778],
    937: [0, 0.69444, 0.08293, 0, 0.72222],
    8211: [0, 0.44444, 0.08616, 0, 0.5],
    8212: [0, 0.44444, 0.08616, 0, 1],
    8216: [0, 0.69444, 0.07816, 0, 0.27778],
    8217: [0, 0.69444, 0.07816, 0, 0.27778],
    8220: [0, 0.69444, 0.14205, 0, 0.5],
    8221: [0, 0.69444, 316e-5, 0, 0.5]
  },
  "SansSerif-Regular": {
    32: [0, 0, 0, 0, 0.25],
    33: [0, 0.69444, 0, 0, 0.31945],
    34: [0, 0.69444, 0, 0, 0.5],
    35: [0.19444, 0.69444, 0, 0, 0.83334],
    36: [0.05556, 0.75, 0, 0, 0.5],
    37: [0.05556, 0.75, 0, 0, 0.83334],
    38: [0, 0.69444, 0, 0, 0.75834],
    39: [0, 0.69444, 0, 0, 0.27778],
    40: [0.25, 0.75, 0, 0, 0.38889],
    41: [0.25, 0.75, 0, 0, 0.38889],
    42: [0, 0.75, 0, 0, 0.5],
    43: [0.08333, 0.58333, 0, 0, 0.77778],
    44: [0.125, 0.08333, 0, 0, 0.27778],
    45: [0, 0.44444, 0, 0, 0.33333],
    46: [0, 0.08333, 0, 0, 0.27778],
    47: [0.25, 0.75, 0, 0, 0.5],
    48: [0, 0.65556, 0, 0, 0.5],
    49: [0, 0.65556, 0, 0, 0.5],
    50: [0, 0.65556, 0, 0, 0.5],
    51: [0, 0.65556, 0, 0, 0.5],
    52: [0, 0.65556, 0, 0, 0.5],
    53: [0, 0.65556, 0, 0, 0.5],
    54: [0, 0.65556, 0, 0, 0.5],
    55: [0, 0.65556, 0, 0, 0.5],
    56: [0, 0.65556, 0, 0, 0.5],
    57: [0, 0.65556, 0, 0, 0.5],
    58: [0, 0.44444, 0, 0, 0.27778],
    59: [0.125, 0.44444, 0, 0, 0.27778],
    61: [-0.13, 0.37, 0, 0, 0.77778],
    63: [0, 0.69444, 0, 0, 0.47222],
    64: [0, 0.69444, 0, 0, 0.66667],
    65: [0, 0.69444, 0, 0, 0.66667],
    66: [0, 0.69444, 0, 0, 0.66667],
    67: [0, 0.69444, 0, 0, 0.63889],
    68: [0, 0.69444, 0, 0, 0.72223],
    69: [0, 0.69444, 0, 0, 0.59722],
    70: [0, 0.69444, 0, 0, 0.56945],
    71: [0, 0.69444, 0, 0, 0.66667],
    72: [0, 0.69444, 0, 0, 0.70834],
    73: [0, 0.69444, 0, 0, 0.27778],
    74: [0, 0.69444, 0, 0, 0.47222],
    75: [0, 0.69444, 0, 0, 0.69445],
    76: [0, 0.69444, 0, 0, 0.54167],
    77: [0, 0.69444, 0, 0, 0.875],
    78: [0, 0.69444, 0, 0, 0.70834],
    79: [0, 0.69444, 0, 0, 0.73611],
    80: [0, 0.69444, 0, 0, 0.63889],
    81: [0.125, 0.69444, 0, 0, 0.73611],
    82: [0, 0.69444, 0, 0, 0.64584],
    83: [0, 0.69444, 0, 0, 0.55556],
    84: [0, 0.69444, 0, 0, 0.68056],
    85: [0, 0.69444, 0, 0, 0.6875],
    86: [0, 0.69444, 0.01389, 0, 0.66667],
    87: [0, 0.69444, 0.01389, 0, 0.94445],
    88: [0, 0.69444, 0, 0, 0.66667],
    89: [0, 0.69444, 0.025, 0, 0.66667],
    90: [0, 0.69444, 0, 0, 0.61111],
    91: [0.25, 0.75, 0, 0, 0.28889],
    93: [0.25, 0.75, 0, 0, 0.28889],
    94: [0, 0.69444, 0, 0, 0.5],
    95: [0.35, 0.09444, 0.02778, 0, 0.5],
    97: [0, 0.44444, 0, 0, 0.48056],
    98: [0, 0.69444, 0, 0, 0.51667],
    99: [0, 0.44444, 0, 0, 0.44445],
    100: [0, 0.69444, 0, 0, 0.51667],
    101: [0, 0.44444, 0, 0, 0.44445],
    102: [0, 0.69444, 0.06944, 0, 0.30556],
    103: [0.19444, 0.44444, 0.01389, 0, 0.5],
    104: [0, 0.69444, 0, 0, 0.51667],
    105: [0, 0.67937, 0, 0, 0.23889],
    106: [0.19444, 0.67937, 0, 0, 0.26667],
    107: [0, 0.69444, 0, 0, 0.48889],
    108: [0, 0.69444, 0, 0, 0.23889],
    109: [0, 0.44444, 0, 0, 0.79445],
    110: [0, 0.44444, 0, 0, 0.51667],
    111: [0, 0.44444, 0, 0, 0.5],
    112: [0.19444, 0.44444, 0, 0, 0.51667],
    113: [0.19444, 0.44444, 0, 0, 0.51667],
    114: [0, 0.44444, 0.01389, 0, 0.34167],
    115: [0, 0.44444, 0, 0, 0.38333],
    116: [0, 0.57143, 0, 0, 0.36111],
    117: [0, 0.44444, 0, 0, 0.51667],
    118: [0, 0.44444, 0.01389, 0, 0.46111],
    119: [0, 0.44444, 0.01389, 0, 0.68334],
    120: [0, 0.44444, 0, 0, 0.46111],
    121: [0.19444, 0.44444, 0.01389, 0, 0.46111],
    122: [0, 0.44444, 0, 0, 0.43472],
    126: [0.35, 0.32659, 0, 0, 0.5],
    160: [0, 0, 0, 0, 0.25],
    168: [0, 0.67937, 0, 0, 0.5],
    176: [0, 0.69444, 0, 0, 0.66667],
    184: [0.17014, 0, 0, 0, 0.44445],
    305: [0, 0.44444, 0, 0, 0.23889],
    567: [0.19444, 0.44444, 0, 0, 0.26667],
    710: [0, 0.69444, 0, 0, 0.5],
    711: [0, 0.63194, 0, 0, 0.5],
    713: [0, 0.60889, 0, 0, 0.5],
    714: [0, 0.69444, 0, 0, 0.5],
    715: [0, 0.69444, 0, 0, 0.5],
    728: [0, 0.69444, 0, 0, 0.5],
    729: [0, 0.67937, 0, 0, 0.27778],
    730: [0, 0.69444, 0, 0, 0.66667],
    732: [0, 0.67659, 0, 0, 0.5],
    733: [0, 0.69444, 0, 0, 0.5],
    915: [0, 0.69444, 0, 0, 0.54167],
    916: [0, 0.69444, 0, 0, 0.83334],
    920: [0, 0.69444, 0, 0, 0.77778],
    923: [0, 0.69444, 0, 0, 0.61111],
    926: [0, 0.69444, 0, 0, 0.66667],
    928: [0, 0.69444, 0, 0, 0.70834],
    931: [0, 0.69444, 0, 0, 0.72222],
    933: [0, 0.69444, 0, 0, 0.77778],
    934: [0, 0.69444, 0, 0, 0.72222],
    936: [0, 0.69444, 0, 0, 0.77778],
    937: [0, 0.69444, 0, 0, 0.72222],
    8211: [0, 0.44444, 0.02778, 0, 0.5],
    8212: [0, 0.44444, 0.02778, 0, 1],
    8216: [0, 0.69444, 0, 0, 0.27778],
    8217: [0, 0.69444, 0, 0, 0.27778],
    8220: [0, 0.69444, 0, 0, 0.5],
    8221: [0, 0.69444, 0, 0, 0.5]
  },
  "Script-Regular": {
    32: [0, 0, 0, 0, 0.25],
    65: [0, 0.7, 0.22925, 0, 0.80253],
    66: [0, 0.7, 0.04087, 0, 0.90757],
    67: [0, 0.7, 0.1689, 0, 0.66619],
    68: [0, 0.7, 0.09371, 0, 0.77443],
    69: [0, 0.7, 0.18583, 0, 0.56162],
    70: [0, 0.7, 0.13634, 0, 0.89544],
    71: [0, 0.7, 0.17322, 0, 0.60961],
    72: [0, 0.7, 0.29694, 0, 0.96919],
    73: [0, 0.7, 0.19189, 0, 0.80907],
    74: [0.27778, 0.7, 0.19189, 0, 1.05159],
    75: [0, 0.7, 0.31259, 0, 0.91364],
    76: [0, 0.7, 0.19189, 0, 0.87373],
    77: [0, 0.7, 0.15981, 0, 1.08031],
    78: [0, 0.7, 0.3525, 0, 0.9015],
    79: [0, 0.7, 0.08078, 0, 0.73787],
    80: [0, 0.7, 0.08078, 0, 1.01262],
    81: [0, 0.7, 0.03305, 0, 0.88282],
    82: [0, 0.7, 0.06259, 0, 0.85],
    83: [0, 0.7, 0.19189, 0, 0.86767],
    84: [0, 0.7, 0.29087, 0, 0.74697],
    85: [0, 0.7, 0.25815, 0, 0.79996],
    86: [0, 0.7, 0.27523, 0, 0.62204],
    87: [0, 0.7, 0.27523, 0, 0.80532],
    88: [0, 0.7, 0.26006, 0, 0.94445],
    89: [0, 0.7, 0.2939, 0, 0.70961],
    90: [0, 0.7, 0.24037, 0, 0.8212],
    160: [0, 0, 0, 0, 0.25]
  },
  "Size1-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.35001, 0.85, 0, 0, 0.45834],
    41: [0.35001, 0.85, 0, 0, 0.45834],
    47: [0.35001, 0.85, 0, 0, 0.57778],
    91: [0.35001, 0.85, 0, 0, 0.41667],
    92: [0.35001, 0.85, 0, 0, 0.57778],
    93: [0.35001, 0.85, 0, 0, 0.41667],
    123: [0.35001, 0.85, 0, 0, 0.58334],
    125: [0.35001, 0.85, 0, 0, 0.58334],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.72222, 0, 0, 0.55556],
    732: [0, 0.72222, 0, 0, 0.55556],
    770: [0, 0.72222, 0, 0, 0.55556],
    771: [0, 0.72222, 0, 0, 0.55556],
    8214: [-99e-5, 0.601, 0, 0, 0.77778],
    8593: [1e-5, 0.6, 0, 0, 0.66667],
    8595: [1e-5, 0.6, 0, 0, 0.66667],
    8657: [1e-5, 0.6, 0, 0, 0.77778],
    8659: [1e-5, 0.6, 0, 0, 0.77778],
    8719: [0.25001, 0.75, 0, 0, 0.94445],
    8720: [0.25001, 0.75, 0, 0, 0.94445],
    8721: [0.25001, 0.75, 0, 0, 1.05556],
    8730: [0.35001, 0.85, 0, 0, 1],
    8739: [-599e-5, 0.606, 0, 0, 0.33333],
    8741: [-599e-5, 0.606, 0, 0, 0.55556],
    8747: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8748: [0.306, 0.805, 0.19445, 0, 0.47222],
    8749: [0.306, 0.805, 0.19445, 0, 0.47222],
    8750: [0.30612, 0.805, 0.19445, 0, 0.47222],
    8896: [0.25001, 0.75, 0, 0, 0.83334],
    8897: [0.25001, 0.75, 0, 0, 0.83334],
    8898: [0.25001, 0.75, 0, 0, 0.83334],
    8899: [0.25001, 0.75, 0, 0, 0.83334],
    8968: [0.35001, 0.85, 0, 0, 0.47222],
    8969: [0.35001, 0.85, 0, 0, 0.47222],
    8970: [0.35001, 0.85, 0, 0, 0.47222],
    8971: [0.35001, 0.85, 0, 0, 0.47222],
    9168: [-99e-5, 0.601, 0, 0, 0.66667],
    10216: [0.35001, 0.85, 0, 0, 0.47222],
    10217: [0.35001, 0.85, 0, 0, 0.47222],
    10752: [0.25001, 0.75, 0, 0, 1.11111],
    10753: [0.25001, 0.75, 0, 0, 1.11111],
    10754: [0.25001, 0.75, 0, 0, 1.11111],
    10756: [0.25001, 0.75, 0, 0, 0.83334],
    10758: [0.25001, 0.75, 0, 0, 0.83334]
  },
  "Size2-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.65002, 1.15, 0, 0, 0.59722],
    41: [0.65002, 1.15, 0, 0, 0.59722],
    47: [0.65002, 1.15, 0, 0, 0.81111],
    91: [0.65002, 1.15, 0, 0, 0.47222],
    92: [0.65002, 1.15, 0, 0, 0.81111],
    93: [0.65002, 1.15, 0, 0, 0.47222],
    123: [0.65002, 1.15, 0, 0, 0.66667],
    125: [0.65002, 1.15, 0, 0, 0.66667],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1],
    732: [0, 0.75, 0, 0, 1],
    770: [0, 0.75, 0, 0, 1],
    771: [0, 0.75, 0, 0, 1],
    8719: [0.55001, 1.05, 0, 0, 1.27778],
    8720: [0.55001, 1.05, 0, 0, 1.27778],
    8721: [0.55001, 1.05, 0, 0, 1.44445],
    8730: [0.65002, 1.15, 0, 0, 1],
    8747: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8748: [0.862, 1.36, 0.44445, 0, 0.55556],
    8749: [0.862, 1.36, 0.44445, 0, 0.55556],
    8750: [0.86225, 1.36, 0.44445, 0, 0.55556],
    8896: [0.55001, 1.05, 0, 0, 1.11111],
    8897: [0.55001, 1.05, 0, 0, 1.11111],
    8898: [0.55001, 1.05, 0, 0, 1.11111],
    8899: [0.55001, 1.05, 0, 0, 1.11111],
    8968: [0.65002, 1.15, 0, 0, 0.52778],
    8969: [0.65002, 1.15, 0, 0, 0.52778],
    8970: [0.65002, 1.15, 0, 0, 0.52778],
    8971: [0.65002, 1.15, 0, 0, 0.52778],
    10216: [0.65002, 1.15, 0, 0, 0.61111],
    10217: [0.65002, 1.15, 0, 0, 0.61111],
    10752: [0.55001, 1.05, 0, 0, 1.51112],
    10753: [0.55001, 1.05, 0, 0, 1.51112],
    10754: [0.55001, 1.05, 0, 0, 1.51112],
    10756: [0.55001, 1.05, 0, 0, 1.11111],
    10758: [0.55001, 1.05, 0, 0, 1.11111]
  },
  "Size3-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [0.95003, 1.45, 0, 0, 0.73611],
    41: [0.95003, 1.45, 0, 0, 0.73611],
    47: [0.95003, 1.45, 0, 0, 1.04445],
    91: [0.95003, 1.45, 0, 0, 0.52778],
    92: [0.95003, 1.45, 0, 0, 1.04445],
    93: [0.95003, 1.45, 0, 0, 0.52778],
    123: [0.95003, 1.45, 0, 0, 0.75],
    125: [0.95003, 1.45, 0, 0, 0.75],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.75, 0, 0, 1.44445],
    732: [0, 0.75, 0, 0, 1.44445],
    770: [0, 0.75, 0, 0, 1.44445],
    771: [0, 0.75, 0, 0, 1.44445],
    8730: [0.95003, 1.45, 0, 0, 1],
    8968: [0.95003, 1.45, 0, 0, 0.58334],
    8969: [0.95003, 1.45, 0, 0, 0.58334],
    8970: [0.95003, 1.45, 0, 0, 0.58334],
    8971: [0.95003, 1.45, 0, 0, 0.58334],
    10216: [0.95003, 1.45, 0, 0, 0.75],
    10217: [0.95003, 1.45, 0, 0, 0.75]
  },
  "Size4-Regular": {
    32: [0, 0, 0, 0, 0.25],
    40: [1.25003, 1.75, 0, 0, 0.79167],
    41: [1.25003, 1.75, 0, 0, 0.79167],
    47: [1.25003, 1.75, 0, 0, 1.27778],
    91: [1.25003, 1.75, 0, 0, 0.58334],
    92: [1.25003, 1.75, 0, 0, 1.27778],
    93: [1.25003, 1.75, 0, 0, 0.58334],
    123: [1.25003, 1.75, 0, 0, 0.80556],
    125: [1.25003, 1.75, 0, 0, 0.80556],
    160: [0, 0, 0, 0, 0.25],
    710: [0, 0.825, 0, 0, 1.8889],
    732: [0, 0.825, 0, 0, 1.8889],
    770: [0, 0.825, 0, 0, 1.8889],
    771: [0, 0.825, 0, 0, 1.8889],
    8730: [1.25003, 1.75, 0, 0, 1],
    8968: [1.25003, 1.75, 0, 0, 0.63889],
    8969: [1.25003, 1.75, 0, 0, 0.63889],
    8970: [1.25003, 1.75, 0, 0, 0.63889],
    8971: [1.25003, 1.75, 0, 0, 0.63889],
    9115: [0.64502, 1.155, 0, 0, 0.875],
    9116: [1e-5, 0.6, 0, 0, 0.875],
    9117: [0.64502, 1.155, 0, 0, 0.875],
    9118: [0.64502, 1.155, 0, 0, 0.875],
    9119: [1e-5, 0.6, 0, 0, 0.875],
    9120: [0.64502, 1.155, 0, 0, 0.875],
    9121: [0.64502, 1.155, 0, 0, 0.66667],
    9122: [-99e-5, 0.601, 0, 0, 0.66667],
    9123: [0.64502, 1.155, 0, 0, 0.66667],
    9124: [0.64502, 1.155, 0, 0, 0.66667],
    9125: [-99e-5, 0.601, 0, 0, 0.66667],
    9126: [0.64502, 1.155, 0, 0, 0.66667],
    9127: [1e-5, 0.9, 0, 0, 0.88889],
    9128: [0.65002, 1.15, 0, 0, 0.88889],
    9129: [0.90001, 0, 0, 0, 0.88889],
    9130: [0, 0.3, 0, 0, 0.88889],
    9131: [1e-5, 0.9, 0, 0, 0.88889],
    9132: [0.65002, 1.15, 0, 0, 0.88889],
    9133: [0.90001, 0, 0, 0, 0.88889],
    9143: [0.88502, 0.915, 0, 0, 1.05556],
    10216: [1.25003, 1.75, 0, 0, 0.80556],
    10217: [1.25003, 1.75, 0, 0, 0.80556],
    57344: [-499e-5, 0.605, 0, 0, 1.05556],
    57345: [-499e-5, 0.605, 0, 0, 1.05556],
    57680: [0, 0.12, 0, 0, 0.45],
    57681: [0, 0.12, 0, 0, 0.45],
    57682: [0, 0.12, 0, 0, 0.45],
    57683: [0, 0.12, 0, 0, 0.45]
  },
  "Typewriter-Regular": {
    32: [0, 0, 0, 0, 0.525],
    33: [0, 0.61111, 0, 0, 0.525],
    34: [0, 0.61111, 0, 0, 0.525],
    35: [0, 0.61111, 0, 0, 0.525],
    36: [0.08333, 0.69444, 0, 0, 0.525],
    37: [0.08333, 0.69444, 0, 0, 0.525],
    38: [0, 0.61111, 0, 0, 0.525],
    39: [0, 0.61111, 0, 0, 0.525],
    40: [0.08333, 0.69444, 0, 0, 0.525],
    41: [0.08333, 0.69444, 0, 0, 0.525],
    42: [0, 0.52083, 0, 0, 0.525],
    43: [-0.08056, 0.53055, 0, 0, 0.525],
    44: [0.13889, 0.125, 0, 0, 0.525],
    45: [-0.08056, 0.53055, 0, 0, 0.525],
    46: [0, 0.125, 0, 0, 0.525],
    47: [0.08333, 0.69444, 0, 0, 0.525],
    48: [0, 0.61111, 0, 0, 0.525],
    49: [0, 0.61111, 0, 0, 0.525],
    50: [0, 0.61111, 0, 0, 0.525],
    51: [0, 0.61111, 0, 0, 0.525],
    52: [0, 0.61111, 0, 0, 0.525],
    53: [0, 0.61111, 0, 0, 0.525],
    54: [0, 0.61111, 0, 0, 0.525],
    55: [0, 0.61111, 0, 0, 0.525],
    56: [0, 0.61111, 0, 0, 0.525],
    57: [0, 0.61111, 0, 0, 0.525],
    58: [0, 0.43056, 0, 0, 0.525],
    59: [0.13889, 0.43056, 0, 0, 0.525],
    60: [-0.05556, 0.55556, 0, 0, 0.525],
    61: [-0.19549, 0.41562, 0, 0, 0.525],
    62: [-0.05556, 0.55556, 0, 0, 0.525],
    63: [0, 0.61111, 0, 0, 0.525],
    64: [0, 0.61111, 0, 0, 0.525],
    65: [0, 0.61111, 0, 0, 0.525],
    66: [0, 0.61111, 0, 0, 0.525],
    67: [0, 0.61111, 0, 0, 0.525],
    68: [0, 0.61111, 0, 0, 0.525],
    69: [0, 0.61111, 0, 0, 0.525],
    70: [0, 0.61111, 0, 0, 0.525],
    71: [0, 0.61111, 0, 0, 0.525],
    72: [0, 0.61111, 0, 0, 0.525],
    73: [0, 0.61111, 0, 0, 0.525],
    74: [0, 0.61111, 0, 0, 0.525],
    75: [0, 0.61111, 0, 0, 0.525],
    76: [0, 0.61111, 0, 0, 0.525],
    77: [0, 0.61111, 0, 0, 0.525],
    78: [0, 0.61111, 0, 0, 0.525],
    79: [0, 0.61111, 0, 0, 0.525],
    80: [0, 0.61111, 0, 0, 0.525],
    81: [0.13889, 0.61111, 0, 0, 0.525],
    82: [0, 0.61111, 0, 0, 0.525],
    83: [0, 0.61111, 0, 0, 0.525],
    84: [0, 0.61111, 0, 0, 0.525],
    85: [0, 0.61111, 0, 0, 0.525],
    86: [0, 0.61111, 0, 0, 0.525],
    87: [0, 0.61111, 0, 0, 0.525],
    88: [0, 0.61111, 0, 0, 0.525],
    89: [0, 0.61111, 0, 0, 0.525],
    90: [0, 0.61111, 0, 0, 0.525],
    91: [0.08333, 0.69444, 0, 0, 0.525],
    92: [0.08333, 0.69444, 0, 0, 0.525],
    93: [0.08333, 0.69444, 0, 0, 0.525],
    94: [0, 0.61111, 0, 0, 0.525],
    95: [0.09514, 0, 0, 0, 0.525],
    96: [0, 0.61111, 0, 0, 0.525],
    97: [0, 0.43056, 0, 0, 0.525],
    98: [0, 0.61111, 0, 0, 0.525],
    99: [0, 0.43056, 0, 0, 0.525],
    100: [0, 0.61111, 0, 0, 0.525],
    101: [0, 0.43056, 0, 0, 0.525],
    102: [0, 0.61111, 0, 0, 0.525],
    103: [0.22222, 0.43056, 0, 0, 0.525],
    104: [0, 0.61111, 0, 0, 0.525],
    105: [0, 0.61111, 0, 0, 0.525],
    106: [0.22222, 0.61111, 0, 0, 0.525],
    107: [0, 0.61111, 0, 0, 0.525],
    108: [0, 0.61111, 0, 0, 0.525],
    109: [0, 0.43056, 0, 0, 0.525],
    110: [0, 0.43056, 0, 0, 0.525],
    111: [0, 0.43056, 0, 0, 0.525],
    112: [0.22222, 0.43056, 0, 0, 0.525],
    113: [0.22222, 0.43056, 0, 0, 0.525],
    114: [0, 0.43056, 0, 0, 0.525],
    115: [0, 0.43056, 0, 0, 0.525],
    116: [0, 0.55358, 0, 0, 0.525],
    117: [0, 0.43056, 0, 0, 0.525],
    118: [0, 0.43056, 0, 0, 0.525],
    119: [0, 0.43056, 0, 0, 0.525],
    120: [0, 0.43056, 0, 0, 0.525],
    121: [0.22222, 0.43056, 0, 0, 0.525],
    122: [0, 0.43056, 0, 0, 0.525],
    123: [0.08333, 0.69444, 0, 0, 0.525],
    124: [0.08333, 0.69444, 0, 0, 0.525],
    125: [0.08333, 0.69444, 0, 0, 0.525],
    126: [0, 0.61111, 0, 0, 0.525],
    127: [0, 0.61111, 0, 0, 0.525],
    160: [0, 0, 0, 0, 0.525],
    176: [0, 0.61111, 0, 0, 0.525],
    184: [0.19445, 0, 0, 0, 0.525],
    305: [0, 0.43056, 0, 0, 0.525],
    567: [0.22222, 0.43056, 0, 0, 0.525],
    711: [0, 0.56597, 0, 0, 0.525],
    713: [0, 0.56555, 0, 0, 0.525],
    714: [0, 0.61111, 0, 0, 0.525],
    715: [0, 0.61111, 0, 0, 0.525],
    728: [0, 0.61111, 0, 0, 0.525],
    730: [0, 0.61111, 0, 0, 0.525],
    770: [0, 0.61111, 0, 0, 0.525],
    771: [0, 0.61111, 0, 0, 0.525],
    776: [0, 0.61111, 0, 0, 0.525],
    915: [0, 0.61111, 0, 0, 0.525],
    916: [0, 0.61111, 0, 0, 0.525],
    920: [0, 0.61111, 0, 0, 0.525],
    923: [0, 0.61111, 0, 0, 0.525],
    926: [0, 0.61111, 0, 0, 0.525],
    928: [0, 0.61111, 0, 0, 0.525],
    931: [0, 0.61111, 0, 0, 0.525],
    933: [0, 0.61111, 0, 0, 0.525],
    934: [0, 0.61111, 0, 0, 0.525],
    936: [0, 0.61111, 0, 0, 0.525],
    937: [0, 0.61111, 0, 0, 0.525],
    8216: [0, 0.61111, 0, 0, 0.525],
    8217: [0, 0.61111, 0, 0, 0.525],
    8242: [0, 0.61111, 0, 0, 0.525],
    9251: [0.11111, 0.21944, 0, 0, 0.525]
  }
}, lm = {
  slant: [0.25, 0.25, 0.25],
  // sigma1
  space: [0, 0, 0],
  // sigma2
  stretch: [0, 0, 0],
  // sigma3
  shrink: [0, 0, 0],
  // sigma4
  xHeight: [0.431, 0.431, 0.431],
  // sigma5
  quad: [1, 1.171, 1.472],
  // sigma6
  extraSpace: [0, 0, 0],
  // sigma7
  num1: [0.677, 0.732, 0.925],
  // sigma8
  num2: [0.394, 0.384, 0.387],
  // sigma9
  num3: [0.444, 0.471, 0.504],
  // sigma10
  denom1: [0.686, 0.752, 1.025],
  // sigma11
  denom2: [0.345, 0.344, 0.532],
  // sigma12
  sup1: [0.413, 0.503, 0.504],
  // sigma13
  sup2: [0.363, 0.431, 0.404],
  // sigma14
  sup3: [0.289, 0.286, 0.294],
  // sigma15
  sub1: [0.15, 0.143, 0.2],
  // sigma16
  sub2: [0.247, 0.286, 0.4],
  // sigma17
  supDrop: [0.386, 0.353, 0.494],
  // sigma18
  subDrop: [0.05, 0.071, 0.1],
  // sigma19
  delim1: [2.39, 1.7, 1.98],
  // sigma20
  delim2: [1.01, 1.157, 1.42],
  // sigma21
  axisHeight: [0.25, 0.25, 0.25],
  // sigma22
  // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
  // they correspond to the font parameters of the extension fonts (family 3).
  // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
  // match cmex7, we'd use cmex7.tfm values for script and scriptscript
  // values.
  defaultRuleThickness: [0.04, 0.049, 0.049],
  // xi8; cmex7: 0.049
  bigOpSpacing1: [0.111, 0.111, 0.111],
  // xi9
  bigOpSpacing2: [0.166, 0.166, 0.166],
  // xi10
  bigOpSpacing3: [0.2, 0.2, 0.2],
  // xi11
  bigOpSpacing4: [0.6, 0.611, 0.611],
  // xi12; cmex7: 0.611
  bigOpSpacing5: [0.1, 0.143, 0.143],
  // xi13; cmex7: 0.143
  // The \sqrt rule width is taken from the height of the surd character.
  // Since we use the same font at all sizes, this thickness doesn't scale.
  sqrtRuleThickness: [0.04, 0.04, 0.04],
  // This value determines how large a pt is, for metrics which are defined
  // in terms of pts.
  // This value is also used in katex.scss; if you change it make sure the
  // values match.
  ptPerEm: [10, 10, 10],
  // The space between adjacent `|` columns in an array definition. From
  // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
  doubleRuleSep: [0.2, 0.2, 0.2],
  // The width of separator lines in {array} environments. From
  // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
  arrayRuleWidth: [0.04, 0.04, 0.04],
  // Two values from LaTeX source2e:
  fboxsep: [0.3, 0.3, 0.3],
  //        3 pt / ptPerEm
  fboxrule: [0.04, 0.04, 0.04]
  // 0.4 pt / ptPerEm
}, KS = {
  // Latin-1
  Å: "A",
  Ð: "D",
  Þ: "o",
  å: "a",
  ð: "d",
  þ: "o",
  // Cyrillic
  А: "A",
  Б: "B",
  В: "B",
  Г: "F",
  Д: "A",
  Е: "E",
  Ж: "K",
  З: "3",
  И: "N",
  Й: "N",
  К: "K",
  Л: "N",
  М: "M",
  Н: "H",
  О: "O",
  П: "N",
  Р: "P",
  С: "C",
  Т: "T",
  У: "y",
  Ф: "O",
  Х: "X",
  Ц: "U",
  Ч: "h",
  Ш: "W",
  Щ: "W",
  Ъ: "B",
  Ы: "X",
  Ь: "B",
  Э: "3",
  Ю: "X",
  Я: "R",
  а: "a",
  б: "b",
  в: "a",
  г: "r",
  д: "y",
  е: "e",
  ж: "m",
  з: "e",
  и: "n",
  й: "n",
  к: "n",
  л: "n",
  м: "m",
  н: "n",
  о: "o",
  п: "n",
  р: "p",
  с: "c",
  т: "o",
  у: "y",
  ф: "b",
  х: "x",
  ц: "n",
  ч: "n",
  ш: "w",
  щ: "w",
  ъ: "a",
  ы: "m",
  ь: "a",
  э: "e",
  ю: "m",
  я: "r"
};
function xse(n, e) {
  Xs[n] = e;
}
function t6(n, e, t) {
  if (!Xs[e])
    throw new Error("Font metrics not found for font: " + e + ".");
  var r = n.charCodeAt(0), i = Xs[e][r];
  if (!i && n[0] in KS && (r = KS[n[0]].charCodeAt(0), i = Xs[e][r]), !i && t === "text" && BD(r) && (i = Xs[e][77]), i)
    return {
      depth: i[0],
      height: i[1],
      italic: i[2],
      skew: i[3],
      width: i[4]
    };
}
var M2 = {};
function Sse(n) {
  var e;
  if (n >= 5 ? e = 0 : n >= 3 ? e = 1 : e = 2, !M2[e]) {
    var t = M2[e] = {
      cssEmPerMu: lm.quad[e] / 18
    };
    for (var r in lm)
      lm.hasOwnProperty(r) && (t[r] = lm[r][e]);
  }
  return M2[e];
}
var Cse = [
  // Each element contains [textsize, scriptsize, scriptscriptsize].
  // The size mappings are taken from TeX with \normalsize=10pt.
  [1, 1, 1],
  // size1: [5, 5, 5]              \tiny
  [2, 1, 1],
  // size2: [6, 5, 5]
  [3, 1, 1],
  // size3: [7, 5, 5]              \scriptsize
  [4, 2, 1],
  // size4: [8, 6, 5]              \footnotesize
  [5, 2, 1],
  // size5: [9, 6, 5]              \small
  [6, 3, 1],
  // size6: [10, 7, 5]             \normalsize
  [7, 4, 2],
  // size7: [12, 8, 6]             \large
  [8, 6, 3],
  // size8: [14.4, 10, 7]          \Large
  [9, 7, 6],
  // size9: [17.28, 12, 10]        \LARGE
  [10, 8, 7],
  // size10: [20.74, 14.4, 12]     \huge
  [11, 10, 9]
  // size11: [24.88, 20.74, 17.28] \HUGE
], GS = [
  // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
  // you change size indexes, change that function.
  0.5,
  0.6,
  0.7,
  0.8,
  0.9,
  1,
  1.2,
  1.44,
  1.728,
  2.074,
  2.488
], JS = function(e, t) {
  return t.size < 2 ? e : Cse[e - 1][t.size - 1];
};
class Bo {
  // A font family applies to a group of fonts (i.e. SansSerif), while a font
  // represents a specific font (i.e. SansSerif Bold).
  // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
  /**
   * The base size index.
   */
  constructor(e) {
    this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = e.style, this.color = e.color, this.size = e.size || Bo.BASESIZE, this.textSize = e.textSize || this.size, this.phantom = !!e.phantom, this.font = e.font || "", this.fontFamily = e.fontFamily || "", this.fontWeight = e.fontWeight || "", this.fontShape = e.fontShape || "", this.sizeMultiplier = GS[this.size - 1], this.maxSize = e.maxSize, this.minRuleThickness = e.minRuleThickness, this._fontMetrics = void 0;
  }
  /**
   * Returns a new options object with the same properties as "this".  Properties
   * from "extension" will be copied to the new options object.
   */
  extend(e) {
    var t = {
      style: this.style,
      size: this.size,
      textSize: this.textSize,
      color: this.color,
      phantom: this.phantom,
      font: this.font,
      fontFamily: this.fontFamily,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize,
      minRuleThickness: this.minRuleThickness
    };
    for (var r in e)
      e.hasOwnProperty(r) && (t[r] = e[r]);
    return new Bo(t);
  }
  /**
   * Return an options object with the given style. If `this.style === style`,
   * returns `this`.
   */
  havingStyle(e) {
    return this.style === e ? this : this.extend({
      style: e,
      size: JS(this.textSize, e)
    });
  }
  /**
   * Return an options object with a cramped version of the current style. If
   * the current style is cramped, returns `this`.
   */
  havingCrampedStyle() {
    return this.havingStyle(this.style.cramp());
  }
  /**
   * Return an options object with the given size and in at least `\textstyle`.
   * Returns `this` if appropriate.
   */
  havingSize(e) {
    return this.size === e && this.textSize === e ? this : this.extend({
      style: this.style.text(),
      size: e,
      textSize: e,
      sizeMultiplier: GS[e - 1]
    });
  }
  /**
   * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
   * changes to at least `\textstyle`.
   */
  havingBaseStyle(e) {
    e = e || this.style.text();
    var t = JS(Bo.BASESIZE, e);
    return this.size === t && this.textSize === Bo.BASESIZE && this.style === e ? this : this.extend({
      style: e,
      size: t
    });
  }
  /**
   * Remove the effect of sizing changes such as \Huge.
   * Keep the effect of the current style, such as \scriptstyle.
   */
  havingBaseSizing() {
    var e;
    switch (this.style.id) {
      case 4:
      case 5:
        e = 3;
        break;
      case 6:
      case 7:
        e = 1;
        break;
      default:
        e = 6;
    }
    return this.extend({
      style: this.style.text(),
      size: e
    });
  }
  /**
   * Create a new options object with the given color.
   */
  withColor(e) {
    return this.extend({
      color: e
    });
  }
  /**
   * Create a new options object with "phantom" set to true.
   */
  withPhantom() {
    return this.extend({
      phantom: !0
    });
  }
  /**
   * Creates a new options object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(e) {
    return this.extend({
      font: e
    });
  }
  /**
   * Create a new options objects with the given fontFamily.
   */
  withTextFontFamily(e) {
    return this.extend({
      fontFamily: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontWeight(e) {
    return this.extend({
      fontWeight: e,
      font: ""
    });
  }
  /**
   * Creates a new options object with the given font weight
   */
  withTextFontShape(e) {
    return this.extend({
      fontShape: e,
      font: ""
    });
  }
  /**
   * Return the CSS sizing classes required to switch from enclosing options
   * `oldOptions` to `this`. Returns an array of classes.
   */
  sizingClasses(e) {
    return e.size !== this.size ? ["sizing", "reset-size" + e.size, "size" + this.size] : [];
  }
  /**
   * Return the CSS sizing classes required to switch to the base size. Like
   * `this.havingSize(BASESIZE).sizingClasses(this)`.
   */
  baseSizingClasses() {
    return this.size !== Bo.BASESIZE ? ["sizing", "reset-size" + this.size, "size" + Bo.BASESIZE] : [];
  }
  /**
   * Return the font metrics for this size.
   */
  fontMetrics() {
    return this._fontMetrics || (this._fontMetrics = Sse(this.size)), this._fontMetrics;
  }
  /**
   * Gets the CSS color of the current options object
   */
  getColor() {
    return this.phantom ? "transparent" : this.color;
  }
}
Bo.BASESIZE = 6;
var K4 = {
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 1,
  // TeX point
  mm: 7227 / 2540,
  // millimeter
  cm: 7227 / 254,
  // centimeter
  in: 72.27,
  // inch
  bp: 803 / 800,
  // big (PostScript) points
  pc: 12,
  // pica
  dd: 1238 / 1157,
  // didot
  cc: 14856 / 1157,
  // cicero (12 didot)
  nd: 685 / 642,
  // new didot
  nc: 1370 / 107,
  // new cicero (12 new didot)
  sp: 1 / 65536,
  // scaled point (TeX's internal smallest unit)
  // https://tex.stackexchange.com/a/41371
  px: 803 / 800
  // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
}, Mse = {
  ex: !0,
  em: !0,
  mu: !0
}, HD = function(e) {
  return typeof e != "string" && (e = e.unit), e in K4 || e in Mse || e === "ex";
}, Sn = function(e, t) {
  var r;
  if (e.unit in K4)
    r = K4[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
  else if (e.unit === "mu")
    r = t.fontMetrics().cssEmPerMu;
  else {
    var i;
    if (t.style.isTight() ? i = t.havingStyle(t.style.text()) : i = t, e.unit === "ex")
      r = i.fontMetrics().xHeight;
    else if (e.unit === "em")
      r = i.fontMetrics().quad;
    else
      throw new ke("Invalid unit: '" + e.unit + "'");
    i !== t && (r *= i.sizeMultiplier / t.sizeMultiplier);
  }
  return Math.min(e.number * r, t.maxSize);
}, Te = function(e) {
  return +e.toFixed(4) + "em";
}, cl = function(e) {
  return e.filter((t) => t).join(" ");
}, zD = function(e, t, r) {
  if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, t) {
    t.style.isTight() && this.classes.push("mtight");
    var i = t.getColor();
    i && (this.style.color = i);
  }
}, FD = function(e) {
  var t = document.createElement(e);
  t.className = cl(this.classes);
  for (var r in this.style)
    this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
  for (var i in this.attributes)
    this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
  for (var s = 0; s < this.children.length; s++)
    t.appendChild(this.children[s].toNode());
  return t;
}, Tse = /[\s"'>/=\x00-\x1f]/, VD = function(e) {
  var t = "<" + e;
  this.classes.length && (t += ' class="' + et.escape(cl(this.classes)) + '"');
  var r = "";
  for (var i in this.style)
    this.style.hasOwnProperty(i) && (r += et.hyphenate(i) + ":" + this.style[i] + ";");
  r && (t += ' style="' + et.escape(r) + '"');
  for (var s in this.attributes)
    if (this.attributes.hasOwnProperty(s)) {
      if (Tse.test(s))
        throw new ke("Invalid attribute name '" + s + "'");
      t += " " + s + '="' + et.escape(this.attributes[s]) + '"';
    }
  t += ">";
  for (var o = 0; o < this.children.length; o++)
    t += this.children[o].toMarkup();
  return t += "</" + e + ">", t;
};
class up {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, zD.call(this, e, r, i), this.children = t || [];
  }
  /**
   * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
   * all browsers support attributes the same, and having too many custom
   * attributes is probably bad.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return et.contains(this.classes, e);
  }
  toNode() {
    return FD.call(this, "span");
  }
  toMarkup() {
    return VD.call(this, "span");
  }
}
class n6 {
  constructor(e, t, r, i) {
    this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, zD.call(this, t, i), this.children = r || [], this.setAttribute("href", e);
  }
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  hasClass(e) {
    return et.contains(this.classes, e);
  }
  toNode() {
    return FD.call(this, "a");
  }
  toMarkup() {
    return VD.call(this, "a");
  }
}
class Ase {
  constructor(e, t, r) {
    this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = r;
  }
  hasClass(e) {
    return et.contains(this.classes, e);
  }
  toNode() {
    var e = document.createElement("img");
    e.src = this.src, e.alt = this.alt, e.className = "mord";
    for (var t in this.style)
      this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
    return e;
  }
  toMarkup() {
    var e = '<img src="' + et.escape(this.src) + '"' + (' alt="' + et.escape(this.alt) + '"'), t = "";
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t += et.hyphenate(r) + ":" + this.style[r] + ";");
    return t && (e += ' style="' + et.escape(t) + '"'), e += "'/>", e;
  }
}
var Ese = {
  î: "ı̂",
  ï: "ı̈",
  í: "ı́",
  // 'ī': '\u0131\u0304', // enable when we add Extended Latin
  ì: "ı̀"
};
class es {
  constructor(e, t, r, i, s, o, a, l) {
    this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = r || 0, this.italic = i || 0, this.skew = s || 0, this.width = o || 0, this.classes = a || [], this.style = l || {}, this.maxFontSize = 0;
    var c = hse(this.text.charCodeAt(0));
    c && this.classes.push(c + "_fallback"), /[îïíì]/.test(this.text) && (this.text = Ese[this.text]);
  }
  hasClass(e) {
    return et.contains(this.classes, e);
  }
  /**
   * Creates a text node or span from a symbol node. Note that a span is only
   * created if it is needed.
   */
  toNode() {
    var e = document.createTextNode(this.text), t = null;
    this.italic > 0 && (t = document.createElement("span"), t.style.marginRight = Te(this.italic)), this.classes.length > 0 && (t = t || document.createElement("span"), t.className = cl(this.classes));
    for (var r in this.style)
      this.style.hasOwnProperty(r) && (t = t || document.createElement("span"), t.style[r] = this.style[r]);
    return t ? (t.appendChild(e), t) : e;
  }
  /**
   * Creates markup for a symbol node.
   */
  toMarkup() {
    var e = !1, t = "<span";
    this.classes.length && (e = !0, t += ' class="', t += et.escape(cl(this.classes)), t += '"');
    var r = "";
    this.italic > 0 && (r += "margin-right:" + this.italic + "em;");
    for (var i in this.style)
      this.style.hasOwnProperty(i) && (r += et.hyphenate(i) + ":" + this.style[i] + ";");
    r && (e = !0, t += ' style="' + et.escape(r) + '"');
    var s = et.escape(this.text);
    return e ? (t += ">", t += s, t += "</span>", t) : s;
  }
}
class aa {
  constructor(e, t) {
    this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "svg");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    for (var i = 0; i < this.children.length; i++)
      t.appendChild(this.children[i].toNode());
    return t;
  }
  toMarkup() {
    var e = '<svg xmlns="http://www.w3.org/2000/svg"';
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + et.escape(this.attributes[t]) + '"');
    e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</svg>", e;
  }
}
class ul {
  constructor(e, t) {
    this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "path");
    return this.alternate ? t.setAttribute("d", this.alternate) : t.setAttribute("d", US[this.pathName]), t;
  }
  toMarkup() {
    return this.alternate ? '<path d="' + et.escape(this.alternate) + '"/>' : '<path d="' + et.escape(US[this.pathName]) + '"/>';
  }
}
class G4 {
  constructor(e) {
    this.attributes = void 0, this.attributes = e || {};
  }
  toNode() {
    var e = "http://www.w3.org/2000/svg", t = document.createElementNS(e, "line");
    for (var r in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, r) && t.setAttribute(r, this.attributes[r]);
    return t;
  }
  toMarkup() {
    var e = "<line";
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="' + et.escape(this.attributes[t]) + '"');
    return e += "/>", e;
  }
}
function YS(n) {
  if (n instanceof es)
    return n;
  throw new Error("Expected symbolNode but got " + String(n) + ".");
}
function Lse(n) {
  if (n instanceof up)
    return n;
  throw new Error("Expected span<HtmlDomNode> but got " + String(n) + ".");
}
var Ose = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
}, Dse = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
}, ln = {
  math: {},
  text: {}
};
function A(n, e, t, r, i, s) {
  ln[n][i] = {
    font: e,
    group: t,
    replace: r
  }, s && r && (ln[n][r] = ln[n][i]);
}
var L = "math", me = "text", N = "main", $ = "ams", vn = "accent-token", Fe = "bin", Fr = "close", Vh = "inner", st = "mathord", Wn = "op-token", Ni = "open", Ay = "punct", j = "rel", ya = "spacing", X = "textord";
A(L, N, j, "≡", "\\equiv", !0);
A(L, N, j, "≺", "\\prec", !0);
A(L, N, j, "≻", "\\succ", !0);
A(L, N, j, "∼", "\\sim", !0);
A(L, N, j, "⊥", "\\perp");
A(L, N, j, "⪯", "\\preceq", !0);
A(L, N, j, "⪰", "\\succeq", !0);
A(L, N, j, "≃", "\\simeq", !0);
A(L, N, j, "∣", "\\mid", !0);
A(L, N, j, "≪", "\\ll", !0);
A(L, N, j, "≫", "\\gg", !0);
A(L, N, j, "≍", "\\asymp", !0);
A(L, N, j, "∥", "\\parallel");
A(L, N, j, "⋈", "\\bowtie", !0);
A(L, N, j, "⌣", "\\smile", !0);
A(L, N, j, "⊑", "\\sqsubseteq", !0);
A(L, N, j, "⊒", "\\sqsupseteq", !0);
A(L, N, j, "≐", "\\doteq", !0);
A(L, N, j, "⌢", "\\frown", !0);
A(L, N, j, "∋", "\\ni", !0);
A(L, N, j, "∝", "\\propto", !0);
A(L, N, j, "⊢", "\\vdash", !0);
A(L, N, j, "⊣", "\\dashv", !0);
A(L, N, j, "∋", "\\owns");
A(L, N, Ay, ".", "\\ldotp");
A(L, N, Ay, "⋅", "\\cdotp");
A(L, N, X, "#", "\\#");
A(me, N, X, "#", "\\#");
A(L, N, X, "&", "\\&");
A(me, N, X, "&", "\\&");
A(L, N, X, "ℵ", "\\aleph", !0);
A(L, N, X, "∀", "\\forall", !0);
A(L, N, X, "ℏ", "\\hbar", !0);
A(L, N, X, "∃", "\\exists", !0);
A(L, N, X, "∇", "\\nabla", !0);
A(L, N, X, "♭", "\\flat", !0);
A(L, N, X, "ℓ", "\\ell", !0);
A(L, N, X, "♮", "\\natural", !0);
A(L, N, X, "♣", "\\clubsuit", !0);
A(L, N, X, "℘", "\\wp", !0);
A(L, N, X, "♯", "\\sharp", !0);
A(L, N, X, "♢", "\\diamondsuit", !0);
A(L, N, X, "ℜ", "\\Re", !0);
A(L, N, X, "♡", "\\heartsuit", !0);
A(L, N, X, "ℑ", "\\Im", !0);
A(L, N, X, "♠", "\\spadesuit", !0);
A(L, N, X, "§", "\\S", !0);
A(me, N, X, "§", "\\S");
A(L, N, X, "¶", "\\P", !0);
A(me, N, X, "¶", "\\P");
A(L, N, X, "†", "\\dag");
A(me, N, X, "†", "\\dag");
A(me, N, X, "†", "\\textdagger");
A(L, N, X, "‡", "\\ddag");
A(me, N, X, "‡", "\\ddag");
A(me, N, X, "‡", "\\textdaggerdbl");
A(L, N, Fr, "⎱", "\\rmoustache", !0);
A(L, N, Ni, "⎰", "\\lmoustache", !0);
A(L, N, Fr, "⟯", "\\rgroup", !0);
A(L, N, Ni, "⟮", "\\lgroup", !0);
A(L, N, Fe, "∓", "\\mp", !0);
A(L, N, Fe, "⊖", "\\ominus", !0);
A(L, N, Fe, "⊎", "\\uplus", !0);
A(L, N, Fe, "⊓", "\\sqcap", !0);
A(L, N, Fe, "∗", "\\ast");
A(L, N, Fe, "⊔", "\\sqcup", !0);
A(L, N, Fe, "◯", "\\bigcirc", !0);
A(L, N, Fe, "∙", "\\bullet", !0);
A(L, N, Fe, "‡", "\\ddagger");
A(L, N, Fe, "≀", "\\wr", !0);
A(L, N, Fe, "⨿", "\\amalg");
A(L, N, Fe, "&", "\\And");
A(L, N, j, "⟵", "\\longleftarrow", !0);
A(L, N, j, "⇐", "\\Leftarrow", !0);
A(L, N, j, "⟸", "\\Longleftarrow", !0);
A(L, N, j, "⟶", "\\longrightarrow", !0);
A(L, N, j, "⇒", "\\Rightarrow", !0);
A(L, N, j, "⟹", "\\Longrightarrow", !0);
A(L, N, j, "↔", "\\leftrightarrow", !0);
A(L, N, j, "⟷", "\\longleftrightarrow", !0);
A(L, N, j, "⇔", "\\Leftrightarrow", !0);
A(L, N, j, "⟺", "\\Longleftrightarrow", !0);
A(L, N, j, "↦", "\\mapsto", !0);
A(L, N, j, "⟼", "\\longmapsto", !0);
A(L, N, j, "↗", "\\nearrow", !0);
A(L, N, j, "↩", "\\hookleftarrow", !0);
A(L, N, j, "↪", "\\hookrightarrow", !0);
A(L, N, j, "↘", "\\searrow", !0);
A(L, N, j, "↼", "\\leftharpoonup", !0);
A(L, N, j, "⇀", "\\rightharpoonup", !0);
A(L, N, j, "↙", "\\swarrow", !0);
A(L, N, j, "↽", "\\leftharpoondown", !0);
A(L, N, j, "⇁", "\\rightharpoondown", !0);
A(L, N, j, "↖", "\\nwarrow", !0);
A(L, N, j, "⇌", "\\rightleftharpoons", !0);
A(L, $, j, "≮", "\\nless", !0);
A(L, $, j, "", "\\@nleqslant");
A(L, $, j, "", "\\@nleqq");
A(L, $, j, "⪇", "\\lneq", !0);
A(L, $, j, "≨", "\\lneqq", !0);
A(L, $, j, "", "\\@lvertneqq");
A(L, $, j, "⋦", "\\lnsim", !0);
A(L, $, j, "⪉", "\\lnapprox", !0);
A(L, $, j, "⊀", "\\nprec", !0);
A(L, $, j, "⋠", "\\npreceq", !0);
A(L, $, j, "⋨", "\\precnsim", !0);
A(L, $, j, "⪹", "\\precnapprox", !0);
A(L, $, j, "≁", "\\nsim", !0);
A(L, $, j, "", "\\@nshortmid");
A(L, $, j, "∤", "\\nmid", !0);
A(L, $, j, "⊬", "\\nvdash", !0);
A(L, $, j, "⊭", "\\nvDash", !0);
A(L, $, j, "⋪", "\\ntriangleleft");
A(L, $, j, "⋬", "\\ntrianglelefteq", !0);
A(L, $, j, "⊊", "\\subsetneq", !0);
A(L, $, j, "", "\\@varsubsetneq");
A(L, $, j, "⫋", "\\subsetneqq", !0);
A(L, $, j, "", "\\@varsubsetneqq");
A(L, $, j, "≯", "\\ngtr", !0);
A(L, $, j, "", "\\@ngeqslant");
A(L, $, j, "", "\\@ngeqq");
A(L, $, j, "⪈", "\\gneq", !0);
A(L, $, j, "≩", "\\gneqq", !0);
A(L, $, j, "", "\\@gvertneqq");
A(L, $, j, "⋧", "\\gnsim", !0);
A(L, $, j, "⪊", "\\gnapprox", !0);
A(L, $, j, "⊁", "\\nsucc", !0);
A(L, $, j, "⋡", "\\nsucceq", !0);
A(L, $, j, "⋩", "\\succnsim", !0);
A(L, $, j, "⪺", "\\succnapprox", !0);
A(L, $, j, "≆", "\\ncong", !0);
A(L, $, j, "", "\\@nshortparallel");
A(L, $, j, "∦", "\\nparallel", !0);
A(L, $, j, "⊯", "\\nVDash", !0);
A(L, $, j, "⋫", "\\ntriangleright");
A(L, $, j, "⋭", "\\ntrianglerighteq", !0);
A(L, $, j, "", "\\@nsupseteqq");
A(L, $, j, "⊋", "\\supsetneq", !0);
A(L, $, j, "", "\\@varsupsetneq");
A(L, $, j, "⫌", "\\supsetneqq", !0);
A(L, $, j, "", "\\@varsupsetneqq");
A(L, $, j, "⊮", "\\nVdash", !0);
A(L, $, j, "⪵", "\\precneqq", !0);
A(L, $, j, "⪶", "\\succneqq", !0);
A(L, $, j, "", "\\@nsubseteqq");
A(L, $, Fe, "⊴", "\\unlhd");
A(L, $, Fe, "⊵", "\\unrhd");
A(L, $, j, "↚", "\\nleftarrow", !0);
A(L, $, j, "↛", "\\nrightarrow", !0);
A(L, $, j, "⇍", "\\nLeftarrow", !0);
A(L, $, j, "⇏", "\\nRightarrow", !0);
A(L, $, j, "↮", "\\nleftrightarrow", !0);
A(L, $, j, "⇎", "\\nLeftrightarrow", !0);
A(L, $, j, "△", "\\vartriangle");
A(L, $, X, "ℏ", "\\hslash");
A(L, $, X, "▽", "\\triangledown");
A(L, $, X, "◊", "\\lozenge");
A(L, $, X, "Ⓢ", "\\circledS");
A(L, $, X, "®", "\\circledR");
A(me, $, X, "®", "\\circledR");
A(L, $, X, "∡", "\\measuredangle", !0);
A(L, $, X, "∄", "\\nexists");
A(L, $, X, "℧", "\\mho");
A(L, $, X, "Ⅎ", "\\Finv", !0);
A(L, $, X, "⅁", "\\Game", !0);
A(L, $, X, "‵", "\\backprime");
A(L, $, X, "▲", "\\blacktriangle");
A(L, $, X, "▼", "\\blacktriangledown");
A(L, $, X, "■", "\\blacksquare");
A(L, $, X, "⧫", "\\blacklozenge");
A(L, $, X, "★", "\\bigstar");
A(L, $, X, "∢", "\\sphericalangle", !0);
A(L, $, X, "∁", "\\complement", !0);
A(L, $, X, "ð", "\\eth", !0);
A(me, N, X, "ð", "ð");
A(L, $, X, "╱", "\\diagup");
A(L, $, X, "╲", "\\diagdown");
A(L, $, X, "□", "\\square");
A(L, $, X, "□", "\\Box");
A(L, $, X, "◊", "\\Diamond");
A(L, $, X, "¥", "\\yen", !0);
A(me, $, X, "¥", "\\yen", !0);
A(L, $, X, "✓", "\\checkmark", !0);
A(me, $, X, "✓", "\\checkmark");
A(L, $, X, "ℶ", "\\beth", !0);
A(L, $, X, "ℸ", "\\daleth", !0);
A(L, $, X, "ℷ", "\\gimel", !0);
A(L, $, X, "ϝ", "\\digamma", !0);
A(L, $, X, "ϰ", "\\varkappa");
A(L, $, Ni, "┌", "\\@ulcorner", !0);
A(L, $, Fr, "┐", "\\@urcorner", !0);
A(L, $, Ni, "└", "\\@llcorner", !0);
A(L, $, Fr, "┘", "\\@lrcorner", !0);
A(L, $, j, "≦", "\\leqq", !0);
A(L, $, j, "⩽", "\\leqslant", !0);
A(L, $, j, "⪕", "\\eqslantless", !0);
A(L, $, j, "≲", "\\lesssim", !0);
A(L, $, j, "⪅", "\\lessapprox", !0);
A(L, $, j, "≊", "\\approxeq", !0);
A(L, $, Fe, "⋖", "\\lessdot");
A(L, $, j, "⋘", "\\lll", !0);
A(L, $, j, "≶", "\\lessgtr", !0);
A(L, $, j, "⋚", "\\lesseqgtr", !0);
A(L, $, j, "⪋", "\\lesseqqgtr", !0);
A(L, $, j, "≑", "\\doteqdot");
A(L, $, j, "≓", "\\risingdotseq", !0);
A(L, $, j, "≒", "\\fallingdotseq", !0);
A(L, $, j, "∽", "\\backsim", !0);
A(L, $, j, "⋍", "\\backsimeq", !0);
A(L, $, j, "⫅", "\\subseteqq", !0);
A(L, $, j, "⋐", "\\Subset", !0);
A(L, $, j, "⊏", "\\sqsubset", !0);
A(L, $, j, "≼", "\\preccurlyeq", !0);
A(L, $, j, "⋞", "\\curlyeqprec", !0);
A(L, $, j, "≾", "\\precsim", !0);
A(L, $, j, "⪷", "\\precapprox", !0);
A(L, $, j, "⊲", "\\vartriangleleft");
A(L, $, j, "⊴", "\\trianglelefteq");
A(L, $, j, "⊨", "\\vDash", !0);
A(L, $, j, "⊪", "\\Vvdash", !0);
A(L, $, j, "⌣", "\\smallsmile");
A(L, $, j, "⌢", "\\smallfrown");
A(L, $, j, "≏", "\\bumpeq", !0);
A(L, $, j, "≎", "\\Bumpeq", !0);
A(L, $, j, "≧", "\\geqq", !0);
A(L, $, j, "⩾", "\\geqslant", !0);
A(L, $, j, "⪖", "\\eqslantgtr", !0);
A(L, $, j, "≳", "\\gtrsim", !0);
A(L, $, j, "⪆", "\\gtrapprox", !0);
A(L, $, Fe, "⋗", "\\gtrdot");
A(L, $, j, "⋙", "\\ggg", !0);
A(L, $, j, "≷", "\\gtrless", !0);
A(L, $, j, "⋛", "\\gtreqless", !0);
A(L, $, j, "⪌", "\\gtreqqless", !0);
A(L, $, j, "≖", "\\eqcirc", !0);
A(L, $, j, "≗", "\\circeq", !0);
A(L, $, j, "≜", "\\triangleq", !0);
A(L, $, j, "∼", "\\thicksim");
A(L, $, j, "≈", "\\thickapprox");
A(L, $, j, "⫆", "\\supseteqq", !0);
A(L, $, j, "⋑", "\\Supset", !0);
A(L, $, j, "⊐", "\\sqsupset", !0);
A(L, $, j, "≽", "\\succcurlyeq", !0);
A(L, $, j, "⋟", "\\curlyeqsucc", !0);
A(L, $, j, "≿", "\\succsim", !0);
A(L, $, j, "⪸", "\\succapprox", !0);
A(L, $, j, "⊳", "\\vartriangleright");
A(L, $, j, "⊵", "\\trianglerighteq");
A(L, $, j, "⊩", "\\Vdash", !0);
A(L, $, j, "∣", "\\shortmid");
A(L, $, j, "∥", "\\shortparallel");
A(L, $, j, "≬", "\\between", !0);
A(L, $, j, "⋔", "\\pitchfork", !0);
A(L, $, j, "∝", "\\varpropto");
A(L, $, j, "◀", "\\blacktriangleleft");
A(L, $, j, "∴", "\\therefore", !0);
A(L, $, j, "∍", "\\backepsilon");
A(L, $, j, "▶", "\\blacktriangleright");
A(L, $, j, "∵", "\\because", !0);
A(L, $, j, "⋘", "\\llless");
A(L, $, j, "⋙", "\\gggtr");
A(L, $, Fe, "⊲", "\\lhd");
A(L, $, Fe, "⊳", "\\rhd");
A(L, $, j, "≂", "\\eqsim", !0);
A(L, N, j, "⋈", "\\Join");
A(L, $, j, "≑", "\\Doteq", !0);
A(L, $, Fe, "∔", "\\dotplus", !0);
A(L, $, Fe, "∖", "\\smallsetminus");
A(L, $, Fe, "⋒", "\\Cap", !0);
A(L, $, Fe, "⋓", "\\Cup", !0);
A(L, $, Fe, "⩞", "\\doublebarwedge", !0);
A(L, $, Fe, "⊟", "\\boxminus", !0);
A(L, $, Fe, "⊞", "\\boxplus", !0);
A(L, $, Fe, "⋇", "\\divideontimes", !0);
A(L, $, Fe, "⋉", "\\ltimes", !0);
A(L, $, Fe, "⋊", "\\rtimes", !0);
A(L, $, Fe, "⋋", "\\leftthreetimes", !0);
A(L, $, Fe, "⋌", "\\rightthreetimes", !0);
A(L, $, Fe, "⋏", "\\curlywedge", !0);
A(L, $, Fe, "⋎", "\\curlyvee", !0);
A(L, $, Fe, "⊝", "\\circleddash", !0);
A(L, $, Fe, "⊛", "\\circledast", !0);
A(L, $, Fe, "⋅", "\\centerdot");
A(L, $, Fe, "⊺", "\\intercal", !0);
A(L, $, Fe, "⋒", "\\doublecap");
A(L, $, Fe, "⋓", "\\doublecup");
A(L, $, Fe, "⊠", "\\boxtimes", !0);
A(L, $, j, "⇢", "\\dashrightarrow", !0);
A(L, $, j, "⇠", "\\dashleftarrow", !0);
A(L, $, j, "⇇", "\\leftleftarrows", !0);
A(L, $, j, "⇆", "\\leftrightarrows", !0);
A(L, $, j, "⇚", "\\Lleftarrow", !0);
A(L, $, j, "↞", "\\twoheadleftarrow", !0);
A(L, $, j, "↢", "\\leftarrowtail", !0);
A(L, $, j, "↫", "\\looparrowleft", !0);
A(L, $, j, "⇋", "\\leftrightharpoons", !0);
A(L, $, j, "↶", "\\curvearrowleft", !0);
A(L, $, j, "↺", "\\circlearrowleft", !0);
A(L, $, j, "↰", "\\Lsh", !0);
A(L, $, j, "⇈", "\\upuparrows", !0);
A(L, $, j, "↿", "\\upharpoonleft", !0);
A(L, $, j, "⇃", "\\downharpoonleft", !0);
A(L, N, j, "⊶", "\\origof", !0);
A(L, N, j, "⊷", "\\imageof", !0);
A(L, $, j, "⊸", "\\multimap", !0);
A(L, $, j, "↭", "\\leftrightsquigarrow", !0);
A(L, $, j, "⇉", "\\rightrightarrows", !0);
A(L, $, j, "⇄", "\\rightleftarrows", !0);
A(L, $, j, "↠", "\\twoheadrightarrow", !0);
A(L, $, j, "↣", "\\rightarrowtail", !0);
A(L, $, j, "↬", "\\looparrowright", !0);
A(L, $, j, "↷", "\\curvearrowright", !0);
A(L, $, j, "↻", "\\circlearrowright", !0);
A(L, $, j, "↱", "\\Rsh", !0);
A(L, $, j, "⇊", "\\downdownarrows", !0);
A(L, $, j, "↾", "\\upharpoonright", !0);
A(L, $, j, "⇂", "\\downharpoonright", !0);
A(L, $, j, "⇝", "\\rightsquigarrow", !0);
A(L, $, j, "⇝", "\\leadsto");
A(L, $, j, "⇛", "\\Rrightarrow", !0);
A(L, $, j, "↾", "\\restriction");
A(L, N, X, "‘", "`");
A(L, N, X, "$", "\\$");
A(me, N, X, "$", "\\$");
A(me, N, X, "$", "\\textdollar");
A(L, N, X, "%", "\\%");
A(me, N, X, "%", "\\%");
A(L, N, X, "_", "\\_");
A(me, N, X, "_", "\\_");
A(me, N, X, "_", "\\textunderscore");
A(L, N, X, "∠", "\\angle", !0);
A(L, N, X, "∞", "\\infty", !0);
A(L, N, X, "′", "\\prime");
A(L, N, X, "△", "\\triangle");
A(L, N, X, "Γ", "\\Gamma", !0);
A(L, N, X, "Δ", "\\Delta", !0);
A(L, N, X, "Θ", "\\Theta", !0);
A(L, N, X, "Λ", "\\Lambda", !0);
A(L, N, X, "Ξ", "\\Xi", !0);
A(L, N, X, "Π", "\\Pi", !0);
A(L, N, X, "Σ", "\\Sigma", !0);
A(L, N, X, "Υ", "\\Upsilon", !0);
A(L, N, X, "Φ", "\\Phi", !0);
A(L, N, X, "Ψ", "\\Psi", !0);
A(L, N, X, "Ω", "\\Omega", !0);
A(L, N, X, "A", "Α");
A(L, N, X, "B", "Β");
A(L, N, X, "E", "Ε");
A(L, N, X, "Z", "Ζ");
A(L, N, X, "H", "Η");
A(L, N, X, "I", "Ι");
A(L, N, X, "K", "Κ");
A(L, N, X, "M", "Μ");
A(L, N, X, "N", "Ν");
A(L, N, X, "O", "Ο");
A(L, N, X, "P", "Ρ");
A(L, N, X, "T", "Τ");
A(L, N, X, "X", "Χ");
A(L, N, X, "¬", "\\neg", !0);
A(L, N, X, "¬", "\\lnot");
A(L, N, X, "⊤", "\\top");
A(L, N, X, "⊥", "\\bot");
A(L, N, X, "∅", "\\emptyset");
A(L, $, X, "∅", "\\varnothing");
A(L, N, st, "α", "\\alpha", !0);
A(L, N, st, "β", "\\beta", !0);
A(L, N, st, "γ", "\\gamma", !0);
A(L, N, st, "δ", "\\delta", !0);
A(L, N, st, "ϵ", "\\epsilon", !0);
A(L, N, st, "ζ", "\\zeta", !0);
A(L, N, st, "η", "\\eta", !0);
A(L, N, st, "θ", "\\theta", !0);
A(L, N, st, "ι", "\\iota", !0);
A(L, N, st, "κ", "\\kappa", !0);
A(L, N, st, "λ", "\\lambda", !0);
A(L, N, st, "μ", "\\mu", !0);
A(L, N, st, "ν", "\\nu", !0);
A(L, N, st, "ξ", "\\xi", !0);
A(L, N, st, "ο", "\\omicron", !0);
A(L, N, st, "π", "\\pi", !0);
A(L, N, st, "ρ", "\\rho", !0);
A(L, N, st, "σ", "\\sigma", !0);
A(L, N, st, "τ", "\\tau", !0);
A(L, N, st, "υ", "\\upsilon", !0);
A(L, N, st, "ϕ", "\\phi", !0);
A(L, N, st, "χ", "\\chi", !0);
A(L, N, st, "ψ", "\\psi", !0);
A(L, N, st, "ω", "\\omega", !0);
A(L, N, st, "ε", "\\varepsilon", !0);
A(L, N, st, "ϑ", "\\vartheta", !0);
A(L, N, st, "ϖ", "\\varpi", !0);
A(L, N, st, "ϱ", "\\varrho", !0);
A(L, N, st, "ς", "\\varsigma", !0);
A(L, N, st, "φ", "\\varphi", !0);
A(L, N, Fe, "∗", "*", !0);
A(L, N, Fe, "+", "+");
A(L, N, Fe, "−", "-", !0);
A(L, N, Fe, "⋅", "\\cdot", !0);
A(L, N, Fe, "∘", "\\circ", !0);
A(L, N, Fe, "÷", "\\div", !0);
A(L, N, Fe, "±", "\\pm", !0);
A(L, N, Fe, "×", "\\times", !0);
A(L, N, Fe, "∩", "\\cap", !0);
A(L, N, Fe, "∪", "\\cup", !0);
A(L, N, Fe, "∖", "\\setminus", !0);
A(L, N, Fe, "∧", "\\land");
A(L, N, Fe, "∨", "\\lor");
A(L, N, Fe, "∧", "\\wedge", !0);
A(L, N, Fe, "∨", "\\vee", !0);
A(L, N, X, "√", "\\surd");
A(L, N, Ni, "⟨", "\\langle", !0);
A(L, N, Ni, "∣", "\\lvert");
A(L, N, Ni, "∥", "\\lVert");
A(L, N, Fr, "?", "?");
A(L, N, Fr, "!", "!");
A(L, N, Fr, "⟩", "\\rangle", !0);
A(L, N, Fr, "∣", "\\rvert");
A(L, N, Fr, "∥", "\\rVert");
A(L, N, j, "=", "=");
A(L, N, j, ":", ":");
A(L, N, j, "≈", "\\approx", !0);
A(L, N, j, "≅", "\\cong", !0);
A(L, N, j, "≥", "\\ge");
A(L, N, j, "≥", "\\geq", !0);
A(L, N, j, "←", "\\gets");
A(L, N, j, ">", "\\gt", !0);
A(L, N, j, "∈", "\\in", !0);
A(L, N, j, "", "\\@not");
A(L, N, j, "⊂", "\\subset", !0);
A(L, N, j, "⊃", "\\supset", !0);
A(L, N, j, "⊆", "\\subseteq", !0);
A(L, N, j, "⊇", "\\supseteq", !0);
A(L, $, j, "⊈", "\\nsubseteq", !0);
A(L, $, j, "⊉", "\\nsupseteq", !0);
A(L, N, j, "⊨", "\\models");
A(L, N, j, "←", "\\leftarrow", !0);
A(L, N, j, "≤", "\\le");
A(L, N, j, "≤", "\\leq", !0);
A(L, N, j, "<", "\\lt", !0);
A(L, N, j, "→", "\\rightarrow", !0);
A(L, N, j, "→", "\\to");
A(L, $, j, "≱", "\\ngeq", !0);
A(L, $, j, "≰", "\\nleq", !0);
A(L, N, ya, " ", "\\ ");
A(L, N, ya, " ", "\\space");
A(L, N, ya, " ", "\\nobreakspace");
A(me, N, ya, " ", "\\ ");
A(me, N, ya, " ", " ");
A(me, N, ya, " ", "\\space");
A(me, N, ya, " ", "\\nobreakspace");
A(L, N, ya, null, "\\nobreak");
A(L, N, ya, null, "\\allowbreak");
A(L, N, Ay, ",", ",");
A(L, N, Ay, ";", ";");
A(L, $, Fe, "⊼", "\\barwedge", !0);
A(L, $, Fe, "⊻", "\\veebar", !0);
A(L, N, Fe, "⊙", "\\odot", !0);
A(L, N, Fe, "⊕", "\\oplus", !0);
A(L, N, Fe, "⊗", "\\otimes", !0);
A(L, N, X, "∂", "\\partial", !0);
A(L, N, Fe, "⊘", "\\oslash", !0);
A(L, $, Fe, "⊚", "\\circledcirc", !0);
A(L, $, Fe, "⊡", "\\boxdot", !0);
A(L, N, Fe, "△", "\\bigtriangleup");
A(L, N, Fe, "▽", "\\bigtriangledown");
A(L, N, Fe, "†", "\\dagger");
A(L, N, Fe, "⋄", "\\diamond");
A(L, N, Fe, "⋆", "\\star");
A(L, N, Fe, "◃", "\\triangleleft");
A(L, N, Fe, "▹", "\\triangleright");
A(L, N, Ni, "{", "\\{");
A(me, N, X, "{", "\\{");
A(me, N, X, "{", "\\textbraceleft");
A(L, N, Fr, "}", "\\}");
A(me, N, X, "}", "\\}");
A(me, N, X, "}", "\\textbraceright");
A(L, N, Ni, "{", "\\lbrace");
A(L, N, Fr, "}", "\\rbrace");
A(L, N, Ni, "[", "\\lbrack", !0);
A(me, N, X, "[", "\\lbrack", !0);
A(L, N, Fr, "]", "\\rbrack", !0);
A(me, N, X, "]", "\\rbrack", !0);
A(L, N, Ni, "(", "\\lparen", !0);
A(L, N, Fr, ")", "\\rparen", !0);
A(me, N, X, "<", "\\textless", !0);
A(me, N, X, ">", "\\textgreater", !0);
A(L, N, Ni, "⌊", "\\lfloor", !0);
A(L, N, Fr, "⌋", "\\rfloor", !0);
A(L, N, Ni, "⌈", "\\lceil", !0);
A(L, N, Fr, "⌉", "\\rceil", !0);
A(L, N, X, "\\", "\\backslash");
A(L, N, X, "∣", "|");
A(L, N, X, "∣", "\\vert");
A(me, N, X, "|", "\\textbar", !0);
A(L, N, X, "∥", "\\|");
A(L, N, X, "∥", "\\Vert");
A(me, N, X, "∥", "\\textbardbl");
A(me, N, X, "~", "\\textasciitilde");
A(me, N, X, "\\", "\\textbackslash");
A(me, N, X, "^", "\\textasciicircum");
A(L, N, j, "↑", "\\uparrow", !0);
A(L, N, j, "⇑", "\\Uparrow", !0);
A(L, N, j, "↓", "\\downarrow", !0);
A(L, N, j, "⇓", "\\Downarrow", !0);
A(L, N, j, "↕", "\\updownarrow", !0);
A(L, N, j, "⇕", "\\Updownarrow", !0);
A(L, N, Wn, "∐", "\\coprod");
A(L, N, Wn, "⋁", "\\bigvee");
A(L, N, Wn, "⋀", "\\bigwedge");
A(L, N, Wn, "⨄", "\\biguplus");
A(L, N, Wn, "⋂", "\\bigcap");
A(L, N, Wn, "⋃", "\\bigcup");
A(L, N, Wn, "∫", "\\int");
A(L, N, Wn, "∫", "\\intop");
A(L, N, Wn, "∬", "\\iint");
A(L, N, Wn, "∭", "\\iiint");
A(L, N, Wn, "∏", "\\prod");
A(L, N, Wn, "∑", "\\sum");
A(L, N, Wn, "⨂", "\\bigotimes");
A(L, N, Wn, "⨁", "\\bigoplus");
A(L, N, Wn, "⨀", "\\bigodot");
A(L, N, Wn, "∮", "\\oint");
A(L, N, Wn, "∯", "\\oiint");
A(L, N, Wn, "∰", "\\oiiint");
A(L, N, Wn, "⨆", "\\bigsqcup");
A(L, N, Wn, "∫", "\\smallint");
A(me, N, Vh, "…", "\\textellipsis");
A(L, N, Vh, "…", "\\mathellipsis");
A(me, N, Vh, "…", "\\ldots", !0);
A(L, N, Vh, "…", "\\ldots", !0);
A(L, N, Vh, "⋯", "\\@cdots", !0);
A(L, N, Vh, "⋱", "\\ddots", !0);
A(L, N, X, "⋮", "\\varvdots");
A(me, N, X, "⋮", "\\varvdots");
A(L, N, vn, "ˊ", "\\acute");
A(L, N, vn, "ˋ", "\\grave");
A(L, N, vn, "¨", "\\ddot");
A(L, N, vn, "~", "\\tilde");
A(L, N, vn, "ˉ", "\\bar");
A(L, N, vn, "˘", "\\breve");
A(L, N, vn, "ˇ", "\\check");
A(L, N, vn, "^", "\\hat");
A(L, N, vn, "⃗", "\\vec");
A(L, N, vn, "˙", "\\dot");
A(L, N, vn, "˚", "\\mathring");
A(L, N, st, "", "\\@imath");
A(L, N, st, "", "\\@jmath");
A(L, N, X, "ı", "ı");
A(L, N, X, "ȷ", "ȷ");
A(me, N, X, "ı", "\\i", !0);
A(me, N, X, "ȷ", "\\j", !0);
A(me, N, X, "ß", "\\ss", !0);
A(me, N, X, "æ", "\\ae", !0);
A(me, N, X, "œ", "\\oe", !0);
A(me, N, X, "ø", "\\o", !0);
A(me, N, X, "Æ", "\\AE", !0);
A(me, N, X, "Œ", "\\OE", !0);
A(me, N, X, "Ø", "\\O", !0);
A(me, N, vn, "ˊ", "\\'");
A(me, N, vn, "ˋ", "\\`");
A(me, N, vn, "ˆ", "\\^");
A(me, N, vn, "˜", "\\~");
A(me, N, vn, "ˉ", "\\=");
A(me, N, vn, "˘", "\\u");
A(me, N, vn, "˙", "\\.");
A(me, N, vn, "¸", "\\c");
A(me, N, vn, "˚", "\\r");
A(me, N, vn, "ˇ", "\\v");
A(me, N, vn, "¨", '\\"');
A(me, N, vn, "˝", "\\H");
A(me, N, vn, "◯", "\\textcircled");
var qD = {
  "--": !0,
  "---": !0,
  "``": !0,
  "''": !0
};
A(me, N, X, "–", "--", !0);
A(me, N, X, "–", "\\textendash");
A(me, N, X, "—", "---", !0);
A(me, N, X, "—", "\\textemdash");
A(me, N, X, "‘", "`", !0);
A(me, N, X, "‘", "\\textquoteleft");
A(me, N, X, "’", "'", !0);
A(me, N, X, "’", "\\textquoteright");
A(me, N, X, "“", "``", !0);
A(me, N, X, "“", "\\textquotedblleft");
A(me, N, X, "”", "''", !0);
A(me, N, X, "”", "\\textquotedblright");
A(L, N, X, "°", "\\degree", !0);
A(me, N, X, "°", "\\degree");
A(me, N, X, "°", "\\textdegree", !0);
A(L, N, X, "£", "\\pounds");
A(L, N, X, "£", "\\mathsterling", !0);
A(me, N, X, "£", "\\pounds");
A(me, N, X, "£", "\\textsterling", !0);
A(L, $, X, "✠", "\\maltese");
A(me, $, X, "✠", "\\maltese");
var XS = '0123456789/@."';
for (var T2 = 0; T2 < XS.length; T2++) {
  var ZS = XS.charAt(T2);
  A(L, N, X, ZS, ZS);
}
var QS = '0123456789!@*()-=+";:?/.,';
for (var A2 = 0; A2 < QS.length; A2++) {
  var eC = QS.charAt(A2);
  A(me, N, X, eC, eC);
}
var d1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (var E2 = 0; E2 < d1.length; E2++) {
  var cm = d1.charAt(E2);
  A(L, N, st, cm, cm), A(me, N, X, cm, cm);
}
A(L, $, X, "C", "ℂ");
A(me, $, X, "C", "ℂ");
A(L, $, X, "H", "ℍ");
A(me, $, X, "H", "ℍ");
A(L, $, X, "N", "ℕ");
A(me, $, X, "N", "ℕ");
A(L, $, X, "P", "ℙ");
A(me, $, X, "P", "ℙ");
A(L, $, X, "Q", "ℚ");
A(me, $, X, "Q", "ℚ");
A(L, $, X, "R", "ℝ");
A(me, $, X, "R", "ℝ");
A(L, $, X, "Z", "ℤ");
A(me, $, X, "Z", "ℤ");
A(L, N, st, "h", "ℎ");
A(me, N, st, "h", "ℎ");
var lt = "";
for (var Lr = 0; Lr < d1.length; Lr++) {
  var Ln = d1.charAt(Lr);
  lt = String.fromCharCode(55349, 56320 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56372 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56424 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56580 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56684 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56736 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56788 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56840 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56944 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), Lr < 26 && (lt = String.fromCharCode(55349, 56632 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt), lt = String.fromCharCode(55349, 56476 + Lr), A(L, N, st, Ln, lt), A(me, N, X, Ln, lt));
}
lt = "𝕜";
A(L, N, st, "k", lt);
A(me, N, X, "k", lt);
for (var Nl = 0; Nl < 10; Nl++) {
  var Ma = Nl.toString();
  lt = String.fromCharCode(55349, 57294 + Nl), A(L, N, st, Ma, lt), A(me, N, X, Ma, lt), lt = String.fromCharCode(55349, 57314 + Nl), A(L, N, st, Ma, lt), A(me, N, X, Ma, lt), lt = String.fromCharCode(55349, 57324 + Nl), A(L, N, st, Ma, lt), A(me, N, X, Ma, lt), lt = String.fromCharCode(55349, 57334 + Nl), A(L, N, st, Ma, lt), A(me, N, X, Ma, lt);
}
var J4 = "ÐÞþ";
for (var L2 = 0; L2 < J4.length; L2++) {
  var um = J4.charAt(L2);
  A(L, N, st, um, um), A(me, N, X, um, um);
}
var hm = [
  ["mathbf", "textbf", "Main-Bold"],
  // A-Z bold upright
  ["mathbf", "textbf", "Main-Bold"],
  // a-z bold upright
  ["mathnormal", "textit", "Math-Italic"],
  // A-Z italic
  ["mathnormal", "textit", "Math-Italic"],
  // a-z italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // A-Z bold italic
  ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
  // a-z bold italic
  // Map fancy A-Z letters to script, not calligraphic.
  // This aligns with unicode-math and math fonts (except Cambria Math).
  ["mathscr", "textscr", "Script-Regular"],
  // A-Z script
  ["", "", ""],
  // a-z script.  No font
  ["", "", ""],
  // A-Z bold script. No font
  ["", "", ""],
  // a-z bold script. No font
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // A-Z Fraktur
  ["mathfrak", "textfrak", "Fraktur-Regular"],
  // a-z Fraktur
  ["mathbb", "textbb", "AMS-Regular"],
  // A-Z double-struck
  ["mathbb", "textbb", "AMS-Regular"],
  // k double-struck
  // Note that we are using a bold font, but font metrics for regular Fraktur.
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // A-Z bold Fraktur
  ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
  // a-z bold Fraktur
  ["mathsf", "textsf", "SansSerif-Regular"],
  // A-Z sans-serif
  ["mathsf", "textsf", "SansSerif-Regular"],
  // a-z sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // A-Z bold sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // a-z bold sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // A-Z italic sans-serif
  ["mathitsf", "textitsf", "SansSerif-Italic"],
  // a-z italic sans-serif
  ["", "", ""],
  // A-Z bold italic sans. No font
  ["", "", ""],
  // a-z bold italic sans. No font
  ["mathtt", "texttt", "Typewriter-Regular"],
  // A-Z monospace
  ["mathtt", "texttt", "Typewriter-Regular"]
  // a-z monospace
], tC = [
  ["mathbf", "textbf", "Main-Bold"],
  // 0-9 bold
  ["", "", ""],
  // 0-9 double-struck. No KaTeX font.
  ["mathsf", "textsf", "SansSerif-Regular"],
  // 0-9 sans-serif
  ["mathboldsf", "textboldsf", "SansSerif-Bold"],
  // 0-9 bold sans-serif
  ["mathtt", "texttt", "Typewriter-Regular"]
  // 0-9 monospace
], Nse = function(e, t) {
  var r = e.charCodeAt(0), i = e.charCodeAt(1), s = (r - 55296) * 1024 + (i - 56320) + 65536, o = t === "math" ? 0 : 1;
  if (119808 <= s && s < 120484) {
    var a = Math.floor((s - 119808) / 26);
    return [hm[a][2], hm[a][o]];
  } else if (120782 <= s && s <= 120831) {
    var l = Math.floor((s - 120782) / 10);
    return [tC[l][2], tC[l][o]];
  } else {
    if (s === 120485 || s === 120486)
      return [hm[0][2], hm[0][o]];
    if (120486 < s && s < 120782)
      return ["", ""];
    throw new ke("Unsupported character: " + e);
  }
}, Ey = function(e, t, r) {
  return ln[r][e] && ln[r][e].replace && (e = ln[r][e].replace), {
    value: e,
    metrics: t6(e, t, r)
  };
}, gs = function(e, t, r, i, s) {
  var o = Ey(e, t, r), a = o.metrics;
  e = o.value;
  var l;
  if (a) {
    var c = a.italic;
    (r === "text" || i && i.font === "mathit") && (c = 0), l = new es(e, a.height, a.depth, c, a.skew, a.width, s);
  } else
    typeof console < "u" && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '" + r + "'")), l = new es(e, 0, 0, 0, 0, 0, s);
  if (i) {
    l.maxFontSize = i.sizeMultiplier, i.style.isTight() && l.classes.push("mtight");
    var u = i.getColor();
    u && (l.style.color = u);
  }
  return l;
}, Ise = function(e, t, r, i) {
  return i === void 0 && (i = []), r.font === "boldsymbol" && Ey(e, "Main-Bold", t).metrics ? gs(e, "Main-Bold", t, r, i.concat(["mathbf"])) : e === "\\" || ln[t][e].font === "main" ? gs(e, "Main-Regular", t, r, i) : gs(e, "AMS-Regular", t, r, i.concat(["amsrm"]));
}, _se = function(e, t, r, i, s) {
  return s !== "textord" && Ey(e, "Math-BoldItalic", t).metrics ? {
    fontName: "Math-BoldItalic",
    fontClass: "boldsymbol"
  } : {
    fontName: "Main-Bold",
    fontClass: "mathbf"
  };
}, Rse = function(e, t, r) {
  var i = e.mode, s = e.text, o = ["mord"], a = i === "math" || i === "text" && t.font, l = a ? t.font : t.fontFamily, c = "", u = "";
  if (s.charCodeAt(0) === 55349 && ([c, u] = Nse(s, i)), c.length > 0)
    return gs(s, c, i, t, o.concat(u));
  if (l) {
    var h, f;
    if (l === "boldsymbol") {
      var m = _se(s, i, t, o, r);
      h = m.fontName, f = [m.fontClass];
    } else a ? (h = WD[l].fontName, f = [l]) : (h = fm(l, t.fontWeight, t.fontShape), f = [l, t.fontWeight, t.fontShape]);
    if (Ey(s, h, i).metrics)
      return gs(s, h, i, t, o.concat(f));
    if (qD.hasOwnProperty(s) && h.slice(0, 10) === "Typewriter") {
      for (var y = [], b = 0; b < s.length; b++)
        y.push(gs(s[b], h, i, t, o.concat(f)));
      return jD(y);
    }
  }
  if (r === "mathord")
    return gs(s, "Math-Italic", i, t, o.concat(["mathnormal"]));
  if (r === "textord") {
    var k = ln[i][s] && ln[i][s].font;
    if (k === "ams") {
      var x = fm("amsrm", t.fontWeight, t.fontShape);
      return gs(s, x, i, t, o.concat("amsrm", t.fontWeight, t.fontShape));
    } else if (k === "main" || !k) {
      var M = fm("textrm", t.fontWeight, t.fontShape);
      return gs(s, M, i, t, o.concat(t.fontWeight, t.fontShape));
    } else {
      var T = fm(k, t.fontWeight, t.fontShape);
      return gs(s, T, i, t, o.concat(T, t.fontWeight, t.fontShape));
    }
  } else
    throw new Error("unexpected type: " + r + " in makeOrd");
}, Pse = (n, e) => {
  if (cl(n.classes) !== cl(e.classes) || n.skew !== e.skew || n.maxFontSize !== e.maxFontSize)
    return !1;
  if (n.classes.length === 1) {
    var t = n.classes[0];
    if (t === "mbin" || t === "mord")
      return !1;
  }
  for (var r in n.style)
    if (n.style.hasOwnProperty(r) && n.style[r] !== e.style[r])
      return !1;
  for (var i in e.style)
    if (e.style.hasOwnProperty(i) && n.style[i] !== e.style[i])
      return !1;
  return !0;
}, Bse = (n) => {
  for (var e = 0; e < n.length - 1; e++) {
    var t = n[e], r = n[e + 1];
    t instanceof es && r instanceof es && Pse(t, r) && (t.text += r.text, t.height = Math.max(t.height, r.height), t.depth = Math.max(t.depth, r.depth), t.italic = r.italic, n.splice(e + 1, 1), e--);
  }
  return n;
}, r6 = function(e) {
  for (var t = 0, r = 0, i = 0, s = 0; s < e.children.length; s++) {
    var o = e.children[s];
    o.height > t && (t = o.height), o.depth > r && (r = o.depth), o.maxFontSize > i && (i = o.maxFontSize);
  }
  e.height = t, e.depth = r, e.maxFontSize = i;
}, Gr = function(e, t, r, i) {
  var s = new up(e, t, r, i);
  return r6(s), s;
}, $D = (n, e, t, r) => new up(n, e, t, r), Hse = function(e, t, r) {
  var i = Gr([e], [], t);
  return i.height = Math.max(r || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = Te(i.height), i.maxFontSize = 1, i;
}, zse = function(e, t, r, i) {
  var s = new n6(e, t, r, i);
  return r6(s), s;
}, jD = function(e) {
  var t = new cp(e);
  return r6(t), t;
}, Fse = function(e, t) {
  return e instanceof cp ? Gr([], [e], t) : e;
}, Vse = function(e) {
  if (e.positionType === "individualShift") {
    for (var t = e.children, r = [t[0]], i = -t[0].shift - t[0].elem.depth, s = i, o = 1; o < t.length; o++) {
      var a = -t[o].shift - s - t[o].elem.depth, l = a - (t[o - 1].elem.height + t[o - 1].elem.depth);
      s = s + a, r.push({
        type: "kern",
        size: l
      }), r.push(t[o]);
    }
    return {
      children: r,
      depth: i
    };
  }
  var c;
  if (e.positionType === "top") {
    for (var u = e.positionData, h = 0; h < e.children.length; h++) {
      var f = e.children[h];
      u -= f.type === "kern" ? f.size : f.elem.height + f.elem.depth;
    }
    c = u;
  } else if (e.positionType === "bottom")
    c = -e.positionData;
  else {
    var m = e.children[0];
    if (m.type !== "elem")
      throw new Error('First child must have type "elem".');
    if (e.positionType === "shift")
      c = -m.elem.depth - e.positionData;
    else if (e.positionType === "firstBaseline")
      c = -m.elem.depth;
    else
      throw new Error("Invalid positionType " + e.positionType + ".");
  }
  return {
    children: e.children,
    depth: c
  };
}, qse = function(e, t) {
  for (var {
    children: r,
    depth: i
  } = Vse(e), s = 0, o = 0; o < r.length; o++) {
    var a = r[o];
    if (a.type === "elem") {
      var l = a.elem;
      s = Math.max(s, l.maxFontSize, l.height);
    }
  }
  s += 2;
  var c = Gr(["pstrut"], []);
  c.style.height = Te(s);
  for (var u = [], h = i, f = i, m = i, y = 0; y < r.length; y++) {
    var b = r[y];
    if (b.type === "kern")
      m += b.size;
    else {
      var k = b.elem, x = b.wrapperClasses || [], M = b.wrapperStyle || {}, T = Gr(x, [c, k], void 0, M);
      T.style.top = Te(-s - m - k.depth), b.marginLeft && (T.style.marginLeft = b.marginLeft), b.marginRight && (T.style.marginRight = b.marginRight), u.push(T), m += k.height + k.depth;
    }
    h = Math.min(h, m), f = Math.max(f, m);
  }
  var E = Gr(["vlist"], u);
  E.style.height = Te(f);
  var C;
  if (h < 0) {
    var O = Gr([], []), R = Gr(["vlist"], [O]);
    R.style.height = Te(-h);
    var F = Gr(["vlist-s"], [new es("​")]);
    C = [Gr(["vlist-r"], [E, F]), Gr(["vlist-r"], [R])];
  } else
    C = [Gr(["vlist-r"], [E])];
  var H = Gr(["vlist-t"], C);
  return C.length === 2 && H.classes.push("vlist-t2"), H.height = f, H.depth = -h, H;
}, $se = (n, e) => {
  var t = Gr(["mspace"], [], e), r = Sn(n, e);
  return t.style.marginRight = Te(r), t;
}, fm = function(e, t, r) {
  var i = "";
  switch (e) {
    case "amsrm":
      i = "AMS";
      break;
    case "textrm":
      i = "Main";
      break;
    case "textsf":
      i = "SansSerif";
      break;
    case "texttt":
      i = "Typewriter";
      break;
    default:
      i = e;
  }
  var s;
  return t === "textbf" && r === "textit" ? s = "BoldItalic" : t === "textbf" ? s = "Bold" : t === "textit" ? s = "Italic" : s = "Regular", i + "-" + s;
}, WD = {
  // styles
  mathbf: {
    variant: "bold",
    fontName: "Main-Bold"
  },
  mathrm: {
    variant: "normal",
    fontName: "Main-Regular"
  },
  textit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathit: {
    variant: "italic",
    fontName: "Main-Italic"
  },
  mathnormal: {
    variant: "italic",
    fontName: "Math-Italic"
  },
  mathsfit: {
    variant: "sans-serif-italic",
    fontName: "SansSerif-Italic"
  },
  // "boldsymbol" is missing because they require the use of multiple fonts:
  // Math-BoldItalic and Main-Bold.  This is handled by a special case in
  // makeOrd which ends up calling boldsymbol.
  // families
  mathbb: {
    variant: "double-struck",
    fontName: "AMS-Regular"
  },
  mathcal: {
    variant: "script",
    fontName: "Caligraphic-Regular"
  },
  mathfrak: {
    variant: "fraktur",
    fontName: "Fraktur-Regular"
  },
  mathscr: {
    variant: "script",
    fontName: "Script-Regular"
  },
  mathsf: {
    variant: "sans-serif",
    fontName: "SansSerif-Regular"
  },
  mathtt: {
    variant: "monospace",
    fontName: "Typewriter-Regular"
  }
}, UD = {
  //   path, width, height
  vec: ["vec", 0.471, 0.714],
  // values from the font glyph
  oiintSize1: ["oiintSize1", 0.957, 0.499],
  // oval to overlay the integrand
  oiintSize2: ["oiintSize2", 1.472, 0.659],
  oiiintSize1: ["oiiintSize1", 1.304, 0.499],
  oiiintSize2: ["oiiintSize2", 1.98, 0.659]
}, jse = function(e, t) {
  var [r, i, s] = UD[e], o = new ul(r), a = new aa([o], {
    width: Te(i),
    height: Te(s),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + Te(i),
    viewBox: "0 0 " + 1e3 * i + " " + 1e3 * s,
    preserveAspectRatio: "xMinYMin"
  }), l = $D(["overlay"], [a], t);
  return l.height = s, l.style.height = Te(s), l.style.width = Te(i), l;
}, Q = {
  fontMap: WD,
  makeSymbol: gs,
  mathsym: Ise,
  makeSpan: Gr,
  makeSvgSpan: $D,
  makeLineSpan: Hse,
  makeAnchor: zse,
  makeFragment: jD,
  wrapFragment: Fse,
  makeVList: qse,
  makeOrd: Rse,
  makeGlue: $se,
  staticSvg: jse,
  svgData: UD,
  tryCombineChars: Bse
}, kn = {
  number: 3,
  unit: "mu"
}, Il = {
  number: 4,
  unit: "mu"
}, Eo = {
  number: 5,
  unit: "mu"
}, Wse = {
  mord: {
    mop: kn,
    mbin: Il,
    mrel: Eo,
    minner: kn
  },
  mop: {
    mord: kn,
    mop: kn,
    mrel: Eo,
    minner: kn
  },
  mbin: {
    mord: Il,
    mop: Il,
    mopen: Il,
    minner: Il
  },
  mrel: {
    mord: Eo,
    mop: Eo,
    mopen: Eo,
    minner: Eo
  },
  mopen: {},
  mclose: {
    mop: kn,
    mbin: Il,
    mrel: Eo,
    minner: kn
  },
  mpunct: {
    mord: kn,
    mop: kn,
    mrel: Eo,
    mopen: kn,
    mclose: kn,
    mpunct: kn,
    minner: kn
  },
  minner: {
    mord: kn,
    mop: kn,
    mbin: Il,
    mrel: Eo,
    mopen: kn,
    mpunct: kn,
    minner: kn
  }
}, Use = {
  mord: {
    mop: kn
  },
  mop: {
    mord: kn,
    mop: kn
  },
  mbin: {},
  mrel: {},
  mopen: {},
  mclose: {
    mop: kn
  },
  mpunct: {},
  minner: {
    mop: kn
  }
}, KD = {}, p1 = {}, m1 = {};
function _e(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, a = {
    type: e,
    numArgs: r.numArgs,
    argTypes: r.argTypes,
    allowedInArgument: !!r.allowedInArgument,
    allowedInText: !!r.allowedInText,
    allowedInMath: r.allowedInMath === void 0 ? !0 : r.allowedInMath,
    numOptionalArgs: r.numOptionalArgs || 0,
    infix: !!r.infix,
    primitive: !!r.primitive,
    handler: i
  }, l = 0; l < t.length; ++l)
    KD[t[l]] = a;
  e && (s && (p1[e] = s), o && (m1[e] = o));
}
function $c(n) {
  var {
    type: e,
    htmlBuilder: t,
    mathmlBuilder: r
  } = n;
  _e({
    type: e,
    names: [],
    props: {
      numArgs: 0
    },
    handler() {
      throw new Error("Should never be called.");
    },
    htmlBuilder: t,
    mathmlBuilder: r
  });
}
var g1 = function(e) {
  return e.type === "ordgroup" && e.body.length === 1 ? e.body[0] : e;
}, _n = function(e) {
  return e.type === "ordgroup" ? e.body : [e];
}, la = Q.makeSpan, Kse = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"], Gse = ["rightmost", "mrel", "mclose", "mpunct"], Jse = {
  display: ot.DISPLAY,
  text: ot.TEXT,
  script: ot.SCRIPT,
  scriptscript: ot.SCRIPTSCRIPT
}, Yse = {
  mord: "mord",
  mop: "mop",
  mbin: "mbin",
  mrel: "mrel",
  mopen: "mopen",
  mclose: "mclose",
  mpunct: "mpunct",
  minner: "minner"
}, Yn = function(e, t, r, i) {
  i === void 0 && (i = [null, null]);
  for (var s = [], o = 0; o < e.length; o++) {
    var a = zt(e[o], t);
    if (a instanceof cp) {
      var l = a.children;
      s.push(...l);
    } else
      s.push(a);
  }
  if (Q.tryCombineChars(s), !r)
    return s;
  var c = t;
  if (e.length === 1) {
    var u = e[0];
    u.type === "sizing" ? c = t.havingSize(u.size) : u.type === "styling" && (c = t.havingStyle(Jse[u.style]));
  }
  var h = la([i[0] || "leftmost"], [], t), f = la([i[1] || "rightmost"], [], t), m = r === "root";
  return nC(s, (y, b) => {
    var k = b.classes[0], x = y.classes[0];
    k === "mbin" && et.contains(Gse, x) ? b.classes[0] = "mord" : x === "mbin" && et.contains(Kse, k) && (y.classes[0] = "mord");
  }, {
    node: h
  }, f, m), nC(s, (y, b) => {
    var k = Y4(b), x = Y4(y), M = k && x ? y.hasClass("mtight") ? Use[k][x] : Wse[k][x] : null;
    if (M)
      return Q.makeGlue(M, c);
  }, {
    node: h
  }, f, m), s;
}, nC = function n(e, t, r, i, s) {
  i && e.push(i);
  for (var o = 0; o < e.length; o++) {
    var a = e[o], l = GD(a);
    if (l) {
      n(l.children, t, r, null, s);
      continue;
    }
    var c = !a.hasClass("mspace");
    if (c) {
      var u = t(a, r.node);
      u && (r.insertAfter ? r.insertAfter(u) : (e.unshift(u), o++));
    }
    c ? r.node = a : s && a.hasClass("newline") && (r.node = la(["leftmost"])), r.insertAfter = /* @__PURE__ */ ((h) => (f) => {
      e.splice(h + 1, 0, f), o++;
    })(o);
  }
  i && e.pop();
}, GD = function(e) {
  return e instanceof cp || e instanceof n6 || e instanceof up && e.hasClass("enclosing") ? e : null;
}, Xse = function n(e, t) {
  var r = GD(e);
  if (r) {
    var i = r.children;
    if (i.length) {
      if (t === "right")
        return n(i[i.length - 1], "right");
      if (t === "left")
        return n(i[0], "left");
    }
  }
  return e;
}, Y4 = function(e, t) {
  return e ? (t && (e = Xse(e, t)), Yse[e.classes[0]] || null) : null;
}, a0 = function(e, t) {
  var r = ["nulldelimiter"].concat(e.baseSizingClasses());
  return la(t.concat(r));
}, zt = function(e, t, r) {
  if (!e)
    return la();
  if (p1[e.type]) {
    var i = p1[e.type](e, t);
    if (r && t.size !== r.size) {
      i = la(t.sizingClasses(r), [i], t);
      var s = t.sizeMultiplier / r.sizeMultiplier;
      i.height *= s, i.depth *= s;
    }
    return i;
  } else
    throw new ke("Got group of unknown type: '" + e.type + "'");
};
function dm(n, e) {
  var t = la(["base"], n, e), r = la(["strut"]);
  return r.style.height = Te(t.height + t.depth), t.depth && (r.style.verticalAlign = Te(-t.depth)), t.children.unshift(r), t;
}
function X4(n, e) {
  var t = null;
  n.length === 1 && n[0].type === "tag" && (t = n[0].tag, n = n[0].body);
  var r = Yn(n, e, "root"), i;
  r.length === 2 && r[1].hasClass("tag") && (i = r.pop());
  for (var s = [], o = [], a = 0; a < r.length; a++)
    if (o.push(r[a]), r[a].hasClass("mbin") || r[a].hasClass("mrel") || r[a].hasClass("allowbreak")) {
      for (var l = !1; a < r.length - 1 && r[a + 1].hasClass("mspace") && !r[a + 1].hasClass("newline"); )
        a++, o.push(r[a]), r[a].hasClass("nobreak") && (l = !0);
      l || (s.push(dm(o, e)), o = []);
    } else r[a].hasClass("newline") && (o.pop(), o.length > 0 && (s.push(dm(o, e)), o = []), s.push(r[a]));
  o.length > 0 && s.push(dm(o, e));
  var c;
  t ? (c = dm(Yn(t, e, !0)), c.classes = ["tag"], s.push(c)) : i && s.push(i);
  var u = la(["katex-html"], s);
  if (u.setAttribute("aria-hidden", "true"), c) {
    var h = c.children[0];
    h.style.height = Te(u.height + u.depth), u.depth && (h.style.verticalAlign = Te(-u.depth));
  }
  return u;
}
function JD(n) {
  return new cp(n);
}
class Si {
  constructor(e, t, r) {
    this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = r || [];
  }
  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(e, t) {
    this.attributes[e] = t;
  }
  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
    this.classes.length > 0 && (e.className = cl(this.classes));
    for (var r = 0; r < this.children.length; r++)
      if (this.children[r] instanceof Zs && this.children[r + 1] instanceof Zs) {
        for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof Zs; )
          i += this.children[++r].toText();
        e.appendChild(new Zs(i).toNode());
      } else
        e.appendChild(this.children[r].toNode());
    return e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    var e = "<" + this.type;
    for (var t in this.attributes)
      Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + '="', e += et.escape(this.attributes[t]), e += '"');
    this.classes.length > 0 && (e += ' class ="' + et.escape(cl(this.classes)) + '"'), e += ">";
    for (var r = 0; r < this.children.length; r++)
      e += this.children[r].toMarkup();
    return e += "</" + this.type + ">", e;
  }
  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((e) => e.toText()).join("");
  }
}
class Zs {
  constructor(e) {
    this.text = void 0, this.text = e;
  }
  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }
  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return et.escape(this.toText());
  }
  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}
class Zse {
  /**
   * Create a Space node with width given in CSS ems.
   */
  constructor(e) {
    this.width = void 0, this.character = void 0, this.width = e, e >= 0.05555 && e <= 0.05556 ? this.character = " " : e >= 0.1666 && e <= 0.1667 ? this.character = " " : e >= 0.2222 && e <= 0.2223 ? this.character = " " : e >= 0.2777 && e <= 0.2778 ? this.character = "  " : e >= -0.05556 && e <= -0.05555 ? this.character = " ⁣" : e >= -0.1667 && e <= -0.1666 ? this.character = " ⁣" : e >= -0.2223 && e <= -0.2222 ? this.character = " ⁣" : e >= -0.2778 && e <= -0.2777 ? this.character = " ⁣" : this.character = null;
  }
  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    if (this.character)
      return document.createTextNode(this.character);
    var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
    return e.setAttribute("width", Te(this.width)), e;
  }
  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    return this.character ? "<mtext>" + this.character + "</mtext>" : '<mspace width="' + Te(this.width) + '"/>';
  }
  /**
   * Converts the math node into a string, similar to innerText.
   */
  toText() {
    return this.character ? this.character : " ";
  }
}
var we = {
  MathNode: Si,
  TextNode: Zs,
  SpaceNode: Zse,
  newDocumentFragment: JD
}, ts = function(e, t, r) {
  return ln[t][e] && ln[t][e].replace && e.charCodeAt(0) !== 55349 && !(qD.hasOwnProperty(e) && r && (r.fontFamily && r.fontFamily.slice(4, 6) === "tt" || r.font && r.font.slice(4, 6) === "tt")) && (e = ln[t][e].replace), new we.TextNode(e);
}, i6 = function(e) {
  return e.length === 1 ? e[0] : new we.MathNode("mrow", e);
}, s6 = function(e, t) {
  if (t.fontFamily === "texttt")
    return "monospace";
  if (t.fontFamily === "textsf")
    return t.fontShape === "textit" && t.fontWeight === "textbf" ? "sans-serif-bold-italic" : t.fontShape === "textit" ? "sans-serif-italic" : t.fontWeight === "textbf" ? "bold-sans-serif" : "sans-serif";
  if (t.fontShape === "textit" && t.fontWeight === "textbf")
    return "bold-italic";
  if (t.fontShape === "textit")
    return "italic";
  if (t.fontWeight === "textbf")
    return "bold";
  var r = t.font;
  if (!r || r === "mathnormal")
    return null;
  var i = e.mode;
  if (r === "mathit")
    return "italic";
  if (r === "boldsymbol")
    return e.type === "textord" ? "bold" : "bold-italic";
  if (r === "mathbf")
    return "bold";
  if (r === "mathbb")
    return "double-struck";
  if (r === "mathsfit")
    return "sans-serif-italic";
  if (r === "mathfrak")
    return "fraktur";
  if (r === "mathscr" || r === "mathcal")
    return "script";
  if (r === "mathsf")
    return "sans-serif";
  if (r === "mathtt")
    return "monospace";
  var s = e.text;
  if (et.contains(["\\imath", "\\jmath"], s))
    return null;
  ln[i][s] && ln[i][s].replace && (s = ln[i][s].replace);
  var o = Q.fontMap[r].fontName;
  return t6(s, o, i) ? Q.fontMap[r].variant : null;
};
function O2(n) {
  if (!n)
    return !1;
  if (n.type === "mi" && n.children.length === 1) {
    var e = n.children[0];
    return e instanceof Zs && e.text === ".";
  } else if (n.type === "mo" && n.children.length === 1 && n.getAttribute("separator") === "true" && n.getAttribute("lspace") === "0em" && n.getAttribute("rspace") === "0em") {
    var t = n.children[0];
    return t instanceof Zs && t.text === ",";
  } else
    return !1;
}
var li = function(e, t, r) {
  if (e.length === 1) {
    var i = rn(e[0], t);
    return r && i instanceof Si && i.type === "mo" && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
  }
  for (var s = [], o, a = 0; a < e.length; a++) {
    var l = rn(e[a], t);
    if (l instanceof Si && o instanceof Si) {
      if (l.type === "mtext" && o.type === "mtext" && l.getAttribute("mathvariant") === o.getAttribute("mathvariant")) {
        o.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && o.type === "mn") {
        o.children.push(...l.children);
        continue;
      } else if (O2(l) && o.type === "mn") {
        o.children.push(...l.children);
        continue;
      } else if (l.type === "mn" && O2(o))
        l.children = [...o.children, ...l.children], s.pop();
      else if ((l.type === "msup" || l.type === "msub") && l.children.length >= 1 && (o.type === "mn" || O2(o))) {
        var c = l.children[0];
        c instanceof Si && c.type === "mn" && (c.children = [...o.children, ...c.children], s.pop());
      } else if (o.type === "mi" && o.children.length === 1) {
        var u = o.children[0];
        if (u instanceof Zs && u.text === "̸" && (l.type === "mo" || l.type === "mi" || l.type === "mn")) {
          var h = l.children[0];
          h instanceof Zs && h.text.length > 0 && (h.text = h.text.slice(0, 1) + "̸" + h.text.slice(1), s.pop());
        }
      }
    }
    s.push(l), o = l;
  }
  return s;
}, hl = function(e, t, r) {
  return i6(li(e, t, r));
}, rn = function(e, t) {
  if (!e)
    return new we.MathNode("mrow");
  if (m1[e.type]) {
    var r = m1[e.type](e, t);
    return r;
  } else
    throw new ke("Got group of unknown type: '" + e.type + "'");
};
function rC(n, e, t, r, i) {
  var s = li(n, t), o;
  s.length === 1 && s[0] instanceof Si && et.contains(["mrow", "mtable"], s[0].type) ? o = s[0] : o = new we.MathNode("mrow", s);
  var a = new we.MathNode("annotation", [new we.TextNode(e)]);
  a.setAttribute("encoding", "application/x-tex");
  var l = new we.MathNode("semantics", [o, a]), c = new we.MathNode("math", [l]);
  c.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), r && c.setAttribute("display", "block");
  var u = i ? "katex" : "katex-mathml";
  return Q.makeSpan([u], [c]);
}
var YD = function(e) {
  return new Bo({
    style: e.displayMode ? ot.DISPLAY : ot.TEXT,
    maxSize: e.maxSize,
    minRuleThickness: e.minRuleThickness
  });
}, XD = function(e, t) {
  if (t.displayMode) {
    var r = ["katex-display"];
    t.leqno && r.push("leqno"), t.fleqn && r.push("fleqn"), e = Q.makeSpan(r, [e]);
  }
  return e;
}, Qse = function(e, t, r) {
  var i = YD(r), s;
  if (r.output === "mathml")
    return rC(e, t, i, r.displayMode, !0);
  if (r.output === "html") {
    var o = X4(e, i);
    s = Q.makeSpan(["katex"], [o]);
  } else {
    var a = rC(e, t, i, r.displayMode, !1), l = X4(e, i);
    s = Q.makeSpan(["katex"], [a, l]);
  }
  return XD(s, r);
}, eoe = function(e, t, r) {
  var i = YD(r), s = X4(e, i), o = Q.makeSpan(["katex"], [s]);
  return XD(o, r);
}, toe = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  utilde: "~",
  overleftarrow: "←",
  underleftarrow: "←",
  xleftarrow: "←",
  overrightarrow: "→",
  underrightarrow: "→",
  xrightarrow: "→",
  underbrace: "⏟",
  overbrace: "⏞",
  overgroup: "⏠",
  undergroup: "⏡",
  overleftrightarrow: "↔",
  underleftrightarrow: "↔",
  xleftrightarrow: "↔",
  Overrightarrow: "⇒",
  xRightarrow: "⇒",
  overleftharpoon: "↼",
  xleftharpoonup: "↼",
  overrightharpoon: "⇀",
  xrightharpoonup: "⇀",
  xLeftarrow: "⇐",
  xLeftrightarrow: "⇔",
  xhookleftarrow: "↩",
  xhookrightarrow: "↪",
  xmapsto: "↦",
  xrightharpoondown: "⇁",
  xleftharpoondown: "↽",
  xrightleftharpoons: "⇌",
  xleftrightharpoons: "⇋",
  xtwoheadleftarrow: "↞",
  xtwoheadrightarrow: "↠",
  xlongequal: "=",
  xtofrom: "⇄",
  xrightleftarrows: "⇄",
  xrightequilibrium: "⇌",
  // Not a perfect match.
  xleftequilibrium: "⇋",
  // None better available.
  "\\cdrightarrow": "→",
  "\\cdleftarrow": "←",
  "\\cdlongequal": "="
}, noe = function(e) {
  var t = new we.MathNode("mo", [new we.TextNode(toe[e.replace(/^\\/, "")])]);
  return t.setAttribute("stretchy", "true"), t;
}, roe = {
  //   path(s), minWidth, height, align
  overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
  underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
  xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
  "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
  // CD minwwidth2.5pc
  xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
  "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
  Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
  xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
  xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
  overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
  xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
  overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
  xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
  xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
  "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
  xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
  xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
  overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
  underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
  underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
  xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
  xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
  xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
  xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
  xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
  xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
  overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
  overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
  undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
  xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
  xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
  // The next three arrows are from the mhchem package.
  // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
  // document as \xrightarrow or \xrightleftharpoons. Those have
  // min-length = 1.75em, so we set min-length on these next three to match.
  xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
  xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
  xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
}, ioe = function(e) {
  return e.type === "ordgroup" ? e.body.length : 1;
}, soe = function(e, t) {
  function r() {
    var a = 4e5, l = e.label.slice(1);
    if (et.contains(["widehat", "widecheck", "widetilde", "utilde"], l)) {
      var c = e, u = ioe(c.base), h, f, m;
      if (u > 5)
        l === "widehat" || l === "widecheck" ? (h = 420, a = 2364, m = 0.42, f = l + "4") : (h = 312, a = 2340, m = 0.34, f = "tilde4");
      else {
        var y = [1, 1, 2, 2, 3, 3][u];
        l === "widehat" || l === "widecheck" ? (a = [0, 1062, 2364, 2364, 2364][y], h = [0, 239, 300, 360, 420][y], m = [0, 0.24, 0.3, 0.3, 0.36, 0.42][y], f = l + y) : (a = [0, 600, 1033, 2339, 2340][y], h = [0, 260, 286, 306, 312][y], m = [0, 0.26, 0.286, 0.3, 0.306, 0.34][y], f = "tilde" + y);
      }
      var b = new ul(f), k = new aa([b], {
        width: "100%",
        height: Te(m),
        viewBox: "0 0 " + a + " " + h,
        preserveAspectRatio: "none"
      });
      return {
        span: Q.makeSvgSpan([], [k], t),
        minWidth: 0,
        height: m
      };
    } else {
      var x = [], M = roe[l], [T, E, C] = M, O = C / 1e3, R = T.length, F, H;
      if (R === 1) {
        var z = M[3];
        F = ["hide-tail"], H = [z];
      } else if (R === 2)
        F = ["halfarrow-left", "halfarrow-right"], H = ["xMinYMin", "xMaxYMin"];
      else if (R === 3)
        F = ["brace-left", "brace-center", "brace-right"], H = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      else
        throw new Error(`Correct katexImagesData or update code here to support
                    ` + R + " children.");
      for (var K = 0; K < R; K++) {
        var U = new ul(T[K]), ae = new aa([U], {
          width: "400em",
          height: Te(O),
          viewBox: "0 0 " + a + " " + C,
          preserveAspectRatio: H[K] + " slice"
        }), ie = Q.makeSvgSpan([F[K]], [ae], t);
        if (R === 1)
          return {
            span: ie,
            minWidth: E,
            height: O
          };
        ie.style.height = Te(O), x.push(ie);
      }
      return {
        span: Q.makeSpan(["stretchy"], x, t),
        minWidth: E,
        height: O
      };
    }
  }
  var {
    span: i,
    minWidth: s,
    height: o
  } = r();
  return i.height = o, i.style.height = Te(o), s > 0 && (i.style.minWidth = Te(s)), i;
}, ooe = function(e, t, r, i, s) {
  var o, a = e.height + e.depth + r + i;
  if (/fbox|color|angl/.test(t)) {
    if (o = Q.makeSpan(["stretchy", t], [], s), t === "fbox") {
      var l = s.color && s.getColor();
      l && (o.style.borderColor = l);
    }
  } else {
    var c = [];
    /^[bx]cancel$/.test(t) && c.push(new G4({
      x1: "0",
      y1: "0",
      x2: "100%",
      y2: "100%",
      "stroke-width": "0.046em"
    })), /^x?cancel$/.test(t) && c.push(new G4({
      x1: "0",
      y1: "100%",
      x2: "100%",
      y2: "0",
      "stroke-width": "0.046em"
    }));
    var u = new aa(c, {
      width: "100%",
      height: Te(a)
    });
    o = Q.makeSvgSpan([], [u], s);
  }
  return o.height = a, o.style.height = Te(a), o;
}, ca = {
  encloseSpan: ooe,
  mathMLnode: noe,
  svgSpan: soe
};
function vt(n, e) {
  if (!n || n.type !== e)
    throw new Error("Expected node of type " + e + ", but got " + (n ? "node of type " + n.type : String(n)));
  return n;
}
function o6(n) {
  var e = Ly(n);
  if (!e)
    throw new Error("Expected node of symbol group type, but got " + (n ? "node of type " + n.type : String(n)));
  return e;
}
function Ly(n) {
  return n && (n.type === "atom" || Dse.hasOwnProperty(n.type)) ? n : null;
}
var a6 = (n, e) => {
  var t, r, i;
  n && n.type === "supsub" ? (r = vt(n.base, "accent"), t = r.base, n.base = t, i = Lse(zt(n, e)), n.base = r) : (r = vt(n, "accent"), t = r.base);
  var s = zt(t, e.havingCrampedStyle()), o = r.isShifty && et.isCharacterBox(t), a = 0;
  if (o) {
    var l = et.getBaseElem(t), c = zt(l, e.havingCrampedStyle());
    a = YS(c).skew;
  }
  var u = r.label === "\\c", h = u ? s.height + s.depth : Math.min(s.height, e.fontMetrics().xHeight), f;
  if (r.isStretchy)
    f = ca.svgSpan(r, e), f = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "elem",
        elem: f,
        wrapperClasses: ["svg-align"],
        wrapperStyle: a > 0 ? {
          width: "calc(100% - " + Te(2 * a) + ")",
          marginLeft: Te(2 * a)
        } : void 0
      }]
    }, e);
  else {
    var m, y;
    r.label === "\\vec" ? (m = Q.staticSvg("vec", e), y = Q.svgData.vec[1]) : (m = Q.makeOrd({
      mode: r.mode,
      text: r.label
    }, e, "textord"), m = YS(m), m.italic = 0, y = m.width, u && (h += m.depth)), f = Q.makeSpan(["accent-body"], [m]);
    var b = r.label === "\\textcircled";
    b && (f.classes.push("accent-full"), h = s.height);
    var k = a;
    b || (k -= y / 2), f.style.left = Te(k), r.label === "\\textcircled" && (f.style.top = ".2em"), f = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: s
      }, {
        type: "kern",
        size: -h
      }, {
        type: "elem",
        elem: f
      }]
    }, e);
  }
  var x = Q.makeSpan(["mord", "accent"], [f], e);
  return i ? (i.children[0] = x, i.height = Math.max(x.height, i.height), i.classes[0] = "mord", i) : x;
}, ZD = (n, e) => {
  var t = n.isStretchy ? ca.mathMLnode(n.label) : new we.MathNode("mo", [ts(n.label, n.mode)]), r = new we.MathNode("mover", [rn(n.base, e), t]);
  return r.setAttribute("accent", "true"), r;
}, aoe = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((n) => "\\" + n).join("|"));
_e({
  type: "accent",
  names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var t = g1(e[0]), r = !aoe.test(n.funcName), i = !r || n.funcName === "\\widehat" || n.funcName === "\\widetilde" || n.funcName === "\\widecheck";
    return {
      type: "accent",
      mode: n.parser.mode,
      label: n.funcName,
      isStretchy: r,
      isShifty: i,
      base: t
    };
  },
  htmlBuilder: a6,
  mathmlBuilder: ZD
});
_e({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    // unless in strict mode
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = e[0], r = n.parser.mode;
    return r === "math" && (n.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + n.funcName + " works only in text mode"), r = "text"), {
      type: "accent",
      mode: r,
      label: n.funcName,
      isStretchy: !1,
      isShifty: !0,
      base: t
    };
  },
  htmlBuilder: a6,
  mathmlBuilder: ZD
});
_e({
  type: "accentUnder",
  names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "accentUnder",
      mode: t.mode,
      label: r,
      base: i
    };
  },
  htmlBuilder: (n, e) => {
    var t = zt(n.base, e), r = ca.svgSpan(n, e), i = n.label === "\\utilde" ? 0.12 : 0, s = Q.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "elem",
        elem: r,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return Q.makeSpan(["mord", "accentunder"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = ca.mathMLnode(n.label), r = new we.MathNode("munder", [rn(n.base, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
var pm = (n) => {
  var e = new we.MathNode("mpadded", n ? [n] : []);
  return e.setAttribute("width", "+0.6em"), e.setAttribute("lspace", "0.3em"), e;
};
_e({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xrightleftharpoons",
    "\\xleftrightharpoons",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    "\\xtofrom",
    // The next 3 functions are here to support the mhchem extension.
    // Direct use of these functions is discouraged and may break someday.
    "\\xrightleftarrows",
    "\\xrightequilibrium",
    "\\xleftequilibrium",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n;
    return {
      type: "xArrow",
      mode: r.mode,
      label: i,
      body: e[0],
      below: t[0]
    };
  },
  // Flow is unable to correctly infer the type of `group`, even though it's
  // unambiguously determined from the passed-in `type` above.
  htmlBuilder(n, e) {
    var t = e.style, r = e.havingStyle(t.sup()), i = Q.wrapFragment(zt(n.body, r, e), e), s = n.label.slice(0, 2) === "\\x" ? "x" : "cd";
    i.classes.push(s + "-arrow-pad");
    var o;
    n.below && (r = e.havingStyle(t.sub()), o = Q.wrapFragment(zt(n.below, r, e), e), o.classes.push(s + "-arrow-pad"));
    var a = ca.svgSpan(n, e), l = -e.fontMetrics().axisHeight + 0.5 * a.height, c = -e.fontMetrics().axisHeight - 0.5 * a.height - 0.111;
    (i.depth > 0.25 || n.label === "\\xleftequilibrium") && (c -= i.depth);
    var u;
    if (o) {
      var h = -e.fontMetrics().axisHeight + o.height + 0.5 * a.height + 0.111;
      u = Q.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: a,
          shift: l
        }, {
          type: "elem",
          elem: o,
          shift: h
        }]
      }, e);
    } else
      u = Q.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: i,
          shift: c
        }, {
          type: "elem",
          elem: a,
          shift: l
        }]
      }, e);
    return u.children[0].children[0].children[1].classes.push("svg-align"), Q.makeSpan(["mrel", "x-arrow"], [u], e);
  },
  mathmlBuilder(n, e) {
    var t = ca.mathMLnode(n.label);
    t.setAttribute("minsize", n.label.charAt(0) === "x" ? "1.75em" : "3.0em");
    var r;
    if (n.body) {
      var i = pm(rn(n.body, e));
      if (n.below) {
        var s = pm(rn(n.below, e));
        r = new we.MathNode("munderover", [t, s, i]);
      } else
        r = new we.MathNode("mover", [t, i]);
    } else if (n.below) {
      var o = pm(rn(n.below, e));
      r = new we.MathNode("munder", [t, o]);
    } else
      r = pm(), r = new we.MathNode("mover", [t, r]);
    return r;
  }
});
var loe = Q.makeSpan;
function QD(n, e) {
  var t = Yn(n.body, e, !0);
  return loe([n.mclass], t, e);
}
function eN(n, e) {
  var t, r = li(n.body, e);
  return n.mclass === "minner" ? t = new we.MathNode("mpadded", r) : n.mclass === "mord" ? n.isCharacterBox ? (t = r[0], t.type = "mi") : t = new we.MathNode("mi", r) : (n.isCharacterBox ? (t = r[0], t.type = "mo") : t = new we.MathNode("mo", r), n.mclass === "mbin" ? (t.attributes.lspace = "0.22em", t.attributes.rspace = "0.22em") : n.mclass === "mpunct" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0.17em") : n.mclass === "mopen" || n.mclass === "mclose" ? (t.attributes.lspace = "0em", t.attributes.rspace = "0em") : n.mclass === "minner" && (t.attributes.lspace = "0.0556em", t.attributes.width = "+0.1111em")), t;
}
_e({
  type: "mclass",
  names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "mclass",
      mode: t.mode,
      mclass: "m" + r.slice(5),
      // TODO(kevinb): don't prefix with 'm'
      body: _n(i),
      isCharacterBox: et.isCharacterBox(i)
    };
  },
  htmlBuilder: QD,
  mathmlBuilder: eN
});
var Oy = (n) => {
  var e = n.type === "ordgroup" && n.body.length ? n.body[0] : n;
  return e.type === "atom" && (e.family === "bin" || e.family === "rel") ? "m" + e.family : "mord";
};
_e({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "mclass",
      mode: t.mode,
      mclass: Oy(e[0]),
      body: _n(e[1]),
      isCharacterBox: et.isCharacterBox(e[1])
    };
  }
});
_e({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[1], s = e[0], o;
    r !== "\\stackrel" ? o = Oy(i) : o = "mrel";
    var a = {
      type: "op",
      mode: i.mode,
      limits: !0,
      alwaysHandleSupSub: !0,
      parentIsSupSub: !1,
      symbol: !1,
      suppressBaseShift: r !== "\\stackrel",
      body: _n(i)
    }, l = {
      type: "supsub",
      mode: s.mode,
      base: a,
      sup: r === "\\underset" ? null : s,
      sub: r === "\\underset" ? s : null
    };
    return {
      type: "mclass",
      mode: t.mode,
      mclass: o,
      body: [l],
      isCharacterBox: et.isCharacterBox(l)
    };
  },
  htmlBuilder: QD,
  mathmlBuilder: eN
});
_e({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "pmb",
      mode: t.mode,
      mclass: Oy(e[0]),
      body: _n(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = Yn(n.body, e, !0), r = Q.makeSpan([n.mclass], t, e);
    return r.style.textShadow = "0.02em 0.01em 0.04px", r;
  },
  mathmlBuilder(n, e) {
    var t = li(n.body, e), r = new we.MathNode("mstyle", t);
    return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
  }
});
var coe = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
}, iC = () => ({
  type: "styling",
  body: [],
  mode: "math",
  style: "display"
}), sC = (n) => n.type === "textord" && n.text === "@", uoe = (n, e) => (n.type === "mathord" || n.type === "atom") && n.text === e;
function hoe(n, e, t) {
  var r = coe[n];
  switch (r) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return t.callFunction(r, [e[0]], [e[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      var i = t.callFunction("\\\\cdleft", [e[0]], []), s = {
        type: "atom",
        text: r,
        mode: "math",
        family: "rel"
      }, o = t.callFunction("\\Big", [s], []), a = t.callFunction("\\\\cdright", [e[1]], []), l = {
        type: "ordgroup",
        mode: "math",
        body: [i, o, a]
      };
      return t.callFunction("\\\\cdparent", [l], []);
    }
    case "\\\\cdlongequal":
      return t.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      var c = {
        type: "textord",
        text: "\\Vert",
        mode: "math"
      };
      return t.callFunction("\\Big", [c], []);
    }
    default:
      return {
        type: "textord",
        text: " ",
        mode: "math"
      };
  }
}
function foe(n) {
  var e = [];
  for (n.gullet.beginGroup(), n.gullet.macros.set("\\cr", "\\\\\\relax"), n.gullet.beginGroup(); ; ) {
    e.push(n.parseExpression(!1, "\\\\")), n.gullet.endGroup(), n.gullet.beginGroup();
    var t = n.fetch().text;
    if (t === "&" || t === "\\\\")
      n.consume();
    else if (t === "\\end") {
      e[e.length - 1].length === 0 && e.pop();
      break;
    } else
      throw new ke("Expected \\\\ or \\cr or \\end", n.nextToken);
  }
  for (var r = [], i = [r], s = 0; s < e.length; s++) {
    for (var o = e[s], a = iC(), l = 0; l < o.length; l++)
      if (!sC(o[l]))
        a.body.push(o[l]);
      else {
        r.push(a), l += 1;
        var c = o6(o[l]).text, u = new Array(2);
        if (u[0] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, u[1] = {
          type: "ordgroup",
          mode: "math",
          body: []
        }, !("=|.".indexOf(c) > -1)) if ("<>AV".indexOf(c) > -1)
          for (var h = 0; h < 2; h++) {
            for (var f = !0, m = l + 1; m < o.length; m++) {
              if (uoe(o[m], c)) {
                f = !1, l = m;
                break;
              }
              if (sC(o[m]))
                throw new ke("Missing a " + c + " character to complete a CD arrow.", o[m]);
              u[h].body.push(o[m]);
            }
            if (f)
              throw new ke("Missing a " + c + " character to complete a CD arrow.", o[l]);
          }
        else
          throw new ke('Expected one of "<>AV=|." after @', o[l]);
        var y = hoe(c, u, n), b = {
          type: "styling",
          body: [y],
          mode: "math",
          style: "display"
          // CD is always displaystyle.
        };
        r.push(b), a = iC();
      }
    s % 2 === 0 ? r.push(a) : r.shift(), r = [], i.push(r);
  }
  n.gullet.endGroup(), n.gullet.endGroup();
  var k = new Array(i[0].length).fill({
    type: "align",
    align: "c",
    pregap: 0.25,
    // CD package sets \enskip between columns.
    postgap: 0.25
    // So pre and post each get half an \enskip, i.e. 0.25em.
  });
  return {
    type: "array",
    mode: "math",
    body: i,
    arraystretch: 1,
    addJot: !0,
    rowGaps: [null],
    cols: k,
    colSeparationType: "CD",
    hLinesBeforeRow: new Array(i.length + 1).fill([])
  };
}
_e({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "cdlabel",
      mode: t.mode,
      side: r.slice(4),
      label: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = e.havingStyle(e.style.sup()), r = Q.wrapFragment(zt(n.label, t, e), e);
    return r.classes.push("cd-label-" + n.side), r.style.bottom = Te(0.8 - r.depth), r.height = 0, r.depth = 0, r;
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mrow", [rn(n.label, e)]);
    return t = new we.MathNode("mpadded", [t]), t.setAttribute("width", "0"), n.side === "left" && t.setAttribute("lspace", "-1width"), t.setAttribute("voffset", "0.7em"), t = new we.MathNode("mstyle", [t]), t.setAttribute("displaystyle", "false"), t.setAttribute("scriptlevel", "1"), t;
  }
});
_e({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "cdlabelparent",
      mode: t.mode,
      fragment: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = Q.wrapFragment(zt(n.fragment, e), e);
    return t.classes.push("cd-vert-arrow"), t;
  },
  mathmlBuilder(n, e) {
    return new we.MathNode("mrow", [rn(n.fragment, e)]);
  }
});
_e({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    for (var {
      parser: t
    } = n, r = vt(e[0], "ordgroup"), i = r.body, s = "", o = 0; o < i.length; o++) {
      var a = vt(i[o], "textord");
      s += a.text;
    }
    var l = parseInt(s), c;
    if (isNaN(l))
      throw new ke("\\@char has non-numeric argument " + s);
    if (l < 0 || l >= 1114111)
      throw new ke("\\@char with invalid code point " + s);
    return l <= 65535 ? c = String.fromCharCode(l) : (l -= 65536, c = String.fromCharCode((l >> 10) + 55296, (l & 1023) + 56320)), {
      type: "textord",
      mode: t.mode,
      text: c
    };
  }
});
var tN = (n, e) => {
  var t = Yn(n.body, e.withColor(n.color), !1);
  return Q.makeFragment(t);
}, nN = (n, e) => {
  var t = li(n.body, e.withColor(n.color)), r = new we.MathNode("mstyle", t);
  return r.setAttribute("mathcolor", n.color), r;
};
_e({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "original"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = vt(e[0], "color-token").color, i = e[1];
    return {
      type: "color",
      mode: t.mode,
      color: r,
      body: _n(i)
    };
  },
  htmlBuilder: tN,
  mathmlBuilder: nN
});
_e({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    allowedInText: !0,
    argTypes: ["color"]
  },
  handler(n, e) {
    var {
      parser: t,
      breakOnTokenText: r
    } = n, i = vt(e[0], "color-token").color;
    t.gullet.macros.set("\\current@color", i);
    var s = t.parseExpression(!0, r);
    return {
      type: "color",
      mode: t.mode,
      color: i,
      body: s
    };
  },
  htmlBuilder: tN,
  mathmlBuilder: nN
});
_e({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = r.gullet.future().text === "[" ? r.parseSizeGroup(!0) : null, s = !r.settings.displayMode || !r.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
    return {
      type: "cr",
      mode: r.mode,
      newLine: s,
      size: i && vt(i, "size").value
    };
  },
  // The following builders are called only at the top level,
  // not within tabular/array environments.
  htmlBuilder(n, e) {
    var t = Q.makeSpan(["mspace"], [], e);
    return n.newLine && (t.classes.push("newline"), n.size && (t.style.marginTop = Te(Sn(n.size, e)))), t;
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mspace");
    return n.newLine && (t.setAttribute("linebreak", "newline"), n.size && t.setAttribute("height", Te(Sn(n.size, e)))), t;
  }
});
var Z4 = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
}, rN = (n) => {
  var e = n.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(e))
    throw new ke("Expected a control sequence", n);
  return e;
}, doe = (n) => {
  var e = n.gullet.popToken();
  return e.text === "=" && (e = n.gullet.popToken(), e.text === " " && (e = n.gullet.popToken())), e;
}, iN = (n, e, t, r) => {
  var i = n.gullet.macros.get(t.text);
  i == null && (t.noexpand = !0, i = {
    tokens: [t],
    numArgs: 0,
    // reproduce the same behavior in expansion
    unexpandable: !n.gullet.isExpandable(t.text)
  }), n.gullet.macros.set(e, i, r);
};
_e({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    e.consumeSpaces();
    var r = e.fetch();
    if (Z4[r.text])
      return (t === "\\global" || t === "\\\\globallong") && (r.text = Z4[r.text]), vt(e.parseFunction(), "internal");
    throw new ke("Invalid token after macro prefix", r);
  }
});
_e({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = e.gullet.popToken(), i = r.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(i))
      throw new ke("Expected a control sequence", r);
    for (var s = 0, o, a = [[]]; e.gullet.future().text !== "{"; )
      if (r = e.gullet.popToken(), r.text === "#") {
        if (e.gullet.future().text === "{") {
          o = e.gullet.future(), a[s].push("{");
          break;
        }
        if (r = e.gullet.popToken(), !/^[1-9]$/.test(r.text))
          throw new ke('Invalid argument number "' + r.text + '"');
        if (parseInt(r.text) !== s + 1)
          throw new ke('Argument number "' + r.text + '" out of order');
        s++, a.push([]);
      } else {
        if (r.text === "EOF")
          throw new ke("Expected a macro definition");
        a[s].push(r.text);
      }
    var {
      tokens: l
    } = e.gullet.consumeArg();
    return o && l.unshift(o), (t === "\\edef" || t === "\\xdef") && (l = e.gullet.expandTokens(l), l.reverse()), e.gullet.macros.set(i, {
      tokens: l,
      numArgs: s,
      delimiters: a
    }, t === Z4[t]), {
      type: "internal",
      mode: e.mode
    };
  }
});
_e({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = rN(e.gullet.popToken());
    e.gullet.consumeSpaces();
    var i = doe(e);
    return iN(e, r, i, t === "\\\\globallet"), {
      type: "internal",
      mode: e.mode
    };
  }
});
_e({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture"
    // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = rN(e.gullet.popToken()), i = e.gullet.popToken(), s = e.gullet.popToken();
    return iN(e, r, s, t === "\\\\globalfuture"), e.gullet.pushToken(s), e.gullet.pushToken(i), {
      type: "internal",
      mode: e.mode
    };
  }
});
var Rf = function(e, t, r) {
  var i = ln.math[e] && ln.math[e].replace, s = t6(i || e, t, r);
  if (!s)
    throw new Error("Unsupported symbol " + e + " and font size " + t + ".");
  return s;
}, l6 = function(e, t, r, i) {
  var s = r.havingBaseStyle(t), o = Q.makeSpan(i.concat(s.sizingClasses(r)), [e], r), a = s.sizeMultiplier / r.sizeMultiplier;
  return o.height *= a, o.depth *= a, o.maxFontSize = s.sizeMultiplier, o;
}, sN = function(e, t, r) {
  var i = t.havingBaseStyle(r), s = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
  e.classes.push("delimcenter"), e.style.top = Te(s), e.height -= s, e.depth += s;
}, poe = function(e, t, r, i, s, o) {
  var a = Q.makeSymbol(e, "Main-Regular", s, i), l = l6(a, t, i, o);
  return r && sN(l, i, t), l;
}, moe = function(e, t, r, i) {
  return Q.makeSymbol(e, "Size" + t + "-Regular", r, i);
}, oN = function(e, t, r, i, s, o) {
  var a = moe(e, t, s, i), l = l6(Q.makeSpan(["delimsizing", "size" + t], [a], i), ot.TEXT, i, o);
  return r && sN(l, i, ot.TEXT), l;
}, D2 = function(e, t, r) {
  var i;
  t === "Size1-Regular" ? i = "delim-size1" : i = "delim-size4";
  var s = Q.makeSpan(["delimsizinginner", i], [Q.makeSpan([], [Q.makeSymbol(e, t, r)])]);
  return {
    type: "elem",
    elem: s
  };
}, N2 = function(e, t, r) {
  var i = Xs["Size4-Regular"][e.charCodeAt(0)] ? Xs["Size4-Regular"][e.charCodeAt(0)][4] : Xs["Size1-Regular"][e.charCodeAt(0)][4], s = new ul("inner", wse(e, Math.round(1e3 * t))), o = new aa([s], {
    width: Te(i),
    height: Te(t),
    // Override CSS rule `.katex svg { width: 100% }`
    style: "width:" + Te(i),
    viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
    preserveAspectRatio: "xMinYMin"
  }), a = Q.makeSvgSpan([], [o], r);
  return a.height = t, a.style.height = Te(t), a.style.width = Te(i), {
    type: "elem",
    elem: a
  };
}, Q4 = 8e-3, mm = {
  type: "kern",
  size: -1 * Q4
}, goe = ["|", "\\lvert", "\\rvert", "\\vert"], yoe = ["\\|", "\\lVert", "\\rVert", "\\Vert"], aN = function(e, t, r, i, s, o) {
  var a, l, c, u, h = "", f = 0;
  a = c = u = e, l = null;
  var m = "Size1-Regular";
  e === "\\uparrow" ? c = u = "⏐" : e === "\\Uparrow" ? c = u = "‖" : e === "\\downarrow" ? a = c = "⏐" : e === "\\Downarrow" ? a = c = "‖" : e === "\\updownarrow" ? (a = "\\uparrow", c = "⏐", u = "\\downarrow") : e === "\\Updownarrow" ? (a = "\\Uparrow", c = "‖", u = "\\Downarrow") : et.contains(goe, e) ? (c = "∣", h = "vert", f = 333) : et.contains(yoe, e) ? (c = "∥", h = "doublevert", f = 556) : e === "[" || e === "\\lbrack" ? (a = "⎡", c = "⎢", u = "⎣", m = "Size4-Regular", h = "lbrack", f = 667) : e === "]" || e === "\\rbrack" ? (a = "⎤", c = "⎥", u = "⎦", m = "Size4-Regular", h = "rbrack", f = 667) : e === "\\lfloor" || e === "⌊" ? (c = a = "⎢", u = "⎣", m = "Size4-Regular", h = "lfloor", f = 667) : e === "\\lceil" || e === "⌈" ? (a = "⎡", c = u = "⎢", m = "Size4-Regular", h = "lceil", f = 667) : e === "\\rfloor" || e === "⌋" ? (c = a = "⎥", u = "⎦", m = "Size4-Regular", h = "rfloor", f = 667) : e === "\\rceil" || e === "⌉" ? (a = "⎤", c = u = "⎥", m = "Size4-Regular", h = "rceil", f = 667) : e === "(" || e === "\\lparen" ? (a = "⎛", c = "⎜", u = "⎝", m = "Size4-Regular", h = "lparen", f = 875) : e === ")" || e === "\\rparen" ? (a = "⎞", c = "⎟", u = "⎠", m = "Size4-Regular", h = "rparen", f = 875) : e === "\\{" || e === "\\lbrace" ? (a = "⎧", l = "⎨", u = "⎩", c = "⎪", m = "Size4-Regular") : e === "\\}" || e === "\\rbrace" ? (a = "⎫", l = "⎬", u = "⎭", c = "⎪", m = "Size4-Regular") : e === "\\lgroup" || e === "⟮" ? (a = "⎧", u = "⎩", c = "⎪", m = "Size4-Regular") : e === "\\rgroup" || e === "⟯" ? (a = "⎫", u = "⎭", c = "⎪", m = "Size4-Regular") : e === "\\lmoustache" || e === "⎰" ? (a = "⎧", u = "⎭", c = "⎪", m = "Size4-Regular") : (e === "\\rmoustache" || e === "⎱") && (a = "⎫", u = "⎩", c = "⎪", m = "Size4-Regular");
  var y = Rf(a, m, s), b = y.height + y.depth, k = Rf(c, m, s), x = k.height + k.depth, M = Rf(u, m, s), T = M.height + M.depth, E = 0, C = 1;
  if (l !== null) {
    var O = Rf(l, m, s);
    E = O.height + O.depth, C = 2;
  }
  var R = b + T + E, F = Math.max(0, Math.ceil((t - R) / (C * x))), H = R + F * C * x, z = i.fontMetrics().axisHeight;
  r && (z *= i.sizeMultiplier);
  var K = H / 2 - z, U = [];
  if (h.length > 0) {
    var ae = H - b - T, ie = Math.round(H * 1e3), he = kse(h, Math.round(ae * 1e3)), Ie = new ul(h, he), Oe = (f / 1e3).toFixed(3) + "em", Ne = (ie / 1e3).toFixed(3) + "em", We = new aa([Ie], {
      width: Oe,
      height: Ne,
      viewBox: "0 0 " + f + " " + ie
    }), q = Q.makeSvgSpan([], [We], i);
    q.height = ie / 1e3, q.style.width = Oe, q.style.height = Ne, U.push({
      type: "elem",
      elem: q
    });
  } else {
    if (U.push(D2(u, m, s)), U.push(mm), l === null) {
      var Re = H - b - T + 2 * Q4;
      U.push(N2(c, Re, i));
    } else {
      var J = (H - b - T - E) / 2 + 2 * Q4;
      U.push(N2(c, J, i)), U.push(mm), U.push(D2(l, m, s)), U.push(mm), U.push(N2(c, J, i));
    }
    U.push(mm), U.push(D2(a, m, s));
  }
  var V = i.havingBaseStyle(ot.TEXT), _t = Q.makeVList({
    positionType: "bottom",
    positionData: K,
    children: U
  }, V);
  return l6(Q.makeSpan(["delimsizing", "mult"], [_t], V), ot.TEXT, i, o);
}, I2 = 80, _2 = 0.08, R2 = function(e, t, r, i, s) {
  var o = vse(e, i, r), a = new ul(e, o), l = new aa([a], {
    // Note: 1000:1 ratio of viewBox to document em width.
    width: "400em",
    height: Te(t),
    viewBox: "0 0 400000 " + r,
    preserveAspectRatio: "xMinYMin slice"
  });
  return Q.makeSvgSpan(["hide-tail"], [l], s);
}, boe = function(e, t) {
  var r = t.havingBaseSizing(), i = hN("\\surd", e * r.sizeMultiplier, uN, r), s = r.sizeMultiplier, o = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), a, l = 0, c = 0, u = 0, h;
  return i.type === "small" ? (u = 1e3 + 1e3 * o + I2, e < 1 ? s = 1 : e < 1.4 && (s = 0.7), l = (1 + o + _2) / s, c = (1 + o) / s, a = R2("sqrtMain", l, u, o, t), a.style.minWidth = "0.853em", h = 0.833 / s) : i.type === "large" ? (u = (1e3 + I2) * Sd[i.size], c = (Sd[i.size] + o) / s, l = (Sd[i.size] + o + _2) / s, a = R2("sqrtSize" + i.size, l, u, o, t), a.style.minWidth = "1.02em", h = 1 / s) : (l = e + o + _2, c = e + o, u = Math.floor(1e3 * e + o) + I2, a = R2("sqrtTall", l, u, o, t), a.style.minWidth = "0.742em", h = 1.056), a.height = c, a.style.height = Te(l), {
    span: a,
    advanceWidth: h,
    // Calculate the actual line width.
    // This actually should depend on the chosen font -- e.g. \boldmath
    // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
    // have thicker rules.
    ruleWidth: (t.fontMetrics().sqrtRuleThickness + o) * s
  };
}, lN = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"], voe = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"], cN = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"], Sd = [0, 1.2, 1.8, 2.4, 3], woe = function(e, t, r, i, s) {
  if (e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle"), et.contains(lN, e) || et.contains(cN, e))
    return oN(e, t, !1, r, i, s);
  if (et.contains(voe, e))
    return aN(e, Sd[t], !1, r, i, s);
  throw new ke("Illegal delimiter: '" + e + "'");
}, koe = [{
  type: "small",
  style: ot.SCRIPTSCRIPT
}, {
  type: "small",
  style: ot.SCRIPT
}, {
  type: "small",
  style: ot.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}], xoe = [{
  type: "small",
  style: ot.SCRIPTSCRIPT
}, {
  type: "small",
  style: ot.SCRIPT
}, {
  type: "small",
  style: ot.TEXT
}, {
  type: "stack"
}], uN = [{
  type: "small",
  style: ot.SCRIPTSCRIPT
}, {
  type: "small",
  style: ot.SCRIPT
}, {
  type: "small",
  style: ot.TEXT
}, {
  type: "large",
  size: 1
}, {
  type: "large",
  size: 2
}, {
  type: "large",
  size: 3
}, {
  type: "large",
  size: 4
}, {
  type: "stack"
}], Soe = function(e) {
  if (e.type === "small")
    return "Main-Regular";
  if (e.type === "large")
    return "Size" + e.size + "-Regular";
  if (e.type === "stack")
    return "Size4-Regular";
  throw new Error("Add support for delim type '" + e.type + "' here.");
}, hN = function(e, t, r, i) {
  for (var s = Math.min(2, 3 - i.style.size), o = s; o < r.length && r[o].type !== "stack"; o++) {
    var a = Rf(e, Soe(r[o]), "math"), l = a.height + a.depth;
    if (r[o].type === "small") {
      var c = i.havingBaseStyle(r[o].style);
      l *= c.sizeMultiplier;
    }
    if (l > t)
      return r[o];
  }
  return r[r.length - 1];
}, fN = function(e, t, r, i, s, o) {
  e === "<" || e === "\\lt" || e === "⟨" ? e = "\\langle" : (e === ">" || e === "\\gt" || e === "⟩") && (e = "\\rangle");
  var a;
  et.contains(cN, e) ? a = koe : et.contains(lN, e) ? a = uN : a = xoe;
  var l = hN(e, t, a, i);
  return l.type === "small" ? poe(e, l.style, r, i, s, o) : l.type === "large" ? oN(e, l.size, r, i, s, o) : aN(e, t, r, i, s, o);
}, Coe = function(e, t, r, i, s, o) {
  var a = i.fontMetrics().axisHeight * i.sizeMultiplier, l = 901, c = 5 / i.fontMetrics().ptPerEm, u = Math.max(t - a, r + a), h = Math.max(
    // In real TeX, calculations are done using integral values which are
    // 65536 per pt, or 655360 per em. So, the division here truncates in
    // TeX but doesn't here, producing different results. If we wanted to
    // exactly match TeX's calculation, we could do
    //   Math.floor(655360 * maxDistFromAxis / 500) *
    //    delimiterFactor / 655360
    // (To see the difference, compare
    //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
    // in TeX and KaTeX)
    u / 500 * l,
    2 * u - c
  );
  return fN(e, h, !0, i, s, o);
}, na = {
  sqrtImage: boe,
  sizedDelim: woe,
  sizeToMaxHeight: Sd,
  customSizedDelim: fN,
  leftRightDelim: Coe
}, oC = {
  "\\bigl": {
    mclass: "mopen",
    size: 1
  },
  "\\Bigl": {
    mclass: "mopen",
    size: 2
  },
  "\\biggl": {
    mclass: "mopen",
    size: 3
  },
  "\\Biggl": {
    mclass: "mopen",
    size: 4
  },
  "\\bigr": {
    mclass: "mclose",
    size: 1
  },
  "\\Bigr": {
    mclass: "mclose",
    size: 2
  },
  "\\biggr": {
    mclass: "mclose",
    size: 3
  },
  "\\Biggr": {
    mclass: "mclose",
    size: 4
  },
  "\\bigm": {
    mclass: "mrel",
    size: 1
  },
  "\\Bigm": {
    mclass: "mrel",
    size: 2
  },
  "\\biggm": {
    mclass: "mrel",
    size: 3
  },
  "\\Biggm": {
    mclass: "mrel",
    size: 4
  },
  "\\big": {
    mclass: "mord",
    size: 1
  },
  "\\Big": {
    mclass: "mord",
    size: 2
  },
  "\\bigg": {
    mclass: "mord",
    size: 3
  },
  "\\Bigg": {
    mclass: "mord",
    size: 4
  }
}, Moe = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
function Dy(n, e) {
  var t = Ly(n);
  if (t && et.contains(Moe, t.text))
    return t;
  throw t ? new ke("Invalid delimiter '" + t.text + "' after '" + e.funcName + "'", n) : new ke("Invalid delimiter type '" + n.type + "'", n);
}
_e({
  type: "delimsizing",
  names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (n, e) => {
    var t = Dy(e[0], n);
    return {
      type: "delimsizing",
      mode: n.parser.mode,
      size: oC[n.funcName].size,
      mclass: oC[n.funcName].mclass,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => n.delim === "." ? Q.makeSpan([n.mclass]) : na.sizedDelim(n.delim, n.size, e, n.mode, [n.mclass]),
  mathmlBuilder: (n) => {
    var e = [];
    n.delim !== "." && e.push(ts(n.delim, n.mode));
    var t = new we.MathNode("mo", e);
    n.mclass === "mopen" || n.mclass === "mclose" ? t.setAttribute("fence", "true") : t.setAttribute("fence", "false"), t.setAttribute("stretchy", "true");
    var r = Te(na.sizeToMaxHeight[n.size]);
    return t.setAttribute("minsize", r), t.setAttribute("maxsize", r), t;
  }
});
function aC(n) {
  if (!n.body)
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
_e({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = n.parser.gullet.macros.get("\\current@color");
    if (t && typeof t != "string")
      throw new ke("\\current@color set to non-string in \\right");
    return {
      type: "leftright-right",
      mode: n.parser.mode,
      delim: Dy(e[0], n).text,
      color: t
      // undefined if not set via \color
    };
  }
});
_e({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = Dy(e[0], n), r = n.parser;
    ++r.leftrightDepth;
    var i = r.parseExpression(!1);
    --r.leftrightDepth, r.expect("\\right", !1);
    var s = vt(r.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: r.mode,
      body: i,
      left: t.text,
      right: s.delim,
      rightColor: s.color
    };
  },
  htmlBuilder: (n, e) => {
    aC(n);
    for (var t = Yn(n.body, e, !0, ["mopen", "mclose"]), r = 0, i = 0, s = !1, o = 0; o < t.length; o++)
      t[o].isMiddle ? s = !0 : (r = Math.max(t[o].height, r), i = Math.max(t[o].depth, i));
    r *= e.sizeMultiplier, i *= e.sizeMultiplier;
    var a;
    if (n.left === "." ? a = a0(e, ["mopen"]) : a = na.leftRightDelim(n.left, r, i, e, n.mode, ["mopen"]), t.unshift(a), s)
      for (var l = 1; l < t.length; l++) {
        var c = t[l], u = c.isMiddle;
        u && (t[l] = na.leftRightDelim(u.delim, r, i, u.options, n.mode, []));
      }
    var h;
    if (n.right === ".")
      h = a0(e, ["mclose"]);
    else {
      var f = n.rightColor ? e.withColor(n.rightColor) : e;
      h = na.leftRightDelim(n.right, r, i, f, n.mode, ["mclose"]);
    }
    return t.push(h), Q.makeSpan(["minner"], t, e);
  },
  mathmlBuilder: (n, e) => {
    aC(n);
    var t = li(n.body, e);
    if (n.left !== ".") {
      var r = new we.MathNode("mo", [ts(n.left, n.mode)]);
      r.setAttribute("fence", "true"), t.unshift(r);
    }
    if (n.right !== ".") {
      var i = new we.MathNode("mo", [ts(n.right, n.mode)]);
      i.setAttribute("fence", "true"), n.rightColor && i.setAttribute("mathcolor", n.rightColor), t.push(i);
    }
    return i6(t);
  }
});
_e({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var t = Dy(e[0], n);
    if (!n.parser.leftrightDepth)
      throw new ke("\\middle without preceding \\left", t);
    return {
      type: "middle",
      mode: n.parser.mode,
      delim: t.text
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    if (n.delim === ".")
      t = a0(e, []);
    else {
      t = na.sizedDelim(n.delim, 1, e, n.mode, []);
      var r = {
        delim: n.delim,
        options: e
      };
      t.isMiddle = r;
    }
    return t;
  },
  mathmlBuilder: (n, e) => {
    var t = n.delim === "\\vert" || n.delim === "|" ? ts("|", "text") : ts(n.delim, n.mode), r = new we.MathNode("mo", [t]);
    return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
  }
});
var c6 = (n, e) => {
  var t = Q.wrapFragment(zt(n.body, e), e), r = n.label.slice(1), i = e.sizeMultiplier, s, o = 0, a = et.isCharacterBox(n.body);
  if (r === "sout")
    s = Q.makeSpan(["stretchy", "sout"]), s.height = e.fontMetrics().defaultRuleThickness / i, o = -0.5 * e.fontMetrics().xHeight;
  else if (r === "phase") {
    var l = Sn({
      number: 0.6,
      unit: "pt"
    }, e), c = Sn({
      number: 0.35,
      unit: "ex"
    }, e), u = e.havingBaseSizing();
    i = i / u.sizeMultiplier;
    var h = t.height + t.depth + l + c;
    t.style.paddingLeft = Te(h / 2 + l);
    var f = Math.floor(1e3 * h * i), m = yse(f), y = new aa([new ul("phase", m)], {
      width: "400em",
      height: Te(f / 1e3),
      viewBox: "0 0 400000 " + f,
      preserveAspectRatio: "xMinYMin slice"
    });
    s = Q.makeSvgSpan(["hide-tail"], [y], e), s.style.height = Te(h), o = t.depth + l + c;
  } else {
    /cancel/.test(r) ? a || t.classes.push("cancel-pad") : r === "angl" ? t.classes.push("anglpad") : t.classes.push("boxpad");
    var b = 0, k = 0, x = 0;
    /box/.test(r) ? (x = Math.max(
      e.fontMetrics().fboxrule,
      // default
      e.minRuleThickness
      // User override.
    ), b = e.fontMetrics().fboxsep + (r === "colorbox" ? 0 : x), k = b) : r === "angl" ? (x = Math.max(e.fontMetrics().defaultRuleThickness, e.minRuleThickness), b = 4 * x, k = Math.max(0, 0.25 - t.depth)) : (b = a ? 0.2 : 0, k = b), s = ca.encloseSpan(t, r, b, k, e), /fbox|boxed|fcolorbox/.test(r) ? (s.style.borderStyle = "solid", s.style.borderWidth = Te(x)) : r === "angl" && x !== 0.049 && (s.style.borderTopWidth = Te(x), s.style.borderRightWidth = Te(x)), o = t.depth + k, n.backgroundColor && (s.style.backgroundColor = n.backgroundColor, n.borderColor && (s.style.borderColor = n.borderColor));
  }
  var M;
  if (n.backgroundColor)
    M = Q.makeVList({
      positionType: "individualShift",
      children: [
        // Put the color background behind inner;
        {
          type: "elem",
          elem: s,
          shift: o
        },
        {
          type: "elem",
          elem: t,
          shift: 0
        }
      ]
    }, e);
  else {
    var T = /cancel|phase/.test(r) ? ["svg-align"] : [];
    M = Q.makeVList({
      positionType: "individualShift",
      children: [
        // Write the \cancel stroke on top of inner.
        {
          type: "elem",
          elem: t,
          shift: 0
        },
        {
          type: "elem",
          elem: s,
          shift: o,
          wrapperClasses: T
        }
      ]
    }, e);
  }
  return /cancel/.test(r) && (M.height = t.height, M.depth = t.depth), /cancel/.test(r) && !a ? Q.makeSpan(["mord", "cancel-lap"], [M], e) : Q.makeSpan(["mord"], [M], e);
}, u6 = (n, e) => {
  var t = 0, r = new we.MathNode(n.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [rn(n.body, e)]);
  switch (n.label) {
    case "\\cancel":
      r.setAttribute("notation", "updiagonalstrike");
      break;
    case "\\bcancel":
      r.setAttribute("notation", "downdiagonalstrike");
      break;
    case "\\phase":
      r.setAttribute("notation", "phasorangle");
      break;
    case "\\sout":
      r.setAttribute("notation", "horizontalstrike");
      break;
    case "\\fbox":
      r.setAttribute("notation", "box");
      break;
    case "\\angl":
      r.setAttribute("notation", "actuarial");
      break;
    case "\\fcolorbox":
    case "\\colorbox":
      if (t = e.fontMetrics().fboxsep * e.fontMetrics().ptPerEm, r.setAttribute("width", "+" + 2 * t + "pt"), r.setAttribute("height", "+" + 2 * t + "pt"), r.setAttribute("lspace", t + "pt"), r.setAttribute("voffset", t + "pt"), n.label === "\\fcolorbox") {
        var i = Math.max(
          e.fontMetrics().fboxrule,
          // default
          e.minRuleThickness
          // user override
        );
        r.setAttribute("style", "border: " + i + "em solid " + String(n.borderColor));
      }
      break;
    case "\\xcancel":
      r.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      break;
  }
  return n.backgroundColor && r.setAttribute("mathbackground", n.backgroundColor), r;
};
_e({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    allowedInText: !0,
    argTypes: ["color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = vt(e[0], "color-token").color, o = e[1];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: s,
      body: o
    };
  },
  htmlBuilder: c6,
  mathmlBuilder: u6
});
_e({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    allowedInText: !0,
    argTypes: ["color", "color", "text"]
  },
  handler(n, e, t) {
    var {
      parser: r,
      funcName: i
    } = n, s = vt(e[0], "color-token").color, o = vt(e[1], "color-token").color, a = e[2];
    return {
      type: "enclose",
      mode: r.mode,
      label: i,
      backgroundColor: o,
      borderColor: s,
      body: a
    };
  },
  htmlBuilder: c6,
  mathmlBuilder: u6
});
_e({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\fbox",
      body: e[0]
    };
  }
});
_e({
  type: "enclose",
  names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "enclose",
      mode: t.mode,
      label: r,
      body: i
    };
  },
  htmlBuilder: c6,
  mathmlBuilder: u6
});
_e({
  type: "enclose",
  names: ["\\angl"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "enclose",
      mode: t.mode,
      label: "\\angl",
      body: e[0]
    };
  }
});
var dN = {};
function fo(n) {
  for (var {
    type: e,
    names: t,
    props: r,
    handler: i,
    htmlBuilder: s,
    mathmlBuilder: o
  } = n, a = {
    type: e,
    numArgs: r.numArgs || 0,
    allowedInText: !1,
    numOptionalArgs: 0,
    handler: i
  }, l = 0; l < t.length; ++l)
    dN[t[l]] = a;
  s && (p1[e] = s), o && (m1[e] = o);
}
var pN = {};
function P(n, e) {
  pN[n] = e;
}
function lC(n) {
  var e = [];
  n.consumeSpaces();
  var t = n.fetch().text;
  for (t === "\\relax" && (n.consume(), n.consumeSpaces(), t = n.fetch().text); t === "\\hline" || t === "\\hdashline"; )
    n.consume(), e.push(t === "\\hdashline"), n.consumeSpaces(), t = n.fetch().text;
  return e;
}
var Ny = (n) => {
  var e = n.parser.settings;
  if (!e.displayMode)
    throw new ke("{" + n.envName + "} can be used only in display mode.");
};
function h6(n) {
  if (n.indexOf("ed") === -1)
    return n.indexOf("*") === -1;
}
function wl(n, e, t) {
  var {
    hskipBeforeAndAfter: r,
    addJot: i,
    cols: s,
    arraystretch: o,
    colSeparationType: a,
    autoTag: l,
    singleRow: c,
    emptySingleRow: u,
    maxNumCols: h,
    leqno: f
  } = e;
  if (n.gullet.beginGroup(), c || n.gullet.macros.set("\\cr", "\\\\\\relax"), !o) {
    var m = n.gullet.expandMacroAsText("\\arraystretch");
    if (m == null)
      o = 1;
    else if (o = parseFloat(m), !o || o < 0)
      throw new ke("Invalid \\arraystretch: " + m);
  }
  n.gullet.beginGroup();
  var y = [], b = [y], k = [], x = [], M = l != null ? [] : void 0;
  function T() {
    l && n.gullet.macros.set("\\@eqnsw", "1", !0);
  }
  function E() {
    M && (n.gullet.macros.get("\\df@tag") ? (M.push(n.subparse([new Ei("\\df@tag")])), n.gullet.macros.set("\\df@tag", void 0, !0)) : M.push(!!l && n.gullet.macros.get("\\@eqnsw") === "1"));
  }
  for (T(), x.push(lC(n)); ; ) {
    var C = n.parseExpression(!1, c ? "\\end" : "\\\\");
    n.gullet.endGroup(), n.gullet.beginGroup(), C = {
      type: "ordgroup",
      mode: n.mode,
      body: C
    }, t && (C = {
      type: "styling",
      mode: n.mode,
      style: t,
      body: [C]
    }), y.push(C);
    var O = n.fetch().text;
    if (O === "&") {
      if (h && y.length === h) {
        if (c || a)
          throw new ke("Too many tab characters: &", n.nextToken);
        n.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
      }
      n.consume();
    } else if (O === "\\end") {
      E(), y.length === 1 && C.type === "styling" && C.body[0].body.length === 0 && (b.length > 1 || !u) && b.pop(), x.length < b.length + 1 && x.push([]);
      break;
    } else if (O === "\\\\") {
      n.consume();
      var R = void 0;
      n.gullet.future().text !== " " && (R = n.parseSizeGroup(!0)), k.push(R ? R.value : null), E(), x.push(lC(n)), y = [], b.push(y), T();
    } else
      throw new ke("Expected & or \\\\ or \\cr or \\end", n.nextToken);
  }
  return n.gullet.endGroup(), n.gullet.endGroup(), {
    type: "array",
    mode: n.mode,
    addJot: i,
    arraystretch: o,
    body: b,
    cols: s,
    rowGaps: k,
    hskipBeforeAndAfter: r,
    hLinesBeforeRow: x,
    colSeparationType: a,
    tags: M,
    leqno: f
  };
}
function f6(n) {
  return n.slice(0, 1) === "d" ? "display" : "text";
}
var po = function(e, t) {
  var r, i, s = e.body.length, o = e.hLinesBeforeRow, a = 0, l = new Array(s), c = [], u = Math.max(
    // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
    t.fontMetrics().arrayRuleWidth,
    t.minRuleThickness
    // User override.
  ), h = 1 / t.fontMetrics().ptPerEm, f = 5 * h;
  if (e.colSeparationType && e.colSeparationType === "small") {
    var m = t.havingStyle(ot.SCRIPT).sizeMultiplier;
    f = 0.2778 * (m / t.sizeMultiplier);
  }
  var y = e.colSeparationType === "CD" ? Sn({
    number: 3,
    unit: "ex"
  }, t) : 12 * h, b = 3 * h, k = e.arraystretch * y, x = 0.7 * k, M = 0.3 * k, T = 0;
  function E(Ut) {
    for (var Kt = 0; Kt < Ut.length; ++Kt)
      Kt > 0 && (T += 0.25), c.push({
        pos: T,
        isDashed: Ut[Kt]
      });
  }
  for (E(o[0]), r = 0; r < e.body.length; ++r) {
    var C = e.body[r], O = x, R = M;
    a < C.length && (a = C.length);
    var F = new Array(C.length);
    for (i = 0; i < C.length; ++i) {
      var H = zt(C[i], t);
      R < H.depth && (R = H.depth), O < H.height && (O = H.height), F[i] = H;
    }
    var z = e.rowGaps[r], K = 0;
    z && (K = Sn(z, t), K > 0 && (K += M, R < K && (R = K), K = 0)), e.addJot && (R += b), F.height = O, F.depth = R, T += O, F.pos = T, T += R + K, l[r] = F, E(o[r + 1]);
  }
  var U = T / 2 + t.fontMetrics().axisHeight, ae = e.cols || [], ie = [], he, Ie, Oe = [];
  if (e.tags && e.tags.some((Ut) => Ut))
    for (r = 0; r < s; ++r) {
      var Ne = l[r], We = Ne.pos - U, q = e.tags[r], Re = void 0;
      q === !0 ? Re = Q.makeSpan(["eqn-num"], [], t) : q === !1 ? Re = Q.makeSpan([], [], t) : Re = Q.makeSpan([], Yn(q, t, !0), t), Re.depth = Ne.depth, Re.height = Ne.height, Oe.push({
        type: "elem",
        elem: Re,
        shift: We
      });
    }
  for (
    i = 0, Ie = 0;
    // Continue while either there are more columns or more column
    // descriptions, so trailing separators don't get lost.
    i < a || Ie < ae.length;
    ++i, ++Ie
  ) {
    for (var J = ae[Ie] || {}, V = !0; J.type === "separator"; ) {
      if (V || (he = Q.makeSpan(["arraycolsep"], []), he.style.width = Te(t.fontMetrics().doubleRuleSep), ie.push(he)), J.separator === "|" || J.separator === ":") {
        var _t = J.separator === "|" ? "solid" : "dashed", at = Q.makeSpan(["vertical-separator"], [], t);
        at.style.height = Te(T), at.style.borderRightWidth = Te(u), at.style.borderRightStyle = _t, at.style.margin = "0 " + Te(-u / 2);
        var mt = T - U;
        mt && (at.style.verticalAlign = Te(-mt)), ie.push(at);
      } else
        throw new ke("Invalid separator type: " + J.separator);
      Ie++, J = ae[Ie] || {}, V = !1;
    }
    if (!(i >= a)) {
      var le = void 0;
      (i > 0 || e.hskipBeforeAndAfter) && (le = et.deflt(J.pregap, f), le !== 0 && (he = Q.makeSpan(["arraycolsep"], []), he.style.width = Te(le), ie.push(he)));
      var tt = [];
      for (r = 0; r < s; ++r) {
        var xe = l[r], ge = xe[i];
        if (ge) {
          var Ot = xe.pos - U;
          ge.depth = xe.depth, ge.height = xe.height, tt.push({
            type: "elem",
            elem: ge,
            shift: Ot
          });
        }
      }
      tt = Q.makeVList({
        positionType: "individualShift",
        children: tt
      }, t), tt = Q.makeSpan(["col-align-" + (J.align || "c")], [tt]), ie.push(tt), (i < a - 1 || e.hskipBeforeAndAfter) && (le = et.deflt(J.postgap, f), le !== 0 && (he = Q.makeSpan(["arraycolsep"], []), he.style.width = Te(le), ie.push(he)));
    }
  }
  if (l = Q.makeSpan(["mtable"], ie), c.length > 0) {
    for (var Ee = Q.makeLineSpan("hline", t, u), Ft = Q.makeLineSpan("hdashline", t, u), ft = [{
      type: "elem",
      elem: l,
      shift: 0
    }]; c.length > 0; ) {
      var Vt = c.pop(), Ue = Vt.pos - U;
      Vt.isDashed ? ft.push({
        type: "elem",
        elem: Ft,
        shift: Ue
      }) : ft.push({
        type: "elem",
        elem: Ee,
        shift: Ue
      });
    }
    l = Q.makeVList({
      positionType: "individualShift",
      children: ft
    }, t);
  }
  if (Oe.length === 0)
    return Q.makeSpan(["mord"], [l], t);
  var yt = Q.makeVList({
    positionType: "individualShift",
    children: Oe
  }, t);
  return yt = Q.makeSpan(["tag"], [yt], t), Q.makeFragment([l, yt]);
}, Toe = {
  c: "center ",
  l: "left ",
  r: "right "
}, mo = function(e, t) {
  for (var r = [], i = new we.MathNode("mtd", [], ["mtr-glue"]), s = new we.MathNode("mtd", [], ["mml-eqn-num"]), o = 0; o < e.body.length; o++) {
    for (var a = e.body[o], l = [], c = 0; c < a.length; c++)
      l.push(new we.MathNode("mtd", [rn(a[c], t)]));
    e.tags && e.tags[o] && (l.unshift(i), l.push(i), e.leqno ? l.unshift(s) : l.push(s)), r.push(new we.MathNode("mtr", l));
  }
  var u = new we.MathNode("mtable", r), h = e.arraystretch === 0.5 ? 0.1 : 0.16 + e.arraystretch - 1 + (e.addJot ? 0.09 : 0);
  u.setAttribute("rowspacing", Te(h));
  var f = "", m = "";
  if (e.cols && e.cols.length > 0) {
    var y = e.cols, b = "", k = !1, x = 0, M = y.length;
    y[0].type === "separator" && (f += "top ", x = 1), y[y.length - 1].type === "separator" && (f += "bottom ", M -= 1);
    for (var T = x; T < M; T++)
      y[T].type === "align" ? (m += Toe[y[T].align], k && (b += "none "), k = !0) : y[T].type === "separator" && k && (b += y[T].separator === "|" ? "solid " : "dashed ", k = !1);
    u.setAttribute("columnalign", m.trim()), /[sd]/.test(b) && u.setAttribute("columnlines", b.trim());
  }
  if (e.colSeparationType === "align") {
    for (var E = e.cols || [], C = "", O = 1; O < E.length; O++)
      C += O % 2 ? "0em " : "1em ";
    u.setAttribute("columnspacing", C.trim());
  } else e.colSeparationType === "alignat" || e.colSeparationType === "gather" ? u.setAttribute("columnspacing", "0em") : e.colSeparationType === "small" ? u.setAttribute("columnspacing", "0.2778em") : e.colSeparationType === "CD" ? u.setAttribute("columnspacing", "0.5em") : u.setAttribute("columnspacing", "1em");
  var R = "", F = e.hLinesBeforeRow;
  f += F[0].length > 0 ? "left " : "", f += F[F.length - 1].length > 0 ? "right " : "";
  for (var H = 1; H < F.length - 1; H++)
    R += F[H].length === 0 ? "none " : F[H][0] ? "dashed " : "solid ";
  return /[sd]/.test(R) && u.setAttribute("rowlines", R.trim()), f !== "" && (u = new we.MathNode("menclose", [u]), u.setAttribute("notation", f.trim())), e.arraystretch && e.arraystretch < 1 && (u = new we.MathNode("mstyle", [u]), u.setAttribute("scriptlevel", "1")), u;
}, mN = function(e, t) {
  e.envName.indexOf("ed") === -1 && Ny(e);
  var r = [], i = e.envName.indexOf("at") > -1 ? "alignat" : "align", s = e.envName === "split", o = wl(e.parser, {
    cols: r,
    addJot: !0,
    autoTag: s ? void 0 : h6(e.envName),
    emptySingleRow: !0,
    colSeparationType: i,
    maxNumCols: s ? 2 : void 0,
    leqno: e.parser.settings.leqno
  }, "display"), a, l = 0, c = {
    type: "ordgroup",
    mode: e.mode,
    body: []
  };
  if (t[0] && t[0].type === "ordgroup") {
    for (var u = "", h = 0; h < t[0].body.length; h++) {
      var f = vt(t[0].body[h], "textord");
      u += f.text;
    }
    a = Number(u), l = a * 2;
  }
  var m = !l;
  o.body.forEach(function(x) {
    for (var M = 1; M < x.length; M += 2) {
      var T = vt(x[M], "styling"), E = vt(T.body[0], "ordgroup");
      E.body.unshift(c);
    }
    if (m)
      l < x.length && (l = x.length);
    else {
      var C = x.length / 2;
      if (a < C)
        throw new ke("Too many math in a row: " + ("expected " + a + ", but got " + C), x[0]);
    }
  });
  for (var y = 0; y < l; ++y) {
    var b = "r", k = 0;
    y % 2 === 1 ? b = "l" : y > 0 && m && (k = 1), r[y] = {
      type: "align",
      align: b,
      pregap: k,
      postgap: 0
    };
  }
  return o.colSeparationType = m ? "align" : "alignat", o;
};
fo({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = Ly(e[0]), r = t ? [e[0]] : vt(e[0], "ordgroup").body, i = r.map(function(o) {
      var a = o6(o), l = a.text;
      if ("lcr".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      if (l === "|")
        return {
          type: "separator",
          separator: "|"
        };
      if (l === ":")
        return {
          type: "separator",
          separator: ":"
        };
      throw new ke("Unknown column alignment: " + l, o);
    }), s = {
      cols: i,
      hskipBeforeAndAfter: !0,
      // \@preamble in lttab.dtx
      maxNumCols: i.length
    };
    return wl(n.parser, s, f6(n.envName));
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[n.envName.replace("*", "")], t = "c", r = {
      hskipBeforeAndAfter: !1,
      cols: [{
        type: "align",
        align: t
      }]
    };
    if (n.envName.charAt(n.envName.length - 1) === "*") {
      var i = n.parser;
      if (i.consumeSpaces(), i.fetch().text === "[") {
        if (i.consume(), i.consumeSpaces(), t = i.fetch().text, "lcr".indexOf(t) === -1)
          throw new ke("Expected l or c or r", i.nextToken);
        i.consume(), i.consumeSpaces(), i.expect("]"), i.consume(), r.cols = [{
          type: "align",
          align: t
        }];
      }
    }
    var s = wl(n.parser, r, f6(n.envName)), o = Math.max(0, ...s.body.map((a) => a.length));
    return s.cols = new Array(o).fill({
      type: "align",
      align: t
    }), e ? {
      type: "leftright",
      mode: n.mode,
      body: [s],
      left: e[0],
      right: e[1],
      rightColor: void 0
      // \right uninfluenced by \color in array
    } : s;
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 0.5
    }, t = wl(n.parser, e, "script");
    return t.colSeparationType = "small", t;
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var t = Ly(e[0]), r = t ? [e[0]] : vt(e[0], "ordgroup").body, i = r.map(function(o) {
      var a = o6(o), l = a.text;
      if ("lc".indexOf(l) !== -1)
        return {
          type: "align",
          align: l
        };
      throw new ke("Unknown column alignment: " + l, o);
    });
    if (i.length > 1)
      throw new ke("{subarray} can contain only one column");
    var s = {
      cols: i,
      hskipBeforeAndAfter: !1,
      arraystretch: 0.5
    };
    if (s = wl(n.parser, s, "script"), s.body.length > 0 && s.body[0].length > 1)
      throw new ke("{subarray} can contain only one column");
    return s;
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var e = {
      arraystretch: 1.2,
      cols: [{
        type: "align",
        align: "l",
        pregap: 0,
        // TODO(kevinb) get the current style.
        // For now we use the metrics for TEXT style which is what we were
        // doing before.  Before attempting to get the current style we
        // should look at TeX's behavior especially for \over and matrices.
        postgap: 1
        /* 1em quad */
      }, {
        type: "align",
        align: "l",
        pregap: 0,
        postgap: 0
      }]
    }, t = wl(n.parser, e, f6(n.envName));
    return {
      type: "leftright",
      mode: n.mode,
      body: [t],
      left: n.envName.indexOf("r") > -1 ? "." : "\\{",
      right: n.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: void 0
    };
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: mN,
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    et.contains(["gather", "gather*"], n.envName) && Ny(n);
    var e = {
      cols: [{
        type: "align",
        align: "c"
      }],
      addJot: !0,
      colSeparationType: "gather",
      autoTag: h6(n.envName),
      emptySingleRow: !0,
      leqno: n.parser.settings.leqno
    };
    return wl(n.parser, e, "display");
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: mN,
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(n) {
    Ny(n);
    var e = {
      autoTag: h6(n.envName),
      emptySingleRow: !0,
      singleRow: !0,
      maxNumCols: 1,
      leqno: n.parser.settings.leqno
    };
    return wl(n.parser, e, "display");
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
fo({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(n) {
    return Ny(n), foe(n.parser);
  },
  htmlBuilder: po,
  mathmlBuilder: mo
});
P("\\nonumber", "\\gdef\\@eqnsw{0}");
P("\\notag", "\\nonumber");
_e({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !0
  },
  handler(n, e) {
    throw new ke(n.funcName + " valid only within array environment");
  }
});
var cC = dN;
_e({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    if (i.type !== "ordgroup")
      throw new ke("Invalid environment name", i);
    for (var s = "", o = 0; o < i.body.length; ++o)
      s += vt(i.body[o], "textord").text;
    if (r === "\\begin") {
      if (!cC.hasOwnProperty(s))
        throw new ke("No such environment: " + s, i);
      var a = cC[s], {
        args: l,
        optArgs: c
      } = t.parseArguments("\\begin{" + s + "}", a), u = {
        mode: t.mode,
        envName: s,
        parser: t
      }, h = a.handler(u, l, c);
      t.expect("\\end", !1);
      var f = t.nextToken, m = vt(t.parseFunction(), "environment");
      if (m.name !== s)
        throw new ke("Mismatch: \\begin{" + s + "} matched by \\end{" + m.name + "}", f);
      return h;
    }
    return {
      type: "environment",
      mode: t.mode,
      name: s,
      nameGroup: i
    };
  }
});
var gN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return zt(n.body, r);
}, yN = (n, e) => {
  var t = n.font, r = e.withFont(t);
  return rn(n.body, r);
}, uC = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};
_e({
  type: "font",
  names: [
    // styles, except \boldsymbol defined below
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\mathsfit",
    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathtt",
    // aliases, except \bm defined below
    "\\Bbb",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = g1(e[0]), s = r;
    return s in uC && (s = uC[s]), {
      type: "font",
      mode: t.mode,
      font: s.slice(1),
      body: i
    };
  },
  htmlBuilder: gN,
  mathmlBuilder: yN
});
_e({
  type: "mclass",
  names: ["\\boldsymbol", "\\bm"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0], i = et.isCharacterBox(r);
    return {
      type: "mclass",
      mode: t.mode,
      mclass: Oy(r),
      body: [{
        type: "font",
        mode: t.mode,
        font: "boldsymbol",
        body: r
      }],
      isCharacterBox: i
    };
  }
});
_e({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      breakOnTokenText: i
    } = n, {
      mode: s
    } = t, o = t.parseExpression(!0, i), a = "math" + r.slice(1);
    return {
      type: "font",
      mode: s,
      font: a,
      body: {
        type: "ordgroup",
        mode: t.mode,
        body: o
      }
    };
  },
  htmlBuilder: gN,
  mathmlBuilder: yN
});
var bN = (n, e) => {
  var t = e;
  return n === "display" ? t = t.id >= ot.SCRIPT.id ? t.text() : ot.DISPLAY : n === "text" && t.size === ot.DISPLAY.size ? t = ot.TEXT : n === "script" ? t = ot.SCRIPT : n === "scriptscript" && (t = ot.SCRIPTSCRIPT), t;
}, d6 = (n, e) => {
  var t = bN(n.size, e.style), r = t.fracNum(), i = t.fracDen(), s;
  s = e.havingStyle(r);
  var o = zt(n.numer, s, e);
  if (n.continued) {
    var a = 8.5 / e.fontMetrics().ptPerEm, l = 3.5 / e.fontMetrics().ptPerEm;
    o.height = o.height < a ? a : o.height, o.depth = o.depth < l ? l : o.depth;
  }
  s = e.havingStyle(i);
  var c = zt(n.denom, s, e), u, h, f;
  n.hasBarLine ? (n.barSize ? (h = Sn(n.barSize, e), u = Q.makeLineSpan("frac-line", e, h)) : u = Q.makeLineSpan("frac-line", e), h = u.height, f = u.height) : (u = null, h = 0, f = e.fontMetrics().defaultRuleThickness);
  var m, y, b;
  t.size === ot.DISPLAY.size || n.size === "display" ? (m = e.fontMetrics().num1, h > 0 ? y = 3 * f : y = 7 * f, b = e.fontMetrics().denom1) : (h > 0 ? (m = e.fontMetrics().num2, y = f) : (m = e.fontMetrics().num3, y = 3 * f), b = e.fontMetrics().denom2);
  var k;
  if (u) {
    var M = e.fontMetrics().axisHeight;
    m - o.depth - (M + 0.5 * h) < y && (m += y - (m - o.depth - (M + 0.5 * h))), M - 0.5 * h - (c.height - b) < y && (b += y - (M - 0.5 * h - (c.height - b)));
    var T = -(M - 0.5 * h);
    k = Q.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: b
      }, {
        type: "elem",
        elem: u,
        shift: T
      }, {
        type: "elem",
        elem: o,
        shift: -m
      }]
    }, e);
  } else {
    var x = m - o.depth - (c.height - b);
    x < y && (m += 0.5 * (y - x), b += 0.5 * (y - x)), k = Q.makeVList({
      positionType: "individualShift",
      children: [{
        type: "elem",
        elem: c,
        shift: b
      }, {
        type: "elem",
        elem: o,
        shift: -m
      }]
    }, e);
  }
  s = e.havingStyle(t), k.height *= s.sizeMultiplier / e.sizeMultiplier, k.depth *= s.sizeMultiplier / e.sizeMultiplier;
  var E;
  t.size === ot.DISPLAY.size ? E = e.fontMetrics().delim1 : t.size === ot.SCRIPTSCRIPT.size ? E = e.havingStyle(ot.SCRIPT).fontMetrics().delim2 : E = e.fontMetrics().delim2;
  var C, O;
  return n.leftDelim == null ? C = a0(e, ["mopen"]) : C = na.customSizedDelim(n.leftDelim, E, !0, e.havingStyle(t), n.mode, ["mopen"]), n.continued ? O = Q.makeSpan([]) : n.rightDelim == null ? O = a0(e, ["mclose"]) : O = na.customSizedDelim(n.rightDelim, E, !0, e.havingStyle(t), n.mode, ["mclose"]), Q.makeSpan(["mord"].concat(s.sizingClasses(e)), [C, Q.makeSpan(["mfrac"], [k]), O], e);
}, p6 = (n, e) => {
  var t = new we.MathNode("mfrac", [rn(n.numer, e), rn(n.denom, e)]);
  if (!n.hasBarLine)
    t.setAttribute("linethickness", "0px");
  else if (n.barSize) {
    var r = Sn(n.barSize, e);
    t.setAttribute("linethickness", Te(r));
  }
  var i = bN(n.size, e.style);
  if (i.size !== e.style.size) {
    t = new we.MathNode("mstyle", [t]);
    var s = i.size === ot.DISPLAY.size ? "true" : "false";
    t.setAttribute("displaystyle", s), t.setAttribute("scriptlevel", "0");
  }
  if (n.leftDelim != null || n.rightDelim != null) {
    var o = [];
    if (n.leftDelim != null) {
      var a = new we.MathNode("mo", [new we.TextNode(n.leftDelim.replace("\\", ""))]);
      a.setAttribute("fence", "true"), o.push(a);
    }
    if (o.push(t), n.rightDelim != null) {
      var l = new we.MathNode("mo", [new we.TextNode(n.rightDelim.replace("\\", ""))]);
      l.setAttribute("fence", "true"), o.push(l);
    }
    return i6(o);
  }
  return t;
};
_e({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac",
    // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac"
    // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1], o, a = null, l = null, c = "auto";
    switch (r) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        o = !0;
        break;
      case "\\\\atopfrac":
        o = !1;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        o = !1, a = "(", l = ")";
        break;
      case "\\\\bracefrac":
        o = !1, a = "\\{", l = "\\}";
        break;
      case "\\\\brackfrac":
        o = !1, a = "[", l = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }
    switch (r) {
      case "\\dfrac":
      case "\\dbinom":
        c = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        c = "text";
        break;
    }
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !1,
      numer: i,
      denom: s,
      hasBarLine: o,
      leftDelim: a,
      rightDelim: l,
      size: c,
      barSize: null
    };
  },
  htmlBuilder: d6,
  mathmlBuilder: p6
});
_e({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = e[1];
    return {
      type: "genfrac",
      mode: t.mode,
      continued: !0,
      numer: i,
      denom: s,
      hasBarLine: !0,
      leftDelim: null,
      rightDelim: null,
      size: "display",
      barSize: null
    };
  }
});
_e({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: !0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t,
      token: r
    } = n, i;
    switch (t) {
      case "\\over":
        i = "\\frac";
        break;
      case "\\choose":
        i = "\\binom";
        break;
      case "\\atop":
        i = "\\\\atopfrac";
        break;
      case "\\brace":
        i = "\\\\bracefrac";
        break;
      case "\\brack":
        i = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: e.mode,
      replaceWith: i,
      token: r
    };
  }
});
var hC = ["display", "text", "script", "scriptscript"], fC = function(e) {
  var t = null;
  return e.length > 0 && (t = e, t = t === "." ? null : t), t;
};
_e({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: !0,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[4], i = e[5], s = g1(e[0]), o = s.type === "atom" && s.family === "open" ? fC(s.text) : null, a = g1(e[1]), l = a.type === "atom" && a.family === "close" ? fC(a.text) : null, c = vt(e[2], "size"), u, h = null;
    c.isBlank ? u = !0 : (h = c.value, u = h.number > 0);
    var f = "auto", m = e[3];
    if (m.type === "ordgroup") {
      if (m.body.length > 0) {
        var y = vt(m.body[0], "textord");
        f = hC[Number(y.text)];
      }
    } else
      m = vt(m, "textord"), f = hC[Number(m.text)];
    return {
      type: "genfrac",
      mode: t.mode,
      numer: r,
      denom: i,
      continued: !1,
      hasBarLine: u,
      barSize: h,
      leftDelim: o,
      rightDelim: l,
      size: f
    };
  },
  htmlBuilder: d6,
  mathmlBuilder: p6
});
_e({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n;
    return {
      type: "infix",
      mode: t.mode,
      replaceWith: "\\\\abovefrac",
      size: vt(e[0], "size").value,
      token: i
    };
  }
});
_e({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0], s = nse(vt(e[1], "infix").size), o = e[2], a = s.number > 0;
    return {
      type: "genfrac",
      mode: t.mode,
      numer: i,
      denom: o,
      continued: !1,
      hasBarLine: a,
      barSize: s,
      leftDelim: null,
      rightDelim: null,
      size: "auto"
    };
  },
  htmlBuilder: d6,
  mathmlBuilder: p6
});
var vN = (n, e) => {
  var t = e.style, r, i;
  n.type === "supsub" ? (r = n.sup ? zt(n.sup, e.havingStyle(t.sup()), e) : zt(n.sub, e.havingStyle(t.sub()), e), i = vt(n.base, "horizBrace")) : i = vt(n, "horizBrace");
  var s = zt(i.base, e.havingBaseStyle(ot.DISPLAY)), o = ca.svgSpan(i, e), a;
  if (i.isOver ? (a = Q.makeVList({
    positionType: "firstBaseline",
    children: [{
      type: "elem",
      elem: s
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: o
    }]
  }, e), a.children[0].children[0].children[1].classes.push("svg-align")) : (a = Q.makeVList({
    positionType: "bottom",
    positionData: s.depth + 0.1 + o.height,
    children: [{
      type: "elem",
      elem: o
    }, {
      type: "kern",
      size: 0.1
    }, {
      type: "elem",
      elem: s
    }]
  }, e), a.children[0].children[0].children[0].classes.push("svg-align")), r) {
    var l = Q.makeSpan(["mord", i.isOver ? "mover" : "munder"], [a], e);
    i.isOver ? a = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: r
      }]
    }, e) : a = Q.makeVList({
      positionType: "bottom",
      positionData: l.depth + 0.2 + r.height + r.depth,
      children: [{
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 0.2
      }, {
        type: "elem",
        elem: l
      }]
    }, e);
  }
  return Q.makeSpan(["mord", i.isOver ? "mover" : "munder"], [a], e);
}, Aoe = (n, e) => {
  var t = ca.mathMLnode(n.label);
  return new we.MathNode(n.isOver ? "mover" : "munder", [rn(n.base, e), t]);
};
_e({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n;
    return {
      type: "horizBrace",
      mode: t.mode,
      label: r,
      isOver: /^\\over/.test(r),
      base: e[0]
    };
  },
  htmlBuilder: vN,
  mathmlBuilder: Aoe
});
_e({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[1], i = vt(e[0], "url").url;
    return t.settings.isTrusted({
      command: "\\href",
      url: i
    }) ? {
      type: "href",
      mode: t.mode,
      href: i,
      body: _n(r)
    } : t.formatUnsupportedCmd("\\href");
  },
  htmlBuilder: (n, e) => {
    var t = Yn(n.body, e, !1);
    return Q.makeAnchor(n.href, [], t, e);
  },
  mathmlBuilder: (n, e) => {
    var t = hl(n.body, e);
    return t instanceof Si || (t = new Si("mrow", [t])), t.setAttribute("href", n.href), t;
  }
});
_e({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = vt(e[0], "url").url;
    if (!t.settings.isTrusted({
      command: "\\url",
      url: r
    }))
      return t.formatUnsupportedCmd("\\url");
    for (var i = [], s = 0; s < r.length; s++) {
      var o = r[s];
      o === "~" && (o = "\\textasciitilde"), i.push({
        type: "textord",
        mode: "text",
        text: o
      });
    }
    var a = {
      type: "text",
      mode: t.mode,
      font: "\\texttt",
      body: i
    };
    return {
      type: "href",
      mode: t.mode,
      href: r,
      body: _n(a)
    };
  }
});
_e({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "hbox",
      mode: t.mode,
      body: _n(e[0])
    };
  },
  htmlBuilder(n, e) {
    var t = Yn(n.body, e, !1);
    return Q.makeFragment(t);
  },
  mathmlBuilder(n, e) {
    return new we.MathNode("mrow", li(n.body, e));
  }
});
_e({
  type: "html",
  names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r,
      token: i
    } = n, s = vt(e[0], "raw").string, o = e[1];
    t.settings.strict && t.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
    var a, l = {};
    switch (r) {
      case "\\htmlClass":
        l.class = s, a = {
          command: "\\htmlClass",
          class: s
        };
        break;
      case "\\htmlId":
        l.id = s, a = {
          command: "\\htmlId",
          id: s
        };
        break;
      case "\\htmlStyle":
        l.style = s, a = {
          command: "\\htmlStyle",
          style: s
        };
        break;
      case "\\htmlData": {
        for (var c = s.split(","), u = 0; u < c.length; u++) {
          var h = c[u].split("=");
          if (h.length !== 2)
            throw new ke("Error parsing key-value for \\htmlData");
          l["data-" + h[0].trim()] = h[1].trim();
        }
        a = {
          command: "\\htmlData",
          attributes: l
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }
    return t.settings.isTrusted(a) ? {
      type: "html",
      mode: t.mode,
      attributes: l,
      body: _n(o)
    } : t.formatUnsupportedCmd(r);
  },
  htmlBuilder: (n, e) => {
    var t = Yn(n.body, e, !1), r = ["enclosing"];
    n.attributes.class && r.push(...n.attributes.class.trim().split(/\s+/));
    var i = Q.makeSpan(r, t, e);
    for (var s in n.attributes)
      s !== "class" && n.attributes.hasOwnProperty(s) && i.setAttribute(s, n.attributes[s]);
    return i;
  },
  mathmlBuilder: (n, e) => hl(n.body, e)
});
_e({
  type: "htmlmathml",
  names: ["\\html@mathml"],
  props: {
    numArgs: 2,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "htmlmathml",
      mode: t.mode,
      html: _n(e[0]),
      mathml: _n(e[1])
    };
  },
  htmlBuilder: (n, e) => {
    var t = Yn(n.html, e, !1);
    return Q.makeFragment(t);
  },
  mathmlBuilder: (n, e) => hl(n.mathml, e)
});
var P2 = function(e) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e))
    return {
      number: +e,
      unit: "bp"
    };
  var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
  if (!t)
    throw new ke("Invalid size: '" + e + "' in \\includegraphics");
  var r = {
    number: +(t[1] + t[2]),
    // sign + magnitude, cast to number
    unit: t[3]
  };
  if (!HD(r))
    throw new ke("Invalid unit: '" + r.unit + "' in \\includegraphics.");
  return r;
};
_e({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: !1
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = {
      number: 0,
      unit: "em"
    }, s = {
      number: 0.9,
      unit: "em"
    }, o = {
      number: 0,
      unit: "em"
    }, a = "";
    if (t[0])
      for (var l = vt(t[0], "raw").string, c = l.split(","), u = 0; u < c.length; u++) {
        var h = c[u].split("=");
        if (h.length === 2) {
          var f = h[1].trim();
          switch (h[0].trim()) {
            case "alt":
              a = f;
              break;
            case "width":
              i = P2(f);
              break;
            case "height":
              s = P2(f);
              break;
            case "totalheight":
              o = P2(f);
              break;
            default:
              throw new ke("Invalid key: '" + h[0] + "' in \\includegraphics.");
          }
        }
      }
    var m = vt(e[0], "url").url;
    return a === "" && (a = m, a = a.replace(/^.*[\\/]/, ""), a = a.substring(0, a.lastIndexOf("."))), r.settings.isTrusted({
      command: "\\includegraphics",
      url: m
    }) ? {
      type: "includegraphics",
      mode: r.mode,
      alt: a,
      width: i,
      height: s,
      totalheight: o,
      src: m
    } : r.formatUnsupportedCmd("\\includegraphics");
  },
  htmlBuilder: (n, e) => {
    var t = Sn(n.height, e), r = 0;
    n.totalheight.number > 0 && (r = Sn(n.totalheight, e) - t);
    var i = 0;
    n.width.number > 0 && (i = Sn(n.width, e));
    var s = {
      height: Te(t + r)
    };
    i > 0 && (s.width = Te(i)), r > 0 && (s.verticalAlign = Te(-r));
    var o = new Ase(n.src, n.alt, s);
    return o.height = t, o.depth = r, o;
  },
  mathmlBuilder: (n, e) => {
    var t = new we.MathNode("mglyph", []);
    t.setAttribute("alt", n.alt);
    var r = Sn(n.height, e), i = 0;
    if (n.totalheight.number > 0 && (i = Sn(n.totalheight, e) - r, t.setAttribute("valign", Te(-i))), t.setAttribute("height", Te(r + i)), n.width.number > 0) {
      var s = Sn(n.width, e);
      t.setAttribute("width", Te(s));
    }
    return t.setAttribute("src", n.src), t;
  }
});
_e({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = vt(e[0], "size");
    if (t.settings.strict) {
      var s = r[1] === "m", o = i.value.unit === "mu";
      s ? (o || t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " supports only mu units, " + ("not " + i.value.unit + " units")), t.mode !== "math" && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " works only in math mode")) : o && t.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + r + " doesn't support mu units");
    }
    return {
      type: "kern",
      mode: t.mode,
      dimension: i.value
    };
  },
  htmlBuilder(n, e) {
    return Q.makeGlue(n.dimension, e);
  },
  mathmlBuilder(n, e) {
    var t = Sn(n.dimension, e);
    return new we.SpaceNode(t);
  }
});
_e({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "lap",
      mode: t.mode,
      alignment: r.slice(5),
      body: i
    };
  },
  htmlBuilder: (n, e) => {
    var t;
    n.alignment === "clap" ? (t = Q.makeSpan([], [zt(n.body, e)]), t = Q.makeSpan(["inner"], [t], e)) : t = Q.makeSpan(["inner"], [zt(n.body, e)]);
    var r = Q.makeSpan(["fix"], []), i = Q.makeSpan([n.alignment], [t, r], e), s = Q.makeSpan(["strut"]);
    return s.style.height = Te(i.height + i.depth), i.depth && (s.style.verticalAlign = Te(-i.depth)), i.children.unshift(s), i = Q.makeSpan(["thinbox"], [i], e), Q.makeSpan(["mord", "vbox"], [i], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new we.MathNode("mpadded", [rn(n.body, e)]);
    if (n.alignment !== "rlap") {
      var r = n.alignment === "llap" ? "-1" : "-0.5";
      t.setAttribute("lspace", r + "width");
    }
    return t.setAttribute("width", "0px"), t;
  }
});
_e({
  type: "styling",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    var {
      funcName: t,
      parser: r
    } = n, i = r.mode;
    r.switchMode("math");
    var s = t === "\\(" ? "\\)" : "$", o = r.parseExpression(!1, s);
    return r.expect(s), r.switchMode(i), {
      type: "styling",
      mode: r.mode,
      style: "text",
      body: o
    };
  }
});
_e({
  type: "text",
  // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInMath: !1
  },
  handler(n, e) {
    throw new ke("Mismatched " + n.funcName);
  }
});
var dC = (n, e) => {
  switch (e.style.size) {
    case ot.DISPLAY.size:
      return n.display;
    case ot.TEXT.size:
      return n.text;
    case ot.SCRIPT.size:
      return n.script;
    case ot.SCRIPTSCRIPT.size:
      return n.scriptscript;
    default:
      return n.text;
  }
};
_e({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n;
    return {
      type: "mathchoice",
      mode: t.mode,
      display: _n(e[0]),
      text: _n(e[1]),
      script: _n(e[2]),
      scriptscript: _n(e[3])
    };
  },
  htmlBuilder: (n, e) => {
    var t = dC(n, e), r = Yn(t, e, !1);
    return Q.makeFragment(r);
  },
  mathmlBuilder: (n, e) => {
    var t = dC(n, e);
    return hl(t, e);
  }
});
var wN = (n, e, t, r, i, s, o) => {
  n = Q.makeSpan([], [n]);
  var a = t && et.isCharacterBox(t), l, c;
  if (e) {
    var u = zt(e, r.havingStyle(i.sup()), r);
    c = {
      elem: u,
      kern: Math.max(r.fontMetrics().bigOpSpacing1, r.fontMetrics().bigOpSpacing3 - u.depth)
    };
  }
  if (t) {
    var h = zt(t, r.havingStyle(i.sub()), r);
    l = {
      elem: h,
      kern: Math.max(r.fontMetrics().bigOpSpacing2, r.fontMetrics().bigOpSpacing4 - h.height)
    };
  }
  var f;
  if (c && l) {
    var m = r.fontMetrics().bigOpSpacing5 + l.elem.height + l.elem.depth + l.kern + n.depth + o;
    f = Q.makeVList({
      positionType: "bottom",
      positionData: m,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: Te(-s)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: Te(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else if (l) {
    var y = n.height - o;
    f = Q.makeVList({
      positionType: "top",
      positionData: y,
      children: [{
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }, {
        type: "elem",
        elem: l.elem,
        marginLeft: Te(-s)
      }, {
        type: "kern",
        size: l.kern
      }, {
        type: "elem",
        elem: n
      }]
    }, r);
  } else if (c) {
    var b = n.depth + o;
    f = Q.makeVList({
      positionType: "bottom",
      positionData: b,
      children: [{
        type: "elem",
        elem: n
      }, {
        type: "kern",
        size: c.kern
      }, {
        type: "elem",
        elem: c.elem,
        marginLeft: Te(s)
      }, {
        type: "kern",
        size: r.fontMetrics().bigOpSpacing5
      }]
    }, r);
  } else
    return n;
  var k = [f];
  if (l && s !== 0 && !a) {
    var x = Q.makeSpan(["mspace"], [], r);
    x.style.marginRight = Te(s), k.unshift(x);
  }
  return Q.makeSpan(["mop", "op-limits"], k, r);
}, kN = ["\\smallint"], qh = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = vt(n.base, "op"), i = !0) : s = vt(n, "op");
  var o = e.style, a = !1;
  o.size === ot.DISPLAY.size && s.symbol && !et.contains(kN, s.name) && (a = !0);
  var l;
  if (s.symbol) {
    var c = a ? "Size2-Regular" : "Size1-Regular", u = "";
    if ((s.name === "\\oiint" || s.name === "\\oiiint") && (u = s.name.slice(1), s.name = u === "oiint" ? "\\iint" : "\\iiint"), l = Q.makeSymbol(s.name, c, "math", e, ["mop", "op-symbol", a ? "large-op" : "small-op"]), u.length > 0) {
      var h = l.italic, f = Q.staticSvg(u + "Size" + (a ? "2" : "1"), e);
      l = Q.makeVList({
        positionType: "individualShift",
        children: [{
          type: "elem",
          elem: l,
          shift: 0
        }, {
          type: "elem",
          elem: f,
          shift: a ? 0.08 : 0
        }]
      }, e), s.name = "\\" + u, l.classes.unshift("mop"), l.italic = h;
    }
  } else if (s.body) {
    var m = Yn(s.body, e, !0);
    m.length === 1 && m[0] instanceof es ? (l = m[0], l.classes[0] = "mop") : l = Q.makeSpan(["mop"], m, e);
  } else {
    for (var y = [], b = 1; b < s.name.length; b++)
      y.push(Q.mathsym(s.name[b], s.mode, e));
    l = Q.makeSpan(["mop"], y, e);
  }
  var k = 0, x = 0;
  return (l instanceof es || s.name === "\\oiint" || s.name === "\\oiiint") && !s.suppressBaseShift && (k = (l.height - l.depth) / 2 - e.fontMetrics().axisHeight, x = l.italic), i ? wN(l, t, r, e, o, x, k) : (k && (l.style.position = "relative", l.style.top = Te(k)), l);
}, hp = (n, e) => {
  var t;
  if (n.symbol)
    t = new Si("mo", [ts(n.name, n.mode)]), et.contains(kN, n.name) && t.setAttribute("largeop", "false");
  else if (n.body)
    t = new Si("mo", li(n.body, e));
  else {
    t = new Si("mi", [new Zs(n.name.slice(1))]);
    var r = new Si("mo", [ts("⁡", "text")]);
    n.parentIsSupSub ? t = new Si("mrow", [t, r]) : t = JD([t, r]);
  }
  return t;
}, Eoe = {
  "∏": "\\prod",
  "∐": "\\coprod",
  "∑": "\\sum",
  "⋀": "\\bigwedge",
  "⋁": "\\bigvee",
  "⋂": "\\bigcap",
  "⋃": "\\bigcup",
  "⨀": "\\bigodot",
  "⨁": "\\bigoplus",
  "⨂": "\\bigotimes",
  "⨄": "\\biguplus",
  "⨆": "\\bigsqcup"
};
_e({
  type: "op",
  names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
  props: {
    numArgs: 0
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = r;
    return i.length === 1 && (i = Eoe[i]), {
      type: "op",
      mode: t.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !0,
      name: i
    };
  },
  htmlBuilder: qh,
  mathmlBuilder: hp
});
_e({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "op",
      mode: t.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      body: _n(r)
    };
  },
  htmlBuilder: qh,
  mathmlBuilder: hp
});
var Loe = {
  "∫": "\\int",
  "∬": "\\iint",
  "∭": "\\iiint",
  "∮": "\\oint",
  "∯": "\\oiint",
  "∰": "\\oiiint"
};
_e({
  type: "op",
  names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: qh,
  mathmlBuilder: hp
});
_e({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n;
    return {
      type: "op",
      mode: e.mode,
      limits: !0,
      parentIsSupSub: !1,
      symbol: !1,
      name: t
    };
  },
  htmlBuilder: qh,
  mathmlBuilder: hp
});
_e({
  type: "op",
  names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
  props: {
    numArgs: 0
  },
  handler(n) {
    var {
      parser: e,
      funcName: t
    } = n, r = t;
    return r.length === 1 && (r = Loe[r]), {
      type: "op",
      mode: e.mode,
      limits: !1,
      parentIsSupSub: !1,
      symbol: !0,
      name: r
    };
  },
  htmlBuilder: qh,
  mathmlBuilder: hp
});
var xN = (n, e) => {
  var t, r, i = !1, s;
  n.type === "supsub" ? (t = n.sup, r = n.sub, s = vt(n.base, "operatorname"), i = !0) : s = vt(n, "operatorname");
  var o;
  if (s.body.length > 0) {
    for (var a = s.body.map((h) => {
      var f = h.text;
      return typeof f == "string" ? {
        type: "textord",
        mode: h.mode,
        text: f
      } : h;
    }), l = Yn(a, e.withFont("mathrm"), !0), c = 0; c < l.length; c++) {
      var u = l[c];
      u instanceof es && (u.text = u.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
    }
    o = Q.makeSpan(["mop"], l, e);
  } else
    o = Q.makeSpan(["mop"], [], e);
  return i ? wN(o, t, r, e, e.style, 0, 0) : o;
}, Ooe = (n, e) => {
  for (var t = li(n.body, e.withFont("mathrm")), r = !0, i = 0; i < t.length; i++) {
    var s = t[i];
    if (!(s instanceof we.SpaceNode)) if (s instanceof we.MathNode)
      switch (s.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mspace":
        case "mtext":
          break;
        // Do nothing yet.
        case "mo": {
          var o = s.children[0];
          s.children.length === 1 && o instanceof we.TextNode ? o.text = o.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : r = !1;
          break;
        }
        default:
          r = !1;
      }
    else
      r = !1;
  }
  if (r) {
    var a = t.map((u) => u.toText()).join("");
    t = [new we.TextNode(a)];
  }
  var l = new we.MathNode("mi", t);
  l.setAttribute("mathvariant", "normal");
  var c = new we.MathNode("mo", [ts("⁡", "text")]);
  return n.parentIsSupSub ? new we.MathNode("mrow", [l, c]) : we.newDocumentFragment([l, c]);
};
_e({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1
  },
  handler: (n, e) => {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "operatorname",
      mode: t.mode,
      body: _n(i),
      alwaysHandleSupSub: r === "\\operatornamewithlimits",
      limits: !1,
      parentIsSupSub: !1
    };
  },
  htmlBuilder: xN,
  mathmlBuilder: Ooe
});
P("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
$c({
  type: "ordgroup",
  htmlBuilder(n, e) {
    return n.semisimple ? Q.makeFragment(Yn(n.body, e, !1)) : Q.makeSpan(["mord"], Yn(n.body, e, !0), e);
  },
  mathmlBuilder(n, e) {
    return hl(n.body, e, !0);
  }
});
_e({
  type: "overline",
  names: ["\\overline"],
  props: {
    numArgs: 1
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "overline",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder(n, e) {
    var t = zt(n.body, e.havingCrampedStyle()), r = Q.makeLineSpan("overline-line", e), i = e.fontMetrics().defaultRuleThickness, s = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: i
      }]
    }, e);
    return Q.makeSpan(["mord", "overline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mo", [new we.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new we.MathNode("mover", [rn(n.body, e), t]);
    return r.setAttribute("accent", "true"), r;
  }
});
_e({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "phantom",
      mode: t.mode,
      body: _n(r)
    };
  },
  htmlBuilder: (n, e) => {
    var t = Yn(n.body, e.withPhantom(), !1);
    return Q.makeFragment(t);
  },
  mathmlBuilder: (n, e) => {
    var t = li(n.body, e);
    return new we.MathNode("mphantom", t);
  }
});
_e({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "hphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = Q.makeSpan([], [zt(n.body, e.withPhantom())]);
    if (t.height = 0, t.depth = 0, t.children)
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0, t.children[r].depth = 0;
    return t = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e), Q.makeSpan(["mord"], [t], e);
  },
  mathmlBuilder: (n, e) => {
    var t = li(_n(n.body), e), r = new we.MathNode("mphantom", t), i = new we.MathNode("mpadded", [r]);
    return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
  }
});
_e({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      parser: t
    } = n, r = e[0];
    return {
      type: "vphantom",
      mode: t.mode,
      body: r
    };
  },
  htmlBuilder: (n, e) => {
    var t = Q.makeSpan(["inner"], [zt(n.body, e.withPhantom())]), r = Q.makeSpan(["fix"], []);
    return Q.makeSpan(["mord", "rlap"], [t, r], e);
  },
  mathmlBuilder: (n, e) => {
    var t = li(_n(n.body), e), r = new we.MathNode("mphantom", t), i = new we.MathNode("mpadded", [r]);
    return i.setAttribute("width", "0px"), i;
  }
});
_e({
  type: "raisebox",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n, r = vt(e[0], "size").value, i = e[1];
    return {
      type: "raisebox",
      mode: t.mode,
      dy: r,
      body: i
    };
  },
  htmlBuilder(n, e) {
    var t = zt(n.body, e), r = Sn(n.dy, e);
    return Q.makeVList({
      positionType: "shift",
      positionData: -r,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mpadded", [rn(n.body, e)]), r = n.dy.number + n.dy.unit;
    return t.setAttribute("voffset", r), t;
  }
});
_e({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    allowedInArgument: !0
  },
  handler(n) {
    var {
      parser: e
    } = n;
    return {
      type: "internal",
      mode: e.mode
    };
  }
});
_e({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: !0,
    allowedInMath: !0,
    argTypes: ["size", "size", "size"]
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = vt(e[0], "size"), o = vt(e[1], "size");
    return {
      type: "rule",
      mode: r.mode,
      shift: i && vt(i, "size").value,
      width: s.value,
      height: o.value
    };
  },
  htmlBuilder(n, e) {
    var t = Q.makeSpan(["mord", "rule"], [], e), r = Sn(n.width, e), i = Sn(n.height, e), s = n.shift ? Sn(n.shift, e) : 0;
    return t.style.borderRightWidth = Te(r), t.style.borderTopWidth = Te(i), t.style.bottom = Te(s), t.width = r, t.height = i + s, t.depth = -s, t.maxFontSize = i * 1.125 * e.sizeMultiplier, t;
  },
  mathmlBuilder(n, e) {
    var t = Sn(n.width, e), r = Sn(n.height, e), i = n.shift ? Sn(n.shift, e) : 0, s = e.color && e.getColor() || "black", o = new we.MathNode("mspace");
    o.setAttribute("mathbackground", s), o.setAttribute("width", Te(t)), o.setAttribute("height", Te(r));
    var a = new we.MathNode("mpadded", [o]);
    return i >= 0 ? a.setAttribute("height", Te(i)) : (a.setAttribute("height", Te(i)), a.setAttribute("depth", Te(-i))), a.setAttribute("voffset", Te(i)), a;
  }
});
function SN(n, e, t) {
  for (var r = Yn(n, e, !1), i = e.sizeMultiplier / t.sizeMultiplier, s = 0; s < r.length; s++) {
    var o = r[s].classes.indexOf("sizing");
    o < 0 ? Array.prototype.push.apply(r[s].classes, e.sizingClasses(t)) : r[s].classes[o + 1] === "reset-size" + e.size && (r[s].classes[o + 1] = "reset-size" + t.size), r[s].height *= i, r[s].depth *= i;
  }
  return Q.makeFragment(r);
}
var pC = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], Doe = (n, e) => {
  var t = e.havingSize(n.size);
  return SN(n.body, t, e);
};
_e({
  type: "sizing",
  names: pC,
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler: (n, e) => {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!1, t);
    return {
      type: "sizing",
      mode: i.mode,
      // Figure out what size to use based on the list of functions above
      size: pC.indexOf(r) + 1,
      body: s
    };
  },
  htmlBuilder: Doe,
  mathmlBuilder: (n, e) => {
    var t = e.havingSize(n.size), r = li(n.body, t), i = new we.MathNode("mstyle", r);
    return i.setAttribute("mathsize", Te(t.sizeMultiplier)), i;
  }
});
_e({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: !0
  },
  handler: (n, e, t) => {
    var {
      parser: r
    } = n, i = !1, s = !1, o = t[0] && vt(t[0], "ordgroup");
    if (o)
      for (var a = "", l = 0; l < o.body.length; ++l) {
        var c = o.body[l];
        if (a = c.text, a === "t")
          i = !0;
        else if (a === "b")
          s = !0;
        else {
          i = !1, s = !1;
          break;
        }
      }
    else
      i = !0, s = !0;
    var u = e[0];
    return {
      type: "smash",
      mode: r.mode,
      body: u,
      smashHeight: i,
      smashDepth: s
    };
  },
  htmlBuilder: (n, e) => {
    var t = Q.makeSpan([], [zt(n.body, e)]);
    if (!n.smashHeight && !n.smashDepth)
      return t;
    if (n.smashHeight && (t.height = 0, t.children))
      for (var r = 0; r < t.children.length; r++)
        t.children[r].height = 0;
    if (n.smashDepth && (t.depth = 0, t.children))
      for (var i = 0; i < t.children.length; i++)
        t.children[i].depth = 0;
    var s = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
    return Q.makeSpan(["mord"], [s], e);
  },
  mathmlBuilder: (n, e) => {
    var t = new we.MathNode("mpadded", [rn(n.body, e)]);
    return n.smashHeight && t.setAttribute("height", "0px"), n.smashDepth && t.setAttribute("depth", "0px"), t;
  }
});
_e({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler(n, e, t) {
    var {
      parser: r
    } = n, i = t[0], s = e[0];
    return {
      type: "sqrt",
      mode: r.mode,
      body: s,
      index: i
    };
  },
  htmlBuilder(n, e) {
    var t = zt(n.body, e.havingCrampedStyle());
    t.height === 0 && (t.height = e.fontMetrics().xHeight), t = Q.wrapFragment(t, e);
    var r = e.fontMetrics(), i = r.defaultRuleThickness, s = i;
    e.style.id < ot.TEXT.id && (s = e.fontMetrics().xHeight);
    var o = i + s / 4, a = t.height + t.depth + o + i, {
      span: l,
      ruleWidth: c,
      advanceWidth: u
    } = na.sqrtImage(a, e), h = l.height - c;
    h > t.height + t.depth + o && (o = (o + h - t.height - t.depth) / 2);
    var f = l.height - t.height - o - c;
    t.style.paddingLeft = Te(u);
    var m = Q.makeVList({
      positionType: "firstBaseline",
      children: [{
        type: "elem",
        elem: t,
        wrapperClasses: ["svg-align"]
      }, {
        type: "kern",
        size: -(t.height + f)
      }, {
        type: "elem",
        elem: l
      }, {
        type: "kern",
        size: c
      }]
    }, e);
    if (n.index) {
      var y = e.havingStyle(ot.SCRIPTSCRIPT), b = zt(n.index, y, e), k = 0.6 * (m.height - m.depth), x = Q.makeVList({
        positionType: "shift",
        positionData: -k,
        children: [{
          type: "elem",
          elem: b
        }]
      }, e), M = Q.makeSpan(["root"], [x]);
      return Q.makeSpan(["mord", "sqrt"], [M, m], e);
    } else
      return Q.makeSpan(["mord", "sqrt"], [m], e);
  },
  mathmlBuilder(n, e) {
    var {
      body: t,
      index: r
    } = n;
    return r ? new we.MathNode("mroot", [rn(t, e), rn(r, e)]) : new we.MathNode("msqrt", [rn(t, e)]);
  }
});
var mC = {
  display: ot.DISPLAY,
  text: ot.TEXT,
  script: ot.SCRIPT,
  scriptscript: ot.SCRIPTSCRIPT
};
_e({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: !0,
    primitive: !0
  },
  handler(n, e) {
    var {
      breakOnTokenText: t,
      funcName: r,
      parser: i
    } = n, s = i.parseExpression(!0, t), o = r.slice(1, r.length - 5);
    return {
      type: "styling",
      mode: i.mode,
      // Figure out what style to use by pulling out the style from
      // the function name
      style: o,
      body: s
    };
  },
  htmlBuilder(n, e) {
    var t = mC[n.style], r = e.havingStyle(t).withFont("");
    return SN(n.body, r, e);
  },
  mathmlBuilder(n, e) {
    var t = mC[n.style], r = e.havingStyle(t), i = li(n.body, r), s = new we.MathNode("mstyle", i), o = {
      display: ["0", "true"],
      text: ["0", "false"],
      script: ["1", "false"],
      scriptscript: ["2", "false"]
    }, a = o[n.style];
    return s.setAttribute("scriptlevel", a[0]), s.setAttribute("displaystyle", a[1]), s;
  }
});
var Noe = function(e, t) {
  var r = e.base;
  if (r)
    if (r.type === "op") {
      var i = r.limits && (t.style.size === ot.DISPLAY.size || r.alwaysHandleSupSub);
      return i ? qh : null;
    } else if (r.type === "operatorname") {
      var s = r.alwaysHandleSupSub && (t.style.size === ot.DISPLAY.size || r.limits);
      return s ? xN : null;
    } else {
      if (r.type === "accent")
        return et.isCharacterBox(r.base) ? a6 : null;
      if (r.type === "horizBrace") {
        var o = !e.sub;
        return o === r.isOver ? vN : null;
      } else
        return null;
    }
  else return null;
};
$c({
  type: "supsub",
  htmlBuilder(n, e) {
    var t = Noe(n, e);
    if (t)
      return t(n, e);
    var {
      base: r,
      sup: i,
      sub: s
    } = n, o = zt(r, e), a, l, c = e.fontMetrics(), u = 0, h = 0, f = r && et.isCharacterBox(r);
    if (i) {
      var m = e.havingStyle(e.style.sup());
      a = zt(i, m, e), f || (u = o.height - m.fontMetrics().supDrop * m.sizeMultiplier / e.sizeMultiplier);
    }
    if (s) {
      var y = e.havingStyle(e.style.sub());
      l = zt(s, y, e), f || (h = o.depth + y.fontMetrics().subDrop * y.sizeMultiplier / e.sizeMultiplier);
    }
    var b;
    e.style === ot.DISPLAY ? b = c.sup1 : e.style.cramped ? b = c.sup3 : b = c.sup2;
    var k = e.sizeMultiplier, x = Te(0.5 / c.ptPerEm / k), M = null;
    if (l) {
      var T = n.base && n.base.type === "op" && n.base.name && (n.base.name === "\\oiint" || n.base.name === "\\oiiint");
      (o instanceof es || T) && (M = Te(-o.italic));
    }
    var E;
    if (a && l) {
      u = Math.max(u, b, a.depth + 0.25 * c.xHeight), h = Math.max(h, c.sub2);
      var C = c.defaultRuleThickness, O = 4 * C;
      if (u - a.depth - (l.height - h) < O) {
        h = O - (u - a.depth) + l.height;
        var R = 0.8 * c.xHeight - (u - a.depth);
        R > 0 && (u += R, h -= R);
      }
      var F = [{
        type: "elem",
        elem: l,
        shift: h,
        marginRight: x,
        marginLeft: M
      }, {
        type: "elem",
        elem: a,
        shift: -u,
        marginRight: x
      }];
      E = Q.makeVList({
        positionType: "individualShift",
        children: F
      }, e);
    } else if (l) {
      h = Math.max(h, c.sub1, l.height - 0.8 * c.xHeight);
      var H = [{
        type: "elem",
        elem: l,
        marginLeft: M,
        marginRight: x
      }];
      E = Q.makeVList({
        positionType: "shift",
        positionData: h,
        children: H
      }, e);
    } else if (a)
      u = Math.max(u, b, a.depth + 0.25 * c.xHeight), E = Q.makeVList({
        positionType: "shift",
        positionData: -u,
        children: [{
          type: "elem",
          elem: a,
          marginRight: x
        }]
      }, e);
    else
      throw new Error("supsub must have either sup or sub.");
    var z = Y4(o, "right") || "mord";
    return Q.makeSpan([z], [o, Q.makeSpan(["msupsub"], [E])], e);
  },
  mathmlBuilder(n, e) {
    var t = !1, r, i;
    n.base && n.base.type === "horizBrace" && (i = !!n.sup, i === n.base.isOver && (t = !0, r = n.base.isOver)), n.base && (n.base.type === "op" || n.base.type === "operatorname") && (n.base.parentIsSupSub = !0);
    var s = [rn(n.base, e)];
    n.sub && s.push(rn(n.sub, e)), n.sup && s.push(rn(n.sup, e));
    var o;
    if (t)
      o = r ? "mover" : "munder";
    else if (n.sub)
      if (n.sup) {
        var c = n.base;
        c && c.type === "op" && c.limits && e.style === ot.DISPLAY || c && c.type === "operatorname" && c.alwaysHandleSupSub && (e.style === ot.DISPLAY || c.limits) ? o = "munderover" : o = "msubsup";
      } else {
        var l = n.base;
        l && l.type === "op" && l.limits && (e.style === ot.DISPLAY || l.alwaysHandleSupSub) || l && l.type === "operatorname" && l.alwaysHandleSupSub && (l.limits || e.style === ot.DISPLAY) ? o = "munder" : o = "msub";
      }
    else {
      var a = n.base;
      a && a.type === "op" && a.limits && (e.style === ot.DISPLAY || a.alwaysHandleSupSub) || a && a.type === "operatorname" && a.alwaysHandleSupSub && (a.limits || e.style === ot.DISPLAY) ? o = "mover" : o = "msup";
    }
    return new we.MathNode(o, s);
  }
});
$c({
  type: "atom",
  htmlBuilder(n, e) {
    return Q.mathsym(n.text, n.mode, e, ["m" + n.family]);
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mo", [ts(n.text, n.mode)]);
    if (n.family === "bin") {
      var r = s6(n, e);
      r === "bold-italic" && t.setAttribute("mathvariant", r);
    } else n.family === "punct" ? t.setAttribute("separator", "true") : (n.family === "open" || n.family === "close") && t.setAttribute("stretchy", "false");
    return t;
  }
});
var CN = {
  mi: "italic",
  mn: "normal",
  mtext: "normal"
};
$c({
  type: "mathord",
  htmlBuilder(n, e) {
    return Q.makeOrd(n, e, "mathord");
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mi", [ts(n.text, n.mode, e)]), r = s6(n, e) || "italic";
    return r !== CN[t.type] && t.setAttribute("mathvariant", r), t;
  }
});
$c({
  type: "textord",
  htmlBuilder(n, e) {
    return Q.makeOrd(n, e, "textord");
  },
  mathmlBuilder(n, e) {
    var t = ts(n.text, n.mode, e), r = s6(n, e) || "normal", i;
    return n.mode === "text" ? i = new we.MathNode("mtext", [t]) : /[0-9]/.test(n.text) ? i = new we.MathNode("mn", [t]) : n.text === "\\prime" ? i = new we.MathNode("mo", [t]) : i = new we.MathNode("mi", [t]), r !== CN[i.type] && i.setAttribute("mathvariant", r), i;
  }
});
var B2 = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
}, H2 = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};
$c({
  type: "spacing",
  htmlBuilder(n, e) {
    if (H2.hasOwnProperty(n.text)) {
      var t = H2[n.text].className || "";
      if (n.mode === "text") {
        var r = Q.makeOrd(n, e, "textord");
        return r.classes.push(t), r;
      } else
        return Q.makeSpan(["mspace", t], [Q.mathsym(n.text, n.mode, e)], e);
    } else {
      if (B2.hasOwnProperty(n.text))
        return Q.makeSpan(["mspace", B2[n.text]], [], e);
      throw new ke('Unknown type of space "' + n.text + '"');
    }
  },
  mathmlBuilder(n, e) {
    var t;
    if (H2.hasOwnProperty(n.text))
      t = new we.MathNode("mtext", [new we.TextNode(" ")]);
    else {
      if (B2.hasOwnProperty(n.text))
        return new we.MathNode("mspace");
      throw new ke('Unknown type of space "' + n.text + '"');
    }
    return t;
  }
});
var gC = () => {
  var n = new we.MathNode("mtd", []);
  return n.setAttribute("width", "50%"), n;
};
$c({
  type: "tag",
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mtable", [new we.MathNode("mtr", [gC(), new we.MathNode("mtd", [hl(n.body, e)]), gC(), new we.MathNode("mtd", [hl(n.tag, e)])])]);
    return t.setAttribute("width", "100%"), t;
  }
});
var yC = {
  "\\text": void 0,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm"
}, bC = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
}, Ioe = {
  "\\textit": "textit",
  "\\textup": "textup"
}, vC = (n, e) => {
  var t = n.font;
  if (t) {
    if (yC[t])
      return e.withTextFontFamily(yC[t]);
    if (bC[t])
      return e.withTextFontWeight(bC[t]);
    if (t === "\\emph")
      return e.fontShape === "textit" ? e.withTextFontShape("textup") : e.withTextFontShape("textit");
  } else return e;
  return e.withTextFontShape(Ioe[t]);
};
_e({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: !0,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t,
      funcName: r
    } = n, i = e[0];
    return {
      type: "text",
      mode: t.mode,
      body: _n(i),
      font: r
    };
  },
  htmlBuilder(n, e) {
    var t = vC(n, e), r = Yn(n.body, t, !0);
    return Q.makeSpan(["mord", "text"], r, t);
  },
  mathmlBuilder(n, e) {
    var t = vC(n, e);
    return hl(n.body, t);
  }
});
_e({
  type: "underline",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: !0
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "underline",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = zt(n.body, e), r = Q.makeLineSpan("underline-line", e), i = e.fontMetrics().defaultRuleThickness, s = Q.makeVList({
      positionType: "top",
      positionData: t.height,
      children: [{
        type: "kern",
        size: i
      }, {
        type: "elem",
        elem: r
      }, {
        type: "kern",
        size: 3 * i
      }, {
        type: "elem",
        elem: t
      }]
    }, e);
    return Q.makeSpan(["mord", "underline"], [s], e);
  },
  mathmlBuilder(n, e) {
    var t = new we.MathNode("mo", [new we.TextNode("‾")]);
    t.setAttribute("stretchy", "true");
    var r = new we.MathNode("munder", [rn(n.body, e), t]);
    return r.setAttribute("accentunder", "true"), r;
  }
});
_e({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    // In LaTeX, \vcenter can act only on a box.
    allowedInText: !1
  },
  handler(n, e) {
    var {
      parser: t
    } = n;
    return {
      type: "vcenter",
      mode: t.mode,
      body: e[0]
    };
  },
  htmlBuilder(n, e) {
    var t = zt(n.body, e), r = e.fontMetrics().axisHeight, i = 0.5 * (t.height - r - (t.depth + r));
    return Q.makeVList({
      positionType: "shift",
      positionData: i,
      children: [{
        type: "elem",
        elem: t
      }]
    }, e);
  },
  mathmlBuilder(n, e) {
    return new we.MathNode("mpadded", [rn(n.body, e)], ["vcenter"]);
  }
});
_e({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: !0
  },
  handler(n, e, t) {
    throw new ke("\\verb ended by end of line instead of matching delimiter");
  },
  htmlBuilder(n, e) {
    for (var t = wC(n), r = [], i = e.havingStyle(e.style.text()), s = 0; s < t.length; s++) {
      var o = t[s];
      o === "~" && (o = "\\textasciitilde"), r.push(Q.makeSymbol(o, "Typewriter-Regular", n.mode, i, ["mord", "texttt"]));
    }
    return Q.makeSpan(["mord", "text"].concat(i.sizingClasses(e)), Q.tryCombineChars(r), i);
  },
  mathmlBuilder(n, e) {
    var t = new we.TextNode(wC(n)), r = new we.MathNode("mtext", [t]);
    return r.setAttribute("mathvariant", "monospace"), r;
  }
});
var wC = (n) => n.body.replace(/ /g, n.star ? "␣" : " "), Ga = KD, MN = `[ \r
	]`, _oe = "\\\\[a-zA-Z@]+", Roe = "\\\\[^\uD800-\uDFFF]", Poe = "(" + _oe + ")" + MN + "*", Boe = `\\\\(
|[ \r	]+
?)[ \r	]*`, ew = "[̀-ͯ]", Hoe = new RegExp(ew + "+$"), zoe = "(" + MN + "+)|" + // whitespace
(Boe + "|") + // \whitespace
"([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
(ew + "*") + // ...plus accents
"|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
(ew + "*") + // ...plus accents
"|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
("|" + Poe) + // \macroName + spaces
("|" + Roe + ")");
class kC {
  // Category codes. The lexer only supports comment characters (14) for now.
  // MacroExpander additionally distinguishes active (13).
  constructor(e, t) {
    this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = new RegExp(zoe, "g"), this.catcodes = {
      "%": 14,
      // comment character
      "~": 13
      // active character
    };
  }
  setCatcode(e, t) {
    this.catcodes[e] = t;
  }
  /**
   * This function lexes a single token.
   */
  lex() {
    var e = this.input, t = this.tokenRegex.lastIndex;
    if (t === e.length)
      return new Ei("EOF", new Jr(this, t, t));
    var r = this.tokenRegex.exec(e);
    if (r === null || r.index !== t)
      throw new ke("Unexpected character: '" + e[t] + "'", new Ei(e[t], new Jr(this, t, t + 1)));
    var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
    if (this.catcodes[i] === 14) {
      var s = e.indexOf(`
`, this.tokenRegex.lastIndex);
      return s === -1 ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = s + 1, this.lex();
    }
    return new Ei(i, new Jr(this, t, this.tokenRegex.lastIndex));
  }
}
class Foe {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(e, t) {
    e === void 0 && (e = {}), t === void 0 && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
  }
  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }
  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0)
      throw new ke("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
    var e = this.undefStack.pop();
    for (var t in e)
      e.hasOwnProperty(t) && (e[t] == null ? delete this.current[t] : this.current[t] = e[t]);
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    for (; this.undefStack.length > 0; )
      this.endGroup();
  }
  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(e) {
    return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
  }
  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(e) {
    return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
  }
  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   * A value of undefined means to delete existing definitions.
   */
  set(e, t, r) {
    if (r === void 0 && (r = !1), r) {
      for (var i = 0; i < this.undefStack.length; i++)
        delete this.undefStack[i][e];
      this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
    } else {
      var s = this.undefStack[this.undefStack.length - 1];
      s && !s.hasOwnProperty(e) && (s[e] = this.current[e]);
    }
    t == null ? delete this.current[e] : this.current[e] = t;
  }
}
var Voe = pN;
P("\\noexpand", function(n) {
  var e = n.popToken();
  return n.isExpandable(e.text) && (e.noexpand = !0, e.treatAsRelax = !0), {
    tokens: [e],
    numArgs: 0
  };
});
P("\\expandafter", function(n) {
  var e = n.popToken();
  return n.expandOnce(!0), {
    tokens: [e],
    numArgs: 0
  };
});
P("\\@firstoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[0],
    numArgs: 0
  };
});
P("\\@secondoftwo", function(n) {
  var e = n.consumeArgs(2);
  return {
    tokens: e[1],
    numArgs: 0
  };
});
P("\\@ifnextchar", function(n) {
  var e = n.consumeArgs(3);
  n.consumeSpaces();
  var t = n.future();
  return e[0].length === 1 && e[0][0].text === t.text ? {
    tokens: e[1],
    numArgs: 0
  } : {
    tokens: e[2],
    numArgs: 0
  };
});
P("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
P("\\TextOrMath", function(n) {
  var e = n.consumeArgs(2);
  return n.mode === "text" ? {
    tokens: e[0],
    numArgs: 0
  } : {
    tokens: e[1],
    numArgs: 0
  };
});
var xC = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};
P("\\char", function(n) {
  var e = n.popToken(), t, r = "";
  if (e.text === "'")
    t = 8, e = n.popToken();
  else if (e.text === '"')
    t = 16, e = n.popToken();
  else if (e.text === "`")
    if (e = n.popToken(), e.text[0] === "\\")
      r = e.text.charCodeAt(1);
    else {
      if (e.text === "EOF")
        throw new ke("\\char` missing argument");
      r = e.text.charCodeAt(0);
    }
  else
    t = 10;
  if (t) {
    if (r = xC[e.text], r == null || r >= t)
      throw new ke("Invalid base-" + t + " digit " + e.text);
    for (var i; (i = xC[n.future().text]) != null && i < t; )
      r *= t, r += i, n.popToken();
  }
  return "\\@char{" + r + "}";
});
var m6 = (n, e, t, r) => {
  var i = n.consumeArg().tokens;
  if (i.length !== 1)
    throw new ke("\\newcommand's first argument must be a macro name");
  var s = i[0].text, o = n.isDefined(s);
  if (o && !e)
    throw new ke("\\newcommand{" + s + "} attempting to redefine " + (s + "; use \\renewcommand"));
  if (!o && !t)
    throw new ke("\\renewcommand{" + s + "} when command " + s + " does not yet exist; use \\newcommand");
  var a = 0;
  if (i = n.consumeArg().tokens, i.length === 1 && i[0].text === "[") {
    for (var l = "", c = n.expandNextToken(); c.text !== "]" && c.text !== "EOF"; )
      l += c.text, c = n.expandNextToken();
    if (!l.match(/^\s*[0-9]+\s*$/))
      throw new ke("Invalid number of arguments: " + l);
    a = parseInt(l), i = n.consumeArg().tokens;
  }
  return o && r || n.macros.set(s, {
    tokens: i,
    numArgs: a
  }), "";
};
P("\\newcommand", (n) => m6(n, !1, !0, !1));
P("\\renewcommand", (n) => m6(n, !0, !1, !1));
P("\\providecommand", (n) => m6(n, !0, !0, !0));
P("\\message", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.log(e.reverse().map((t) => t.text).join("")), "";
});
P("\\errmessage", (n) => {
  var e = n.consumeArgs(1)[0];
  return console.error(e.reverse().map((t) => t.text).join("")), "";
});
P("\\show", (n) => {
  var e = n.popToken(), t = e.text;
  return console.log(e, n.macros.get(t), Ga[t], ln.math[t], ln.text[t]), "";
});
P("\\bgroup", "{");
P("\\egroup", "}");
P("~", "\\nobreakspace");
P("\\lq", "`");
P("\\rq", "'");
P("\\aa", "\\r a");
P("\\AA", "\\r A");
P("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
P("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
P("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
P("ℬ", "\\mathscr{B}");
P("ℰ", "\\mathscr{E}");
P("ℱ", "\\mathscr{F}");
P("ℋ", "\\mathscr{H}");
P("ℐ", "\\mathscr{I}");
P("ℒ", "\\mathscr{L}");
P("ℳ", "\\mathscr{M}");
P("ℛ", "\\mathscr{R}");
P("ℭ", "\\mathfrak{C}");
P("ℌ", "\\mathfrak{H}");
P("ℨ", "\\mathfrak{Z}");
P("\\Bbbk", "\\Bbb{k}");
P("·", "\\cdotp");
P("\\llap", "\\mathllap{\\textrm{#1}}");
P("\\rlap", "\\mathrlap{\\textrm{#1}}");
P("\\clap", "\\mathclap{\\textrm{#1}}");
P("\\mathstrut", "\\vphantom{(}");
P("\\underbar", "\\underline{\\text{#1}}");
P("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
P("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
P("\\ne", "\\neq");
P("≠", "\\neq");
P("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
P("∉", "\\notin");
P("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
P("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
P("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
P("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
P("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
P("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
P("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
P("⟂", "\\perp");
P("‼", "\\mathclose{!\\mkern-0.8mu!}");
P("∌", "\\notni");
P("⌜", "\\ulcorner");
P("⌝", "\\urcorner");
P("⌞", "\\llcorner");
P("⌟", "\\lrcorner");
P("©", "\\copyright");
P("®", "\\textregistered");
P("️", "\\textregistered");
P("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
P("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
P("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
P("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
P("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
P("⋮", "\\vdots");
P("\\varGamma", "\\mathit{\\Gamma}");
P("\\varDelta", "\\mathit{\\Delta}");
P("\\varTheta", "\\mathit{\\Theta}");
P("\\varLambda", "\\mathit{\\Lambda}");
P("\\varXi", "\\mathit{\\Xi}");
P("\\varPi", "\\mathit{\\Pi}");
P("\\varSigma", "\\mathit{\\Sigma}");
P("\\varUpsilon", "\\mathit{\\Upsilon}");
P("\\varPhi", "\\mathit{\\Phi}");
P("\\varPsi", "\\mathit{\\Psi}");
P("\\varOmega", "\\mathit{\\Omega}");
P("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
P("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
P("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
P("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
P("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
P("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
P("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
P("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var SC = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};
P("\\dots", function(n) {
  var e = "\\dotso", t = n.expandAfterFuture().text;
  return t in SC ? e = SC[t] : (t.slice(0, 4) === "\\not" || t in ln.math && et.contains(["bin", "rel"], ln.math[t].group)) && (e = "\\dotsb"), e;
});
var g6 = {
  // \rightdelim@ checks for the following:
  ")": !0,
  "]": !0,
  "\\rbrack": !0,
  "\\}": !0,
  "\\rbrace": !0,
  "\\rangle": !0,
  "\\rceil": !0,
  "\\rfloor": !0,
  "\\rgroup": !0,
  "\\rmoustache": !0,
  "\\right": !0,
  "\\bigr": !0,
  "\\biggr": !0,
  "\\Bigr": !0,
  "\\Biggr": !0,
  // \extra@ also tests for the following:
  $: !0,
  // \extrap@ checks for the following:
  ";": !0,
  ".": !0,
  ",": !0
};
P("\\dotso", function(n) {
  var e = n.future().text;
  return e in g6 ? "\\ldots\\," : "\\ldots";
});
P("\\dotsc", function(n) {
  var e = n.future().text;
  return e in g6 && e !== "," ? "\\ldots\\," : "\\ldots";
});
P("\\cdots", function(n) {
  var e = n.future().text;
  return e in g6 ? "\\@cdots\\," : "\\@cdots";
});
P("\\dotsb", "\\cdots");
P("\\dotsm", "\\cdots");
P("\\dotsi", "\\!\\cdots");
P("\\dotsx", "\\ldots\\,");
P("\\DOTSI", "\\relax");
P("\\DOTSB", "\\relax");
P("\\DOTSX", "\\relax");
P("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
P("\\,", "\\tmspace+{3mu}{.1667em}");
P("\\thinspace", "\\,");
P("\\>", "\\mskip{4mu}");
P("\\:", "\\tmspace+{4mu}{.2222em}");
P("\\medspace", "\\:");
P("\\;", "\\tmspace+{5mu}{.2777em}");
P("\\thickspace", "\\;");
P("\\!", "\\tmspace-{3mu}{.1667em}");
P("\\negthinspace", "\\!");
P("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
P("\\negthickspace", "\\tmspace-{5mu}{.277em}");
P("\\enspace", "\\kern.5em ");
P("\\enskip", "\\hskip.5em\\relax");
P("\\quad", "\\hskip1em\\relax");
P("\\qquad", "\\hskip2em\\relax");
P("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
P("\\tag@paren", "\\tag@literal{({#1})}");
P("\\tag@literal", (n) => {
  if (n.macros.get("\\df@tag"))
    throw new ke("Multiple \\tag");
  return "\\gdef\\df@tag{\\text{#1}}";
});
P("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
P("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
P("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
P("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
P("\\newline", "\\\\\\relax");
P("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var TN = Te(Xs["Main-Regular"][84][1] - 0.7 * Xs["Main-Regular"][65][1]);
P("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + TN + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
P("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + TN + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
P("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
P("\\@hspace", "\\hskip #1\\relax");
P("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
P("\\ordinarycolon", ":");
P("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
P("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
P("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
P("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
P("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
P("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
P("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
P("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
P("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
P("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
P("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
P("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
P("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
P("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
P("∷", "\\dblcolon");
P("∹", "\\eqcolon");
P("≔", "\\coloneqq");
P("≕", "\\eqqcolon");
P("⩴", "\\Coloneqq");
P("\\ratio", "\\vcentcolon");
P("\\coloncolon", "\\dblcolon");
P("\\colonequals", "\\coloneqq");
P("\\coloncolonequals", "\\Coloneqq");
P("\\equalscolon", "\\eqqcolon");
P("\\equalscoloncolon", "\\Eqqcolon");
P("\\colonminus", "\\coloneq");
P("\\coloncolonminus", "\\Coloneq");
P("\\minuscolon", "\\eqcolon");
P("\\minuscoloncolon", "\\Eqcolon");
P("\\coloncolonapprox", "\\Colonapprox");
P("\\coloncolonsim", "\\Colonsim");
P("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
P("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
P("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
P("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
P("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
P("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
P("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
P("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
P("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
P("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
P("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
P("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
P("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
P("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
P("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
P("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
P("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
P("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
P("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
P("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
P("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
P("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
P("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
P("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
P("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
P("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
P("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
P("\\imath", "\\html@mathml{\\@imath}{ı}");
P("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
P("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
P("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
P("⟦", "\\llbracket");
P("⟧", "\\rrbracket");
P("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
P("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
P("⦃", "\\lBrace");
P("⦄", "\\rBrace");
P("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
P("⦵", "\\minuso");
P("\\darr", "\\downarrow");
P("\\dArr", "\\Downarrow");
P("\\Darr", "\\Downarrow");
P("\\lang", "\\langle");
P("\\rang", "\\rangle");
P("\\uarr", "\\uparrow");
P("\\uArr", "\\Uparrow");
P("\\Uarr", "\\Uparrow");
P("\\N", "\\mathbb{N}");
P("\\R", "\\mathbb{R}");
P("\\Z", "\\mathbb{Z}");
P("\\alef", "\\aleph");
P("\\alefsym", "\\aleph");
P("\\Alpha", "\\mathrm{A}");
P("\\Beta", "\\mathrm{B}");
P("\\bull", "\\bullet");
P("\\Chi", "\\mathrm{X}");
P("\\clubs", "\\clubsuit");
P("\\cnums", "\\mathbb{C}");
P("\\Complex", "\\mathbb{C}");
P("\\Dagger", "\\ddagger");
P("\\diamonds", "\\diamondsuit");
P("\\empty", "\\emptyset");
P("\\Epsilon", "\\mathrm{E}");
P("\\Eta", "\\mathrm{H}");
P("\\exist", "\\exists");
P("\\harr", "\\leftrightarrow");
P("\\hArr", "\\Leftrightarrow");
P("\\Harr", "\\Leftrightarrow");
P("\\hearts", "\\heartsuit");
P("\\image", "\\Im");
P("\\infin", "\\infty");
P("\\Iota", "\\mathrm{I}");
P("\\isin", "\\in");
P("\\Kappa", "\\mathrm{K}");
P("\\larr", "\\leftarrow");
P("\\lArr", "\\Leftarrow");
P("\\Larr", "\\Leftarrow");
P("\\lrarr", "\\leftrightarrow");
P("\\lrArr", "\\Leftrightarrow");
P("\\Lrarr", "\\Leftrightarrow");
P("\\Mu", "\\mathrm{M}");
P("\\natnums", "\\mathbb{N}");
P("\\Nu", "\\mathrm{N}");
P("\\Omicron", "\\mathrm{O}");
P("\\plusmn", "\\pm");
P("\\rarr", "\\rightarrow");
P("\\rArr", "\\Rightarrow");
P("\\Rarr", "\\Rightarrow");
P("\\real", "\\Re");
P("\\reals", "\\mathbb{R}");
P("\\Reals", "\\mathbb{R}");
P("\\Rho", "\\mathrm{P}");
P("\\sdot", "\\cdot");
P("\\sect", "\\S");
P("\\spades", "\\spadesuit");
P("\\sub", "\\subset");
P("\\sube", "\\subseteq");
P("\\supe", "\\supseteq");
P("\\Tau", "\\mathrm{T}");
P("\\thetasym", "\\vartheta");
P("\\weierp", "\\wp");
P("\\Zeta", "\\mathrm{Z}");
P("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
P("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
P("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
P("\\bra", "\\mathinner{\\langle{#1}|}");
P("\\ket", "\\mathinner{|{#1}\\rangle}");
P("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
P("\\Bra", "\\left\\langle#1\\right|");
P("\\Ket", "\\left|#1\\right\\rangle");
var AN = (n) => (e) => {
  var t = e.consumeArg().tokens, r = e.consumeArg().tokens, i = e.consumeArg().tokens, s = e.consumeArg().tokens, o = e.macros.get("|"), a = e.macros.get("\\|");
  e.macros.beginGroup();
  var l = (h) => (f) => {
    n && (f.macros.set("|", o), i.length && f.macros.set("\\|", a));
    var m = h;
    if (!h && i.length) {
      var y = f.future();
      y.text === "|" && (f.popToken(), m = !0);
    }
    return {
      tokens: m ? i : r,
      numArgs: 0
    };
  };
  e.macros.set("|", l(!1)), i.length && e.macros.set("\\|", l(!0));
  var c = e.consumeArg().tokens, u = e.expandTokens([
    ...s,
    ...c,
    ...t
    // reversed
  ]);
  return e.macros.endGroup(), {
    tokens: u.reverse(),
    numArgs: 0
  };
};
P("\\bra@ket", AN(!1));
P("\\bra@set", AN(!0));
P("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
P("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
P("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
P("\\angln", "{\\angl n}");
P("\\blue", "\\textcolor{##6495ed}{#1}");
P("\\orange", "\\textcolor{##ffa500}{#1}");
P("\\pink", "\\textcolor{##ff00af}{#1}");
P("\\red", "\\textcolor{##df0030}{#1}");
P("\\green", "\\textcolor{##28ae7b}{#1}");
P("\\gray", "\\textcolor{gray}{#1}");
P("\\purple", "\\textcolor{##9d38bd}{#1}");
P("\\blueA", "\\textcolor{##ccfaff}{#1}");
P("\\blueB", "\\textcolor{##80f6ff}{#1}");
P("\\blueC", "\\textcolor{##63d9ea}{#1}");
P("\\blueD", "\\textcolor{##11accd}{#1}");
P("\\blueE", "\\textcolor{##0c7f99}{#1}");
P("\\tealA", "\\textcolor{##94fff5}{#1}");
P("\\tealB", "\\textcolor{##26edd5}{#1}");
P("\\tealC", "\\textcolor{##01d1c1}{#1}");
P("\\tealD", "\\textcolor{##01a995}{#1}");
P("\\tealE", "\\textcolor{##208170}{#1}");
P("\\greenA", "\\textcolor{##b6ffb0}{#1}");
P("\\greenB", "\\textcolor{##8af281}{#1}");
P("\\greenC", "\\textcolor{##74cf70}{#1}");
P("\\greenD", "\\textcolor{##1fab54}{#1}");
P("\\greenE", "\\textcolor{##0d923f}{#1}");
P("\\goldA", "\\textcolor{##ffd0a9}{#1}");
P("\\goldB", "\\textcolor{##ffbb71}{#1}");
P("\\goldC", "\\textcolor{##ff9c39}{#1}");
P("\\goldD", "\\textcolor{##e07d10}{#1}");
P("\\goldE", "\\textcolor{##a75a05}{#1}");
P("\\redA", "\\textcolor{##fca9a9}{#1}");
P("\\redB", "\\textcolor{##ff8482}{#1}");
P("\\redC", "\\textcolor{##f9685d}{#1}");
P("\\redD", "\\textcolor{##e84d39}{#1}");
P("\\redE", "\\textcolor{##bc2612}{#1}");
P("\\maroonA", "\\textcolor{##ffbde0}{#1}");
P("\\maroonB", "\\textcolor{##ff92c6}{#1}");
P("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
P("\\maroonD", "\\textcolor{##ca337c}{#1}");
P("\\maroonE", "\\textcolor{##9e034e}{#1}");
P("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
P("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
P("\\purpleC", "\\textcolor{##aa87ff}{#1}");
P("\\purpleD", "\\textcolor{##7854ab}{#1}");
P("\\purpleE", "\\textcolor{##543b78}{#1}");
P("\\mintA", "\\textcolor{##f5f9e8}{#1}");
P("\\mintB", "\\textcolor{##edf2df}{#1}");
P("\\mintC", "\\textcolor{##e0e5cc}{#1}");
P("\\grayA", "\\textcolor{##f6f7f7}{#1}");
P("\\grayB", "\\textcolor{##f0f1f2}{#1}");
P("\\grayC", "\\textcolor{##e3e5e6}{#1}");
P("\\grayD", "\\textcolor{##d6d8da}{#1}");
P("\\grayE", "\\textcolor{##babec2}{#1}");
P("\\grayF", "\\textcolor{##888d93}{#1}");
P("\\grayG", "\\textcolor{##626569}{#1}");
P("\\grayH", "\\textcolor{##3b3e40}{#1}");
P("\\grayI", "\\textcolor{##21242c}{#1}");
P("\\kaBlue", "\\textcolor{##314453}{#1}");
P("\\kaGreen", "\\textcolor{##71B307}{#1}");
var EN = {
  "^": !0,
  // Parser.js
  _: !0,
  // Parser.js
  "\\limits": !0,
  // Parser.js
  "\\nolimits": !0
  // Parser.js
};
class qoe {
  constructor(e, t, r) {
    this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new Foe(Voe, t.macros), this.mode = r, this.stack = [];
  }
  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(e) {
    this.lexer = new kC(e, this.settings);
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e;
  }
  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }
  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }
  /**
   * Ends all currently nested groups (if any), restoring values before the
   * groups began.  Useful in case of an error in the middle of parsing.
   */
  endGroups() {
    this.macros.endGroups();
  }
  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    return this.stack.length === 0 && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
  }
  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    return this.future(), this.stack.pop();
  }
  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(e) {
    this.stack.push(e);
  }
  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(e) {
    this.stack.push(...e);
  }
  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(e) {
    var t, r, i;
    if (e) {
      if (this.consumeSpaces(), this.future().text !== "[")
        return null;
      t = this.popToken(), {
        tokens: i,
        end: r
      } = this.consumeArg(["]"]);
    } else
      ({
        tokens: i,
        start: t,
        end: r
      } = this.consumeArg());
    return this.pushToken(new Ei("EOF", r.loc)), this.pushTokens(i), new Ei("", Jr.range(t, r));
  }
  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (; ; ) {
      var e = this.future();
      if (e.text === " ")
        this.stack.pop();
      else
        break;
    }
  }
  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(e) {
    var t = [], r = e && e.length > 0;
    r || this.consumeSpaces();
    var i = this.future(), s, o = 0, a = 0;
    do {
      if (s = this.popToken(), t.push(s), s.text === "{")
        ++o;
      else if (s.text === "}") {
        if (--o, o === -1)
          throw new ke("Extra }", s);
      } else if (s.text === "EOF")
        throw new ke("Unexpected end of input in a macro argument, expected '" + (e && r ? e[a] : "}") + "'", s);
      if (e && r)
        if ((o === 0 || o === 1 && e[a] === "{") && s.text === e[a]) {
          if (++a, a === e.length) {
            t.splice(-a, a);
            break;
          }
        } else
          a = 0;
    } while (o !== 0 || r);
    return i.text === "{" && t[t.length - 1].text === "}" && (t.pop(), t.shift()), t.reverse(), {
      tokens: t,
      start: i,
      end: s
    };
  }
  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(e, t) {
    if (t) {
      if (t.length !== e + 1)
        throw new ke("The length of delimiters doesn't match the number of args!");
      for (var r = t[0], i = 0; i < r.length; i++) {
        var s = this.popToken();
        if (r[i] !== s.text)
          throw new ke("Use of the macro doesn't match its definition", s);
      }
    }
    for (var o = [], a = 0; a < e; a++)
      o.push(this.consumeArg(t && t[a + 1]).tokens);
    return o;
  }
  /**
   * Increment `expansionCount` by the specified amount.
   * Throw an error if it exceeds `maxExpand`.
   */
  countExpansion(e) {
    if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand)
      throw new ke("Too many expansions: infinite loop or need to increase maxExpand setting");
  }
  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(e) {
    var t = this.popToken(), r = t.text, i = t.noexpand ? null : this._getExpansion(r);
    if (i == null || e && i.unexpandable) {
      if (e && i == null && r[0] === "\\" && !this.isDefined(r))
        throw new ke("Undefined control sequence: " + r);
      return this.pushToken(t), !1;
    }
    this.countExpansion(1);
    var s = i.tokens, o = this.consumeArgs(i.numArgs, i.delimiters);
    if (i.numArgs) {
      s = s.slice();
      for (var a = s.length - 1; a >= 0; --a) {
        var l = s[a];
        if (l.text === "#") {
          if (a === 0)
            throw new ke("Incomplete placeholder at end of macro body", l);
          if (l = s[--a], l.text === "#")
            s.splice(a + 1, 1);
          else if (/^[1-9]$/.test(l.text))
            s.splice(a, 2, ...o[+l.text - 1]);
          else
            throw new ke("Not a valid argument number", l);
        }
      }
    }
    return this.pushTokens(s), s.length;
  }
  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    return this.expandOnce(), this.future();
  }
  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (; ; )
      if (this.expandOnce() === !1) {
        var e = this.stack.pop();
        return e.treatAsRelax && (e.text = "\\relax"), e;
      }
    throw new Error();
  }
  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(e) {
    return this.macros.has(e) ? this.expandTokens([new Ei(e)]) : void 0;
  }
  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(e) {
    var t = [], r = this.stack.length;
    for (this.pushTokens(e); this.stack.length > r; )
      if (this.expandOnce(!0) === !1) {
        var i = this.stack.pop();
        i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
      }
    return this.countExpansion(t.length), t;
  }
  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(e) {
    var t = this.expandMacro(e);
    return t && t.map((r) => r.text).join("");
  }
  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(e) {
    var t = this.macros.get(e);
    if (t == null)
      return t;
    if (e.length === 1) {
      var r = this.lexer.catcodes[e];
      if (r != null && r !== 13)
        return;
    }
    var i = typeof t == "function" ? t(this) : t;
    if (typeof i == "string") {
      var s = 0;
      if (i.indexOf("#") !== -1)
        for (var o = i.replace(/##/g, ""); o.indexOf("#" + (s + 1)) !== -1; )
          ++s;
      for (var a = new kC(i, this.settings), l = [], c = a.lex(); c.text !== "EOF"; )
        l.push(c), c = a.lex();
      l.reverse();
      var u = {
        tokens: l,
        numArgs: s
      };
      return u;
    }
    return i;
  }
  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(e) {
    return this.macros.has(e) || Ga.hasOwnProperty(e) || ln.math.hasOwnProperty(e) || ln.text.hasOwnProperty(e) || EN.hasOwnProperty(e);
  }
  /**
   * Determine whether a command is expandable.
   */
  isExpandable(e) {
    var t = this.macros.get(e);
    return t != null ? typeof t == "string" || typeof t == "function" || !t.unexpandable : Ga.hasOwnProperty(e) && !Ga[e].primitive;
  }
}
var CC = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/, gm = Object.freeze({
  "₊": "+",
  "₋": "-",
  "₌": "=",
  "₍": "(",
  "₎": ")",
  "₀": "0",
  "₁": "1",
  "₂": "2",
  "₃": "3",
  "₄": "4",
  "₅": "5",
  "₆": "6",
  "₇": "7",
  "₈": "8",
  "₉": "9",
  "ₐ": "a",
  "ₑ": "e",
  "ₕ": "h",
  "ᵢ": "i",
  "ⱼ": "j",
  "ₖ": "k",
  "ₗ": "l",
  "ₘ": "m",
  "ₙ": "n",
  "ₒ": "o",
  "ₚ": "p",
  "ᵣ": "r",
  "ₛ": "s",
  "ₜ": "t",
  "ᵤ": "u",
  "ᵥ": "v",
  "ₓ": "x",
  "ᵦ": "β",
  "ᵧ": "γ",
  "ᵨ": "ρ",
  "ᵩ": "ϕ",
  "ᵪ": "χ",
  "⁺": "+",
  "⁻": "-",
  "⁼": "=",
  "⁽": "(",
  "⁾": ")",
  "⁰": "0",
  "¹": "1",
  "²": "2",
  "³": "3",
  "⁴": "4",
  "⁵": "5",
  "⁶": "6",
  "⁷": "7",
  "⁸": "8",
  "⁹": "9",
  "ᴬ": "A",
  "ᴮ": "B",
  "ᴰ": "D",
  "ᴱ": "E",
  "ᴳ": "G",
  "ᴴ": "H",
  "ᴵ": "I",
  "ᴶ": "J",
  "ᴷ": "K",
  "ᴸ": "L",
  "ᴹ": "M",
  "ᴺ": "N",
  "ᴼ": "O",
  "ᴾ": "P",
  "ᴿ": "R",
  "ᵀ": "T",
  "ᵁ": "U",
  "ⱽ": "V",
  "ᵂ": "W",
  "ᵃ": "a",
  "ᵇ": "b",
  "ᶜ": "c",
  "ᵈ": "d",
  "ᵉ": "e",
  "ᶠ": "f",
  "ᵍ": "g",
  ʰ: "h",
  "ⁱ": "i",
  ʲ: "j",
  "ᵏ": "k",
  ˡ: "l",
  "ᵐ": "m",
  ⁿ: "n",
  "ᵒ": "o",
  "ᵖ": "p",
  ʳ: "r",
  ˢ: "s",
  "ᵗ": "t",
  "ᵘ": "u",
  "ᵛ": "v",
  ʷ: "w",
  ˣ: "x",
  ʸ: "y",
  "ᶻ": "z",
  "ᵝ": "β",
  "ᵞ": "γ",
  "ᵟ": "δ",
  "ᵠ": "ϕ",
  "ᵡ": "χ",
  "ᶿ": "θ"
}), z2 = {
  "́": {
    text: "\\'",
    math: "\\acute"
  },
  "̀": {
    text: "\\`",
    math: "\\grave"
  },
  "̈": {
    text: '\\"',
    math: "\\ddot"
  },
  "̃": {
    text: "\\~",
    math: "\\tilde"
  },
  "̄": {
    text: "\\=",
    math: "\\bar"
  },
  "̆": {
    text: "\\u",
    math: "\\breve"
  },
  "̌": {
    text: "\\v",
    math: "\\check"
  },
  "̂": {
    text: "\\^",
    math: "\\hat"
  },
  "̇": {
    text: "\\.",
    math: "\\dot"
  },
  "̊": {
    text: "\\r",
    math: "\\mathring"
  },
  "̋": {
    text: "\\H"
  },
  "̧": {
    text: "\\c"
  }
}, MC = {
  á: "á",
  à: "à",
  ä: "ä",
  ǟ: "ǟ",
  ã: "ã",
  ā: "ā",
  ă: "ă",
  ắ: "ắ",
  ằ: "ằ",
  ẵ: "ẵ",
  ǎ: "ǎ",
  â: "â",
  ấ: "ấ",
  ầ: "ầ",
  ẫ: "ẫ",
  ȧ: "ȧ",
  ǡ: "ǡ",
  å: "å",
  ǻ: "ǻ",
  ḃ: "ḃ",
  ć: "ć",
  ḉ: "ḉ",
  č: "č",
  ĉ: "ĉ",
  ċ: "ċ",
  ç: "ç",
  ď: "ď",
  ḋ: "ḋ",
  ḑ: "ḑ",
  é: "é",
  è: "è",
  ë: "ë",
  ẽ: "ẽ",
  ē: "ē",
  ḗ: "ḗ",
  ḕ: "ḕ",
  ĕ: "ĕ",
  ḝ: "ḝ",
  ě: "ě",
  ê: "ê",
  ế: "ế",
  ề: "ề",
  ễ: "ễ",
  ė: "ė",
  ȩ: "ȩ",
  ḟ: "ḟ",
  ǵ: "ǵ",
  ḡ: "ḡ",
  ğ: "ğ",
  ǧ: "ǧ",
  ĝ: "ĝ",
  ġ: "ġ",
  ģ: "ģ",
  ḧ: "ḧ",
  ȟ: "ȟ",
  ĥ: "ĥ",
  ḣ: "ḣ",
  ḩ: "ḩ",
  í: "í",
  ì: "ì",
  ï: "ï",
  ḯ: "ḯ",
  ĩ: "ĩ",
  ī: "ī",
  ĭ: "ĭ",
  ǐ: "ǐ",
  î: "î",
  ǰ: "ǰ",
  ĵ: "ĵ",
  ḱ: "ḱ",
  ǩ: "ǩ",
  ķ: "ķ",
  ĺ: "ĺ",
  ľ: "ľ",
  ļ: "ļ",
  ḿ: "ḿ",
  ṁ: "ṁ",
  ń: "ń",
  ǹ: "ǹ",
  ñ: "ñ",
  ň: "ň",
  ṅ: "ṅ",
  ņ: "ņ",
  ó: "ó",
  ò: "ò",
  ö: "ö",
  ȫ: "ȫ",
  õ: "õ",
  ṍ: "ṍ",
  ṏ: "ṏ",
  ȭ: "ȭ",
  ō: "ō",
  ṓ: "ṓ",
  ṑ: "ṑ",
  ŏ: "ŏ",
  ǒ: "ǒ",
  ô: "ô",
  ố: "ố",
  ồ: "ồ",
  ỗ: "ỗ",
  ȯ: "ȯ",
  ȱ: "ȱ",
  ő: "ő",
  ṕ: "ṕ",
  ṗ: "ṗ",
  ŕ: "ŕ",
  ř: "ř",
  ṙ: "ṙ",
  ŗ: "ŗ",
  ś: "ś",
  ṥ: "ṥ",
  š: "š",
  ṧ: "ṧ",
  ŝ: "ŝ",
  ṡ: "ṡ",
  ş: "ş",
  ẗ: "ẗ",
  ť: "ť",
  ṫ: "ṫ",
  ţ: "ţ",
  ú: "ú",
  ù: "ù",
  ü: "ü",
  ǘ: "ǘ",
  ǜ: "ǜ",
  ǖ: "ǖ",
  ǚ: "ǚ",
  ũ: "ũ",
  ṹ: "ṹ",
  ū: "ū",
  ṻ: "ṻ",
  ŭ: "ŭ",
  ǔ: "ǔ",
  û: "û",
  ů: "ů",
  ű: "ű",
  ṽ: "ṽ",
  ẃ: "ẃ",
  ẁ: "ẁ",
  ẅ: "ẅ",
  ŵ: "ŵ",
  ẇ: "ẇ",
  ẘ: "ẘ",
  ẍ: "ẍ",
  ẋ: "ẋ",
  ý: "ý",
  ỳ: "ỳ",
  ÿ: "ÿ",
  ỹ: "ỹ",
  ȳ: "ȳ",
  ŷ: "ŷ",
  ẏ: "ẏ",
  ẙ: "ẙ",
  ź: "ź",
  ž: "ž",
  ẑ: "ẑ",
  ż: "ż",
  Á: "Á",
  À: "À",
  Ä: "Ä",
  Ǟ: "Ǟ",
  Ã: "Ã",
  Ā: "Ā",
  Ă: "Ă",
  Ắ: "Ắ",
  Ằ: "Ằ",
  Ẵ: "Ẵ",
  Ǎ: "Ǎ",
  Â: "Â",
  Ấ: "Ấ",
  Ầ: "Ầ",
  Ẫ: "Ẫ",
  Ȧ: "Ȧ",
  Ǡ: "Ǡ",
  Å: "Å",
  Ǻ: "Ǻ",
  Ḃ: "Ḃ",
  Ć: "Ć",
  Ḉ: "Ḉ",
  Č: "Č",
  Ĉ: "Ĉ",
  Ċ: "Ċ",
  Ç: "Ç",
  Ď: "Ď",
  Ḋ: "Ḋ",
  Ḑ: "Ḑ",
  É: "É",
  È: "È",
  Ë: "Ë",
  Ẽ: "Ẽ",
  Ē: "Ē",
  Ḗ: "Ḗ",
  Ḕ: "Ḕ",
  Ĕ: "Ĕ",
  Ḝ: "Ḝ",
  Ě: "Ě",
  Ê: "Ê",
  Ế: "Ế",
  Ề: "Ề",
  Ễ: "Ễ",
  Ė: "Ė",
  Ȩ: "Ȩ",
  Ḟ: "Ḟ",
  Ǵ: "Ǵ",
  Ḡ: "Ḡ",
  Ğ: "Ğ",
  Ǧ: "Ǧ",
  Ĝ: "Ĝ",
  Ġ: "Ġ",
  Ģ: "Ģ",
  Ḧ: "Ḧ",
  Ȟ: "Ȟ",
  Ĥ: "Ĥ",
  Ḣ: "Ḣ",
  Ḩ: "Ḩ",
  Í: "Í",
  Ì: "Ì",
  Ï: "Ï",
  Ḯ: "Ḯ",
  Ĩ: "Ĩ",
  Ī: "Ī",
  Ĭ: "Ĭ",
  Ǐ: "Ǐ",
  Î: "Î",
  İ: "İ",
  Ĵ: "Ĵ",
  Ḱ: "Ḱ",
  Ǩ: "Ǩ",
  Ķ: "Ķ",
  Ĺ: "Ĺ",
  Ľ: "Ľ",
  Ļ: "Ļ",
  Ḿ: "Ḿ",
  Ṁ: "Ṁ",
  Ń: "Ń",
  Ǹ: "Ǹ",
  Ñ: "Ñ",
  Ň: "Ň",
  Ṅ: "Ṅ",
  Ņ: "Ņ",
  Ó: "Ó",
  Ò: "Ò",
  Ö: "Ö",
  Ȫ: "Ȫ",
  Õ: "Õ",
  Ṍ: "Ṍ",
  Ṏ: "Ṏ",
  Ȭ: "Ȭ",
  Ō: "Ō",
  Ṓ: "Ṓ",
  Ṑ: "Ṑ",
  Ŏ: "Ŏ",
  Ǒ: "Ǒ",
  Ô: "Ô",
  Ố: "Ố",
  Ồ: "Ồ",
  Ỗ: "Ỗ",
  Ȯ: "Ȯ",
  Ȱ: "Ȱ",
  Ő: "Ő",
  Ṕ: "Ṕ",
  Ṗ: "Ṗ",
  Ŕ: "Ŕ",
  Ř: "Ř",
  Ṙ: "Ṙ",
  Ŗ: "Ŗ",
  Ś: "Ś",
  Ṥ: "Ṥ",
  Š: "Š",
  Ṧ: "Ṧ",
  Ŝ: "Ŝ",
  Ṡ: "Ṡ",
  Ş: "Ş",
  Ť: "Ť",
  Ṫ: "Ṫ",
  Ţ: "Ţ",
  Ú: "Ú",
  Ù: "Ù",
  Ü: "Ü",
  Ǘ: "Ǘ",
  Ǜ: "Ǜ",
  Ǖ: "Ǖ",
  Ǚ: "Ǚ",
  Ũ: "Ũ",
  Ṹ: "Ṹ",
  Ū: "Ū",
  Ṻ: "Ṻ",
  Ŭ: "Ŭ",
  Ǔ: "Ǔ",
  Û: "Û",
  Ů: "Ů",
  Ű: "Ű",
  Ṽ: "Ṽ",
  Ẃ: "Ẃ",
  Ẁ: "Ẁ",
  Ẅ: "Ẅ",
  Ŵ: "Ŵ",
  Ẇ: "Ẇ",
  Ẍ: "Ẍ",
  Ẋ: "Ẋ",
  Ý: "Ý",
  Ỳ: "Ỳ",
  Ÿ: "Ÿ",
  Ỹ: "Ỹ",
  Ȳ: "Ȳ",
  Ŷ: "Ŷ",
  Ẏ: "Ẏ",
  Ź: "Ź",
  Ž: "Ž",
  Ẑ: "Ẑ",
  Ż: "Ż",
  ά: "ά",
  ὰ: "ὰ",
  ᾱ: "ᾱ",
  ᾰ: "ᾰ",
  έ: "έ",
  ὲ: "ὲ",
  ή: "ή",
  ὴ: "ὴ",
  ί: "ί",
  ὶ: "ὶ",
  ϊ: "ϊ",
  ΐ: "ΐ",
  ῒ: "ῒ",
  ῑ: "ῑ",
  ῐ: "ῐ",
  ό: "ό",
  ὸ: "ὸ",
  ύ: "ύ",
  ὺ: "ὺ",
  ϋ: "ϋ",
  ΰ: "ΰ",
  ῢ: "ῢ",
  ῡ: "ῡ",
  ῠ: "ῠ",
  ώ: "ώ",
  ὼ: "ὼ",
  Ύ: "Ύ",
  Ὺ: "Ὺ",
  Ϋ: "Ϋ",
  Ῡ: "Ῡ",
  Ῠ: "Ῠ",
  Ώ: "Ώ",
  Ὼ: "Ὼ"
};
class Iy {
  constructor(e, t) {
    this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new qoe(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
  }
  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(e, t) {
    if (t === void 0 && (t = !0), this.fetch().text !== e)
      throw new ke("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
    t && this.consume();
  }
  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }
  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    return this.nextToken == null && (this.nextToken = this.gullet.expandNextToken()), this.nextToken;
  }
  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(e) {
    this.mode = e, this.gullet.switchMode(e);
  }
  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
    try {
      var e = this.parseExpression(!1);
      return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
    } finally {
      this.gullet.endGroups();
    }
  }
  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(e) {
    var t = this.nextToken;
    this.consume(), this.gullet.pushToken(new Ei("}")), this.gullet.pushTokens(e);
    var r = this.parseExpression(!1);
    return this.expect("}"), this.nextToken = t, r;
  }
  /**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   */
  parseExpression(e, t) {
    for (var r = []; ; ) {
      this.mode === "math" && this.consumeSpaces();
      var i = this.fetch();
      if (Iy.endOfExpression.indexOf(i.text) !== -1 || t && i.text === t || e && Ga[i.text] && Ga[i.text].infix)
        break;
      var s = this.parseAtom(t);
      if (s) {
        if (s.type === "internal")
          continue;
      } else break;
      r.push(s);
    }
    return this.mode === "text" && this.formLigatures(r), this.handleInfixNodes(r);
  }
  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(e) {
    for (var t = -1, r, i = 0; i < e.length; i++)
      if (e[i].type === "infix") {
        if (t !== -1)
          throw new ke("only one infix operator per group", e[i].token);
        t = i, r = e[i].replaceWith;
      }
    if (t !== -1 && r) {
      var s, o, a = e.slice(0, t), l = e.slice(t + 1);
      a.length === 1 && a[0].type === "ordgroup" ? s = a[0] : s = {
        type: "ordgroup",
        mode: this.mode,
        body: a
      }, l.length === 1 && l[0].type === "ordgroup" ? o = l[0] : o = {
        type: "ordgroup",
        mode: this.mode,
        body: l
      };
      var c;
      return r === "\\\\abovefrac" ? c = this.callFunction(r, [s, e[t], o], []) : c = this.callFunction(r, [s, o], []), [c];
    } else
      return e;
  }
  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(e) {
    var t = this.fetch(), r = t.text;
    this.consume(), this.consumeSpaces();
    var i;
    do {
      var s;
      i = this.parseGroup(e);
    } while (((s = i) == null ? void 0 : s.type) === "internal");
    if (!i)
      throw new ke("Expected group after '" + r + "'", t);
    return i;
  }
  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push({
        type: "textord",
        mode: "text",
        text: e[r]
      });
    var i = {
      type: "text",
      mode: this.mode,
      body: t
    }, s = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [i]
    };
    return s;
  }
  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(e) {
    var t = this.parseGroup("atom", e);
    if ((t == null ? void 0 : t.type) === "internal" || this.mode === "text")
      return t;
    for (var r, i; ; ) {
      this.consumeSpaces();
      var s = this.fetch();
      if (s.text === "\\limits" || s.text === "\\nolimits") {
        if (t && t.type === "op") {
          var o = s.text === "\\limits";
          t.limits = o, t.alwaysHandleSupSub = !0;
        } else if (t && t.type === "operatorname")
          t.alwaysHandleSupSub && (t.limits = s.text === "\\limits");
        else
          throw new ke("Limit controls must follow a math operator", s);
        this.consume();
      } else if (s.text === "^") {
        if (r)
          throw new ke("Double superscript", s);
        r = this.handleSupSubscript("superscript");
      } else if (s.text === "_") {
        if (i)
          throw new ke("Double subscript", s);
        i = this.handleSupSubscript("subscript");
      } else if (s.text === "'") {
        if (r)
          throw new ke("Double superscript", s);
        var a = {
          type: "textord",
          mode: this.mode,
          text: "\\prime"
        }, l = [a];
        for (this.consume(); this.fetch().text === "'"; )
          l.push(a), this.consume();
        this.fetch().text === "^" && l.push(this.handleSupSubscript("superscript")), r = {
          type: "ordgroup",
          mode: this.mode,
          body: l
        };
      } else if (gm[s.text]) {
        var c = CC.test(s.text), u = [];
        for (u.push(new Ei(gm[s.text])), this.consume(); ; ) {
          var h = this.fetch().text;
          if (!gm[h] || CC.test(h) !== c)
            break;
          u.unshift(new Ei(gm[h])), this.consume();
        }
        var f = this.subparse(u);
        c ? i = {
          type: "ordgroup",
          mode: "math",
          body: f
        } : r = {
          type: "ordgroup",
          mode: "math",
          body: f
        };
      } else
        break;
    }
    return r || i ? {
      type: "supsub",
      mode: this.mode,
      base: t,
      sup: r,
      sub: i
    } : t;
  }
  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(e, t) {
    var r = this.fetch(), i = r.text, s = Ga[i];
    if (!s)
      return null;
    if (this.consume(), t && t !== "atom" && !s.allowedInArgument)
      throw new ke("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), r);
    if (this.mode === "text" && !s.allowedInText)
      throw new ke("Can't use function '" + i + "' in text mode", r);
    if (this.mode === "math" && s.allowedInMath === !1)
      throw new ke("Can't use function '" + i + "' in math mode", r);
    var {
      args: o,
      optArgs: a
    } = this.parseArguments(i, s);
    return this.callFunction(i, o, a, r, e);
  }
  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(e, t, r, i, s) {
    var o = {
      funcName: e,
      parser: this,
      token: i,
      breakOnTokenText: s
    }, a = Ga[e];
    if (a && a.handler)
      return a.handler(o, t, r);
    throw new ke("No function handler for " + e);
  }
  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(e, t) {
    var r = t.numArgs + t.numOptionalArgs;
    if (r === 0)
      return {
        args: [],
        optArgs: []
      };
    for (var i = [], s = [], o = 0; o < r; o++) {
      var a = t.argTypes && t.argTypes[o], l = o < t.numOptionalArgs;
      (t.primitive && a == null || // \sqrt expands into primitive if optional argument doesn't exist
      t.type === "sqrt" && o === 1 && s[0] == null) && (a = "primitive");
      var c = this.parseGroupOfType("argument to '" + e + "'", a, l);
      if (l)
        s.push(c);
      else if (c != null)
        i.push(c);
      else
        throw new ke("Null argument, please report this as a bug");
    }
    return {
      args: i,
      optArgs: s
    };
  }
  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(e, t, r) {
    switch (t) {
      case "color":
        return this.parseColorGroup(r);
      case "size":
        return this.parseSizeGroup(r);
      case "url":
        return this.parseUrlGroup(r);
      case "math":
      case "text":
        return this.parseArgumentGroup(r, t);
      case "hbox": {
        var i = this.parseArgumentGroup(r, "text");
        return i != null ? {
          type: "styling",
          mode: i.mode,
          body: [i],
          style: "text"
          // simulate \textstyle
        } : null;
      }
      case "raw": {
        var s = this.parseStringGroup("raw", r);
        return s != null ? {
          type: "raw",
          mode: "text",
          string: s.text
        } : null;
      }
      case "primitive": {
        if (r)
          throw new ke("A primitive argument cannot be optional");
        var o = this.parseGroup(e);
        if (o == null)
          throw new ke("Expected group as " + e, this.fetch());
        return o;
      }
      case "original":
      case null:
      case void 0:
        return this.parseArgumentGroup(r);
      default:
        throw new ke("Unknown group type as " + e, this.fetch());
    }
  }
  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    for (; this.fetch().text === " "; )
      this.consume();
  }
  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(e, t) {
    var r = this.gullet.scanArgument(t);
    if (r == null)
      return null;
    for (var i = "", s; (s = this.fetch()).text !== "EOF"; )
      i += s.text, this.consume();
    return this.consume(), r.text = i, r;
  }
  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(e, t) {
    for (var r = this.fetch(), i = r, s = "", o; (o = this.fetch()).text !== "EOF" && e.test(s + o.text); )
      i = o, s += i.text, this.consume();
    if (s === "")
      throw new ke("Invalid " + t + ": '" + r.text + "'", r);
    return r.range(i, s);
  }
  /**
   * Parses a color description.
   */
  parseColorGroup(e) {
    var t = this.parseStringGroup("color", e);
    if (t == null)
      return null;
    var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
    if (!r)
      throw new ke("Invalid color: '" + t.text + "'", t);
    var i = r[0];
    return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
      type: "color-token",
      mode: this.mode,
      color: i
    };
  }
  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(e) {
    var t, r = !1;
    if (this.gullet.consumeSpaces(), !e && this.gullet.future().text !== "{" ? t = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size") : t = this.parseStringGroup("size", e), !t)
      return null;
    !e && t.text.length === 0 && (t.text = "0pt", r = !0);
    var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
    if (!i)
      throw new ke("Invalid size: '" + t.text + "'", t);
    var s = {
      number: +(i[1] + i[2]),
      // sign + magnitude, cast to number
      unit: i[3]
    };
    if (!HD(s))
      throw new ke("Invalid unit: '" + s.unit + "'", t);
    return {
      type: "size",
      mode: this.mode,
      value: s,
      isBlank: r
    };
  }
  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(e) {
    this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
    var t = this.parseStringGroup("url", e);
    if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), t == null)
      return null;
    var r = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
    return {
      type: "url",
      mode: this.mode,
      url: r
    };
  }
  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(e, t) {
    var r = this.gullet.scanArgument(e);
    if (r == null)
      return null;
    var i = this.mode;
    t && this.switchMode(t), this.gullet.beginGroup();
    var s = this.parseExpression(!1, "EOF");
    this.expect("EOF"), this.gullet.endGroup();
    var o = {
      type: "ordgroup",
      mode: this.mode,
      loc: r.loc,
      body: s
    };
    return t && this.switchMode(i), o;
  }
  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(e, t) {
    var r = this.fetch(), i = r.text, s;
    if (i === "{" || i === "\\begingroup") {
      this.consume();
      var o = i === "{" ? "}" : "\\endgroup";
      this.gullet.beginGroup();
      var a = this.parseExpression(!1, o), l = this.fetch();
      this.expect(o), this.gullet.endGroup(), s = {
        type: "ordgroup",
        mode: this.mode,
        loc: Jr.range(r, l),
        body: a,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/when-should-one-
        // use-begingroup-instead-of-bgroup
        semisimple: i === "\\begingroup" || void 0
      };
    } else if (s = this.parseFunction(t, e) || this.parseSymbol(), s == null && i[0] === "\\" && !EN.hasOwnProperty(i)) {
      if (this.settings.throwOnError)
        throw new ke("Undefined control sequence: " + i, r);
      s = this.formatUnsupportedCmd(i), this.consume();
    }
    return s;
  }
  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(e) {
    for (var t = e.length - 1, r = 0; r < t; ++r) {
      var i = e[r], s = i.text;
      s === "-" && e[r + 1].text === "-" && (r + 1 < t && e[r + 2].text === "-" ? (e.splice(r, 3, {
        type: "textord",
        mode: "text",
        loc: Jr.range(i, e[r + 2]),
        text: "---"
      }), t -= 2) : (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Jr.range(i, e[r + 1]),
        text: "--"
      }), t -= 1)), (s === "'" || s === "`") && e[r + 1].text === s && (e.splice(r, 2, {
        type: "textord",
        mode: "text",
        loc: Jr.range(i, e[r + 1]),
        text: s + s
      }), t -= 1);
    }
  }
  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    var e = this.fetch(), t = e.text;
    if (/^\\verb[^a-zA-Z]/.test(t)) {
      this.consume();
      var r = t.slice(5), i = r.charAt(0) === "*";
      if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1))
        throw new ke(`\\verb assertion failed --
                    please report what input caused this bug`);
      return r = r.slice(1, -1), {
        type: "verb",
        mode: "text",
        body: r,
        star: i
      };
    }
    MC.hasOwnProperty(t[0]) && !ln[this.mode][t[0]] && (this.settings.strict && this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + t[0] + '" used in math mode', e), t = MC[t[0]] + t.slice(1));
    var s = Hoe.exec(t);
    s && (t = t.substring(0, s.index), t === "i" ? t = "ı" : t === "j" && (t = "ȷ"));
    var o;
    if (ln[this.mode][t]) {
      this.settings.strict && this.mode === "math" && J4.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + t[0] + '" used in math mode', e);
      var a = ln[this.mode][t].group, l = Jr.range(e), c;
      if (Ose.hasOwnProperty(a)) {
        var u = a;
        c = {
          type: "atom",
          mode: this.mode,
          family: u,
          loc: l,
          text: t
        };
      } else
        c = {
          type: a,
          mode: this.mode,
          loc: l,
          text: t
        };
      o = c;
    } else if (t.charCodeAt(0) >= 128)
      this.settings.strict && (BD(t.charCodeAt(0)) ? this.mode === "math" && this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + t[0] + '" used in math mode', e) : this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + t[0] + '"' + (" (" + t.charCodeAt(0) + ")"), e)), o = {
        type: "textord",
        mode: "text",
        loc: Jr.range(e),
        text: t
      };
    else
      return null;
    if (this.consume(), s)
      for (var h = 0; h < s[0].length; h++) {
        var f = s[0][h];
        if (!z2[f])
          throw new ke("Unknown accent ' " + f + "'", e);
        var m = z2[f][this.mode] || z2[f].text;
        if (!m)
          throw new ke("Accent " + f + " unsupported in " + this.mode + " mode", e);
        o = {
          type: "accent",
          mode: this.mode,
          loc: Jr.range(e),
          label: m,
          isStretchy: !1,
          isShifty: !0,
          // $FlowFixMe
          base: o
        };
      }
    return o;
  }
}
Iy.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
var y6 = function(e, t) {
  if (!(typeof e == "string" || e instanceof String))
    throw new TypeError("KaTeX can only parse string typed expression");
  var r = new Iy(e, t);
  delete r.gullet.macros.current["\\df@tag"];
  var i = r.parse();
  if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
    if (!t.displayMode)
      throw new ke("\\tag works only in display equations");
    i = [{
      type: "tag",
      mode: "text",
      body: i,
      tag: r.subparse([new Ei("\\df@tag")])
    }];
  }
  return i;
}, LN = function(e, t, r) {
  t.textContent = "";
  var i = b6(e, r).toNode();
  t.appendChild(i);
};
typeof document < "u" && document.compatMode !== "CSS1Compat" && (typeof console < "u" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), LN = function() {
  throw new ke("KaTeX doesn't work in quirks mode.");
});
var $oe = function(e, t) {
  var r = b6(e, t).toMarkup();
  return r;
}, joe = function(e, t) {
  var r = new Q3(t);
  return y6(e, r);
}, ON = function(e, t, r) {
  if (r.throwOnError || !(e instanceof ke))
    throw e;
  var i = Q.makeSpan(["katex-error"], [new es(t)]);
  return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, b6 = function(e, t) {
  var r = new Q3(t);
  try {
    var i = y6(e, r);
    return Qse(i, e, r);
  } catch (s) {
    return ON(s, e, r);
  }
}, Woe = function(e, t) {
  var r = new Q3(t);
  try {
    var i = y6(e, r);
    return eoe(i, e, r);
  } catch (s) {
    return ON(s, e, r);
  }
}, Uoe = "0.16.23", Koe = {
  Span: up,
  Anchor: n6,
  SymbolNode: es,
  SvgNode: aa,
  PathNode: ul,
  LineNode: G4
}, DN = {
  /**
   * Current KaTeX version
   */
  version: Uoe,
  /**
   * Renders the given LaTeX into an HTML+MathML combination, and adds
   * it as a child to the specified DOM node.
   */
  render: LN,
  /**
   * Renders the given LaTeX into an HTML+MathML combination string,
   * for sending to the client.
   */
  renderToString: $oe,
  /**
   * KaTeX error, usually during parsing.
   */
  ParseError: ke,
  /**
   * The schema of Settings
   */
  SETTINGS_SCHEMA: rg,
  /**
   * Parses the given LaTeX into KaTeX's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: joe,
  /**
   * Renders the given LaTeX into an HTML+MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToDomTree: b6,
  /**
   * Renders the given LaTeX into an HTML internal DOM tree representation,
   * without MathML and without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToHTMLTree: Woe,
  /**
   * extends internal font metrics object with a new object
   * each key in the new object represents a font name
  */
  __setFontMetrics: xse,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: A,
  /**
   * adds a new function to builtin function list,
   * which directly produce parse tree elements
   * and have their own html/mathml builders
   */
  __defineFunction: _e,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: P,
  /**
   * Expose the dom tree node types, which can be useful for type checking nodes.
   *
   * NOTE: These methods are not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __domTree: Koe
}, D0, N0, Qu, eh, I0, th, nh, rh, ih, _0, w1, NN;
class _y {
  constructor(e) {
    Se(this, w1);
    /// @internal
    Se(this, D0);
    /// @internal
    Se(this, N0);
    /// @internal
    Se(this, Qu);
    /// @internal
    Se(this, eh);
    /// @internal
    Se(this, I0);
    Se(this, th);
    /// @internal
    Se(this, nh);
    /// @internal
    Se(this, rh);
    /// @internal
    Se(this, ih);
    Se(this, _0);
    re(this, th, !1), this.onShow = () => {
    }, this.onHide = () => {
    }, re(this, _0, (t, r) => {
      const { state: i, composing: s } = t, { selection: o, doc: a } = i, { ranges: l } = o, c = Math.min(...l.map((m) => m.$from.pos)), u = Math.max(...l.map((m) => m.$to.pos)), h = r && r.doc.eq(a) && r.selection.eq(o);
      if (G(this, th) || ((G(this, I0) ?? t.dom.parentElement ?? document.body).appendChild(this.element), re(this, th, !0)), s || h) return;
      if (!G(this, N0).call(this, t, r)) {
        this.hide();
        return;
      }
      Cs({
        getBoundingClientRect: () => $1(t, c, u)
      }, this.element, {
        placement: G(this, eh).placement ?? "top",
        middleware: [
          e1(),
          ll(G(this, nh)),
          O8(G(this, rh)),
          ...G(this, Qu)
        ]
      }).then(({ x: m, y }) => {
        Object.assign(this.element.style, {
          left: `${m}px`,
          top: `${y}px`
        });
      }).catch(console.error), this.show();
    }), this.update = (t, r) => {
      G(this, ih).call(this, t, r);
    }, this.destroy = () => {
      G(this, ih).cancel();
    }, this.show = (t) => {
      this.element.dataset.show = "true", t && Cs(t, this.element, {
        placement: "top",
        middleware: [
          e1(),
          ll(G(this, nh)),
          O8(G(this, rh)),
          ...G(this, Qu)
        ],
        ...G(this, eh)
      }).then(({ x: r, y: i }) => {
        Object.assign(this.element.style, {
          left: `${r}px`,
          top: `${i}px`
        });
      }).catch(console.error), this.onShow();
    }, this.hide = () => {
      this.element.dataset.show !== "false" && (this.element.dataset.show = "false", this.onHide());
    }, this.element = e.content, re(this, D0, e.debounce ?? 200), re(this, N0, e.shouldShow ?? Cp(this, w1, NN)), re(this, nh, e.offset), re(this, rh, e.shift), re(this, Qu, e.middleware ?? []), re(this, eh, e.floatingUIOptions ?? {}), re(this, I0, e.root), this.element.dataset.show = "false", re(this, ih, T1(G(this, _0), G(this, D0)));
  }
}
D0 = new WeakMap(), N0 = new WeakMap(), Qu = new WeakMap(), eh = new WeakMap(), I0 = new WeakMap(), th = new WeakMap(), nh = new WeakMap(), rh = new WeakMap(), ih = new WeakMap(), _0 = new WeakMap(), w1 = new WeakSet(), /// @internal
NN = function(e) {
  const { doc: t, selection: r } = e.state, { empty: i, from: s, to: o } = r, a = !t.textBetween(s, o).length && e.state.selection instanceof Ye, l = this.element.contains(document.activeElement), c = !e.hasFocus() && !l, u = !e.editable;
  return !(c || i || a || u);
};
function Ry(n) {
  const e = Wt(
    {},
    `${n}_TOOLTIP_SPEC`
  ), t = jn((i) => {
    const s = i.get(e.key);
    return new mn({
      key: new gn(`${n}_TOOLTIP`),
      ...s
    });
  }), r = [e, t];
  return r.key = e.key, r.pluginKey = t.key, e.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${n}`
  }, t.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${n}`
  }, r;
}
function Goe() {
  return {
    enter: {
      mathFlow: n,
      mathFlowFenceMeta: e,
      mathText: s
    },
    exit: {
      mathFlow: i,
      mathFlowFence: r,
      mathFlowFenceMeta: t,
      mathFlowValue: a,
      mathText: o,
      mathTextData: a
    }
  };
  function n(l) {
    const c = {
      type: "element",
      tagName: "code",
      properties: { className: ["language-math", "math-display"] },
      children: []
    };
    this.enter(
      {
        type: "math",
        meta: null,
        value: "",
        data: { hName: "pre", hChildren: [c] }
      },
      l
    );
  }
  function e() {
    this.buffer();
  }
  function t() {
    const l = this.resume(), c = this.stack[this.stack.length - 1];
    c.type, c.meta = l;
  }
  function r() {
    this.data.mathFlowInside || (this.buffer(), this.data.mathFlowInside = !0);
  }
  function i(l) {
    const c = this.resume().replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), u = this.stack[this.stack.length - 1];
    u.type, this.exit(l), u.value = c;
    const h = (
      /** @type {HastElement} */
      u.data.hChildren[0]
    );
    h.type, h.tagName, h.children.push({ type: "text", value: c }), this.data.mathFlowInside = void 0;
  }
  function s(l) {
    this.enter(
      {
        type: "inlineMath",
        value: "",
        data: {
          hName: "code",
          hProperties: { className: ["language-math", "math-inline"] },
          hChildren: []
        }
      },
      l
    ), this.buffer();
  }
  function o(l) {
    const c = this.resume(), u = this.stack[this.stack.length - 1];
    u.type, this.exit(l), u.value = c, /** @type {Array<HastElementContent>} */
    // @ts-expect-error: we defined it in `enterMathFlow`.
    u.data.hChildren.push({ type: "text", value: c });
  }
  function a(l) {
    this.config.enter.data.call(this, l), this.config.exit.data.call(this, l);
  }
}
function Joe(n) {
  let e = (n || {}).singleDollarTextMath;
  return e == null && (e = !0), r.peek = i, {
    unsafe: [
      { character: "\r", inConstruct: "mathFlowMeta" },
      { character: `
`, inConstruct: "mathFlowMeta" },
      {
        character: "$",
        after: e ? void 0 : "\\$",
        inConstruct: "phrasing"
      },
      { character: "$", inConstruct: "mathFlowMeta" },
      { atBreak: !0, character: "$", after: "\\$" }
    ],
    handlers: { math: t, inlineMath: r }
  };
  function t(s, o, a, l) {
    const c = s.value || "", u = a.createTracker(l), h = "$".repeat(Math.max(NA(c, "$") + 1, 2)), f = a.enter("mathFlow");
    let m = u.move(h);
    if (s.meta) {
      const y = a.enter("mathFlowMeta");
      m += u.move(
        a.safe(s.meta, {
          after: `
`,
          before: m,
          encode: ["$"],
          ...u.current()
        })
      ), y();
    }
    return m += u.move(`
`), c && (m += u.move(c + `
`)), m += u.move(h), f(), m;
  }
  function r(s, o, a) {
    let l = s.value || "", c = 1;
    for (e || c++; new RegExp("(^|[^$])" + "\\$".repeat(c) + "([^$]|$)").test(l); )
      c++;
    const u = "$".repeat(c);
    // Contains non-space.
    /[^ \r\n]/.test(l) && // Starts with space and ends with space.
    (/^[ \r\n]/.test(l) && /[ \r\n]$/.test(l) || // Starts or ends with dollar.
    /^\$|\$$/.test(l)) && (l = " " + l + " ");
    let h = -1;
    for (; ++h < a.unsafe.length; ) {
      const f = a.unsafe[h];
      if (!f.atBreak) continue;
      const m = a.compilePattern(f);
      let y;
      for (; y = m.exec(l); ) {
        let b = y.index;
        l.codePointAt(b) === 10 && l.codePointAt(b - 1) === 13 && b--, l = l.slice(0, b) + " " + l.slice(y.index + 1);
      }
    }
    return u + l + u;
  }
  function i() {
    return "$";
  }
}
const Yoe = {
  tokenize: Xoe,
  concrete: !0,
  name: "mathFlow"
}, TC = {
  tokenize: Zoe,
  partial: !0
};
function Xoe(n, e, t) {
  const r = this, i = r.events[r.events.length - 1], s = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0;
  let o = 0;
  return a;
  function a(M) {
    return n.enter("mathFlow"), n.enter("mathFlowFence"), n.enter("mathFlowFenceSequence"), l(M);
  }
  function l(M) {
    return M === 36 ? (n.consume(M), o++, l) : o < 2 ? t(M) : (n.exit("mathFlowFenceSequence"), Ct(n, c, "whitespace")(M));
  }
  function c(M) {
    return M === null || Xe(M) ? h(M) : (n.enter("mathFlowFenceMeta"), n.enter("chunkString", {
      contentType: "string"
    }), u(M));
  }
  function u(M) {
    return M === null || Xe(M) ? (n.exit("chunkString"), n.exit("mathFlowFenceMeta"), h(M)) : M === 36 ? t(M) : (n.consume(M), u);
  }
  function h(M) {
    return n.exit("mathFlowFence"), r.interrupt ? e(M) : n.attempt(TC, f, k)(M);
  }
  function f(M) {
    return n.attempt({
      tokenize: x,
      partial: !0
    }, k, m)(M);
  }
  function m(M) {
    return (s ? Ct(n, y, "linePrefix", s + 1) : y)(M);
  }
  function y(M) {
    return M === null ? k(M) : Xe(M) ? n.attempt(TC, f, k)(M) : (n.enter("mathFlowValue"), b(M));
  }
  function b(M) {
    return M === null || Xe(M) ? (n.exit("mathFlowValue"), y(M)) : (n.consume(M), b);
  }
  function k(M) {
    return n.exit("mathFlow"), e(M);
  }
  function x(M, T, E) {
    let C = 0;
    return Ct(M, O, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
    function O(H) {
      return M.enter("mathFlowFence"), M.enter("mathFlowFenceSequence"), R(H);
    }
    function R(H) {
      return H === 36 ? (C++, M.consume(H), R) : C < o ? E(H) : (M.exit("mathFlowFenceSequence"), Ct(M, F, "whitespace")(H));
    }
    function F(H) {
      return H === null || Xe(H) ? (M.exit("mathFlowFence"), T(H)) : E(H);
    }
  }
}
function Zoe(n, e, t) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? e(o) : (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), s);
  }
  function s(o) {
    return r.parser.lazy[r.now().line] ? t(o) : e(o);
  }
}
function Qoe(n) {
  let t = (n || {}).singleDollarTextMath;
  return t == null && (t = !0), {
    tokenize: r,
    resolve: eae,
    previous: tae,
    name: "mathText"
  };
  function r(i, s, o) {
    let a = 0, l, c;
    return u;
    function u(b) {
      return i.enter("mathText"), i.enter("mathTextSequence"), h(b);
    }
    function h(b) {
      return b === 36 ? (i.consume(b), a++, h) : a < 2 && !t ? o(b) : (i.exit("mathTextSequence"), f(b));
    }
    function f(b) {
      return b === null ? o(b) : b === 36 ? (c = i.enter("mathTextSequence"), l = 0, y(b)) : b === 32 ? (i.enter("space"), i.consume(b), i.exit("space"), f) : Xe(b) ? (i.enter("lineEnding"), i.consume(b), i.exit("lineEnding"), f) : (i.enter("mathTextData"), m(b));
    }
    function m(b) {
      return b === null || b === 32 || b === 36 || Xe(b) ? (i.exit("mathTextData"), f(b)) : (i.consume(b), m);
    }
    function y(b) {
      return b === 36 ? (i.consume(b), l++, y) : l === a ? (i.exit("mathTextSequence"), i.exit("mathText"), s(b)) : (c.type = "mathTextData", m(b));
    }
  }
}
function eae(n) {
  let e = n.length - 4, t = 3, r, i;
  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {
    for (r = t; ++r < e; )
      if (n[r][1].type === "mathTextData") {
        n[e][1].type = "mathTextPadding", n[t][1].type = "mathTextPadding", t += 2, e -= 2;
        break;
      }
  }
  for (r = t - 1, e++; ++r <= e; )
    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "mathTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);
  return n;
}
function tae(n) {
  return n !== 36 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function nae(n) {
  return {
    flow: {
      36: Yoe
    },
    text: {
      36: Qoe(n)
    }
  };
}
const rae = {};
function iae(n) {
  const e = (
    /** @type {Processor} */
    this
  ), t = n || rae, r = e.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), s = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(nae(t)), s.push(Goe()), o.push(Joe(t));
}
var sae = Object.defineProperty, AC = Object.getOwnPropertySymbols, oae = Object.prototype.hasOwnProperty, aae = Object.prototype.propertyIsEnumerable, EC = (n, e, t) => e in n ? sae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, lae = (n, e) => {
  for (var t in e || (e = {}))
    oae.call(e, t) && EC(n, t, e[t]);
  if (AC)
    for (var t of AC(e))
      aae.call(e, t) && EC(n, t, e[t]);
  return n;
};
function jc(n, e) {
  return Object.assign(n, {
    meta: lae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var cae = Object.defineProperty, LC = Object.getOwnPropertySymbols, uae = Object.prototype.hasOwnProperty, hae = Object.prototype.propertyIsEnumerable, OC = (n, e, t) => e in n ? cae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, v6 = (n, e) => {
  for (var t in e || (e = {}))
    uae.call(e, t) && OC(n, t, e[t]);
  if (LC)
    for (var t of LC(e))
      hae.call(e, t) && OC(n, t, e[t]);
  return n;
};
const fae = {
  mode: "preview"
}, ua = Wt(v6({}, fae), "linkTooltipStateCtx");
jc(ua, {
  displayName: "State<link-tooltip>",
  group: "LinkTooltip"
});
const dae = {
  addLink: () => {
  },
  editLink: () => {
  },
  removeLink: () => {
  }
}, xh = Wt(v6({}, dae), "linkTooltipAPICtx");
jc(ua, {
  displayName: "API<link-tooltip>",
  group: "LinkTooltip"
});
const pae = {
  linkIcon: "🔗",
  editButton: "✎",
  removeButton: "⌫",
  confirmButton: "Confirm ⏎",
  onCopyLink: () => {
  },
  inputPlaceholder: "Paste link..."
}, Sh = Wt(
  v6({}, pae),
  "linkTooltipConfigCtx"
);
jc(ua, {
  displayName: "Config<link-tooltip>",
  group: "LinkTooltip"
});
const IN = ct("ToggleLink", (n) => () => (e) => {
  const { doc: t, selection: r } = e, i = vs.type(n);
  return t.rangeHasMark(r.from, r.to, i) ? (n.get(xh.key).removeLink(r.from, r.to), !0) : (n.get(xh.key).addLink(r.from, r.to), !0);
}), fp = Ry("LINK_PREVIEW");
jc(fp[0], {
  displayName: "PreviewTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
jc(fp[1], {
  displayName: "PreviewTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
const Py = Ry("LINK_EDIT");
jc(Py[0], {
  displayName: "EditTooltipSpec<link-tooltip>",
  group: "LinkTooltip"
});
jc(Py[1], {
  displayName: "EditTooltipPlugin<link-tooltip>",
  group: "LinkTooltip"
});
function Cd({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
Cd.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const mae = Xn({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onConfirm: {
      type: Function,
      required: !0
    },
    onCancel: {
      type: Function,
      required: !0
    }
  },
  setup({ config: n, src: e, onConfirm: t, onCancel: r }) {
    const i = Be(e);
    hw(e, (a) => {
      i.value = a;
    });
    const s = () => {
      t(i.value);
    }, o = (a) => {
      a.stopPropagation(), a.key === "Enter" && (a.preventDefault(), s()), a.key === "Escape" && (a.preventDefault(), r());
    };
    return () => /* @__PURE__ */ te("div", { class: "link-edit" }, /* @__PURE__ */ te(
      "input",
      {
        class: "input-area",
        placeholder: n.value.inputPlaceholder,
        onKeydown: o,
        onInput: (a) => {
          i.value = a.target.value;
        },
        value: i.value
      }
    ), i.value ? /* @__PURE__ */ te(
      Cd,
      {
        class: "button confirm",
        icon: n.value.confirmButton,
        onClick: s
      }
    ) : null);
  }
});
var gae = Object.defineProperty, yae = Object.defineProperties, bae = Object.getOwnPropertyDescriptors, DC = Object.getOwnPropertySymbols, vae = Object.prototype.hasOwnProperty, wae = Object.prototype.propertyIsEnumerable, _N = (n) => {
  throw TypeError(n);
}, NC = (n, e, t) => e in n ? gae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, ym = (n, e) => {
  for (var t in e || (e = {}))
    vae.call(e, t) && NC(n, t, e[t]);
  if (DC)
    for (var t of DC(e))
      wae.call(e, t) && NC(n, t, e[t]);
  return n;
}, IC = (n, e) => yae(n, bae(e)), RN = (n, e, t) => e.has(n) || _N("Cannot " + t), wn = (n, e, t) => (RN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Lo = (n, e, t) => e.has(n) ? _N("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), _l = (n, e, t, r) => (RN(n, e, "write to private field"), e.set(n, t), t), Pf, Ea, La, sg, Bf, og, zl, tw, ag;
const _C = {
  from: -1,
  to: -1,
  mark: null
};
class kae {
  constructor(e, t) {
    this.ctx = e, Lo(this, Pf), Lo(this, Ea), Lo(this, La, ym({}, _C)), Lo(this, sg), Lo(this, Bf), Lo(this, og, Be("")), Lo(this, zl, () => {
      wn(this, Ea).hide(), this.ctx.update(ua.key, (s) => IC(ym({}, s), {
        mode: "preview"
      })), _l(this, La, ym({}, _C));
    }), Lo(this, tw, (s) => {
      const o = this.ctx.get(on), { from: a, to: l, mark: c } = wn(this, La), u = vs.type(this.ctx), h = Es.sanitize(s);
      if (c && c.attrs.href === h) {
        wn(this, zl).call(this);
        return;
      }
      const f = o.state.tr;
      c && f.removeMark(a, l, c), f.addMark(a, l, u.create({ href: h })), o.dispatch(f), wn(this, zl).call(this);
    }), Lo(this, ag, (s, o, a) => {
      const l = this.ctx.get(Sh.key);
      wn(this, Bf).value = l, wn(this, og).value = s, this.ctx.update(ua.key, (u) => IC(ym({}, u), {
        mode: "edit"
      }));
      const c = this.ctx.get(on);
      c.dispatch(
        c.state.tr.setSelection(Ye.create(c.state.doc, o, a))
      ), wn(this, Ea).show({
        getBoundingClientRect: () => $1(c, o, a)
      }), requestAnimationFrame(() => {
        var u;
        (u = wn(this, Pf).querySelector("input")) == null || u.focus();
      });
    }), this.update = (s) => {
      const { state: o } = s, { selection: a } = o;
      if (!(a instanceof Ye)) return;
      const { from: l, to: c } = a;
      l === wn(this, La).from && c === wn(this, La).to || wn(this, zl).call(this);
    }, this.destroy = () => {
      wn(this, sg).unmount(), wn(this, Ea).destroy(), wn(this, Pf).remove();
    }, this.addLink = (s, o) => {
      _l(this, La, {
        from: s,
        to: o,
        mark: null
      }), wn(this, ag).call(this, "", s, o);
    }, this.editLink = (s, o, a) => {
      _l(this, La, {
        from: o,
        to: a,
        mark: s
      }), wn(this, ag).call(this, s.attrs.href, o, a);
    }, this.removeLink = (s, o) => {
      const a = this.ctx.get(on), l = a.state.tr;
      l.removeMark(s, o, vs.type(this.ctx)), a.dispatch(l), wn(this, zl).call(this);
    }, _l(this, Bf, Be(this.ctx.get(Sh.key)));
    const r = document.createElement("div");
    r.className = "milkdown-link-edit";
    const i = ns(mae, {
      config: wn(this, Bf),
      src: wn(this, og),
      onConfirm: wn(this, tw),
      onCancel: wn(this, zl)
    });
    i.mount(r), _l(this, sg, i), _l(this, Pf, r), _l(this, Ea, new _y({
      content: r,
      debounce: 0,
      shouldShow: () => !1
    })), wn(this, Ea).onHide = () => {
      requestAnimationFrame(() => {
        t.dom.focus({ preventScroll: !0 });
      });
    }, wn(this, Ea).update(t);
  }
}
Pf = /* @__PURE__ */ new WeakMap();
Ea = /* @__PURE__ */ new WeakMap();
La = /* @__PURE__ */ new WeakMap();
sg = /* @__PURE__ */ new WeakMap();
Bf = /* @__PURE__ */ new WeakMap();
og = /* @__PURE__ */ new WeakMap();
zl = /* @__PURE__ */ new WeakMap();
tw = /* @__PURE__ */ new WeakMap();
ag = /* @__PURE__ */ new WeakMap();
var xae = Object.defineProperty, Sae = Object.defineProperties, Cae = Object.getOwnPropertyDescriptors, RC = Object.getOwnPropertySymbols, Mae = Object.prototype.hasOwnProperty, Tae = Object.prototype.propertyIsEnumerable, PC = (n, e, t) => e in n ? xae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Aae = (n, e) => {
  for (var t in e || (e = {}))
    Mae.call(e, t) && PC(n, t, e[t]);
  if (RC)
    for (var t of RC(e))
      Tae.call(e, t) && PC(n, t, e[t]);
  return n;
}, Eae = (n, e) => Sae(n, Cae(e));
function Lae(n) {
  let e;
  n.update(xh.key, (t) => Eae(Aae({}, t), {
    addLink: (r, i) => {
      e == null || e.addLink(r, i);
    },
    editLink: (r, i, s) => {
      e == null || e.editLink(r, i, s);
    },
    removeLink: (r, i) => {
      e == null || e.removeLink(r, i);
    }
  })), n.set(Py.key, {
    view: (t) => (e = new kae(n, t), e)
  });
}
function Oae(n, e, t, r, i) {
  let s = { start: -1, end: -1 };
  return t.nodesBetween(r, i, (o, a) => {
    if (s.start > -1) return !1;
    s.start === -1 && n.isInSet(o.marks) && e === o && (s = {
      start: a,
      end: a + Math.max(o.textContent.length, 1)
    });
  }), s;
}
function Dae(n, e, t) {
  const r = e.posAtCoords({ left: t.clientX, top: t.clientY });
  if (!r) return;
  const { pos: i } = r, s = e.state.doc.nodeAt(i);
  if (!s) return;
  const o = s.marks.find(
    (l) => l.type === vs.mark.type(n)
  );
  if (!(!o || !fp.pluginKey()))
    return { show: !0, pos: i, node: s, mark: o };
}
const Nae = Xn({
  props: {
    config: {
      type: Object,
      required: !0
    },
    src: {
      type: Object,
      required: !0
    },
    onEdit: {
      type: Object,
      required: !0
    },
    onRemove: {
      type: Object,
      required: !0
    }
  },
  setup({ config: n, src: e, onEdit: t, onRemove: r }) {
    const i = (a) => {
      a.preventDefault(), a.stopPropagation(), t.value();
    }, s = (a) => {
      a.preventDefault(), a.stopPropagation(), r.value();
    }, o = (a) => {
      a.preventDefault();
      const l = e.value;
      navigator.clipboard && l && navigator.clipboard.writeText(l).then(() => {
        n.value.onCopyLink(l);
      }).catch((c) => console.error(c));
    };
    return () => /* @__PURE__ */ te("div", { class: "link-preview" }, /* @__PURE__ */ te(
      Cd,
      {
        class: "button link-icon",
        icon: n.value.linkIcon,
        onClick: o
      }
    ), /* @__PURE__ */ te("a", { href: e.value, target: "_blank", class: "link-display" }, e.value), /* @__PURE__ */ te(
      Cd,
      {
        class: "button link-edit-button",
        icon: n.value.editButton,
        onClick: i
      }
    ), /* @__PURE__ */ te(
      Cd,
      {
        class: "button link-remove-button",
        icon: n.value.removeButton,
        onClick: s
      }
    ));
  }
});
var PN = (n) => {
  throw TypeError(n);
}, BN = (n, e, t) => e.has(n) || PN("Cannot " + t), Pt = (n, e, t) => (BN(n, e, "read from private field"), t ? t.call(n) : e.get(n)), pi = (n, e, t) => e.has(n) ? PN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Rl = (n, e, t, r) => (BN(n, e, "write to private field"), e.set(n, t), t), Fl, hs, Hf, zf, lg, cg, ug, Ff, Vf, hg, fg, dg, qf;
class Iae {
  constructor(e, t) {
    this.ctx = e, pi(this, Fl), pi(this, hs), pi(this, Hf, this.ctx.use(ua.key)), pi(this, zf), pi(this, lg, Be("")), pi(this, cg, Be(() => {
    })), pi(this, ug, Be(() => {
    })), pi(this, Ff), pi(this, Vf, !1), pi(this, hg, ({ mode: r }) => {
      r === "edit" && Pt(this, qf).call(this);
    }), pi(this, fg, () => {
      Rl(this, Vf, !0);
    }), pi(this, dg, () => {
      Rl(this, Vf, !1);
    }), pi(this, qf, () => {
      Pt(this, hs).hide(), Pt(this, hs).element.removeEventListener("mouseenter", Pt(this, fg)), Pt(this, hs).element.removeEventListener("mouseleave", Pt(this, dg));
    }), this.show = (r, i, s, o) => {
      Pt(this, zf).value = this.ctx.get(Sh.key), Pt(this, lg).value = r.attrs.href, Pt(this, cg).value = () => {
        this.ctx.get(xh.key).editLink(r, i, s);
      }, Pt(this, ug).value = () => {
        this.ctx.get(xh.key).removeLink(i, s), Pt(this, qf).call(this);
      }, Pt(this, hs).show({
        getBoundingClientRect: () => o
      }), Pt(this, hs).element.addEventListener("mouseenter", Pt(this, fg)), Pt(this, hs).element.addEventListener("mouseleave", Pt(this, dg));
    }, this.hide = () => {
      Pt(this, Vf) || Pt(this, qf).call(this);
    }, this.update = () => {
    }, this.destroy = () => {
      Pt(this, Ff).unmount(), Pt(this, Hf).off(Pt(this, hg)), Pt(this, hs).destroy(), Pt(this, Fl).remove();
    }, Rl(this, zf, Be(this.ctx.get(Sh.key))), Rl(this, Ff, ns(Nae, {
      config: Pt(this, zf),
      src: Pt(this, lg),
      onEdit: Pt(this, cg),
      onRemove: Pt(this, ug)
    })), Rl(this, Fl, document.createElement("div")), Pt(this, Fl).className = "milkdown-link-preview", Pt(this, Ff).mount(Pt(this, Fl)), Rl(this, hs, new _y({
      debounce: 0,
      content: Pt(this, Fl),
      shouldShow: () => !1
    })), Pt(this, hs).update(t), Rl(this, Hf, e.use(ua.key)), Pt(this, Hf).on(Pt(this, hg));
  }
}
Fl = /* @__PURE__ */ new WeakMap();
hs = /* @__PURE__ */ new WeakMap();
Hf = /* @__PURE__ */ new WeakMap();
zf = /* @__PURE__ */ new WeakMap();
lg = /* @__PURE__ */ new WeakMap();
cg = /* @__PURE__ */ new WeakMap();
ug = /* @__PURE__ */ new WeakMap();
Ff = /* @__PURE__ */ new WeakMap();
Vf = /* @__PURE__ */ new WeakMap();
hg = /* @__PURE__ */ new WeakMap();
fg = /* @__PURE__ */ new WeakMap();
dg = /* @__PURE__ */ new WeakMap();
qf = /* @__PURE__ */ new WeakMap();
function _ae(n) {
  let e;
  const r = M1((s, o) => {
    if (!e || !s.hasFocus() || n.get(ua.key).mode === "edit") return;
    const l = Dae(n, s, o);
    if (l) {
      const c = s.state.doc.resolve(l.pos), u = Oae(
        l.mark,
        l.node,
        s.state.doc,
        c.before(),
        c.after()
      ), h = u.start, f = u.end;
      e.show(
        l.mark,
        h,
        f,
        $1(s, h, f)
      );
      return;
    }
    e.hide();
  }, 50), i = () => {
    setTimeout(() => {
      e == null || e.hide();
    }, 50);
  };
  n.set(fp.key, {
    props: {
      handleDOMEvents: {
        mousemove: r,
        mouseleave: i
      }
    },
    view: (s) => (e = new Iae(n, s), e)
  });
}
function Rae(n) {
  _ae(n), Lae(n);
}
const Pae = [
  ua,
  xh,
  Sh,
  fp,
  Py,
  IN
].flat();
var Bae = Object.defineProperty, BC = Object.getOwnPropertySymbols, Hae = Object.prototype.hasOwnProperty, zae = Object.prototype.propertyIsEnumerable, HC = (n, e, t) => e in n ? Bae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Fae = (n, e) => {
  for (var t in e || (e = {}))
    Hae.call(e, t) && HC(n, t, e[t]);
  if (BC)
    for (var t of BC(e))
      zae.call(e, t) && HC(n, t, e[t]);
  return n;
};
function HN(n, e) {
  return Object.assign(n, {
    meta: Fae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
const Vae = {
  renderLabel: ({ label: n, listType: e, checked: t }) => t == null ? e === "bullet" ? "⦿" : n : t ? "☑" : "□"
}, By = Wt(
  Vae,
  "listItemBlockConfigCtx"
);
HN(By, {
  displayName: "Config<list-item-block>",
  group: "ListItemBlock"
});
function zN({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
zN.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
const qae = Xn({
  props: {
    label: {
      type: Object,
      required: !0
    },
    checked: {
      type: Object,
      required: !0
    },
    listType: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    readonly: {
      type: Object,
      required: !0
    },
    selected: {
      type: Object,
      required: !0
    },
    setAttr: {
      type: Function,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    }
  },
  setup({
    label: n,
    checked: e,
    listType: t,
    config: r,
    readonly: i,
    setAttr: s,
    onMount: o,
    selected: a
  }) {
    const l = (f) => {
      f != null && f instanceof Element && o(f);
    }, c = (f) => {
      f.stopPropagation(), f.preventDefault(), e.value != null && s("checked", !e.value);
    }, u = Qa(() => r.renderLabel({
      label: n.value,
      listType: t.value,
      checked: e.value,
      readonly: i.value
    })), h = Qa(() => e.value == null ? t.value === "bullet" ? "bullet" : "ordered" : e.value ? "checked" : "unchecked");
    return () => /* @__PURE__ */ te(
      "li",
      {
        class: pr(
          "list-item",
          a.value && "ProseMirror-selectednode"
        )
      },
      /* @__PURE__ */ te(
        "div",
        {
          class: "label-wrapper",
          onPointerdown: c,
          contenteditable: !1
        },
        /* @__PURE__ */ te(
          zN,
          {
            class: pr(
              "label",
              i.value && "readonly",
              h.value
            ),
            icon: u.value
          }
        )
      ),
      /* @__PURE__ */ te("div", { class: "children", ref: l })
    );
  }
}), FN = J0(
  As.node,
  (n) => (e, t, r) => {
    const i = document.createElement("div");
    i.className = "milkdown-list-item-block";
    const s = document.createElement("div");
    s.setAttribute("data-content-dom", "true"), s.classList.add("content-dom");
    const o = Be(e.attrs.label), a = Be(e.attrs.checked), l = Be(e.attrs.listType), c = Be(!t.editable), u = n.get(By.key), h = Be(!1), f = (T, E) => {
      if (!t.editable) return;
      const C = r();
      C != null && (t.hasFocus() || t.focus(), t.dispatch(t.state.tr.setNodeAttribute(C, T, E)));
    }, m = Ch(() => {
      h.value ? i.classList.add("selected") : i.classList.remove("selected");
    });
    let y = 0;
    const k = ns(qae, {
      label: o,
      checked: a,
      listType: l,
      readonly: c,
      config: u,
      selected: h,
      setAttr: f,
      onMount: (T) => {
        const { anchor: E, head: C } = t.state.selection;
        T.appendChild(s);
        const O = t.state.doc.resolve(E), R = t.state.doc.resolve(C);
        y = requestAnimationFrame(() => {
          if (cancelAnimationFrame(y), !O.doc.eq(t.state.doc)) return;
          const F = new Ye(O, R);
          t.dispatch(t.state.tr.setSelection(F));
        });
      }
    });
    k.mount(i);
    const x = (T) => {
      l.value = T.attrs.listType, o.value = T.attrs.label, a.value = T.attrs.checked, c.value = !t.editable;
    };
    x(e);
    let M = e;
    return {
      dom: i,
      contentDOM: s,
      update: (T) => T.type !== e.type ? !1 : (T.sameMarkup(M) && T.content.eq(M.content) || (M = T, x(T)), !0),
      ignoreMutation: (T) => !i || !s ? !0 : T.type === "selection" ? !1 : s === T.target && T.type === "attributes" ? !0 : !s.contains(T.target),
      selectNode: () => {
        h.value = !0;
      },
      deselectNode: () => {
        h.value = !1;
      },
      destroy: () => {
        m(), k.unmount(), i.remove(), s.remove();
      }
    };
  }
);
HN(FN, {
  displayName: "NodeView<list-item-block>",
  group: "ListItemBlock"
});
const $ae = [
  By,
  FN
];
var jae = Object.defineProperty, zC = Object.getOwnPropertySymbols, Wae = Object.prototype.hasOwnProperty, Uae = Object.prototype.propertyIsEnumerable, FC = (n, e, t) => e in n ? jae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Kae = (n, e) => {
  for (var t in e || (e = {}))
    Wae.call(e, t) && FC(n, t, e[t]);
  if (zC)
    for (var t of zC(e))
      Uae.call(e, t) && FC(n, t, e[t]);
  return n;
};
function VN(n, e) {
  return Object.assign(n, {
    meta: Kae({
      package: "@milkdown/components"
    }, e)
  }), n;
}
var Gae = Object.defineProperty, VC = Object.getOwnPropertySymbols, Jae = Object.prototype.hasOwnProperty, Yae = Object.prototype.propertyIsEnumerable, qC = (n, e, t) => e in n ? Gae(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Xae = (n, e) => {
  for (var t in e || (e = {}))
    Jae.call(e, t) && qC(n, t, e[t]);
  if (VC)
    for (var t of VC(e))
      Yae.call(e, t) && qC(n, t, e[t]);
  return n;
};
const Zae = {
  renderButton: (n) => {
    switch (n) {
      case "add_row":
        return "+";
      case "add_col":
        return "+";
      case "delete_row":
        return "-";
      case "delete_col":
        return "-";
      case "align_col_left":
        return "left";
      case "align_col_center":
        return "center";
      case "align_col_right":
        return "right";
      case "col_drag_handle":
        return "=";
      case "row_drag_handle":
        return "=";
    }
  }
}, Hy = Wt(
  Xae({}, Zae),
  "tableBlockConfigCtx"
);
VN(Hy, {
  displayName: "Config<table-block>",
  group: "TableBlock"
});
function Vs({ icon: n, class: e, onClick: t }) {
  return /* @__PURE__ */ te(
    "span",
    {
      class: pr("milkdown-icon", e),
      onPointerdown: t,
      ref: (r) => {
        r && n && (r.innerHTML = Es.sanitize(n.trim()));
      }
    }
  );
}
Vs.props = {
  icon: {
    type: String,
    required: !1
  },
  class: {
    type: String,
    required: !1
  },
  onClick: {
    type: Function,
    required: !1
  }
};
function qN(n) {
  const {
    dragPreviewRef: e,
    tableWrapperRef: t,
    contentWrapperRef: r,
    yLineHandleRef: i,
    xLineHandleRef: s,
    colHandleRef: o,
    rowHandleRef: a
  } = n, l = e.value;
  if (!l) return;
  const c = t.value;
  if (!c) return;
  const u = r.value;
  if (!u) return;
  const h = u.querySelector("tbody");
  if (!h) return;
  const f = l.querySelector("tbody");
  if (!f) return;
  const m = i.value;
  if (!m) return;
  const y = s.value;
  if (!y) return;
  const b = o.value;
  if (!b) return;
  const k = a.value;
  return k ? {
    preview: l,
    wrapper: c,
    content: u,
    contentRoot: h,
    previewRoot: f,
    yHandle: m,
    xHandle: y,
    colHandle: b,
    rowHandle: k
  } : void 0;
}
function $N(n) {
  for (; n.firstChild; ) n.removeChild(n.firstChild);
}
function jN(n, e, t, r, i) {
  const { width: s, height: o } = r.querySelector("tbody").getBoundingClientRect();
  if (n === "y") {
    const l = r.querySelectorAll("tr")[i];
    if (!l) return;
    t.appendChild(l.cloneNode(!0));
    const c = l.getBoundingClientRect().height;
    Object.assign(e.style, {
      width: `${s}px`,
      height: `${c}px`
    }), e.dataset.show = "true";
    return;
  }
  if (n === "x") {
    const a = r.querySelectorAll("tr");
    let l;
    Array.from(a).forEach((c) => {
      const u = c.children[i];
      if (!u) return;
      l === void 0 && (l = u.getBoundingClientRect().width);
      const h = u.parentElement.cloneNode(!1), f = u.cloneNode(!0);
      h.appendChild(f), t.appendChild(h);
    }), Object.assign(e.style, {
      width: `${l}px`,
      height: `${o}px`
    }), e.dataset.show = "true";
    return;
  }
}
function Qae(n, e) {
  return (t) => {
    UN(n, t, e, (r) => {
      WN("y", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r;
      $N(o);
      const { hoverIndex: a } = n, [l] = a.value;
      jN("y", i, o, s, l);
    });
  };
}
function ele(n, e) {
  return (t) => {
    UN(n, t, e, (r) => {
      WN("x", t, r, n);
      const { preview: i, content: s, previewRoot: o } = r, { hoverIndex: a } = n, [l, c] = a.value;
      $N(o), jN("x", i, o, s, c);
    });
  };
}
function WN(n, e, t, r) {
  const { xHandle: i, yHandle: s, colHandle: o, rowHandle: a, preview: l } = t;
  i.dataset.displayType = n === "y" ? "indicator" : "none", s.dataset.displayType = n === "x" ? "indicator" : "none", n === "y" ? (o.dataset.show = "false", $C(a)) : (a.dataset.show = "false", $C(o));
  const { hoverIndex: c, dragInfo: u } = r, [h, f] = c.value;
  u.value = {
    startCoords: [e.clientX, e.clientY],
    startIndex: n === "y" ? h : f,
    endIndex: n === "y" ? h : f,
    type: n === "y" ? "row" : "col"
  }, l.dataset.direction = n === "y" ? "vertical" : "horizontal";
}
function UN(n, e, t, r) {
  const i = t == null ? void 0 : t.get(on);
  if (!(i != null && i.editable)) return;
  e.stopPropagation(), e.dataTransfer && (e.dataTransfer.effectAllowed = "move");
  const s = qN(n);
  s && requestAnimationFrame(() => {
    r(s);
  });
}
function $C(n) {
  var e;
  (e = n.querySelector(".button-group")) == null || e.setAttribute("data-show", "false");
}
function nw(n, e) {
  for (let t = 0; t < n.childCount; t++)
    if (n.child(t) === e) return t;
  return -1;
}
function tle(n, e) {
  var t, r, i;
  if (e)
    try {
      const s = e.posAtCoords({
        left: n.clientX,
        top: n.clientY
      });
      if (!s) return;
      const o = s == null ? void 0 : s.inside;
      if (o == null || o < 0) return;
      const a = e.state.doc.resolve(o), l = e.state.doc.nodeAt(o);
      if (!l) return;
      const c = ["table_cell", "table_header"], u = ["table_row", "table_header_row"], h = c.includes(l.type.name) ? l : (t = eo((k) => c.includes(k.type.name))(a)) == null ? void 0 : t.node, f = (r = eo((k) => u.includes(k.type.name))(
        a
      )) == null ? void 0 : r.node, m = (i = eo((k) => k.type.name === "table")(a)) == null ? void 0 : i.node;
      if (!h || !f || !m) return;
      const y = nw(f, h);
      return [nw(m, f), y];
    } catch {
      return;
    }
}
function zy(n, [e, t]) {
  const r = n.value;
  if (!r) return;
  const i = r.querySelectorAll("tr"), s = i[e];
  if (!s) return;
  const o = i[0];
  if (!o) return;
  const a = o.children[t];
  if (!a) return;
  const l = s.children[t];
  if (l)
    return {
      row: s,
      col: l,
      headerCol: a
    };
}
function nle(n, e, t) {
  if (!t || !e) return;
  const { selection: r } = e.state;
  if (!(r instanceof nn)) return;
  const { $from: i } = r, s = Ph(i);
  if (!(!s || s.node !== t)) {
    if (r.isColSelection()) {
      const { $head: o } = r, a = o.index(o.depth - 1);
      w6({
        refs: n,
        index: [0, a],
        before: (l) => {
          var c;
          (c = l.querySelector(".button-group")) == null || c.setAttribute("data-show", "true");
        }
      });
      return;
    }
    if (r.isRowSelection()) {
      const { $head: o } = r, a = eo(
        (c) => c.type.name === "table_row" || c.type.name === "table_header_row"
      )(o);
      if (!a) return;
      const l = nw(s.node, a.node);
      k6({
        refs: n,
        index: [l, 0],
        before: (c) => {
          var u;
          l > 0 && ((u = c.querySelector(".button-group")) == null || u.setAttribute("data-show", "true"));
        }
      });
    }
  }
}
function w6({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, colHandleRef: s, hoverIndex: o } = n, a = s.value;
  if (!a) return;
  o.value = e;
  const l = zy(i, e);
  if (!l) return;
  const { headerCol: c } = l;
  a.dataset.show = "true", t && t(a), Cs(c, a, { placement: "top" }).then(({ x: u, y: h }) => {
    Object.assign(a.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(a);
  }).catch(console.error);
}
function k6({
  refs: n,
  index: e,
  before: t,
  after: r
}) {
  const { contentWrapperRef: i, rowHandleRef: s, hoverIndex: o } = n, a = s.value;
  if (!a) return;
  o.value = e;
  const l = zy(i, e);
  if (!l) return;
  const { row: c } = l;
  a.dataset.show = "true", t && t(a), Cs(c, a, { placement: "left" }).then(({ x: u, y: h }) => {
    Object.assign(a.style, {
      left: `${u}px`,
      top: `${h}px`
    }), r && r(a);
  }).catch(console.error);
}
function KN(n, e, t) {
  const r = t === "x" ? "left" : "top", i = t === "x" ? "right" : "bottom", s = n.length - 1, o = n.findIndex((l, c) => {
    const u = l.getBoundingClientRect(), h = u[r], f = u[i];
    return h <= e && e <= f || c === s && e > f || c === 0 && e < h;
  }), a = n[o];
  return a ? [a, o] : void 0;
}
function rle(n, e) {
  const t = n.querySelector("tr");
  if (!t) return;
  const r = Array.from(t.children);
  return KN(r, e, "x");
}
function ile(n, e) {
  const t = Array.from(n.querySelectorAll("tr"));
  return KN(t, e, "y");
}
function sle(n) {
  return T1((e) => {
    const t = qN(n);
    if (!t) return;
    const { preview: r, content: i, contentRoot: s, xHandle: o, yHandle: a } = t, { dragInfo: l, hoverIndex: c } = n;
    if (r.dataset.show === "false") return;
    const u = zy(n.contentWrapperRef, c.value);
    if (!u || !s.querySelector("tr")) return;
    const f = l.value;
    if (!f || !s.offsetParent) return;
    const m = s.offsetParent.offsetTop, y = s.offsetParent.offsetLeft;
    if (f.type === "col") {
      const b = u.col.getBoundingClientRect().width, { left: k, width: x } = s.getBoundingClientRect(), M = y - k, T = e.clientX + M - b / 2, [E] = f.startCoords, C = E < e.clientX ? "right" : "left";
      r.style.top = `${m}px`;
      const O = T < k + M - 20 ? k + M - 20 : T > k + x + M - b + 20 ? k + x + M - b + 20 : T;
      r.style.left = `${O}px`;
      const R = rle(s, e.clientX);
      if (R) {
        const [F, H] = R, z = a.getBoundingClientRect().width, K = i.getBoundingClientRect();
        f.endIndex = H, Cs(F, a, {
          placement: C === "left" ? "left" : "right",
          middleware: [ll(C === "left" ? -1 * z : 0)]
        }).then(({ x: U }) => {
          a.dataset.show = "true", Object.assign(a.style, {
            height: `${K.height}px`,
            left: `${U}px`,
            top: `${m}px`
          });
        }).catch(console.error);
      }
    } else if (f.type === "row") {
      const b = u.row.getBoundingClientRect().height, { top: k, height: x } = s.getBoundingClientRect(), M = m - k, T = e.clientY + M - b / 2, [E, C] = f.startCoords, O = C < e.clientY ? "down" : "up", R = T < k + M - 20 ? k + M - 20 : T > k + x + M - b + 20 ? k + x + M - b + 20 : T;
      r.style.top = `${R}px`, r.style.left = `${y}px`;
      const F = ile(s, e.clientY);
      if (F) {
        const [H, z] = F, K = o.getBoundingClientRect().height, U = i.getBoundingClientRect();
        f.endIndex = z, Cs(H, o, {
          placement: O === "up" ? "top" : "bottom",
          middleware: [ll(O === "up" ? -1 * K : 0)]
        }).then(({ y: ae }) => {
          o.dataset.show = "true", Object.assign(o.style, {
            width: `${U.width}px`,
            top: `${ae}px`
          });
        }).catch(console.error);
      }
    }
  }, 20);
}
function ole(n, e, t) {
  const { dragPreviewRef: r, yLineHandleRef: i, xLineHandleRef: s, dragInfo: o } = n, a = Qae(n, e), l = ele(n, e), c = () => {
    const f = r.value;
    if (!f || f.dataset.show === "false") return;
    const m = f == null ? void 0 : f.querySelector("tbody");
    for (; m != null && m.firstChild; )
      m == null || m.removeChild(m.firstChild);
    f && (f.dataset.show = "false");
  }, u = () => {
    var f;
    const m = r.value;
    if (!m) return;
    const y = i.value;
    if (!y) return;
    const b = s.value;
    if (!b) return;
    const k = o.value;
    if (!k || !e || m.dataset.show === "false" || !n.colHandleRef.value || !n.rowHandleRef.value || (y.dataset.show = "false", b.dataset.show = "false", k.startIndex === k.endIndex)) return;
    const T = e.get(je), E = {
      from: k.startIndex,
      to: k.endIndex,
      pos: ((f = t == null ? void 0 : t()) != null ? f : 0) + 1
    };
    if (k.type === "col") {
      T.call(Xl.key, {
        pos: E.pos,
        index: k.startIndex
      }), T.call(M3.key, E);
      const C = [0, k.endIndex];
      w6({
        refs: n,
        index: C
      });
    } else {
      T.call(Yl.key, {
        pos: E.pos,
        index: k.startIndex
      }), T.call(C3.key, E);
      const C = [k.endIndex, 0];
      k6({
        refs: n,
        index: C
      });
    }
    requestAnimationFrame(() => {
      e.get(on).focus();
    });
  }, h = sle(n);
  return R0(() => {
    window.addEventListener("dragover", h), window.addEventListener("dragend", c), window.addEventListener("drop", u);
  }), k1(() => {
    window.removeEventListener("dragover", h), window.removeEventListener("dragend", c), window.removeEventListener("drop", u);
  }), {
    dragRow: a,
    dragCol: l
  };
}
function ale(n, e, t) {
  const {
    xLineHandleRef: r,
    contentWrapperRef: i,
    colHandleRef: s,
    rowHandleRef: o,
    hoverIndex: a,
    lineHoverIndex: l
  } = n;
  return {
    onAddRow: () => {
      var b, k, x;
      if (!e) return;
      const M = r.value;
      if (!M) return;
      const [T] = l.value;
      if (T < 0 || !e.get(on).editable) return;
      const E = Array.from(
        (k = (b = i.value) == null ? void 0 : b.querySelectorAll("tr")) != null ? k : []
      ), C = e.get(je), O = ((x = t == null ? void 0 : t()) != null ? x : 0) + 1;
      E.length === T ? (C.call(Yl.key, { pos: O, index: T - 1 }), C.call(O3.key)) : (C.call(Yl.key, { pos: O, index: T }), C.call(L3.key)), C.call(Yl.key, { pos: O, index: T }), M.dataset.show = "false";
    },
    onAddCol: () => {
      var b, k, x, M;
      if (!e || !r.value) return;
      const [E, C] = l.value;
      if (C < 0 || !e.get(on).editable) return;
      const O = Array.from(
        (x = (k = (b = i.value) == null ? void 0 : b.querySelector("tr")) == null ? void 0 : k.children) != null ? x : []
      ), R = e.get(je), F = ((M = t == null ? void 0 : t()) != null ? M : 0) + 1;
      O.length === C ? (R.call(Xl.key, { pos: F, index: C - 1 }), R.call(E3.key)) : (R.call(Xl.key, { pos: F, index: C }), R.call(A3.key)), R.call(Xl.key, { pos: F, index: C });
    },
    selectCol: () => {
      var b, k;
      if (!e) return;
      const [x, M] = a.value, T = e.get(je), E = ((b = t == null ? void 0 : t()) != null ? b : 0) + 1;
      T.call(Xl.key, { pos: E, index: M });
      const C = (k = s.value) == null ? void 0 : k.querySelector(".button-group");
      C && (C.dataset.show = C.dataset.show === "true" ? "false" : "true");
    },
    selectRow: () => {
      var b, k;
      if (!e) return;
      const [x, M] = a.value, T = e.get(je), E = ((b = t == null ? void 0 : t()) != null ? b : 0) + 1;
      T.call(Yl.key, { pos: E, index: x });
      const C = (k = o.value) == null ? void 0 : k.querySelector(".button-group");
      C && x > 0 && (C.dataset.show = C.dataset.show === "true" ? "false" : "true");
    },
    deleteSelected: (b) => {
      if (!e || !e.get(on).editable) return;
      b.preventDefault(), b.stopPropagation(), e.get(je).call(T3.key), requestAnimationFrame(() => {
        e.get(on).focus();
      });
    },
    onAlign: (b) => (k) => {
      if (!e || !e.get(on).editable) return;
      k.preventDefault(), k.stopPropagation(), e.get(je).call(D3.key, b), requestAnimationFrame(() => {
        e.get(on).focus();
      });
    }
  };
}
function lle(n, e) {
  return T1((t) => {
    if (!(e != null && e.editable)) return;
    const {
      contentWrapperRef: r,
      yLineHandleRef: i,
      xLineHandleRef: s,
      colHandleRef: o,
      rowHandleRef: a,
      hoverIndex: l,
      lineHoverIndex: c
    } = n, u = i.value;
    if (!u) return;
    const h = s.value;
    if (!h) return;
    const f = r.value;
    if (!f) return;
    const m = a.value;
    if (!m) return;
    const y = o.value;
    if (!y) return;
    const b = tle(t, e);
    if (!b) return;
    const k = zy(r, b);
    if (!k) return;
    const [x, M] = b, T = k.col.getBoundingClientRect(), E = Math.abs(t.clientX - T.left) < 8, C = Math.abs(T.right - t.clientX) < 8, O = Math.abs(t.clientY - T.top) < 8, R = Math.abs(T.bottom - t.clientY) < 8, F = E || C || O || R, H = m.querySelector(".button-group"), z = y.querySelector(".button-group");
    if (H && (H.dataset.show = "false"), z && (z.dataset.show = "false"), F) {
      const K = f.getBoundingClientRect();
      m.dataset.show = "false", y.dataset.show = "false", h.dataset.displayType = "tool", u.dataset.displayType = "tool";
      const U = u.getBoundingClientRect().width, ae = h.getBoundingClientRect().height;
      E || C ? (c.value[1] = E ? M : M + 1, Cs(k.col, u, {
        placement: E ? "left" : "right",
        middleware: [ll(E ? -1 * U : 0)]
      }).then(({ x: ie }) => {
        u.dataset.show = "true", Object.assign(u.style, {
          height: `${K.height}px`,
          left: `${ie}px`
        });
      }).catch(console.error)) : u.dataset.show = "false", b[0] !== 0 && (O || R) ? (c.value[0] = O ? x : x + 1, Cs(k.row, h, {
        placement: O ? "top" : "bottom",
        middleware: [ll(O ? -1 * ae : 0)]
      }).then(({ y: ie }) => {
        h.dataset.show = "true", Object.assign(h.style, {
          width: `${K.width}px`,
          top: `${ie}px`
        });
      }).catch(console.error)) : h.dataset.show = "false";
      return;
    }
    c.value = [-1, -1], u.dataset.show = "false", h.dataset.show = "false", m.dataset.show = "true", y.dataset.show = "true", k6({
      refs: n,
      index: b
    }), w6({
      refs: n,
      index: b
    }), l.value = b;
  }, 20);
}
function cle(n) {
  return () => {
    const { rowHandleRef: e, colHandleRef: t, yLineHandleRef: r, xLineHandleRef: i } = n;
    setTimeout(() => {
      const s = e.value;
      if (!s) return;
      const o = t.value;
      if (!o) return;
      const a = r.value;
      if (!a) return;
      const l = i.value;
      l && (s.dataset.show = "false", o.dataset.show = "false", a.dataset.show = "false", l.dataset.show = "false");
    }, 200);
  };
}
function ule(n, e) {
  const t = lle(n, e), r = cle(n);
  return {
    pointerMove: t,
    pointerLeave: r
  };
}
const hle = Xn({
  props: {
    view: {
      type: Object,
      required: !0
    },
    ctx: {
      type: Object,
      required: !0
    },
    getPos: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !0
    },
    onMount: {
      type: Function,
      required: !0
    },
    node: {
      type: Object,
      required: !0
    }
  },
  setup({ view: n, node: e, ctx: t, getPos: r, config: i, onMount: s }) {
    const o = Be(), a = (U) => {
      U != null && (U instanceof HTMLElement ? (o.value = U, s(U)) : o.value = void 0);
    }, l = Be(), c = Be(), u = Be(), h = Be(), f = Be(), m = Be(), y = Be([0, 0]), b = Be([-1, -1]), k = Be(), x = {
      dragPreviewRef: m,
      tableWrapperRef: f,
      contentWrapperRef: o,
      yLineHandleRef: h,
      xLineHandleRef: u,
      colHandleRef: l,
      rowHandleRef: c,
      hoverIndex: y,
      lineHoverIndex: b,
      dragInfo: k
    }, { pointerLeave: M, pointerMove: T } = ule(x, n), { dragRow: E, dragCol: C } = ole(x, t, r), {
      onAddRow: O,
      onAddCol: R,
      selectCol: F,
      selectRow: H,
      deleteSelected: z,
      onAlign: K
    } = ale(x, t, r);
    return R0(() => {
      requestAnimationFrame(() => {
        n.editable && nle(x, n, e.value);
      });
    }), () => /* @__PURE__ */ te(
      "div",
      {
        onDragstart: (U) => U.preventDefault(),
        onDragover: (U) => U.preventDefault(),
        onDragleave: (U) => U.preventDefault(),
        onPointermove: T,
        onPointerleave: M
      },
      /* @__PURE__ */ te(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "col-drag-handle",
          class: "handle cell-handle",
          onDragstart: C,
          onClick: F,
          onPointerdown: (U) => U.stopPropagation(),
          onPointermove: (U) => U.stopPropagation(),
          ref: l
        },
        /* @__PURE__ */ te(Vs, { icon: i.renderButton("col_drag_handle") }),
        /* @__PURE__ */ te(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (U) => U.stopPropagation()
          },
          /* @__PURE__ */ te("button", { type: "button", onPointerdown: K("left") }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("align_col_left") })),
          /* @__PURE__ */ te("button", { type: "button", onPointerdown: K("center") }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("align_col_center") })),
          /* @__PURE__ */ te("button", { type: "button", onPointerdown: K("right") }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("align_col_right") })),
          /* @__PURE__ */ te("button", { type: "button", onPointerdown: z }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("delete_col") }))
        )
      ),
      /* @__PURE__ */ te(
        "button",
        {
          type: "button",
          "data-show": "false",
          contenteditable: "false",
          draggable: "true",
          "data-role": "row-drag-handle",
          class: "handle cell-handle",
          onDragstart: E,
          onClick: H,
          onPointerdown: (U) => U.stopPropagation(),
          onPointermove: (U) => U.stopPropagation(),
          ref: c
        },
        /* @__PURE__ */ te(Vs, { icon: i.renderButton("row_drag_handle") }),
        /* @__PURE__ */ te(
          "div",
          {
            "data-show": "false",
            class: "button-group",
            onPointermove: (U) => U.stopPropagation()
          },
          /* @__PURE__ */ te("button", { type: "button", onPointerdown: z }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("delete_row") }))
        )
      ),
      /* @__PURE__ */ te("div", { class: "table-wrapper", ref: f }, /* @__PURE__ */ te(
        "div",
        {
          "data-show": "false",
          class: "drag-preview",
          "data-direction": "vertical",
          ref: m
        },
        /* @__PURE__ */ te("table", null, /* @__PURE__ */ te("tbody", null))
      ), /* @__PURE__ */ te(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "x-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (U) => U.stopPropagation(),
          ref: u
        },
        /* @__PURE__ */ te("button", { type: "button", onClick: O, class: "add-button" }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("add_row") }))
      ), /* @__PURE__ */ te(
        "div",
        {
          "data-show": "false",
          contenteditable: "false",
          "data-display-type": "tool",
          "data-role": "y-line-drag-handle",
          class: "handle line-handle",
          onPointermove: (U) => U.stopPropagation(),
          ref: h
        },
        /* @__PURE__ */ te("button", { type: "button", onClick: R, class: "add-button" }, /* @__PURE__ */ te(Vs, { icon: i.renderButton("add_col") }))
      ), /* @__PURE__ */ te("table", { ref: a, class: "children" }))
    );
  }
});
var GN = (n) => {
  throw TypeError(n);
}, fle = (n, e, t) => e.has(n) || GN("Cannot " + t), dle = (n, e, t) => e.has(n) ? GN("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), ple = (n, e, t) => (fle(n, e, "access private method"), t), rw, JN;
class mle {
  constructor(e, t, r, i) {
    this.ctx = e, this.node = t, this.view = r, this.getPos = i, dle(this, rw);
    const s = document.createElement("div");
    s.className = "milkdown-table-block";
    const o = document.createElement("tbody");
    this.contentDOM = o, o.setAttribute("data-content-dom", "true"), o.classList.add("content-dom"), this.nodeRef = Sg(t);
    const a = ns(hle, {
      view: r,
      ctx: e,
      getPos: i,
      config: e.get(Hy.key),
      onMount: (l) => {
        l.appendChild(o);
      },
      node: this.nodeRef
    });
    a.mount(s), this.app = a, this.dom = s;
  }
  update(e) {
    return e.type !== this.node.type || e.sameMarkup(this.node) && e.content.eq(this.node.content) ? !1 : (this.node = e, this.nodeRef.value = e, !0);
  }
  stopEvent(e) {
    if (e.type === "drop" || e.type.startsWith("drag")) return !0;
    if (e.type === "mousedown" || e.type === "pointerdown") {
      if (e.target instanceof Element && e.target.closest("button")) return !0;
      const t = e.target;
      if (t instanceof HTMLElement && (t.closest("th") || t.closest("td"))) {
        const r = e;
        return ple(this, rw, JN).call(this, r);
      }
    }
    return !1;
  }
  ignoreMutation(e) {
    return !this.dom || !this.contentDOM ? !0 : e.type === "selection" ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target);
  }
  destroy() {
    this.app.unmount(), this.dom.remove(), this.contentDOM.remove();
  }
}
rw = /* @__PURE__ */ new WeakSet();
JN = function(n) {
  const e = this.view;
  if (!e.editable) return !1;
  const { state: t, dispatch: r } = e, i = e.posAtCoords({ left: n.clientX, top: n.clientY });
  if (!i) return !1;
  const s = t.doc.resolve(i.inside), o = eo(
    (c) => c.type.name === "table_cell" || c.type.name === "table_header"
  )(s);
  if (!o) return !1;
  if (t.selection instanceof Ye) {
    const c = eo(
      (u) => u.type.name === "table_cell" || u.type.name === "table_header"
    )(t.selection.$from);
    if ((c == null ? void 0 : c.node) === o.node) return !1;
  }
  const { from: a } = o, l = Qe.create(t.doc, a + 1);
  return t.selection.eq(l) ? !1 : (t.selection instanceof nn ? setTimeout(() => {
    r(t.tr.setSelection(l).scrollIntoView());
  }, 20) : requestAnimationFrame(() => {
    r(t.tr.setSelection(l).scrollIntoView());
  }), !0);
};
const YN = J0(
  qc.node,
  (n) => (e, t, r) => new mle(n, e, t, r)
);
VN(YN, {
  displayName: "NodeView<table-block>",
  group: "TableBlock"
});
const gle = [Hy, YN];
function iw(n) {
  if (!n) return !1;
  if (Array.isArray(n))
    return n.length > 1 ? !1 : iw(n[0]);
  const e = n.content;
  return e ? iw(e) : n.type === "text";
}
const XN = jn((n) => {
  const e = n.get(to);
  n.update(vd, (i) => ({
    ...i,
    editable: i.editable ?? (() => !0)
  }));
  const t = new gn("MILKDOWN_CLIPBOARD");
  return new mn({
    key: t,
    props: {
      handlePaste: (i, s) => {
        var x, M;
        const o = n.get(yd), a = (M = (x = i.props).editable) == null ? void 0 : M.call(x, i.state), { clipboardData: l } = s;
        if (!a || !l || i.state.selection.$from.node().type.spec.code) return !1;
        const u = l.getData("text/plain"), h = l.getData("vscode-editor-data");
        if (h) {
          const T = JSON.parse(h), E = T == null ? void 0 : T.mode;
          if (u && E) {
            const { tr: C } = i.state, O = j$("code_block", e);
            return C.replaceSelectionWith(O.create({ language: E })).setSelection(
              Ye.near(
                C.doc.resolve(Math.max(0, C.selection.from - 2))
              )
            ).insertText(u.replace(/\r\n?/g, `
`)), i.dispatch(C), !0;
          }
        }
        const f = l.getData("text/html");
        if (f.length === 0 && u.length === 0) return !1;
        const m = R1.fromSchema(e);
        let y;
        if (f.length === 0) {
          const T = o(u);
          if (!T || typeof T == "string") return !1;
          y = Bc.fromSchema(e).serializeFragment(
            T.content
          );
        } else {
          const T = document.createElement("template");
          T.innerHTML = f, y = T.content.cloneNode(!0), T.remove();
        }
        const b = m.parseSlice(y), k = q$(b);
        return k ? (i.dispatch(i.state.tr.replaceSelectionWith(k, !0)), !0) : (i.dispatch(i.state.tr.replaceSelection(b)), !0);
      },
      clipboardTextSerializer: (i) => {
        const s = n.get(Cu);
        if (iw(i.content.toJSON()))
          return i.content.textBetween(
            0,
            i.content.size,
            `

`
          );
        const a = e.topNodeType.createAndFill(void 0, i.content);
        return a ? s(a) : "";
      }
    }
  });
});
XN.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};
function $h(n, e) {
  return Object.assign(n, {
    meta: {
      package: "@milkdown/plugin-history",
      ...e
    }
  }), n;
}
const x6 = ct("Undo", () => () => Sy);
$h(x6, {
  displayName: "Command<undo>"
});
const S6 = ct("Redo", () => () => bh);
$h(S6, {
  displayName: "Command<redo>"
});
const C6 = Wt({}, "historyProviderConfig");
$h(C6, {
  displayName: "Ctx<historyProviderConfig>"
});
const ZN = jn(
  (n) => dne(n.get(C6.key))
);
$h(ZN, {
  displayName: "Ctx<historyProviderPlugin>"
});
const M6 = ai("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (n) => {
      const e = n.get(je);
      return () => e.call(x6.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (n) => {
      const e = n.get(je);
      return () => e.call(S6.key);
    }
  }
});
$h(M6.ctx, {
  displayName: "KeymapCtx<history>"
});
$h(M6.shortcuts, {
  displayName: "Keymap<history>"
});
const yle = [
  C6,
  ZN,
  M6,
  x6,
  S6
].flat();
function ble(n, e) {
  const { doc: t, selection: r } = n;
  if (!t || !r || !(r instanceof Ye || r instanceof ni))
    return n;
  const { to: i } = r, s = e.type === "space" ? Array(e.size).fill(" ").join("") : "	";
  return n.insertText(s, i);
}
const Fy = Wt(
  { type: "space", size: 2 },
  "indentConfig"
);
Fy.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
const QN = GE((n) => ({
  Tab: (e, t) => {
    const r = n.get(Fy.key), { tr: i } = e, s = ble(i, r);
    return s.docChanged ? (t == null || t(s), !0) : !1;
  }
}));
QN.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
const vle = [Fy, QN];
class eI {
  constructor() {
    this.beforeMountedListeners = [], this.mountedListeners = [], this.updatedListeners = [], this.selectionUpdatedListeners = [], this.markdownUpdatedListeners = [], this.blurListeners = [], this.focusListeners = [], this.destroyListeners = [], this.beforeMount = (e) => (this.beforeMountedListeners.push(e), this), this.mounted = (e) => (this.mountedListeners.push(e), this), this.updated = (e) => (this.updatedListeners.push(e), this);
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners,
      selectionUpdated: this.selectionUpdatedListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(e) {
    return this.markdownUpdatedListeners.push(e), this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(e) {
    return this.blurListeners.push(e), this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(e) {
    return this.focusListeners.push(e), this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(e) {
    return this.destroyListeners.push(e), this;
  }
  /// Subscribe to the selectionUpdated event.
  /// This event will be triggered when the editor selection is updated.
  selectionUpdated(e) {
    return this.selectionUpdatedListeners.push(e), this;
  }
}
const y1 = It(
  new eI(),
  "listener"
), wle = new gn("MILKDOWN_LISTENER"), tI = (n) => (n.inject(y1, new eI()), async () => {
  await n.wait(yc);
  const e = n.get(y1), { listeners: t } = e;
  t.beforeMount.forEach((l) => l(n)), await n.wait(bd);
  const r = n.get(Cu);
  let i = null, s = null, o = null;
  const a = new mn({
    key: wle,
    view: () => ({
      destroy: () => {
        t.destroy.forEach((l) => l(n));
      }
    }),
    props: {
      handleDOMEvents: {
        focus: () => (t.focus.forEach((l) => l(n)), !1),
        blur: () => (t.blur.forEach((l) => l(n)), !1)
      }
    },
    state: {
      init: (l, c) => {
        i = c.doc, s = r(c.doc);
      },
      apply: (l) => {
        const c = l.selection;
        return (!o && c || o && !c.eq(o)) && (t.selectionUpdated.forEach((h) => {
          h(n, c, o);
        }), o = c), !l.docChanged || l.getMeta("addToHistory") === !1 ? void 0 : M1(() => {
          const { doc: h } = l;
          if (t.updated.length > 0 && i && !i.eq(h) && t.updated.forEach((f) => {
            f(n, h, i);
          }), t.markdownUpdated.length > 0 && i && !i.eq(h)) {
            const f = r(h);
            t.markdownUpdated.forEach((m) => {
              m(n, f, s);
            }), s = f;
          }
          i = h;
        }, 200)();
      }
    }
  });
  n.update(ol, (l) => l.concat(a)), await n.wait(Ym), t.mounted.forEach((l) => l(n));
});
tI.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};
const T6 = Wt(
  {
    shouldAppend: (n) => !(!n || ["heading", "paragraph"].includes(n.type.name)),
    getNode: (n) => n.schema.nodes.paragraph.create()
  },
  "trailingConfig"
);
T6.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
const nI = jn((n) => {
  const e = new gn("MILKDOWN_TRAILING"), { shouldAppend: t, getNode: r } = n.get(T6.key), i = new mn({
    key: e,
    state: {
      init: (s, o) => {
        const a = o.tr.doc.lastChild;
        return t(a, o);
      },
      apply: (s, o, a, l) => {
        if (!s.docChanged) return o;
        const c = s.doc.lastChild;
        return t(c, l);
      }
    },
    appendTransaction: (s, o, a) => {
      const { doc: l, tr: c } = a, u = r == null ? void 0 : r(a), h = i.getState(a), f = l.content.size;
      if (!(!h || !u))
        return c.insert(f, u);
    }
  });
  return i;
});
nI.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
const kle = [T6, nI];
var Jt = /* @__PURE__ */ ((n) => (n.CodeMirror = "code-mirror", n.ListItem = "list-item", n.LinkTooltip = "link-tooltip", n.Cursor = "cursor", n.ImageBlock = "image-block", n.BlockEdit = "block-edit", n.Toolbar = "toolbar", n.Placeholder = "placeholder", n.Table = "table", n.Latex = "latex", n))(Jt || {});
const xle = {
  cursor: !0,
  "list-item": !0,
  "link-tooltip": !0,
  "image-block": !0,
  "block-edit": !0,
  placeholder: !0,
  toolbar: !0,
  "code-mirror": !0,
  table: !0,
  latex: !0
}, Sle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM8.25 16.625C8.0375 16.625 7.85942 16.5531 7.71575 16.4093C7.57192 16.2654 7.5 16.0872 7.5 15.8748C7.5 15.6621 7.57192 15.484 7.71575 15.3405C7.85942 15.1968 8.0375 15.125 8.25 15.125H15.75C15.9625 15.125 16.1406 15.1969 16.2843 15.3408C16.4281 15.4846 16.5 15.6628 16.5 15.8753C16.5 16.0879 16.4281 16.266 16.2843 16.4095C16.1406 16.5532 15.9625 16.625 15.75 16.625H8.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM8.25 8.875C8.0375 8.875 7.85942 8.80308 7.71575 8.65925C7.57192 8.51542 7.5 8.33725 7.5 8.12475C7.5 7.91208 7.57192 7.734 7.71575 7.5905C7.85942 7.44683 8.0375 7.375 8.25 7.375H15.75C15.9625 7.375 16.1406 7.44692 16.2843 7.59075C16.4281 7.73458 16.5 7.91275 16.5 8.12525C16.5 8.33792 16.4281 8.516 16.2843 8.6595C16.1406 8.80317 15.9625 8.875 15.75 8.875H8.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, Cle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25ZM4.25 16.625C4.0375 16.625 3.85942 16.5531 3.71575 16.4093C3.57192 16.2654 3.5 16.0872 3.5 15.8748C3.5 15.6621 3.57192 15.484 3.71575 15.3405C3.85942 15.1968 4.0375 15.125 4.25 15.125H13.75C13.9625 15.125 14.1406 15.1969 14.2843 15.3408C14.4281 15.4846 14.5 15.6628 14.5 15.8753C14.5 16.0879 14.4281 16.266 14.2843 16.4095C14.1406 16.5532 13.9625 16.625 13.75 16.625H4.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM4.25 8.875C4.0375 8.875 3.85942 8.80308 3.71575 8.65925C3.57192 8.51542 3.5 8.33725 3.5 8.12475C3.5 7.91208 3.57192 7.734 3.71575 7.5905C3.85942 7.44683 4.0375 7.375 4.25 7.375H13.75C13.9625 7.375 14.1406 7.44692 14.2843 7.59075C14.4281 7.73458 14.5 7.91275 14.5 8.12525C14.5 8.33792 14.4281 8.516 14.2843 8.6595C14.1406 8.80317 13.9625 8.875 13.75 8.875H4.25ZM4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25Z"
    />
  </svg>
`, Mle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M4.25 5C4.0375 5 3.85942 4.92808 3.71575 4.78425C3.57192 4.64042 3.5 4.46225 3.5 4.24975C3.5 4.03708 3.57192 3.859 3.71575 3.7155C3.85942 3.57183 4.0375 3.5 4.25 3.5H19.75C19.9625 3.5 20.1406 3.57192 20.2843 3.71575C20.4281 3.85958 20.5 4.03775 20.5 4.25025C20.5 4.46292 20.4281 4.641 20.2843 4.7845C20.1406 4.92817 19.9625 5 19.75 5H4.25ZM10.25 8.875C10.0375 8.875 9.85942 8.80308 9.71575 8.65925C9.57192 8.51542 9.5 8.33725 9.5 8.12475C9.5 7.91208 9.57192 7.734 9.71575 7.5905C9.85942 7.44683 10.0375 7.375 10.25 7.375H19.75C19.9625 7.375 20.1406 7.44692 20.2843 7.59075C20.4281 7.73458 20.5 7.91275 20.5 8.12525C20.5 8.33792 20.4281 8.516 20.2843 8.6595C20.1406 8.80317 19.9625 8.875 19.75 8.875H10.25ZM4.25 12.75C4.0375 12.75 3.85942 12.6781 3.71575 12.5343C3.57192 12.3904 3.5 12.2122 3.5 11.9998C3.5 11.7871 3.57192 11.609 3.71575 11.4655C3.85942 11.3218 4.0375 11.25 4.25 11.25H19.75C19.9625 11.25 20.1406 11.3219 20.2843 11.4658C20.4281 11.6096 20.5 11.7878 20.5 12.0003C20.5 12.2129 20.4281 12.391 20.2843 12.5345C20.1406 12.6782 19.9625 12.75 19.75 12.75H4.25ZM10.25 16.625C10.0375 16.625 9.85942 16.5531 9.71575 16.4093C9.57192 16.2654 9.5 16.0872 9.5 15.8748C9.5 15.6621 9.57192 15.484 9.71575 15.3405C9.85942 15.1968 10.0375 15.125 10.25 15.125H19.75C19.9625 15.125 20.1406 15.1969 20.2843 15.3408C20.4281 15.4846 20.5 15.6628 20.5 15.8753C20.5 16.0879 20.4281 16.266 20.2843 16.4095C20.1406 16.5532 19.9625 16.625 19.75 16.625H10.25ZM4.25 20.5C4.0375 20.5 3.85942 20.4281 3.71575 20.2843C3.57192 20.1404 3.5 19.9622 3.5 19.7498C3.5 19.5371 3.57192 19.359 3.71575 19.2155C3.85942 19.0718 4.0375 19 4.25 19H19.75C19.9625 19 20.1406 19.0719 20.2843 19.2158C20.4281 19.3596 20.5 19.5378 20.5 19.7502C20.5 19.9629 20.4281 20.141 20.2843 20.2845C20.1406 20.4282 19.9625 20.5 19.75 20.5H4.25Z"
    />
  </svg>
`, Tle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M8.85758 18.625C8.4358 18.625 8.07715 18.4772 7.78163 18.1817C7.48613 17.8862 7.33838 17.5275 7.33838 17.1058V6.8942C7.33838 6.47242 7.48613 6.11377 7.78163 5.81825C8.07715 5.52275 8.4358 5.375 8.85758 5.375H12.1999C13.2191 5.375 14.1406 5.69231 14.9643 6.32693C15.788 6.96154 16.1999 7.81603 16.1999 8.89038C16.1999 9.63779 16.0194 10.2471 15.6585 10.7183C15.2976 11.1894 14.9088 11.5314 14.4922 11.7442C15.005 11.9211 15.4947 12.2708 15.9614 12.7933C16.428 13.3157 16.6614 14.0192 16.6614 14.9038C16.6614 16.182 16.1902 17.1217 15.2479 17.723C14.3056 18.3243 13.3563 18.625 12.3999 18.625H8.85758ZM9.4883 16.6327H12.3191C13.1063 16.6327 13.6627 16.4141 13.9884 15.9769C14.314 15.5397 14.4768 15.1205 14.4768 14.7192C14.4768 14.3179 14.314 13.8987 13.9884 13.4615C13.6627 13.0243 13.0909 12.8057 12.273 12.8057H9.4883V16.6327ZM9.4883 10.875H12.0826C12.6903 10.875 13.172 10.7013 13.5278 10.3539C13.8836 10.0064 14.0615 9.59037 14.0615 9.10575C14.0615 8.59035 13.8733 8.16918 13.497 7.84225C13.1207 7.51533 12.6595 7.35188 12.1133 7.35188H9.4883V10.875Z"
    />
  </svg>
`, Ale = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_952_6527)">
      <circle cx="12" cy="12" r="3" />
    </g>
    <defs>
      <clipPath id="clip0_952_6527">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ele = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8070)">
      <path
        d="M4 10.5C3.17 10.5 2.5 11.17 2.5 12C2.5 12.83 3.17 13.5 4 13.5C4.83 13.5 5.5 12.83 5.5 12C5.5 11.17 4.83 10.5 4 10.5ZM4 4.5C3.17 4.5 2.5 5.17 2.5 6C2.5 6.83 3.17 7.5 4 7.5C4.83 7.5 5.5 6.83 5.5 6C5.5 5.17 4.83 4.5 4 4.5ZM4 16.5C3.17 16.5 2.5 17.18 2.5 18C2.5 18.82 3.18 19.5 4 19.5C4.82 19.5 5.5 18.82 5.5 18C5.5 17.18 4.83 16.5 4 16.5ZM8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19ZM8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13ZM7 6C7 6.55 7.45 7 8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8070">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Lle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M9 22a1 1 0 0 1-1-1v-3H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6.1l-3.7 3.71c-.2.19-.45.29-.7.29zm1-6v3.08L13.08 16H20V4H4v12z"
    />
  </svg>
`, Ole = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_1151)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM10.71 16.29C10.32 16.68 9.69 16.68 9.3 16.29L5.71 12.7C5.32 12.31 5.32 11.68 5.71 11.29C6.1 10.9 6.73 10.9 7.12 11.29L10 14.17L16.88 7.29C17.27 6.9 17.9 6.9 18.29 7.29C18.68 7.68 18.68 8.31 18.29 8.7L10.71 16.29Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_1151">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Dle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1803_535)">
      <path
        d="M18 19H6C5.45 19 5 18.55 5 18V6C5 5.45 5.45 5 6 5H18C18.55 5 19 5.45 19 6V18C19 18.55 18.55 19 18 19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1803_535">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, rI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M19.5 8.25l-7.5 7.5-7.5-7.5"
    />
  </svg>
`, iI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1098_15553)">
      <path
        d="M18.3007 5.70973C17.9107 5.31973 17.2807 5.31973 16.8907 5.70973L12.0007 10.5897L7.1107 5.69973C6.7207 5.30973 6.0907 5.30973 5.7007 5.69973C5.3107 6.08973 5.3107 6.71973 5.7007 7.10973L10.5907 11.9997L5.7007 16.8897C5.3107 17.2797 5.3107 17.9097 5.7007 18.2997C6.0907 18.6897 6.7207 18.6897 7.1107 18.2997L12.0007 13.4097L16.8907 18.2997C17.2807 18.6897 17.9107 18.6897 18.3007 18.2997C18.6907 17.9097 18.6907 17.2797 18.3007 16.8897L13.4107 11.9997L18.3007 7.10973C18.6807 6.72973 18.6807 6.08973 18.3007 5.70973Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1098_15553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, sI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8081)">
      <path
        d="M9.4 16.6L4.8 12L9.4 7.4L8 6L2 12L8 18L9.4 16.6ZM14.6 16.6L19.2 12L14.6 7.4L16 6L22 12L16 18L14.6 16.6Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8081">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, A6 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
    fill="none"
  >
    <g clip-path="url(#clip0_1013_1606)">
      <path
        d="M9.00012 16.1998L5.50012 12.6998C5.11012 12.3098 4.49012 12.3098 4.10012 12.6998C3.71012 13.0898 3.71012 13.7098 4.10012 14.0998L8.29012 18.2898C8.68012 18.6798 9.31012 18.6798 9.70012 18.2898L20.3001 7.69982C20.6901 7.30982 20.6901 6.68982 20.3001 6.29982C19.9101 5.90982 19.2901 5.90982 18.9001 6.29982L9.00012 16.1998Z"
        fill="#817567"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1606">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, oI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
    fill="none"
  >
    <path
      d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240H360Zm0-80h360v-480H360v480ZM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80H200Zm160-240v-480 480Z"
    />
  </svg>
`, Nle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7900)">
      <path
        fill-rule="evenodd"
        clip-rule="evenodd"
        d="M19 13H5C4.45 13 4 12.55 4 12C4 11.45 4.45 11 5 11H19C19.55 11 20 11.45 20 12C20 12.55 19.55 13 19 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7900">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, jC = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="16"
    height="16"
    viewBox="0 0 16 16"
  >
    <path
      d="M3.5 9.83366C3.35833 9.83366 3.23961 9.78571 3.14383 9.68983C3.04794 9.59394 3 9.47516 3 9.33349C3 9.19171 3.04794 9.07299 3.14383 8.97733C3.23961 8.88155 3.35833 8.83366 3.5 8.83366H12.5C12.6417 8.83366 12.7604 8.8816 12.8562 8.97749C12.9521 9.07338 13 9.19216 13 9.33383C13 9.4756 12.9521 9.59433 12.8562 9.68999C12.7604 9.78577 12.6417 9.83366 12.5 9.83366H3.5ZM3.5 7.16699C3.35833 7.16699 3.23961 7.11905 3.14383 7.02316C3.04794 6.92727 3 6.80849 3 6.66683C3 6.52505 3.04794 6.40633 3.14383 6.31066C3.23961 6.21488 3.35833 6.16699 3.5 6.16699H12.5C12.6417 6.16699 12.7604 6.21494 12.8562 6.31083C12.9521 6.40671 13 6.52549 13 6.66716C13 6.80894 12.9521 6.92766 12.8562 7.02333C12.7604 7.1191 12.6417 7.16699 12.5 7.16699H3.5Z"
    />
  </svg>
`, E6 = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_1013_1585)">
      <path
        d="M14.06 9.02L14.98 9.94L5.92 19H5V18.08L14.06 9.02ZM17.66 3C17.41 3 17.15 3.1 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C18.17 3.09 17.92 3 17.66 3ZM14.06 6.19L3 17.25V21H6.75L17.81 9.94L14.06 6.19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_1013_1585">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ile = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5553)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM12 17H14V7H10V9H12V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5553">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, _le = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5559)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15H11V13H13C14.1 13 15 12.11 15 11V9C15 7.89 14.1 7 13 7H9V9H13V11H11C9.9 11 9 11.89 9 13V17H15V15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5559">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Rle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5565)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13.5C15 12.67 14.33 12 13.5 12C14.33 12 15 11.33 15 10.5V9C15 7.89 14.1 7 13 7H9V9H13V11H11V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5565">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ple = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7757)">
      <path
        d="M19.04 3H5.04004C3.94004 3 3.04004 3.9 3.04004 5V19C3.04004 20.1 3.94004 21 5.04004 21H19.04C20.14 21 21.04 20.1 21.04 19V5C21.04 3.9 20.14 3 19.04 3ZM19.04 19H5.04004V5H19.04V19ZM13.04 17H15.04V7H13.04V11H11.04V7H9.04004V13H13.04V17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7757">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ble = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7760)">
      <path
        d="M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19ZM15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H9V13H13V15H9V17H13C14.1 17 15 16.11 15 15Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7760">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Hle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7763)">
      <path
        d="M11 17H13C14.1 17 15 16.11 15 15V13C15 11.89 14.1 11 13 11H11V9H15V7H11C9.9 7 9 7.89 9 9V15C9 16.11 9.9 17 11 17ZM11 13H13V15H11V13ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V5H19V19Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7763">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, sw = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8075)">
      <path
        d="M19 5V19H5V5H19ZM19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14.14 11.86L11.14 15.73L9 13.14L6 17H18L14.14 11.86Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8075">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, zle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M6.29811 18.625C6.04505 18.625 5.83115 18.5375 5.65641 18.3626C5.48166 18.1877 5.39429 17.9736 5.39429 17.7203C5.39429 17.467 5.48166 17.2532 5.65641 17.0788C5.83115 16.9045 6.04505 16.8173 6.29811 16.8173H9.21159L12.452 7.18265H9.53851C9.28545 7.18265 9.07155 7.0952 8.89681 6.9203C8.72206 6.7454 8.63469 6.5313 8.63469 6.278C8.63469 6.02472 8.72206 5.81089 8.89681 5.63652C9.07155 5.46217 9.28545 5.375 9.53851 5.375H16.8847C17.1377 5.375 17.3516 5.46245 17.5264 5.63735C17.7011 5.81225 17.7885 6.02634 17.7885 6.27962C17.7885 6.53293 17.7011 6.74676 17.5264 6.92113C17.3516 7.09548 17.1377 7.18265 16.8847 7.18265H14.2789L11.0385 16.8173H13.6443C13.8973 16.8173 14.1112 16.9048 14.286 17.0797C14.4607 17.2546 14.5481 17.4687 14.5481 17.722C14.5481 17.9752 14.4607 18.1891 14.286 18.3634C14.1112 18.5378 13.8973 18.625 13.6443 18.625H6.29811Z"
    />
  </svg>
`, Fle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M17.0385 19.5003V16.5388H14.0769V15.0388H17.0385V12.0773H18.5384V15.0388H21.5V16.5388H18.5384V19.5003H17.0385ZM10.8077 16.5388H7.03845C5.78282 16.5388 4.7125 16.0963 3.8275 15.2114C2.9425 14.3266 2.5 13.2564 2.5 12.0009C2.5 10.7454 2.9425 9.67504 3.8275 8.78979C4.7125 7.90454 5.78282 7.46191 7.03845 7.46191H10.8077V8.96186H7.03845C6.1987 8.96186 5.48235 9.25834 4.8894 9.85129C4.29645 10.4442 3.99998 11.1606 3.99998 12.0003C3.99998 12.8401 4.29645 13.5564 4.8894 14.1494C5.48235 14.7423 6.1987 15.0388 7.03845 15.0388H10.8077V16.5388ZM8.25 12.7503V11.2504H15.75V12.7503H8.25ZM21.5 12.0003H20C20 11.1606 19.7035 10.4442 19.1106 9.85129C18.5176 9.25834 17.8013 8.96186 16.9615 8.96186H13.1923V7.46191H16.9615C18.2171 7.46191 19.2875 7.90441 20.1725 8.78939C21.0575 9.67439 21.5 10.7447 21.5 12.0003Z"
    />
  </svg>
`, Vle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7680)">
      <path
        d="M11 18C11 19.1 10.1 20 9 20C7.9 20 7 19.1 7 18C7 16.9 7.9 16 9 16C10.1 16 11 16.9 11 18ZM9 10C7.9 10 7 10.9 7 12C7 13.1 7.9 14 9 14C10.1 14 11 13.1 11 12C11 10.9 10.1 10 9 10ZM9 4C7.9 4 7 4.9 7 6C7 7.1 7.9 8 9 8C10.1 8 11 7.1 11 6C11 4.9 10.1 4 9 4ZM15 8C16.1 8 17 7.1 17 6C17 4.9 16.1 4 15 4C13.9 4 13 4.9 13 6C13 7.1 13.9 8 15 8ZM15 10C13.9 10 13 10.9 13 12C13 13.1 13.9 14 15 14C16.1 14 17 13.1 17 12C17 10.9 16.1 10 15 10ZM15 16C13.9 16 13 16.9 13 18C13 19.1 13.9 20 15 20C16.1 20 17 19.1 17 18C17 16.9 16.1 16 15 16Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7680">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, qle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8067)">
      <path
        d="M8 7H20C20.55 7 21 6.55 21 6C21 5.45 20.55 5 20 5H8C7.45 5 7 5.45 7 6C7 6.55 7.45 7 8 7ZM20 17H8C7.45 17 7 17.45 7 18C7 18.55 7.45 19 8 19H20C20.55 19 21 18.55 21 18C21 17.45 20.55 17 20 17ZM20 11H8C7.45 11 7 11.45 7 12C7 12.55 7.45 13 8 13H20C20.55 13 21 12.55 21 12C21 11.45 20.55 11 20 11ZM4.5 16H2.5C2.22 16 2 16.22 2 16.5C2 16.78 2.22 17 2.5 17H4V17.5H3.5C3.22 17.5 3 17.72 3 18C3 18.28 3.22 18.5 3.5 18.5H4V19H2.5C2.22 19 2 19.22 2 19.5C2 19.78 2.22 20 2.5 20H4.5C4.78 20 5 19.78 5 19.5V16.5C5 16.22 4.78 16 4.5 16ZM2.5 5H3V7.5C3 7.78 3.22 8 3.5 8C3.78 8 4 7.78 4 7.5V4.5C4 4.22 3.78 4 3.5 4H2.5C2.22 4 2 4.22 2 4.5C2 4.78 2.22 5 2.5 5ZM4.5 10H2.5C2.22 10 2 10.22 2 10.5C2 10.78 2.22 11 2.5 11H3.8L2.12 12.96C2.04 13.05 2 13.17 2 13.28V13.5C2 13.78 2.22 14 2.5 14H4.5C4.78 14 5 13.78 5 13.5C5 13.22 4.78 13 4.5 13H3.2L4.88 11.04C4.96 10.95 5 10.83 5 10.72V10.5C5 10.22 4.78 10 4.5 10Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8067">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, ow = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_971_7676)">
      <path
        d="M18 13H13V18C13 18.55 12.55 19 12 19C11.45 19 11 18.55 11 18V13H6C5.45 13 5 12.55 5 12C5 11.45 5.45 11 6 11H11V6C11 5.45 11.45 5 12 5C12.55 5 13 5.45 13 6V11H18C18.55 11 19 11.45 19 12C19 12.55 18.55 13 18 13Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_971_7676">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, $le = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_7897)">
      <path
        d="M7.17 17C7.68 17 8.15 16.71 8.37 16.26L9.79 13.42C9.93 13.14 10 12.84 10 12.53V8C10 7.45 9.55 7 9 7H5C4.45 7 4 7.45 4 8V12C4 12.55 4.45 13 5 13H7L5.97 15.06C5.52 15.95 6.17 17 7.17 17ZM17.17 17C17.68 17 18.15 16.71 18.37 16.26L19.79 13.42C19.93 13.14 20 12.84 20 12.53V8C20 7.45 19.55 7 19 7H15C14.45 7 14 7.45 14 8V12C14 12.55 14.45 13 15 13H17L15.97 15.06C15.52 15.95 16.17 17 17.17 17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_7897">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, aw = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M7.30775 20.4997C6.81058 20.4997 6.385 20.3227 6.031 19.9687C5.677 19.6147 5.5 19.1892 5.5 18.692V5.99973H5.25C5.0375 5.99973 4.85942 5.92782 4.71575 5.78398C4.57192 5.64015 4.5 5.46198 4.5 5.24948C4.5 5.03682 4.57192 4.85873 4.71575 4.71523C4.85942 4.57157 5.0375 4.49973 5.25 4.49973H9C9 4.2549 9.08625 4.04624 9.25875 3.87374C9.43108 3.7014 9.63967 3.61523 9.8845 3.61523H14.1155C14.3603 3.61523 14.5689 3.7014 14.7413 3.87374C14.9138 4.04624 15 4.2549 15 4.49973H18.75C18.9625 4.49973 19.1406 4.57165 19.2843 4.71548C19.4281 4.85932 19.5 5.03748 19.5 5.24998C19.5 5.46265 19.4281 5.64073 19.2843 5.78423C19.1406 5.9279 18.9625 5.99973 18.75 5.99973H18.5V18.692C18.5 19.1892 18.323 19.6147 17.969 19.9687C17.615 20.3227 17.1894 20.4997 16.6923 20.4997H7.30775ZM17 5.99973H7V18.692C7 18.7818 7.02883 18.8556 7.0865 18.9132C7.14417 18.9709 7.21792 18.9997 7.30775 18.9997H16.6923C16.7821 18.9997 16.8558 18.9709 16.9135 18.9132C16.9712 18.8556 17 18.7818 17 18.692V5.99973ZM10.1543 16.9997C10.3668 16.9997 10.5448 16.9279 10.6885 16.7842C10.832 16.6404 10.9037 16.4622 10.9037 16.2497V8.74973C10.9037 8.53723 10.8318 8.35907 10.688 8.21523C10.5443 8.07157 10.3662 7.99973 10.1535 7.99973C9.941 7.99973 9.76292 8.07157 9.61925 8.21523C9.47575 8.35907 9.404 8.53723 9.404 8.74973V16.2497C9.404 16.4622 9.47583 16.6404 9.6195 16.7842C9.76333 16.9279 9.94158 16.9997 10.1543 16.9997ZM13.8465 16.9997C14.059 16.9997 14.2371 16.9279 14.3807 16.7842C14.5243 16.6404 14.596 16.4622 14.596 16.2497V8.74973C14.596 8.53723 14.5242 8.35907 14.3805 8.21523C14.2367 8.07157 14.0584 7.99973 13.8458 7.99973C13.6333 7.99973 13.4552 8.07157 13.3115 8.21523C13.168 8.35907 13.0962 8.53723 13.0962 8.74973V16.2497C13.0962 16.4622 13.1682 16.6404 13.312 16.7842C13.4557 16.9279 13.6338 16.9997 13.8465 16.9997Z"
    />
  </svg>
`, aI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    fill="none"
    viewBox="0 0 24 24"
    stroke-width="1.5"
    stroke="currentColor"
    class="w-6 h-6"
  >
    <path
      stroke-linecap="round"
      stroke-linejoin="round"
      d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z"
    />
  </svg>
`, jle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M3.25 13.7404C3.0375 13.7404 2.85938 13.6684 2.71563 13.5246C2.57188 13.3808 2.5 13.2026 2.5 12.99C2.5 12.7774 2.57188 12.5993 2.71563 12.4558C2.85938 12.3122 3.0375 12.2404 3.25 12.2404H20.75C20.9625 12.2404 21.1406 12.3123 21.2843 12.4561C21.4281 12.5999 21.5 12.7781 21.5 12.9907C21.5 13.2033 21.4281 13.3814 21.2843 13.525C21.1406 13.6686 20.9625 13.7404 20.75 13.7404H3.25ZM10.9423 10.2596V6.62495H6.5673C6.2735 6.62495 6.02377 6.52201 5.8181 6.31613C5.61245 6.11026 5.50963 5.86027 5.50963 5.56615C5.50963 5.27205 5.61245 5.02083 5.8181 4.8125C6.02377 4.60417 6.2735 4.5 6.5673 4.5H17.4423C17.7361 4.5 17.9858 4.60294 18.1915 4.80883C18.3971 5.01471 18.5 5.2647 18.5 5.5588C18.5 5.85292 18.3971 6.10413 18.1915 6.31245C17.9858 6.52078 17.7361 6.62495 17.4423 6.62495H13.0673V10.2596H10.9423ZM10.9423 15.7211H13.0673V18.4423C13.0673 18.7361 12.9643 18.9858 12.7584 19.1915C12.5526 19.3971 12.3026 19.5 12.0085 19.5C11.7144 19.5 11.4631 19.3962 11.2548 19.1887C11.0465 18.9811 10.9423 18.7291 10.9423 18.4327V15.7211Z"
    />
  </svg>
`, Wle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_977_8078)">
      <path
        d="M20 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3ZM20 5V8H5V5H20ZM15 19H10V10H15V19ZM5 10H8V19H5V10ZM17 19V10H20V19H17Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_977_8078">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Ule = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <g clip-path="url(#clip0_992_5547)">
      <path
        d="M5 5.5C5 6.33 5.67 7 6.5 7H10.5V17.5C10.5 18.33 11.17 19 12 19C12.83 19 13.5 18.33 13.5 17.5V7H17.5C18.33 7 19 6.33 19 5.5C19 4.67 18.33 4 17.5 4H6.5C5.67 4 5 4.67 5 5.5Z"
      />
    </g>
    <defs>
      <clipPath id="clip0_992_5547">
        <rect width="24" height="24" />
      </clipPath>
    </defs>
  </svg>
`, Kle = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    viewBox="0 0 24 24"
  >
    <path
      d="M5.66936 16.3389L9.39244 12.6158C9.54115 12.4671 9.71679 12.3937 9.91936 12.3957C10.1219 12.3976 10.2975 12.4761 10.4463 12.6312C10.5847 12.7823 10.654 12.9585 10.654 13.1599C10.654 13.3613 10.5847 13.5363 10.4463 13.6851L6.32704 17.8197C6.14627 18.0004 5.93538 18.0908 5.69436 18.0908C5.45333 18.0908 5.24243 18.0004 5.06166 17.8197L3.01744 15.7754C2.87899 15.637 2.81136 15.4629 2.81456 15.2533C2.81776 15.0437 2.88859 14.8697 3.02706 14.7312C3.16551 14.5928 3.34008 14.5235 3.55076 14.5235C3.76144 14.5235 3.93494 14.5928 4.07126 14.7312L5.66936 16.3389ZM5.66936 8.72359L9.39244 5.00049C9.54115 4.85177 9.71679 4.77838 9.91936 4.78031C10.1219 4.78223 10.2975 4.86075 10.4463 5.01586C10.5847 5.16691 10.654 5.34314 10.654 5.54454C10.654 5.74592 10.5847 5.92097 10.4463 6.06969L6.32704 10.2043C6.14627 10.3851 5.93538 10.4755 5.69436 10.4755C5.45333 10.4755 5.24243 10.3851 5.06166 10.2043L3.01744 8.16009C2.87899 8.02162 2.81136 7.84759 2.81456 7.63799C2.81776 7.42837 2.88859 7.25433 3.02706 7.11586C3.16551 6.97741 3.34008 6.90819 3.55076 6.90819C3.76144 6.90819 3.93494 6.97741 4.07126 7.11586L5.66936 8.72359ZM13.7597 16.5581C13.5472 16.5581 13.3691 16.4862 13.2253 16.3424C13.0816 16.1986 13.0097 16.0204 13.0097 15.8078C13.0097 15.5952 13.0816 15.4171 13.2253 15.2735C13.3691 15.13 13.5472 15.0582 13.7597 15.0582H20.7597C20.9722 15.0582 21.1503 15.1301 21.2941 15.2739C21.4378 15.4177 21.5097 15.5959 21.5097 15.8085C21.5097 16.0211 21.4378 16.1992 21.2941 16.3427C21.1503 16.4863 20.9722 16.5581 20.7597 16.5581H13.7597ZM13.7597 8.94276C13.5472 8.94276 13.3691 8.87085 13.2253 8.72704C13.0816 8.58324 13.0097 8.40504 13.0097 8.19244C13.0097 7.97985 13.0816 7.80177 13.2253 7.65819C13.3691 7.5146 13.5472 7.44281 13.7597 7.44281H20.7597C20.9722 7.44281 21.1503 7.51471 21.2941 7.65851C21.4378 7.80233 21.5097 7.98053 21.5097 8.19311C21.5097 8.40571 21.4378 8.5838 21.2941 8.72739C21.1503 8.87097 20.9722 8.94276 20.7597 8.94276H13.7597Z"
    />
  </svg>
`, lI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="32"
    height="32"
    viewBox="0 0 24 24"
  >
    <path
      fill="currentColor"
      d="M7 19v-.808L13.096 12L7 5.808V5h10v1.25H9.102L14.727 12l-5.625 5.77H17V19z"
    />
  </svg>
`, cI = `
  <svg
    xmlns="http://www.w3.org/2000/svg"
    height="24px"
    viewBox="0 -960 960 960"
    width="24px"
  >
    <path
      d="m644-428-58-58q9-47-27-88t-93-32l-58-58q17-8 34.5-12t37.5-4q75 0 127.5 52.5T660-500q0 20-4 37.5T644-428Zm128 126-58-56q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-62-62q41-17 84-25.5t90-8.5q151 0 269 83.5T920-500q-23 59-60.5 109.5T772-302Zm20 246L624-222q-35 11-70.5 16.5T480-200q-151 0-269-83.5T40-500q21-53 53-98.5t73-81.5L56-792l56-56 736 736-56 56ZM222-624q-29 26-53 57t-41 67q50 101 143.5 160.5T480-280q20 0 39-2.5t39-5.5l-36-38q-11 3-21 4.5t-21 1.5q-75 0-127.5-52.5T300-500q0-11 1.5-21t4.5-21l-84-82Zm319 93Zm-151 75Z"
    />
  </svg>
`, Gle = {
  [Jt.CodeMirror]: {
    theme: pq,
    languages: rq,
    expandIcon: rI,
    searchIcon: aI,
    clearSearchIcon: iI,
    searchPlaceholder: "Search language",
    noResultText: "No result",
    previewToggleIcon: (n) => n ? E6 : cI
  }
}, Jle = It([], "FeaturesCtx"), Yle = It({}, "CrepeCtx");
function Xle(n) {
  return n.get("CrepeCtx");
}
function Vy(n) {
  return n.use("FeaturesCtx");
}
function go(n) {
  return (e) => {
    Vy(e).update((t) => t.includes(n) ? t : [...t, n]);
  };
}
function uI(n) {
  return n.$from.parent.type.name === "code_block";
}
function hI(n) {
  var e;
  const t = (e = n.$from.node(n.$from.depth - 1)) == null ? void 0 : e.type;
  return (t == null ? void 0 : t.name) === "list_item";
}
var fI = (n) => {
  throw TypeError(n);
}, dI = (n, e, t) => e.has(n) || fI("Cannot " + t), ff = (n, e, t) => (dI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), WC = (n, e, t) => e.has(n) ? fI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Zle = (n, e, t, r) => (dI(n, e, "write to private field"), e.set(n, t), t), fu, pg;
class pI {
  constructor() {
    WC(this, fu, []), this.clear = () => (Zle(this, fu, []), this), WC(this, pg, (e) => {
      const t = {
        group: e,
        addItem: (r, i) => {
          const s = { ...i, key: r };
          return e.items.push(s), t;
        },
        clear: () => (e.items = [], t)
      };
      return t;
    }), this.addGroup = (e, t) => {
      const i = {
        key: e,
        label: t,
        items: []
      };
      return ff(this, fu).push(i), ff(this, pg).call(this, i);
    }, this.getGroup = (e) => {
      const t = ff(this, fu).find((r) => r.key === e);
      if (!t) throw new Error(`Group with key ${e} not found`);
      return ff(this, pg).call(this, t);
    }, this.build = () => ff(this, fu);
  }
}
fu = /* @__PURE__ */ new WeakMap();
pg = /* @__PURE__ */ new WeakMap();
function Qle(n, e, t) {
  var r, i, s, o, a, l, c, u, h, f, m, y, b, k, x, M, T, E, C, O, R, F, H, z, K, U, ae, ie, he, Ie, Oe, Ne, We, q, Re, J, V, _t, at, mt, le, tt, xe, ge, Ot, Ee, Ft, ft, Vt, Ue, yt, Ut, Kt, ci, Ds, yo, Ns, mr, kt, ne, Ce, it, dt, Dt, Un, Kn, Cn, Mn, Dn, Tn, Gt, An, Pn, Is, ss, Mr, ir, _s, cn, as, Tr, Gn, ui, ba, kl, Wc, Tt, Ii, hi, xl, _i, bo, Ar, vo, wo, ko, xo, un, Ke, Y, be, Ve, qt, Nn, gt, Bn, Vr, Ri, So, En, Sl, Cl, dp, pp, Uc, Ml, mp, jh, Wh;
  const Co = t && Vy(t).get(), gp = Co == null ? void 0 : Co.includes(Jt.Latex), yp = Co == null ? void 0 : Co.includes(Jt.ImageBlock), Tl = Co == null ? void 0 : Co.includes(Jt.Table), Al = new pI();
  if ((e == null ? void 0 : e.textGroup) !== null) {
    const Nt = Al.addGroup(
      "text",
      (i = (r = e == null ? void 0 : e.textGroup) == null ? void 0 : r.label) != null ? i : "Text"
    );
    ((s = e == null ? void 0 : e.textGroup) == null ? void 0 : s.text) !== null && Nt.addItem("text", {
      label: (l = (a = (o = e == null ? void 0 : e.textGroup) == null ? void 0 : o.text) == null ? void 0 : a.label) != null ? l : "Text",
      icon: (h = (u = (c = e == null ? void 0 : e.textGroup) == null ? void 0 : c.text) == null ? void 0 : u.icon) != null ? h : Ule,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = uo.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt
        });
      }
    }), ((f = e == null ? void 0 : e.textGroup) == null ? void 0 : f.h1) !== null && Nt.addItem("h1", {
      label: (b = (y = (m = e == null ? void 0 : e.textGroup) == null ? void 0 : m.h1) == null ? void 0 : y.label) != null ? b : "Heading 1",
      icon: (M = (x = (k = e == null ? void 0 : e.textGroup) == null ? void 0 : k.h1) == null ? void 0 : x.icon) != null ? M : Ile,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = wi.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt,
          attrs: {
            level: 1
          }
        });
      }
    }), ((T = e == null ? void 0 : e.textGroup) == null ? void 0 : T.h2) !== null && Nt.addItem("h2", {
      label: (O = (C = (E = e == null ? void 0 : e.textGroup) == null ? void 0 : E.h2) == null ? void 0 : C.label) != null ? O : "Heading 2",
      icon: (H = (F = (R = e == null ? void 0 : e.textGroup) == null ? void 0 : R.h2) == null ? void 0 : F.icon) != null ? H : _le,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = wi.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt,
          attrs: {
            level: 2
          }
        });
      }
    }), ((z = e == null ? void 0 : e.textGroup) == null ? void 0 : z.h3) !== null && Nt.addItem("h3", {
      label: (ae = (U = (K = e == null ? void 0 : e.textGroup) == null ? void 0 : K.h3) == null ? void 0 : U.label) != null ? ae : "Heading 3",
      icon: (Ie = (he = (ie = e == null ? void 0 : e.textGroup) == null ? void 0 : ie.h3) == null ? void 0 : he.icon) != null ? Ie : Rle,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = wi.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt,
          attrs: {
            level: 3
          }
        });
      }
    }), ((Oe = e == null ? void 0 : e.textGroup) == null ? void 0 : Oe.h4) !== null && Nt.addItem("h4", {
      label: (q = (We = (Ne = e == null ? void 0 : e.textGroup) == null ? void 0 : Ne.h4) == null ? void 0 : We.label) != null ? q : "Heading 4",
      icon: (V = (J = (Re = e == null ? void 0 : e.textGroup) == null ? void 0 : Re.h4) == null ? void 0 : J.icon) != null ? V : Ple,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = wi.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt,
          attrs: {
            level: 4
          }
        });
      }
    }), ((_t = e == null ? void 0 : e.textGroup) == null ? void 0 : _t.h5) !== null && Nt.addItem("h5", {
      label: (le = (mt = (at = e == null ? void 0 : e.textGroup) == null ? void 0 : at.h5) == null ? void 0 : mt.label) != null ? le : "Heading 5",
      icon: (ge = (xe = (tt = e == null ? void 0 : e.textGroup) == null ? void 0 : tt.h5) == null ? void 0 : xe.icon) != null ? ge : Ble,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = wi.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt,
          attrs: {
            level: 5
          }
        });
      }
    }), ((Ot = e == null ? void 0 : e.textGroup) == null ? void 0 : Ot.h6) !== null && Nt.addItem("h6", {
      label: (ft = (Ft = (Ee = e == null ? void 0 : e.textGroup) == null ? void 0 : Ee.h6) == null ? void 0 : Ft.label) != null ? ft : "Heading 6",
      icon: (yt = (Ue = (Vt = e == null ? void 0 : e.textGroup) == null ? void 0 : Vt.h6) == null ? void 0 : Ue.icon) != null ? yt : Hle,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = wi.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt,
          attrs: {
            level: 6
          }
        });
      }
    }), ((Ut = e == null ? void 0 : e.textGroup) == null ? void 0 : Ut.quote) !== null && Nt.addItem("quote", {
      label: (Ds = (ci = (Kt = e == null ? void 0 : e.textGroup) == null ? void 0 : Kt.quote) == null ? void 0 : ci.label) != null ? Ds : "Quote",
      icon: (mr = (Ns = (yo = e == null ? void 0 : e.textGroup) == null ? void 0 : yo.quote) == null ? void 0 : Ns.icon) != null ? mr : $le,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = _h.type(Ge);
        Ze.call(or.key), Ze.call(Nf.key, {
          nodeType: Rt
        });
      }
    }), ((kt = e == null ? void 0 : e.textGroup) == null ? void 0 : kt.divider) !== null && Nt.addItem("divider", {
      label: (it = (Ce = (ne = e == null ? void 0 : e.textGroup) == null ? void 0 : ne.divider) == null ? void 0 : Ce.label) != null ? it : "Divider",
      icon: (Un = (Dt = (dt = e == null ? void 0 : e.textGroup) == null ? void 0 : dt.divider) == null ? void 0 : Dt.icon) != null ? Un : Nle,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = Rh.type(Ge);
        Ze.call(or.key), Ze.call(If.key, {
          nodeType: Rt
        });
      }
    });
  }
  if ((e == null ? void 0 : e.listGroup) !== null) {
    const Nt = Al.addGroup(
      "list",
      (Cn = (Kn = e == null ? void 0 : e.listGroup) == null ? void 0 : Kn.label) != null ? Cn : "List"
    );
    ((Mn = e == null ? void 0 : e.listGroup) == null ? void 0 : Mn.bulletList) !== null && Nt.addItem("bullet-list", {
      label: (Gt = (Tn = (Dn = e == null ? void 0 : e.listGroup) == null ? void 0 : Dn.bulletList) == null ? void 0 : Tn.label) != null ? Gt : "Bullet List",
      icon: (Is = (Pn = (An = e == null ? void 0 : e.listGroup) == null ? void 0 : An.bulletList) == null ? void 0 : Pn.icon) != null ? Is : Ele,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = Fc.type(Ge);
        Ze.call(or.key), Ze.call(Nf.key, {
          nodeType: Rt
        });
      }
    }), ((ss = e == null ? void 0 : e.listGroup) == null ? void 0 : ss.orderedList) !== null && Nt.addItem("ordered-list", {
      label: (_s = (ir = (Mr = e == null ? void 0 : e.listGroup) == null ? void 0 : Mr.orderedList) == null ? void 0 : ir.label) != null ? _s : "Ordered List",
      icon: (Tr = (as = (cn = e == null ? void 0 : e.listGroup) == null ? void 0 : cn.orderedList) == null ? void 0 : as.icon) != null ? Tr : qle,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = Vc.type(Ge);
        Ze.call(or.key), Ze.call(Nf.key, {
          nodeType: Rt
        });
      }
    }), ((Gn = e == null ? void 0 : e.listGroup) == null ? void 0 : Gn.taskList) !== null && Nt.addItem("task-list", {
      label: (kl = (ba = (ui = e == null ? void 0 : e.listGroup) == null ? void 0 : ui.taskList) == null ? void 0 : ba.label) != null ? kl : "Task List",
      icon: (Ii = (Tt = (Wc = e == null ? void 0 : e.listGroup) == null ? void 0 : Wc.taskList) == null ? void 0 : Tt.icon) != null ? Ii : Kle,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = As.type(Ge);
        Ze.call(or.key), Ze.call(Nf.key, {
          nodeType: Rt,
          attrs: { checked: !1 }
        });
      }
    });
  }
  if ((e == null ? void 0 : e.advancedGroup) !== null) {
    const Nt = Al.addGroup(
      "advanced",
      (xl = (hi = e == null ? void 0 : e.advancedGroup) == null ? void 0 : hi.label) != null ? xl : "Advanced"
    );
    ((_i = e == null ? void 0 : e.advancedGroup) == null ? void 0 : _i.image) !== null && yp && Nt.addItem("image", {
      label: (vo = (Ar = (bo = e == null ? void 0 : e.advancedGroup) == null ? void 0 : bo.image) == null ? void 0 : Ar.label) != null ? vo : "Image",
      icon: (xo = (ko = (wo = e == null ? void 0 : e.advancedGroup) == null ? void 0 : wo.image) == null ? void 0 : ko.icon) != null ? xo : sw,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = py.type(Ge);
        Ze.call(or.key), Ze.call(If.key, {
          nodeType: Rt
        });
      }
    }), ((un = e == null ? void 0 : e.advancedGroup) == null ? void 0 : un.codeBlock) !== null && Nt.addItem("code", {
      label: (be = (Y = (Ke = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Ke.codeBlock) == null ? void 0 : Y.label) != null ? be : "Code",
      icon: (Nn = (qt = (Ve = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Ve.codeBlock) == null ? void 0 : qt.icon) != null ? Nn : sI,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = ao.type(Ge);
        Ze.call(or.key), Ze.call(Do.key, {
          nodeType: Rt
        });
      }
    }), ((gt = e == null ? void 0 : e.advancedGroup) == null ? void 0 : gt.table) !== null && Tl && Nt.addItem("table", {
      label: (Ri = (Vr = (Bn = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Bn.table) == null ? void 0 : Vr.label) != null ? Ri : "Table",
      icon: (Sl = (En = (So = e == null ? void 0 : e.advancedGroup) == null ? void 0 : So.table) == null ? void 0 : En.icon) != null ? Sl : Wle,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = Ge.get(on);
        Ze.call(or.key);
        const { from: Kh } = Rt.state.selection;
        Ze.call(If.key, {
          nodeType: w3(Ge, 3, 3)
        }), Ze.call(LL.key, {
          pos: Kh
        });
      }
    }), ((Cl = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Cl.math) !== null && gp && Nt.addItem("math", {
      label: (Uc = (pp = (dp = e == null ? void 0 : e.advancedGroup) == null ? void 0 : dp.math) == null ? void 0 : pp.label) != null ? Uc : "Math",
      icon: (jh = (mp = (Ml = e == null ? void 0 : e.advancedGroup) == null ? void 0 : Ml.math) == null ? void 0 : mp.icon) != null ? jh : lI,
      onRun: (Ge) => {
        const Ze = Ge.get(je), Rt = ao.type(Ge);
        Ze.call(or.key), Ze.call(If.key, {
          nodeType: Rt,
          attrs: { language: "LaTex" }
        });
      }
    });
  }
  (Wh = e == null ? void 0 : e.buildMenu) == null || Wh.call(e, Al);
  let El = Al.build();
  n && (El = El.map((Nt) => {
    const Ge = Nt.items.filter(
      (Ze) => Ze.label.toLowerCase().includes(n.toLowerCase())
    );
    return {
      ...Nt,
      items: Ge
    };
  }).filter((Nt) => Nt.items.length > 0));
  const Uh = El.flatMap((Nt) => Nt.items);
  return Uh.forEach((Nt, Ge) => {
    Object.assign(Nt, { index: Ge });
  }), El.reduce((Nt, Ge) => {
    const Ze = Nt + Ge.items.length;
    return Object.assign(Ge, {
      range: [Nt, Ze]
    }), Ze;
  }, 0), {
    groups: El,
    size: Uh.length
  };
}
const ece = Xn({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    filter: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup({ ctx: n, show: e, filter: t, hide: r, config: i }) {
    const s = Be(), o = Qa(() => Qle(t.value, i, n)), a = Be(0), l = Be({ x: -999, y: -999 }), c = (b) => {
      const { x: k, y: x } = b;
      l.value = { x: k, y: x };
    };
    hw([o, e], () => {
      const { size: b } = o.value;
      b === 0 && e.value ? r() : a.value >= b && (a.value = 0);
    });
    const u = (b, k) => {
      const x = a.value, M = typeof b == "function" ? b(x) : b;
      k == null || k(M), a.value = M;
    }, h = (b) => {
      var k, x;
      const M = (k = s.value) == null ? void 0 : k.querySelector(
        `[data-index="${b}"]`
      ), T = (x = s.value) == null ? void 0 : x.querySelector(".menu-groups");
      !M || !T || (T.scrollTop = M.offsetTop - T.offsetTop);
    }, f = (b) => {
      const k = o.value.groups.flatMap((x) => x.items).at(b);
      k && n && k.onRun(n), r();
    }, m = (b) => {
      const { size: k, groups: x } = o.value;
      if (b.key === "Escape") {
        b.preventDefault(), r == null || r();
        return;
      }
      if (b.key === "ArrowDown")
        return b.preventDefault(), u(
          (M) => M < k - 1 ? M + 1 : M,
          h
        );
      if (b.key === "ArrowUp")
        return b.preventDefault(), u(
          (M) => M <= 0 ? M : M - 1,
          h
        );
      if (b.key === "ArrowLeft")
        return b.preventDefault(), u((M) => {
          const T = x.find(
            (C) => C.range[0] <= M && C.range[1] > M
          );
          if (!T) return M;
          const E = x[x.indexOf(T) - 1];
          return E ? E.range[1] - 1 : M;
        }, h);
      if (b.key === "ArrowRight")
        return b.preventDefault(), u((M) => {
          const T = x.find(
            (C) => C.range[0] <= M && C.range[1] > M
          );
          if (!T) return M;
          const E = x[x.indexOf(T) + 1];
          return E ? E.range[0] : M;
        }, h);
      b.key === "Enter" && (b.preventDefault(), f(a.value));
    }, y = (b) => (k) => {
      const x = l.value;
      if (!x) return;
      const { x: M, y: T } = k;
      M === x.x && T === x.y || u(b);
    };
    return Ch(() => {
      e.value ? window.addEventListener("keydown", m, { capture: !0 }) : window.removeEventListener("keydown", m, { capture: !0 });
    }), k1(() => {
      window.removeEventListener("keydown", m, { capture: !0 });
    }), () => /* @__PURE__ */ te("div", { ref: s, onPointerdown: (b) => b.preventDefault() }, /* @__PURE__ */ te("nav", { class: "tab-group" }, /* @__PURE__ */ te("ul", null, o.value.groups.map((b) => /* @__PURE__ */ te(
      "li",
      {
        key: b.key,
        onPointerdown: () => u(b.range[0], h),
        class: a.value >= b.range[0] && a.value < b.range[1] ? "selected" : ""
      },
      b.label
    )))), /* @__PURE__ */ te("div", { class: "menu-groups", onPointermove: c }, o.value.groups.map((b) => /* @__PURE__ */ te("div", { key: b.key, class: "menu-group" }, /* @__PURE__ */ te("h6", null, b.label), /* @__PURE__ */ te("ul", null, b.items.map((k) => /* @__PURE__ */ te(
      "li",
      {
        key: k.key,
        "data-index": k.index,
        class: a.value === k.index ? "hover" : "",
        onPointerenter: y(k.index),
        onPointerdown: () => {
          var x, M;
          (M = (x = s.value) == null ? void 0 : x.querySelector(`[data-index="${k.index}"]`)) == null || M.classList.add("active");
        },
        onPointerup: () => {
          var x, M;
          (M = (x = s.value) == null ? void 0 : x.querySelector(`[data-index="${k.index}"]`)) == null || M.classList.remove("active"), f(k.index);
        }
      },
      /* @__PURE__ */ te(yh, { icon: k.icon }),
      /* @__PURE__ */ te("span", null, k.label)
    )))))));
  }
});
var mI = (n) => {
  throw TypeError(n);
}, gI = (n, e, t) => e.has(n) || mI("Cannot " + t), cs = (n, e, t) => (gI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), df = (n, e, t) => e.has(n) ? mI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), Pl = (n, e, t, r) => (gI(n, e, "write to private field"), e.set(n, t), t), $f, mg, gg, _o, du;
const yI = iX("CREPE_MENU"), L6 = Wt(
  {
    show: () => {
    },
    hide: () => {
    }
  },
  "menuAPICtx"
);
function tce(n, e) {
  n.set(yI.key, {
    view: (t) => new nce(n, t, e)
  });
}
class nce {
  constructor(e, t, r) {
    df(this, $f), df(this, mg), df(this, gg), df(this, _o), df(this, du, null), this.update = (u) => {
      cs(this, _o).update(u);
    }, this.show = (u) => {
      Pl(this, du, u), cs(this, gg).value = "", cs(this, _o).show();
    }, this.hide = () => {
      Pl(this, du, null), cs(this, _o).hide();
    }, this.destroy = () => {
      cs(this, _o).destroy(), cs(this, mg).unmount(), cs(this, $f).remove();
    };
    const i = document.createElement("div");
    i.classList.add("milkdown-slash-menu");
    const s = Be(!1), o = Be("");
    Pl(this, gg, o);
    const a = this.hide, l = ns(ece, {
      ctx: e,
      config: r,
      show: s,
      filter: o,
      hide: a
    });
    Pl(this, mg, l), l.mount(i), Pl(this, $f, i);
    const c = this;
    Pl(this, _o, new sX({
      content: cs(this, $f),
      debounce: 20,
      shouldShow(u) {
        if (uI(u.state.selection) || hI(u.state.selection))
          return !1;
        const h = this.getContent(
          u,
          (m) => ["paragraph", "heading"].includes(m.type.name)
        );
        if (h == null || !rce(u.state.selection))
          return !1;
        const f = cs(c, du);
        if (o.value = h.startsWith("/") ? h.slice(1) : h, typeof f == "number") {
          const m = u.state.doc.nodeSize - 2, y = Math.min(f, m);
          return u.state.doc.resolve(y).node() !== u.state.doc.resolve(u.state.selection.from).node() ? (Pl(c, du, null), !1) : !0;
        }
        return !!h.startsWith("/");
      },
      offset: 10
    })), cs(this, _o).onShow = () => {
      s.value = !0;
    }, cs(this, _o).onHide = () => {
      s.value = !1;
    }, this.update(t), e.set(L6.key, {
      show: (u) => this.show(u),
      hide: () => this.hide()
    });
  }
}
$f = /* @__PURE__ */ new WeakMap();
mg = /* @__PURE__ */ new WeakMap();
gg = /* @__PURE__ */ new WeakMap();
_o = /* @__PURE__ */ new WeakMap();
du = /* @__PURE__ */ new WeakMap();
function rce(n) {
  if (!(n instanceof Ye)) return !1;
  const { $head: e } = n, t = e.parent;
  return e.parentOffset === t.content.size;
}
const ice = Xn({
  props: {
    onAdd: {
      type: Function,
      required: !0
    },
    addIcon: {
      type: String,
      required: !0
    },
    handleIcon: {
      type: String,
      required: !0
    }
  },
  setup(n) {
    const e = Be();
    return () => /* @__PURE__ */ te(Rc, null, /* @__PURE__ */ te(
      "div",
      {
        ref: e,
        class: "operation-item",
        onPointerdown: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.add("active");
        },
        onPointerup: (t) => {
          var r;
          t.preventDefault(), t.stopPropagation(), (r = e.value) == null || r.classList.remove("active"), n.onAdd();
        }
      },
      /* @__PURE__ */ te(yh, { icon: n.addIcon })
    ), /* @__PURE__ */ te("div", { class: "operation-item" }, /* @__PURE__ */ te(yh, { icon: n.handleIcon })));
  }
});
var bI = (n) => {
  throw TypeError(n);
}, vI = (n, e, t) => e.has(n) || bI("Cannot " + t), Bl = (n, e, t) => (vI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), bm = (n, e, t) => e.has(n) ? bI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), vm = (n, e, t, r) => (vI(n, e, "write to private field"), e.set(n, t), t), yg, Vl, bg, vg;
class sce {
  constructor(e, t) {
    bm(this, yg), bm(this, Vl), bm(this, bg), bm(this, vg), this.update = () => {
      Bl(this, Vl).update();
    }, this.destroy = () => {
      Bl(this, Vl).destroy(), Bl(this, yg).remove(), Bl(this, bg).unmount();
    }, this.onAdd = () => {
      const c = Bl(this, vg), u = c.get(on);
      u.hasFocus() || u.focus();
      const { state: h, dispatch: f } = u, m = Bl(this, Vl).active;
      if (!m) return;
      const b = m.$pos.pos + m.node.nodeSize;
      let k = h.tr.insert(b, uo.type(c).create());
      k = k.setSelection(Ye.near(k.doc.resolve(b))), f(k.scrollIntoView()), Bl(this, Vl).hide(), c.get(L6.key).show(k.selection.from);
    };
    var r, i, s;
    vm(this, vg, e);
    const o = document.createElement("div");
    o.classList.add("milkdown-block-handle");
    const a = ns(ice, {
      onAdd: this.onAdd,
      addIcon: (r = t == null ? void 0 : t.handleAddIcon) != null ? r : ow,
      handleIcon: (i = t == null ? void 0 : t.handleDragIcon) != null ? i : Vle
    });
    a.mount(o), vm(this, bg, a), vm(this, yg, o);
    const l = (s = t == null ? void 0 : t.blockHandle) != null ? s : {};
    vm(this, Vl, new NY({
      ctx: e,
      content: o,
      getOffset: () => 16,
      getPlacement: ({ active: c, blockDom: u }) => {
        if (c.node.type.name === "heading") return "left";
        let h = 0;
        c.node.descendants((E) => {
          h += E.childCount;
        });
        const f = c.el, m = f.getBoundingClientRect(), y = u.getBoundingClientRect(), b = window.getComputedStyle(f), k = Number.parseInt(b.paddingTop, 10) || 0, x = Number.parseInt(b.paddingBottom, 10) || 0, M = m.height - k - x, T = y.height;
        return h > 2 || T < M ? "left-start" : "left";
      },
      ...l
    })), this.update();
  }
}
yg = /* @__PURE__ */ new WeakMap();
Vl = /* @__PURE__ */ new WeakMap();
bg = /* @__PURE__ */ new WeakMap();
vg = /* @__PURE__ */ new WeakMap();
function oce(n, e) {
  n.set(iy.key, {
    filterNodes: (t) => !eo(
      (i) => ["table", "blockquote", "math_inline"].includes(i.type.name)
    )(t)
  }), n.set(ay.key, {
    view: () => new sce(n, e)
  });
}
const ace = (n, e) => {
  n.config(go(Jt.BlockEdit)).config((t) => oce(t, e)).config((t) => tce(t, e)).use(L6).use(ay).use(yI);
}, lce = (n, e = {}) => {
  n.config(go(Jt.CodeMirror)).config((t) => {
    const { languages: r = [], theme: i } = e, s = [
      Lh.of(tD.concat(ine)),
      die
    ];
    i && s.push(i), e.extensions && s.push(...e.extensions), t.update(sp.key, (o) => ({
      extensions: s,
      languages: r,
      expandIcon: e.expandIcon || rI,
      searchIcon: e.searchIcon || aI,
      clearSearchIcon: e.clearSearchIcon || iI,
      searchPlaceholder: e.searchPlaceholder || "Search language",
      copyText: e.copyText || "Copy",
      copyIcon: e.copyIcon || oI,
      onCopy: e.onCopy || (() => {
      }),
      noResultText: e.noResultText || "No result",
      renderLanguage: e.renderLanguage || o.renderLanguage,
      renderPreview: e.renderPreview || o.renderPreview,
      previewToggleButton: (a) => {
        var l, c;
        const u = ((l = e.previewToggleIcon) == null ? void 0 : l.call(e, a)) || (a ? E6 : cI), h = ((c = e.previewToggleText) == null ? void 0 : c.call(e, a)) || (a ? "Edit" : "Hide");
        return [u, h].map((f) => f.trim()).join(" ");
      },
      previewLabel: e.previewLabel || o.previewLabel
    }));
  }).use(Ene);
}, cce = (n, e) => {
  if (n.config(go(Jt.Cursor)).config((r) => {
    r.update(My.key, () => {
      var i, s;
      return {
        class: "crepe-drop-cursor",
        width: (i = e == null ? void 0 : e.width) != null ? i : 4,
        color: (s = e == null ? void 0 : e.color) != null ? s : !1
      };
    });
  }).use(Nie), (e == null ? void 0 : e.virtual) === !1)
    return;
  const t = Iie();
  n.use(jn(() => t));
}, uce = (n, e) => {
  n.config(go(Jt.ImageBlock)).config((t) => {
    t.update(Ty.key, (r) => {
      var i, s, o, a, l, c;
      return {
        uploadButton: (i = e == null ? void 0 : e.inlineUploadButton) != null ? i : "Upload",
        imageIcon: (s = e == null ? void 0 : e.inlineImageIcon) != null ? s : sw,
        confirmButton: (o = e == null ? void 0 : e.inlineConfirmButton) != null ? o : A6,
        uploadPlaceholderText: (a = e == null ? void 0 : e.inlineUploadPlaceholderText) != null ? a : "or paste link",
        onUpload: (c = (l = e == null ? void 0 : e.inlineOnUpload) != null ? l : e == null ? void 0 : e.onUpload) != null ? c : r.onUpload,
        proxyDomURL: e == null ? void 0 : e.proxyDomURL
      };
    }), t.update(dy.key, (r) => {
      var i, s, o, a, l, c, u, h;
      return {
        uploadButton: (i = e == null ? void 0 : e.blockUploadButton) != null ? i : "Upload file",
        imageIcon: (s = e == null ? void 0 : e.blockImageIcon) != null ? s : sw,
        captionIcon: (o = e == null ? void 0 : e.blockCaptionIcon) != null ? o : Lle,
        confirmButton: (a = e == null ? void 0 : e.blockConfirmButton) != null ? a : "Confirm",
        captionPlaceholderText: (l = e == null ? void 0 : e.blockCaptionPlaceholderText) != null ? l : "Write Image Caption",
        uploadPlaceholderText: (c = e == null ? void 0 : e.blockUploadPlaceholderText) != null ? c : "or paste link",
        onUpload: (h = (u = e == null ? void 0 : e.blockOnUpload) != null ? u : e == null ? void 0 : e.onUpload) != null ? h : r.onUpload,
        proxyDomURL: e == null ? void 0 : e.proxyDomURL
      };
    });
  }).use(WX).use(Kie);
}, hce = ao.extendSchema((n) => (e) => {
  const t = n(e);
  return {
    ...t,
    toMarkdown: {
      match: t.toMarkdown.match,
      runner: (r, i) => {
        var s, o;
        if (((s = i.attrs.language) != null ? s : "").toLowerCase() === "latex")
          r.addNode(
            "math",
            void 0,
            ((o = i.content.firstChild) == null ? void 0 : o.text) || ""
          );
        else
          return t.toMarkdown.runner(r, i);
      }
    }
  };
}), jf = "math_inline", l0 = Rn(jf, () => ({
  group: "inline",
  inline: !0,
  draggable: !0,
  atom: !0,
  attrs: {
    value: {
      default: ""
    }
  },
  parseDOM: [
    {
      tag: `span[data-type="${jf}"]`,
      getAttrs: (n) => {
        var e;
        return {
          value: (e = n.dataset.value) != null ? e : ""
        };
      }
    }
  ],
  toDOM: (n) => {
    const e = n.attrs.value, t = document.createElement("span");
    return t.dataset.type = jf, t.dataset.value = e, DN.render(e, t, {
      throwOnError: !1
    }), t;
  },
  parseMarkdown: {
    match: (n) => n.type === "inlineMath",
    runner: (n, e, t) => {
      n.addNode(t, { value: e.value });
    }
  },
  toMarkdown: {
    match: (n) => n.type.name === jf,
    runner: (n, e) => {
      n.addNode("inlineMath", void 0, e.attrs.value);
    }
  }
})), wI = ct("ToggleLatex", (n) => () => (e, t) => {
  const {
    hasNode: r,
    pos: i,
    target: s
  } = dA(e, l0.type(n)), { selection: o, doc: a, tr: l } = e;
  if (!r) {
    const m = a.textBetween(o.from, o.to);
    let y = l.replaceSelectionWith(
      l0.type(n).create({
        value: m
      })
    );
    return t && t(
      y.setSelection(Qe.create(y.doc, o.from))
    ), !0;
  }
  const { from: c, to: u } = o;
  if (!s || i < 0) return !1;
  let h = l.delete(i, i + 1);
  const f = s.attrs.value;
  return h = h.insertText(f, i), t && t(
    h.setSelection(
      Ye.create(h.doc, c, u + f.length - 1)
    )
  ), !0;
}), UC = Ry("INLINE_LATEX"), fce = Xn({
  props: {
    config: {
      type: Object,
      required: !0
    },
    innerView: {
      type: Object,
      required: !0
    },
    updateValue: {
      type: Object,
      required: !0
    }
  },
  setup(n) {
    const e = (r) => {
      if (!(!r || !(r instanceof HTMLElement))) {
        for (; r.firstChild; )
          r.removeChild(r.firstChild);
        n.innerView.value && r.appendChild(n.innerView.value.dom);
      }
    }, t = (r) => {
      r.preventDefault(), n.updateValue.value();
    };
    return () => /* @__PURE__ */ te("div", { class: "container" }, n.innerView && /* @__PURE__ */ te("div", { ref: e }), /* @__PURE__ */ te("button", { onPointerdown: t }, /* @__PURE__ */ te(yh, { icon: n.config.inlineEditConfirm })));
  }
});
var kI = (n) => {
  throw TypeError(n);
}, xI = (n, e, t) => e.has(n) || kI("Cannot " + t), Qn = (n, e, t) => (xI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), Ta = (n, e, t) => e.has(n) ? kI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), wm = (n, e, t, r) => (xI(n, e, "write to private field"), e.set(n, t), t), Wf, pu, wg, ql, Uf, Kf, lw, cw;
class dce {
  constructor(e, t, r) {
    this.ctx = e, Ta(this, Wf), Ta(this, pu), Ta(this, wg), Ta(this, ql, Sg(null)), Ta(this, Uf, Sg(() => {
    })), Ta(this, Kf), Ta(this, lw, () => {
      Qn(this, ql).value && (Qn(this, ql).value.destroy(), Qn(this, ql).value = null);
    }), Ta(this, cw, (s) => {
      const a = (() => {
        const { selection: l, schema: c } = s.state;
        if (l.empty || !(l instanceof Qe)) return !1;
        const u = l.node;
        if (u.type.name !== jf) return !1;
        const h = l.from, f = c.nodes.paragraph.create(
          null,
          c.text(u.attrs.value)
        ), m = new y5(Qn(this, wg), {
          state: Kl.create({
            doc: f,
            schema: new VT({
              nodes: {
                doc: {
                  content: "block+"
                },
                paragraph: {
                  content: "inline*",
                  group: "block",
                  parseDOM: [{ tag: "p" }],
                  toDOM() {
                    return ["p", 0];
                  }
                },
                text: {
                  group: "inline"
                }
              }
            }),
            plugins: [
              rE({
                "Mod-z": Sy,
                "Mod-Z": bh,
                "Mod-y": bh,
                Enter: () => (Qn(this, Uf).value(), !0)
              })
            ]
          })
        });
        return Qn(this, ql).value = m, Qn(this, Uf).value = () => {
          const { tr: y } = s.state;
          y.setNodeAttribute(h, "value", m.state.doc.textContent), s.dispatch(y), requestAnimationFrame(() => {
            s.focus();
          });
        }, !0;
      })();
      return a || Qn(this, lw).call(this), a;
    }), this.update = (s, o) => {
      Qn(this, pu).update(s, o);
    }, this.destroy = () => {
      Qn(this, Kf).unmount(), Qn(this, pu).destroy(), Qn(this, Wf).remove();
    };
    const i = document.createElement("div");
    i.className = "milkdown-latex-inline-edit", wm(this, Wf, i), wm(this, Kf, ns(fce, {
      config: r,
      innerView: Qn(this, ql),
      updateValue: Qn(this, Uf)
    })), Qn(this, Kf).mount(i), wm(this, pu, new _y({
      debounce: 0,
      content: Qn(this, Wf),
      shouldShow: Qn(this, cw),
      offset: 10,
      floatingUIOptions: {
        placement: "bottom"
      }
    })), Qn(this, pu).update(t), wm(this, wg, document.createElement("div"));
  }
}
Wf = /* @__PURE__ */ new WeakMap();
pu = /* @__PURE__ */ new WeakMap();
wg = /* @__PURE__ */ new WeakMap();
ql = /* @__PURE__ */ new WeakMap();
Uf = /* @__PURE__ */ new WeakMap();
Kf = /* @__PURE__ */ new WeakMap();
lw = /* @__PURE__ */ new WeakMap();
cw = /* @__PURE__ */ new WeakMap();
const pce = Sr(
  (n) => I$(/(?:\$)([^$]+)(?:\$)$/, l0.type(n), {
    getAttr: (e) => {
      var t;
      return {
        value: (t = e[1]) != null ? t : ""
      };
    }
  })
), mce = Sr(
  (n) => Kw(/^\$\$[\s\n]$/, ao.type(n), () => ({
    language: "LaTeX"
  }))
), gce = co(
  "remarkMath",
  () => iae
);
function yce(n) {
  return ml(
    n,
    "math",
    (e, t, r) => {
      const { value: i } = e, s = {
        type: "code",
        lang: "LaTeX",
        value: i
      };
      r.children.splice(t, 1, s);
    }
  );
}
const bce = co(
  "remarkMathBlock",
  () => () => yce
), vce = (n, e) => {
  n.config(go(Jt.Latex)).config((t) => {
    if (!Vy(t).get().includes(Jt.CodeMirror))
      throw new Error("You need to enable CodeMirror to use LaTeX feature");
    t.update(sp.key, (s) => ({
      ...s,
      renderPreview: (o, a) => {
        if (o.toLowerCase() === "latex" && a.length > 0)
          return wce(a, e == null ? void 0 : e.katexOptions);
        const l = s.renderPreview;
        return l(o, a);
      }
    })), t.set(UC.key, {
      view: (s) => {
        var o;
        return new dce(t, s, {
          inlineEditConfirm: (o = e == null ? void 0 : e.inlineEditConfirm) != null ? o : A6,
          ...e
        });
      }
    });
  }).use(gce).use(bce).use(l0).use(UC).use(pce).use(mce).use(hce).use(wI);
};
function wce(n, e) {
  return DN.renderToString(n, {
    ...e,
    throwOnError: !1,
    displayMode: !0
  });
}
const kce = (n, e) => {
  n.config(go(Jt.LinkTooltip)).config(Rae).config((t) => {
    t.update(Sh.key, (r) => {
      var i, s, o, a, l, c;
      return {
        ...r,
        linkIcon: (i = e == null ? void 0 : e.linkIcon) != null ? i : oI,
        editButton: (s = e == null ? void 0 : e.editButton) != null ? s : E6,
        removeButton: (o = e == null ? void 0 : e.removeButton) != null ? o : aw,
        confirmButton: (a = e == null ? void 0 : e.confirmButton) != null ? a : A6,
        inputPlaceholder: (l = e == null ? void 0 : e.inputPlaceholder) != null ? l : "Paste link...",
        onCopyLink: (c = e == null ? void 0 : e.onCopyLink) != null ? c : () => {
        }
      };
    });
  }).use(Pae);
};
function xce(n, e) {
  n.set(By.key, {
    renderLabel: ({ label: t, listType: r, checked: i }) => {
      var s, o, a;
      return i == null ? r === "bullet" ? (s = e == null ? void 0 : e.bulletIcon) != null ? s : Ale : t : i ? (o = e == null ? void 0 : e.checkBoxCheckedIcon) != null ? o : Ole : (a = e == null ? void 0 : e.checkBoxUncheckedIcon) != null ? a : Dle;
    }
  });
}
const Sce = (n, e) => {
  n.config(go(Jt.ListItem)).config((t) => xce(t, e)).use($ae);
};
function Cce(n) {
  var e;
  return n.childCount <= 1 && !((e = n.firstChild) != null && e.content.size);
}
function Mce(n, e) {
  const { selection: t } = n;
  if (!t.empty) return null;
  const r = t.$anchor, i = r.parent;
  if (i.content.size > 0 || eo((a) => a.type.name === "table")(r)) return null;
  const o = r.before();
  return qn.node(o, o + i.nodeSize, {
    class: "crepe-placeholder",
    "data-placeholder": e
  });
}
const uw = Wt(
  {
    text: "Please enter...",
    mode: "block"
  },
  "placeholderConfigCtx"
), Tce = jn((n) => new mn({
  key: new gn("CREPE_PLACEHOLDER"),
  props: {
    decorations: (e) => {
      var t;
      if (Xle(n).readonly) return null;
      const i = n.get(uw.key);
      if (i.mode === "doc" && !Cce(e.doc) || uI(e.selection) || hI(e.selection))
        return null;
      const s = (t = i.text) != null ? t : "Please enter...", o = Mce(e, s);
      return o ? Qt.create(e.doc, [o]) : null;
    }
  }
})), Ace = (n, e) => {
  n.config(go(Jt.Placeholder)).config((t) => {
    e && t.update(uw.key, (r) => ({
      ...r,
      ...e
    }));
  }).use(Tce).use(uw);
}, Ece = (n, e) => {
  n.config(go(Jt.Table)).config((t) => {
    t.update(Hy.key, (r) => ({
      ...r,
      renderButton: (i) => {
        var s, o, a, l, c, u, h, f, m;
        switch (i) {
          case "add_row":
            return (s = e == null ? void 0 : e.addRowIcon) != null ? s : ow;
          case "add_col":
            return (o = e == null ? void 0 : e.addColIcon) != null ? o : ow;
          case "delete_row":
            return (a = e == null ? void 0 : e.deleteRowIcon) != null ? a : aw;
          case "delete_col":
            return (l = e == null ? void 0 : e.deleteColIcon) != null ? l : aw;
          case "align_col_left":
            return (c = e == null ? void 0 : e.alignLeftIcon) != null ? c : Cle;
          case "align_col_center":
            return (u = e == null ? void 0 : e.alignCenterIcon) != null ? u : Sle;
          case "align_col_right":
            return (h = e == null ? void 0 : e.alignRightIcon) != null ? h : Mle;
          case "col_drag_handle":
            return (f = e == null ? void 0 : e.colDragHandleIcon) != null ? f : jC;
          case "row_drag_handle":
            return (m = e == null ? void 0 : e.rowDragHandleIcon) != null ? m : jC;
        }
      }
    }));
  }).use(gle);
};
function Lce(n, e) {
  var t, r, i, s, o, a, l;
  const c = new pI();
  c.addGroup("formatting", "Formatting").addItem("bold", {
    icon: (t = n == null ? void 0 : n.boldIcon) != null ? t : Tle,
    active: (m) => m.get(je).call(ou.key, Ih.type(m)),
    onRun: (m) => {
      m.get(je).call(cy.key);
    }
  }).addItem("italic", {
    icon: (r = n == null ? void 0 : n.italicIcon) != null ? r : zle,
    active: (m) => m.get(je).call(
      ou.key,
      Hc.type(m)
    ),
    onRun: (m) => {
      m.get(je).call(ly.key);
    }
  }).addItem("strikethrough", {
    icon: (i = n == null ? void 0 : n.strikethroughIcon) != null ? i : jle,
    active: (m) => m.get(je).call(
      ou.key,
      Bh.type(m)
    ),
    onRun: (m) => {
      m.get(je).call(gy.key);
    }
  });
  const u = c.addGroup("function", "Function");
  u.addItem("code", {
    icon: (s = n == null ? void 0 : n.codeIcon) != null ? s : sI,
    active: (m) => m.get(je).call(
      ou.key,
      Jo.type(m)
    ),
    onRun: (m) => {
      m.get(je).call(uy.key);
    }
  });
  const h = e && Vy(e).get();
  return (h == null ? void 0 : h.includes(Jt.Latex)) && u.addItem("latex", {
    icon: (o = n == null ? void 0 : n.latexIcon) != null ? o : lI,
    active: (m) => m.get(je).call(
      EL.key,
      l0.type(m)
    ),
    onRun: (m) => {
      m.get(je).call(wI.key);
    }
  }), u.addItem("link", {
    icon: (a = n == null ? void 0 : n.linkIcon) != null ? a : Fle,
    active: (m) => m.get(je).call(ou.key, vs.type(m)),
    onRun: (m) => {
      m.get(je).call(IN.key);
    }
  }), (l = n == null ? void 0 : n.buildToolbar) == null || l.call(n, c), c.build();
}
const Oce = Xn({
  props: {
    ctx: {
      type: Object,
      required: !0
    },
    hide: {
      type: Function,
      required: !0
    },
    show: {
      type: Object,
      required: !0
    },
    selection: {
      type: Object,
      required: !0
    },
    config: {
      type: Object,
      required: !1
    }
  },
  setup(n) {
    const { ctx: e, config: t } = n, r = (o) => (a) => {
      a.preventDefault(), e && o(e);
    };
    function i(o) {
      return n.selection.value, e.get(x4).status !== Yg.Created ? !1 : o(e);
    }
    const s = Qa(() => Lce(t, e));
    return () => /* @__PURE__ */ te(Rc, null, s.value.map((o) => o.items.map((a) => /* @__PURE__ */ te(
      "button",
      {
        type: "button",
        class: pr(
          "toolbar-item",
          e && i(a.active) && "active"
        ),
        onPointerdown: r(a.onRun)
      },
      /* @__PURE__ */ te(yh, { icon: a.icon })
    ))).reduce((o, a, l) => (l === 0 ? o.push(...a) : o.push(/* @__PURE__ */ te("div", { class: "divider" }), ...a), o), []));
  }
});
var SI = (n) => {
  throw TypeError(n);
}, CI = (n, e, t) => e.has(n) || SI("Cannot " + t), mi = (n, e, t) => (CI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), pf = (n, e, t) => e.has(n) ? SI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), km = (n, e, t, r) => (CI(n, e, "write to private field"), e.set(n, t), t), Oa, Gf, kg, Jf, Yf;
const KC = Ry("CREPE_TOOLBAR");
class Dce {
  constructor(e, t, r) {
    pf(this, Oa), pf(this, Gf), pf(this, kg), pf(this, Jf), pf(this, Yf, Be(!1)), this.update = (o, a) => {
      mi(this, Oa).update(o, a), mi(this, Jf).value = o.state.selection;
    }, this.destroy = () => {
      mi(this, Oa).destroy(), mi(this, kg).unmount(), mi(this, Gf).remove();
    }, this.hide = () => {
      mi(this, Oa).hide();
    };
    const i = document.createElement("div");
    i.className = "milkdown-toolbar", km(this, Jf, Sg(t.state.selection));
    const s = ns(Oce, {
      ctx: e,
      hide: this.hide,
      config: r,
      selection: mi(this, Jf),
      show: mi(this, Yf)
    });
    s.mount(i), km(this, Gf, i), km(this, kg, s), km(this, Oa, new _y({
      content: mi(this, Gf),
      debounce: 20,
      offset: 10,
      shouldShow(o) {
        const { doc: a, selection: l } = o.state, { empty: c, from: u, to: h } = l, f = !a.textBetween(u, h).length && l instanceof Ye, m = !(l instanceof Ye), y = o.dom.getRootNode().activeElement, b = i.contains(y), k = !o.hasFocus() && !b, x = !o.editable;
        return !(k || m || c || f || x);
      }
    })), mi(this, Oa).onShow = () => {
      mi(this, Yf).value = !0;
    }, mi(this, Oa).onHide = () => {
      mi(this, Yf).value = !1;
    }, this.update(t);
  }
}
Oa = /* @__PURE__ */ new WeakMap();
Gf = /* @__PURE__ */ new WeakMap();
kg = /* @__PURE__ */ new WeakMap();
Jf = /* @__PURE__ */ new WeakMap();
Yf = /* @__PURE__ */ new WeakMap();
const Nce = (n, e) => {
  n.config(go(Jt.Toolbar)).config((t) => {
    t.set(KC.key, {
      view: (r) => new Dce(t, r, e)
    });
  }).use(KC);
};
function Ice(n, e, t) {
  switch (n) {
    case Jt.CodeMirror:
      return lce(e, t);
    case Jt.ListItem:
      return Sce(e, t);
    case Jt.LinkTooltip:
      return kce(e, t);
    case Jt.ImageBlock:
      return uce(e, t);
    case Jt.Cursor:
      return cce(e, t);
    case Jt.BlockEdit:
      return ace(e, t);
    case Jt.Placeholder:
      return Ace(e, t);
    case Jt.Toolbar:
      return Nce(e, t);
    case Jt.Table:
      return Ece(e, t);
    case Jt.Latex:
      return vce(e, t);
  }
}
var MI = (n) => {
  throw TypeError(n);
}, TI = (n, e, t) => e.has(n) || MI("Cannot " + t), gi = (n, e, t) => (TI(n, e, "read from private field"), t ? t.call(n) : e.get(n)), F2 = (n, e, t) => e.has(n) ? MI("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t), V2 = (n, e, t, r) => (TI(n, e, "write to private field"), e.set(n, t), t), yi, xg, Xf;
class _ce {
  /// The constructor of the crepe builder.
  /// You can pass configs to the builder to configure the editor.
  constructor({ root: e, defaultValue: t = "" } = {}) {
    F2(this, yi), F2(this, xg), F2(this, Xf, !0), this.addFeature = (i, s) => (i(gi(this, yi), s), this), this.create = () => gi(this, yi).create(), this.destroy = () => gi(this, yi).destroy(), this.setReadonly = (i) => (V2(this, Xf, !i), gi(this, yi).action((s) => {
      gi(this, yi).status === Yg.Created && s.get(on).setProps({
        editable: () => !i
      });
    }), this), this.getMarkdown = () => gi(this, yi).action(VJ()), this.on = (i) => gi(this, yi).status !== Yg.Created ? (gi(this, yi).config((s) => {
      const o = s.get(y1);
      i(o);
    }), this) : (gi(this, yi).action((s) => {
      const o = s.get(y1);
      i(o);
    }), this);
    var r;
    V2(this, xg, (r = typeof e == "string" ? document.querySelector(e) : e) != null ? r : document.body), V2(this, yi, M4.make().config((i) => {
      i.inject(Yle, this), i.inject(Jle, []);
    }).config((i) => {
      i.set(Xm, gi(this, xg)), i.set(Gm, t), i.set(vd, {
        editable: () => gi(this, Xf)
      }), i.update(Fy.key, (s) => ({
        ...s,
        size: 4
      }));
    }).use(rX).use(tI).use(yle).use(vle).use(kle).use(XN).use(Uee));
  }
  /// Get the milkdown editor instance.
  get editor() {
    return gi(this, yi);
  }
  /// Get the readonly state of the editor.
  get readonly() {
    return !gi(this, Xf);
  }
}
yi = /* @__PURE__ */ new WeakMap();
xg = /* @__PURE__ */ new WeakMap();
Xf = /* @__PURE__ */ new WeakMap();
class AI extends _ce {
  /// The constructor of the crepe editor.
  /// You can pass configs to the editor to configure the editor.
  /// Calling the constructor will not create the editor, you need to call `create` to create the editor.
  constructor({
    features: e = {},
    featureConfigs: t = {},
    ...r
  } = {}) {
    super(r);
    const i = VB(t, Gle);
    Object.entries({
      ...xle,
      ...e
    }).filter(([, o]) => o).map(([o]) => o).forEach((o) => {
      const a = i[o];
      Ice(o, this.editor, a);
    });
  }
}
AI.Feature = Jt;
class Rce {
  constructor(e, t, r) {
    this.rootElemId = e, this.firstLoad = !0, this.editor = new AI({
      root: document.getElementById(e),
      defaultValue: t
    }), this.editor.on((i) => {
      i.markdownUpdated(() => {
        !this.firstLoad && r.afterContentChange ? r.afterContentChange(this) : this.firstLoad = !1;
      });
    }), this.editor.create().then(() => {
      r.afterRender && r.afterRender(this), console.log("[mdnotes] Crepe editor created!");
    });
  }
  getMarkdownContent() {
    return this.editor.getMarkdown();
  }
  getScrollTop() {
    return document.getElementById(this.rootElemId).parentElement.scrollTop;
  }
  setScrollTop(e) {
    let r = document.getElementById(this.rootElemId).parentElement;
    console.log("[mdnotes] Setting scrollTop value to ", e), r.scrollTo({
      top: e,
      left: 0,
      behavior: "smooth"
    });
  }
  gc() {
    this.editor.destroy();
  }
}
function GC(n, e) {
  switch (n) {
    case Ks.vditor:
      return new nR(
        e.rootElemId,
        e.mdContent,
        e.cdnUrl || mu.unpkg,
        e.callbacks
      );
    case Ks.milkdown:
      return new Rce(
        e.rootElemId,
        e.mdContent,
        e.callbacks
      );
  }
}
const Pce = { class: "endericedragon-sticky-buttons" }, Bce = /* @__PURE__ */ Xn({
  __name: "EditorModal",
  setup(n) {
    const e = Y_(), t = Be(null);
    R0(() => {
      window.addEventListener(q2.showEditor, r);
    }), k1(() => {
      window.removeEventListener(q2.showEditor, r);
    });
    function r(c) {
      let u = c.detail, h = u.content, f = u.rel_file_path;
      e.notePath.value !== f && (e.notePath.value = f, e.scrollTopVal.value = 0), e.mdContent.value = h, e.isModalShown.value = !0;
    }
    function i() {
      var u;
      const c = (u = t.value) == null ? void 0 : u.getMarkdownContent();
      c !== e.mdContent.value && (e.mdContent.value = c, ZC(
        Ci,
        fw.saveContent,
        new XC(
          c,
          e.notePath.value
        )
      ).then((h) => {
        Ci.extensionManager.toast.add({
          severity: "success",
          summary: "MDNotes",
          detail: "Note is saved!",
          life: 2e3
        });
      }));
    }
    class s {
      static ok() {
        e.needSaving.value = !0, e.isModalShown.value = !1;
      }
      static cancel() {
        e.isModalShown.value = !1;
      }
    }
    function o() {
      e.unsaveMark.value = !1, e.needSaving.value = !1;
      const c = {
        rootElemId: "mde-point",
        mdContent: e.mdContent.value,
        callbacks: {
          afterContentChange: (u) => {
            e.unsaveMark.value = !0, Ci.extensionManager.setting.get(Uo.saveOnClose) && (e.needSaving.value = !0);
          }
        }
      };
      switch (Ci.extensionManager.setting.get(Uo.editorSwitch)) {
        case Ks.vditor:
          c.cdnUrl = e.cdnToUse.value, c.callbacks.afterRender = (u) => {
            u.editor.setTheme(
              "dark",
              "dark",
              "atom-one-dark"
            ), u.setScrollTop(e.scrollTopVal.value);
          }, t.value = GC(Ks.vditor, c);
          break;
        case Ks.milkdown:
          c.callbacks.afterRender = (u) => {
            u.setScrollTop(e.scrollTopVal.value);
          }, t.value = GC(Ks.milkdown, c);
          break;
      }
    }
    function a() {
      var c;
      e.needSaving.value && i(), (c = t.value) == null || c.gc();
    }
    function l() {
      var c;
      e.scrollTopVal.value = (c = t.value) == null ? void 0 : c.getScrollTop();
    }
    return (c, u) => (YC(), JC(Yc(G_), {
      visible: Yc(e).isModalShown.value,
      "onUpdate:visible": u[0] || (u[0] = (h) => Yc(e).isModalShown.value = h),
      onShow: o,
      onHide: l,
      onAfterHide: a,
      header: Yc(e).dialogTitle.value,
      "close-on-escape": ""
    }, {
      default: Xy(() => [
        u[3] || (u[3] = Mp("div", { id: "mde-point" }, null, -1)),
        Mp("div", Pce, [
          ik(Yc(sk), {
            severity: "danger",
            onClick: s.cancel
          }, {
            default: Xy(() => [...u[1] || (u[1] = [
              Mp("i", { class: "bi bi-x-circle" }, null, -1)
            ])]),
            _: 1
          }, 8, ["onClick"]),
          ik(Yc(sk), {
            severity: "success",
            onClick: s.ok
          }, {
            default: Xy(() => [...u[2] || (u[2] = [
              Mp("i", { class: "bi bi-check2-circle" }, null, -1)
            ])]),
            _: 1
          }, 8, ["onClick"])
        ])
      ]),
      _: 1
    }, 8, ["visible", "header"]));
  }
}), Hce = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, i] of e)
    t[r] = i;
  return t;
}, zce = /* @__PURE__ */ Hce(Bce, [["__scopeId", "data-v-187f468d"]]), Fce = /* @__PURE__ */ Xn({
  __name: "App",
  setup(n) {
    return (e, t) => (YC(), JC(zce, {
      onKeydown: t[0] || (t[0] = j_(() => {
      }, ["stop"]))
    }));
  }
}), Vce = "extensions/comfyui-mdnotes/assets/main.css";
K_.addStylesheet(Vce);
Ci.registerExtension({
  name: "endericedragon.comfyui-mdnotes",
  settings: [
    {
      id: Uo.saveOnClose,
      name: "Always save on close?",
      type: "boolean",
      defaultValue: !1
    },
    {
      id: Uo.editorSwitch,
      name: "Markdown editor to use",
      type: "combo",
      defaultValue: Ks.vditor,
      options: [
        { text: "vditor", value: Ks.vditor },
        { text: "milkdown/crepe", value: Ks.milkdown }
      ]
    },
    {
      id: Uo.cdnSwitch,
      name: "CDN for vditor resources",
      type: "combo",
      defaultValue: mu.unpkg,
      options: [
        { text: "unpkg", value: mu.unpkg },
        { text: "jsDelivr", value: mu.jsDelivr },
        { text: "npmmirror", value: mu.npmmirror }
      ],
      tooltip: "Set the CDN used for fetching resources of vditor."
    },
    {
      id: Uo.useLocalCDN,
      name: "Cache vditor resources locally?",
      type: "boolean",
      defaultValue: !1,
      tooltip: "Store resources of vditor locally.This is recommended since editor could be loaded much faster."
    }
  ],
  async beforeRegisterNodeDef(n, e, t) {
    let r = n.prototype.getExtraMenuOptions;
    n.prototype.getExtraMenuOptions = function(i, s) {
      r == null || r.apply(this, arguments);
      let o = this.widgets.find((u) => u.name === "ckpt_name"), a = this.widgets.filter((u) => u.name.includes("lora") && u.name.includes("name")), l = [];
      function c(u, h) {
        ZC(Ci, fw.sendCurrentModel, { model_type: h, model_path: u }).then((f) => {
          let m = f.content, y = f.rel_file_path;
          window.dispatchEvent(new CustomEvent(q2.showEditor, {
            detail: new XC(m, y)
          }));
        });
      }
      if (o) {
        const u = o.value;
        l.push({
          content: "Show note of checkpoint",
          callback: () => {
            c(u, $2.CKPT);
          }
        });
      }
      for (let [u, h] of a.entries()) {
        const f = h.value;
        f !== "None" && l.push({
          content: `Show note of lora${u + 1}`,
          callback: () => {
            c(f, $2.LORA);
          }
        });
      }
      return s.unshift(...l), s;
    };
  },
  async setup() {
    let n = document.createElement("div");
    n.id = "mdnotes-ui", document.body.appendChild(n), ns(Fce).use(W_).mount(n);
  }
});
export {
  Ul as A,
  bn as B,
  mD as C,
  ee as D,
  $e as E,
  Rv as F,
  KV as G,
  $B as H,
  xn as I,
  cV as J,
  fV as L,
  Gce as N,
  S9 as P,
  zi as T,
  _v as a,
  uue as b,
  sue as c,
  ire as d,
  dr as e,
  SV as f,
  rue as g,
  iue as h,
  iT as i,
  oue as j,
  hue as k,
  ce as l,
  Oi as m,
  Mt as n,
  bw as o,
  Yce as p,
  an as q,
  xV as r,
  iV as s,
  se as t,
  fl as u,
  Lh as v,
  $i as w,
  nT as x,
  Eh as y,
  D1 as z
};
